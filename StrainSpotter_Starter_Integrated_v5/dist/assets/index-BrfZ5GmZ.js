var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __restKey = (key) => typeof key === "symbol" ? key : key + "";
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) return;
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) processPreload(link);
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") continue;
      for (const node2 of mutation.addedNodes) if (node2.tagName === "LINK" && node2.rel === "modulepreload") processPreload(node2);
    }
  }).observe(document, {
    childList: true,
    subtree: true
  });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep) return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
const common = {
  black: "#000",
  white: "#fff"
};
const red = {
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  700: "#d32f2f",
  800: "#c62828"
};
const purple = {
  50: "#f3e5f5",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  700: "#7b1fa2"
};
const blue = {
  50: "#e3f2fd",
  200: "#90caf9",
  400: "#42a5f5",
  700: "#1976d2",
  800: "#1565c0"
};
const lightBlue = {
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  700: "#0288d1",
  900: "#01579b"
};
const green = {
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20"
};
const orange = {
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  700: "#f57c00",
  900: "#e65100"
};
const grey = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
};
function formatMuiErrorMessage(code, ...args) {
  const url = new URL(`https://mui.com/production-error/?code=${code}`);
  args.forEach((arg2) => url.searchParams.append("args[]", arg2));
  return `Minified MUI error #${code}; visit ${url} for the full message.`;
}
const THEME_ID = "$$material";
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
  return void 0;
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ (function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      var _tag$parentNode;
      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
})();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash$2(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end2) {
  return value.slice(begin, end2);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type, props, children, length2) {
  return { value, root, parent, type, props, children, line, column, length: length2, return: "" };
}
function copy(root, props) {
  return assign(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end2) {
  return substr(characters, begin, end2);
}
function token(type) {
  switch (type) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      // ] ) " '
      case type:
        return position;
      // " '
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      // (
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      // \
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index2) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice(index2, position);
}
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset2 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference2 = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      // (
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      // \
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      // /
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      // {
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      // } ; \0
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          // \0 }
          case 0:
          case 125:
            scanning = 0;
          // ;
          case 59 + offset2:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          // @ ;
          case 59:
            characters2 += ";";
          // { rule/at-rule
          default:
            append(reference2 = ruleset(characters2, root, parent, index2, offset2, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset2 === 0)
                parse(characters2, root, reference2, reference2, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference2, reference2, rule && append(ruleset(value, reference2, reference2, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                }
        }
        index2 = offset2 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      // :
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          // &
          case 38:
            ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          // ,
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          // @
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset2 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          // -
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index2, offset2, rules, points, type, props, children, length2) {
  var post2 = offset2 - 1;
  var rule = offset2 === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i = 0, j = 0, k = 0; i < index2; ++i)
    for (var x = 0, y = substr(value, post2 + 1, post2 = abs(j = points[i])), z = value; x < size; ++x)
      if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x])))
        props[k++] = z;
  return node(value, root, parent, offset2 === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root, parent) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent, length2) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i = 0; i < length2; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
function stringify(element, index2, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children, callback) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection[i](element, index2, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
function memoize$1(fn2) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg2) {
    if (cache[arg2] === void 0) cache[arg2] = fn2(arg2);
    return cache[arg2];
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      // fallthrough
      default:
        parsed[index2] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value;
  var parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent) return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix(value, length2) {
  switch (hash$2(value, length2)) {
    // color-adjust
    case 5103:
      return WEBKIT + "print-" + value + value;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    // flex, flex-direction
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    // order
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    // align-items
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    // align-self
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    // align-content
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    // flex-shrink
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    // flex-basis
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    // flex-grow
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    // transition
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    // cursor
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    // background, background-image
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    // justify-content
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (charat(value, length2 + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
        // (s)tretch
        case 115:
          return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
      }
      break;
    // position: sticky
    case 4949:
      if (charat(value, length2 + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        // stic(k)y
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        // (inline-)?fl(e)x
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    // writing-mode
    case 5936:
      switch (charat(value, length2 + 11)) {
        // vertical-l(r)
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        // vertical-r(l)
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        // horizontal(-)tb
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index2, children, callback) {
  if (element.length > -1) {
    if (!element["return"]) switch (element.type) {
      case DECLARATION:
        element["return"] = prefix(element.value, element.length);
        break;
      case KEYFRAMES:
        return serialize([copy(element, {
          value: replace(element.value, "@", "@" + WEBKIT)
        })], callback);
      case RULESET:
        if (element.length) return combine(element.props, function(value) {
          switch (match(value, /(::plac\w+|:read-\w+)/)) {
            // :read-(only|write)
            case ":read-only":
            case ":read-write":
              return serialize([copy(element, {
                props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
              })], callback);
            // :placeholder
            case "::placeholder":
              return serialize([copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
              })], callback);
          }
          return "";
        });
    }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize(compile(styles2), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      var isInstance = false;
      try {
        isInstance = this instanceof a2;
      } catch (e) {
      }
      if (isInstance) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var reactIs$1 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min) return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r2 = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
  function z(a) {
    if ("object" === typeof a && null !== a) {
      var u = a.$$typeof;
      switch (u) {
        case c:
          switch (a = a.type, a) {
            case l:
            case m:
            case e:
            case g:
            case f:
            case p:
              return a;
            default:
              switch (a = a && a.$$typeof, a) {
                case k:
                case n:
                case t:
                case r2:
                case h:
                  return a;
                default:
                  return u;
              }
          }
        case d:
          return u;
      }
    }
  }
  function A(a) {
    return z(a) === m;
  }
  reactIs_production_min.AsyncMode = l;
  reactIs_production_min.ConcurrentMode = m;
  reactIs_production_min.ContextConsumer = k;
  reactIs_production_min.ContextProvider = h;
  reactIs_production_min.Element = c;
  reactIs_production_min.ForwardRef = n;
  reactIs_production_min.Fragment = e;
  reactIs_production_min.Lazy = t;
  reactIs_production_min.Memo = r2;
  reactIs_production_min.Portal = d;
  reactIs_production_min.Profiler = g;
  reactIs_production_min.StrictMode = f;
  reactIs_production_min.Suspense = p;
  reactIs_production_min.isAsyncMode = function(a) {
    return A(a) || z(a) === l;
  };
  reactIs_production_min.isConcurrentMode = A;
  reactIs_production_min.isContextConsumer = function(a) {
    return z(a) === k;
  };
  reactIs_production_min.isContextProvider = function(a) {
    return z(a) === h;
  };
  reactIs_production_min.isElement = function(a) {
    return "object" === typeof a && null !== a && a.$$typeof === c;
  };
  reactIs_production_min.isForwardRef = function(a) {
    return z(a) === n;
  };
  reactIs_production_min.isFragment = function(a) {
    return z(a) === e;
  };
  reactIs_production_min.isLazy = function(a) {
    return z(a) === t;
  };
  reactIs_production_min.isMemo = function(a) {
    return z(a) === r2;
  };
  reactIs_production_min.isPortal = function(a) {
    return z(a) === d;
  };
  reactIs_production_min.isProfiler = function(a) {
    return z(a) === g;
  };
  reactIs_production_min.isStrictMode = function(a) {
    return z(a) === f;
  };
  reactIs_production_min.isSuspense = function(a) {
    return z(a) === p;
  };
  reactIs_production_min.isValidElementType = function(a) {
    return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r2 || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
  };
  reactIs_production_min.typeOf = z;
  return reactIs_production_min;
}
var hasRequiredReactIs$1;
function requireReactIs$1() {
  if (hasRequiredReactIs$1) return reactIs$1.exports;
  hasRequiredReactIs$1 = 1;
  {
    reactIs$1.exports = requireReactIs_production_min();
  }
  return reactIs$1.exports;
}
var hoistNonReactStatics_cjs;
var hasRequiredHoistNonReactStatics_cjs;
function requireHoistNonReactStatics_cjs() {
  if (hasRequiredHoistNonReactStatics_cjs) return hoistNonReactStatics_cjs;
  hasRequiredHoistNonReactStatics_cjs = 1;
  var reactIs2 = requireReactIs$1();
  var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
  };
  var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
  };
  var FORWARD_REF_STATICS = {
    "$$typeof": true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
  };
  var MEMO_STATICS = {
    "$$typeof": true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
  };
  var TYPE_STATICS = {};
  TYPE_STATICS[reactIs2.ForwardRef] = FORWARD_REF_STATICS;
  TYPE_STATICS[reactIs2.Memo] = MEMO_STATICS;
  function getStatics(component) {
    if (reactIs2.isMemo(component)) {
      return MEMO_STATICS;
    }
    return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
  }
  var defineProperty = Object.defineProperty;
  var getOwnPropertyNames = Object.getOwnPropertyNames;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectPrototype = Object.prototype;
  function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== "string") {
      if (objectPrototype) {
        var inheritedComponent = getPrototypeOf(sourceComponent);
        if (inheritedComponent && inheritedComponent !== objectPrototype) {
          hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
        }
      }
      var keys = getOwnPropertyNames(sourceComponent);
      if (getOwnPropertySymbols) {
        keys = keys.concat(getOwnPropertySymbols(sourceComponent));
      }
      var targetStatics = getStatics(targetComponent);
      var sourceStatics = getStatics(sourceComponent);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
          var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
          try {
            defineProperty(targetComponent, key, descriptor);
          } catch (e) {
          }
        }
      }
    }
    return targetComponent;
  }
  hoistNonReactStatics_cjs = hoistNonReactStatics;
  return hoistNonReactStatics_cjs;
}
requireHoistNonReactStatics_cjs();
var isBrowser$4 = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else if (className) {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag2) {
  var className = cache.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag2 === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser$4 === false) && cache.registered[className] === void 0
  ) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag2) {
  registerStyles(cache, serialized, isStringTag2);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h = 0;
  var k, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
    k ^= /* k >>> r: */
    k >>> 24;
    h = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 255;
      h = /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  h ^= h >>> 13;
  h = /* Math.imul(h, m): */
  (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize$1(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  var componentSelector = interpolation;
  if (componentSelector.__emotion_styles !== void 0) {
    return componentSelector;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      var keyframes2 = interpolation;
      if (keyframes2.anim === 1) {
        cursor = {
          name: keyframes2.name,
          styles: keyframes2.styles,
          next: cursor
        };
        return keyframes2.name;
      }
      var serializedStyles = interpolation;
      if (serializedStyles.styles !== void 0) {
        var next2 = serializedStyles.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = serializedStyles.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  var asString = interpolation;
  if (registered == null) {
    return asString;
  }
  var cached = registered[asString];
  return cached !== void 0 ? cached : asString;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var key in obj) {
      var value = obj[key];
      if (typeof value !== "object") {
        var asString = value;
        if (registered != null && registered[asString] !== void 0) {
          string += key + "{" + registered[asString] + "}";
        } else if (isProcessableValue(asString)) {
          string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
        }
      } else {
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (key) {
            case "animation":
            case "animationName": {
              string += processStyleName(key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string += key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
var cursor;
function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    var asTemplateStringsArr = strings;
    styles2 += asTemplateStringsArr[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      var templateStringsArr = strings;
      styles2 += templateStringsArr[i];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + match2[1];
  }
  var name2 = murmur2(styles2) + identifierName;
  return {
    name: name2,
    styles: styles2,
    next: cursor
  };
}
const React$25 = window["React"];
var syncFallback = function syncFallback2(create) {
  return create();
};
var useInsertionEffect = React$25["useInsertionEffect"] ? React$25["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || React$25.useLayoutEffect;
const React$24 = window["React"];
const useContext$1 = window["React"].useContext;
const forwardRef = window["React"].forwardRef;
var EmotionCacheContext = /* @__PURE__ */ React$24.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ forwardRef(function(props, ref) {
    var cache = useContext$1(EmotionCacheContext);
    return func(props, cache, ref);
  });
};
var ThemeContext$1 = /* @__PURE__ */ React$24.createContext({});
var hasOwn = {}.hasOwnProperty;
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type, props) {
  var newProps = {};
  for (var _key in props) {
    if (hasOwn.call(props, _key)) {
      newProps[_key] = props[_key];
    }
  }
  newProps[typePropName] = type;
  return newProps;
};
var Insertion$1 = function Insertion(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag2);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag2);
  });
  return null;
};
var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache, ref) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache.registered[cssProp] !== void 0) {
    cssProp = cache.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, React$24.useContext(ThemeContext$1));
  className += cache.key + "-" + serialized.name;
  var newProps = {};
  for (var _key2 in props) {
    if (hasOwn.call(props, _key2) && _key2 !== "css" && _key2 !== typePropName && true) {
      newProps[_key2] = props[_key2];
    }
  }
  newProps.className = className;
  if (ref) {
    newProps.ref = ref;
  }
  return /* @__PURE__ */ React$24.createElement(React$24.Fragment, null, /* @__PURE__ */ React$24.createElement(Insertion$1, {
    cache,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), /* @__PURE__ */ React$24.createElement(WrappedComponent, newProps));
});
var Emotion$1 = Emotion;
const React$23 = window["React"];
var jsx = function jsx2(type, props) {
  var args = arguments;
  if (props == null || !hasOwn.call(props, "css")) {
    return React$23.createElement.apply(void 0, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1;
  createElementArgArray[1] = createEmotionProps(type, props);
  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  }
  return React$23.createElement.apply(null, createElementArgArray);
};
(function(_jsx) {
  var JSX;
  /* @__PURE__ */ (function(_JSX) {
  })(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
})(jsx || (jsx = {}));
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache) {
  var styles2 = props.styles;
  var serialized = serializeStyles([styles2], void 0, React$23.useContext(ThemeContext$1));
  var sheetRef = React$23.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache.key + "-global";
    var sheet = new cache.sheet.constructor({
      key,
      nonce: cache.sheet.nonce,
      container: cache.sheet.container,
      speedy: cache.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache.sheet.tags.length) {
      sheet.before = cache.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache.insert("", serialized, sheet, false);
  }, [cache, serialized.name]);
  return null;
});
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
function keyframes() {
  var insertable = css.apply(void 0, arguments);
  var name2 = "animation-" + insertable.name;
  return {
    name: name2,
    styles: "@keyframes " + name2 + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|popover|popoverTarget|popoverTargetAction|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize$1(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
const React$22 = window["React"];
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
  return key !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
  var shouldForwardProp2;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp2 !== "function" && isReal) {
    shouldForwardProp2 = tag.__emotion_forwardProp;
  }
  return shouldForwardProp2;
};
var Insertion2 = function Insertion3(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag2);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag2);
  });
  return null;
};
var createStyled$1 = function createStyled(tag, options) {
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles2.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles2.push.apply(styles2, args);
    } else {
      var templateStringsArr = args[0];
      styles2.push(templateStringsArr[0]);
      var len = args.length;
      var i = 1;
      for (; i < len; i++) {
        styles2.push(args[i], templateStringsArr[i]);
      }
    }
    var Styled = withEmotionCache(function(props, cache, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key in props) {
          mergedProps[key] = props[key];
        }
        mergedProps.theme = React$22.useContext(ThemeContext$1);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(styles2.concat(classInterpolations), cache.registered, mergedProps);
      className += cache.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as") continue;
        if (finalShouldForwardProp(_key)) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      if (ref) {
        newProps.ref = ref;
      }
      return /* @__PURE__ */ React$22.createElement(React$22.Fragment, null, /* @__PURE__ */ React$22.createElement(Insertion2, {
        cache,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ React$22.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles2;
    Styled.__emotion_forwardProp = shouldForwardProp2;
    Object.defineProperty(Styled, "toString", {
      value: function value() {
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      var newStyled = createStyled(nextTag, _extends({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      }));
      return newStyled.apply(void 0, styles2);
    };
    return Styled;
  };
};
var tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var styled$3 = createStyled$1.bind(null);
tags.forEach(function(tagName) {
  styled$3[tagName] = styled$3(tagName);
});
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f = window["React"], k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
  function q(c, a, g) {
    var b, d = {}, e = null, h = null;
    void 0 !== g && (e = "" + g);
    void 0 !== a.key && (e = "" + a.key);
    void 0 !== a.ref && (h = a.ref);
    for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
    if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
    return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
  }
  reactJsxRuntime_production_min.Fragment = l;
  reactJsxRuntime_production_min.jsx = q;
  reactJsxRuntime_production_min.jsxs = q;
  return reactJsxRuntime_production_min;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  {
    jsxRuntime.exports = requireReactJsxRuntime_production_min();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
function isEmpty$2(obj) {
  return obj === void 0 || obj === null || Object.keys(obj).length === 0;
}
function GlobalStyles$3(props) {
  const {
    styles: styles2,
    defaultTheme: defaultTheme2 = {}
  } = props;
  const globalStyles = typeof styles2 === "function" ? (themeInput) => styles2(isEmpty$2(themeInput) ? defaultTheme2 : themeInput) : styles2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Global, {
    styles: globalStyles
  });
}
function styled$2(tag, options) {
  const stylesFactory = styled$3(tag, options);
  return stylesFactory;
}
function internal_mutateStyles(tag, processor) {
  if (Array.isArray(tag.__emotion_styles)) {
    tag.__emotion_styles = processor(tag.__emotion_styles);
  }
}
const wrapper = [];
function internal_serializeStyles(styles2) {
  wrapper[0] = styles2;
  return serializeStyles(wrapper);
}
var reactIs = { exports: {} };
var reactIs_production = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production;
function requireReactIs_production() {
  if (hasRequiredReactIs_production) return reactIs_production;
  hasRequiredReactIs_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
  function typeOf(object) {
    if ("object" === typeof object && null !== object) {
      var $$typeof = object.$$typeof;
      switch ($$typeof) {
        case REACT_ELEMENT_TYPE:
          switch (object = object.type, object) {
            case REACT_FRAGMENT_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_SUSPENSE_TYPE:
            case REACT_SUSPENSE_LIST_TYPE:
            case REACT_VIEW_TRANSITION_TYPE:
              return object;
            default:
              switch (object = object && object.$$typeof, object) {
                case REACT_CONTEXT_TYPE:
                case REACT_FORWARD_REF_TYPE:
                case REACT_LAZY_TYPE:
                case REACT_MEMO_TYPE:
                  return object;
                case REACT_CONSUMER_TYPE:
                  return object;
                default:
                  return $$typeof;
              }
          }
        case REACT_PORTAL_TYPE:
          return $$typeof;
      }
    }
  }
  reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE;
  reactIs_production.ContextProvider = REACT_CONTEXT_TYPE;
  reactIs_production.Element = REACT_ELEMENT_TYPE;
  reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE;
  reactIs_production.Fragment = REACT_FRAGMENT_TYPE;
  reactIs_production.Lazy = REACT_LAZY_TYPE;
  reactIs_production.Memo = REACT_MEMO_TYPE;
  reactIs_production.Portal = REACT_PORTAL_TYPE;
  reactIs_production.Profiler = REACT_PROFILER_TYPE;
  reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE;
  reactIs_production.Suspense = REACT_SUSPENSE_TYPE;
  reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
  reactIs_production.isContextConsumer = function(object) {
    return typeOf(object) === REACT_CONSUMER_TYPE;
  };
  reactIs_production.isContextProvider = function(object) {
    return typeOf(object) === REACT_CONTEXT_TYPE;
  };
  reactIs_production.isElement = function(object) {
    return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
  };
  reactIs_production.isForwardRef = function(object) {
    return typeOf(object) === REACT_FORWARD_REF_TYPE;
  };
  reactIs_production.isFragment = function(object) {
    return typeOf(object) === REACT_FRAGMENT_TYPE;
  };
  reactIs_production.isLazy = function(object) {
    return typeOf(object) === REACT_LAZY_TYPE;
  };
  reactIs_production.isMemo = function(object) {
    return typeOf(object) === REACT_MEMO_TYPE;
  };
  reactIs_production.isPortal = function(object) {
    return typeOf(object) === REACT_PORTAL_TYPE;
  };
  reactIs_production.isProfiler = function(object) {
    return typeOf(object) === REACT_PROFILER_TYPE;
  };
  reactIs_production.isStrictMode = function(object) {
    return typeOf(object) === REACT_STRICT_MODE_TYPE;
  };
  reactIs_production.isSuspense = function(object) {
    return typeOf(object) === REACT_SUSPENSE_TYPE;
  };
  reactIs_production.isSuspenseList = function(object) {
    return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
  };
  reactIs_production.isValidElementType = function(type) {
    return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;
  };
  reactIs_production.typeOf = typeOf;
  return reactIs_production;
}
var hasRequiredReactIs;
function requireReactIs() {
  if (hasRequiredReactIs) return reactIs.exports;
  hasRequiredReactIs = 1;
  {
    reactIs.exports = /* @__PURE__ */ requireReactIs_production();
  }
  return reactIs.exports;
}
var reactIsExports = /* @__PURE__ */ requireReactIs();
const React$21 = window["React"];
function isPlainObject$2(item) {
  if (typeof item !== "object" || item === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(item);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in item) && !(Symbol.iterator in item);
}
function deepClone$1(source) {
  if (/* @__PURE__ */ React$21.isValidElement(source) || reactIsExports.isValidElementType(source) || !isPlainObject$2(source)) {
    return source;
  }
  const output = {};
  Object.keys(source).forEach((key) => {
    output[key] = deepClone$1(source[key]);
  });
  return output;
}
function deepmerge(target, source, options = {
  clone: true
}) {
  const output = options.clone ? __spreadValues({}, target) : target;
  if (isPlainObject$2(target) && isPlainObject$2(source)) {
    Object.keys(source).forEach((key) => {
      if (/* @__PURE__ */ React$21.isValidElement(source[key]) || reactIsExports.isValidElementType(source[key])) {
        output[key] = source[key];
      } else if (isPlainObject$2(source[key]) && // Avoid prototype pollution
      Object.prototype.hasOwnProperty.call(target, key) && isPlainObject$2(target[key])) {
        output[key] = deepmerge(target[key], source[key], options);
      } else if (options.clone) {
        output[key] = isPlainObject$2(source[key]) ? deepClone$1(source[key]) : source[key];
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
const sortBreakpointsValues = (values2) => {
  const breakpointsAsArray = Object.keys(values2).map((key) => ({
    key,
    val: values2[key]
  })) || [];
  breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
  return breakpointsAsArray.reduce((acc, obj) => {
    return __spreadProps(__spreadValues({}, acc), {
      [obj.key]: obj.val
    });
  }, {});
};
function createBreakpoints(breakpoints) {
  const _a2 = breakpoints, {
    values: values2 = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit = "px",
    step = 5
  } = _a2, other = __objRest(_a2, [
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    "values",
    "unit",
    "step"
  ]);
  const sortedValues = sortBreakpointsValues(values2);
  const keys = Object.keys(sortedValues);
  function up(key) {
    const value = typeof values2[key] === "number" ? values2[key] : key;
    return `@media (min-width:${value}${unit})`;
  }
  function down(key) {
    const value = typeof values2[key] === "number" ? values2[key] : key;
    return `@media (max-width:${value - step / 100}${unit})`;
  }
  function between(start2, end2) {
    const endIndex = keys.indexOf(end2);
    return `@media (min-width:${typeof values2[start2] === "number" ? values2[start2] : start2}${unit}) and (max-width:${(endIndex !== -1 && typeof values2[keys[endIndex]] === "number" ? values2[keys[endIndex]] : end2) - step / 100}${unit})`;
  }
  function only(key) {
    if (keys.indexOf(key) + 1 < keys.length) {
      return between(key, keys[keys.indexOf(key) + 1]);
    }
    return up(key);
  }
  function not(key) {
    const keyIndex = keys.indexOf(key);
    if (keyIndex === 0) {
      return up(keys[1]);
    }
    if (keyIndex === keys.length - 1) {
      return down(keys[keyIndex]);
    }
    return between(key, keys[keys.indexOf(key) + 1]).replace("@media", "@media not all and");
  }
  return __spreadValues({
    keys,
    values: sortedValues,
    up,
    down,
    between,
    only,
    not,
    unit
  }, other);
}
function sortContainerQueries(theme2, css2) {
  if (!theme2.containerQueries) {
    return css2;
  }
  const sorted = Object.keys(css2).filter((key) => key.startsWith("@container")).sort((a, b) => {
    var _a2, _b;
    const regex = /min-width:\s*([0-9.]+)/;
    return +(((_a2 = a.match(regex)) == null ? void 0 : _a2[1]) || 0) - +(((_b = b.match(regex)) == null ? void 0 : _b[1]) || 0);
  });
  if (!sorted.length) {
    return css2;
  }
  return sorted.reduce((acc, key) => {
    const value = css2[key];
    delete acc[key];
    acc[key] = value;
    return acc;
  }, __spreadValues({}, css2));
}
function isCqShorthand(breakpointKeys, value) {
  return value === "@" || value.startsWith("@") && (breakpointKeys.some((key) => value.startsWith(`@${key}`)) || !!value.match(/^@\d/));
}
function getContainerQuery(theme2, shorthand) {
  const matches = shorthand.match(/^@([^/]+)?\/?(.+)?$/);
  if (!matches) {
    return null;
  }
  const [, containerQuery, containerName] = matches;
  const value = Number.isNaN(+containerQuery) ? containerQuery || 0 : +containerQuery;
  return theme2.containerQueries(containerName).up(value);
}
function cssContainerQueries(themeInput) {
  const toContainerQuery = (mediaQuery, name2) => mediaQuery.replace("@media", name2 ? `@container ${name2}` : "@container");
  function attachCq(node22, name2) {
    node22.up = (...args) => toContainerQuery(themeInput.breakpoints.up(...args), name2);
    node22.down = (...args) => toContainerQuery(themeInput.breakpoints.down(...args), name2);
    node22.between = (...args) => toContainerQuery(themeInput.breakpoints.between(...args), name2);
    node22.only = (...args) => toContainerQuery(themeInput.breakpoints.only(...args), name2);
    node22.not = (...args) => {
      const result = toContainerQuery(themeInput.breakpoints.not(...args), name2);
      if (result.includes("not all and")) {
        return result.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or");
      }
      return result;
    };
  }
  const node2 = {};
  const containerQueries = (name2) => {
    attachCq(node2, name2);
    return node2;
  };
  attachCq(containerQueries);
  return __spreadProps(__spreadValues({}, themeInput), {
    containerQueries
  });
}
const shape = {
  borderRadius: 4
};
function merge(acc, item) {
  if (!item) {
    return acc;
  }
  return deepmerge(acc, item, {
    clone: false
    // No need to clone deep, it's way faster.
  });
}
const values$1 = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
};
const defaultBreakpoints = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (key) => `@media (min-width:${values$1[key]}px)`
};
const defaultContainerQueries = {
  containerQueries: (containerName) => ({
    up: (key) => {
      let result = typeof key === "number" ? key : values$1[key] || key;
      if (typeof result === "number") {
        result = `${result}px`;
      }
      return containerName ? `@container ${containerName} (min-width:${result})` : `@container (min-width:${result})`;
    }
  })
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
  const theme2 = props.theme || {};
  if (Array.isArray(propValue)) {
    const themeBreakpoints = theme2.breakpoints || defaultBreakpoints;
    return propValue.reduce((acc, item, index2) => {
      acc[themeBreakpoints.up(themeBreakpoints.keys[index2])] = styleFromPropValue(propValue[index2]);
      return acc;
    }, {});
  }
  if (typeof propValue === "object") {
    const themeBreakpoints = theme2.breakpoints || defaultBreakpoints;
    return Object.keys(propValue).reduce((acc, breakpoint) => {
      if (isCqShorthand(themeBreakpoints.keys, breakpoint)) {
        const containerKey = getContainerQuery(theme2.containerQueries ? theme2 : defaultContainerQueries, breakpoint);
        if (containerKey) {
          acc[containerKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
        }
      } else if (Object.keys(themeBreakpoints.values || values$1).includes(breakpoint)) {
        const mediaKey = themeBreakpoints.up(breakpoint);
        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
      } else {
        const cssKey = breakpoint;
        acc[cssKey] = propValue[cssKey];
      }
      return acc;
    }, {});
  }
  const output = styleFromPropValue(propValue);
  return output;
}
function createEmptyBreakpointObject(breakpointsInput = {}) {
  var _a2;
  const breakpointsInOrder = (_a2 = breakpointsInput.keys) == null ? void 0 : _a2.reduce((acc, key) => {
    const breakpointStyleKey = breakpointsInput.up(key);
    acc[breakpointStyleKey] = {};
    return acc;
  }, {});
  return breakpointsInOrder || {};
}
function removeUnusedBreakpoints(breakpointKeys, style2) {
  return breakpointKeys.reduce((acc, key) => {
    const breakpointOutput = acc[key];
    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
    if (isBreakpointUnused) {
      delete acc[key];
    }
    return acc;
  }, style2);
}
function mergeBreakpointsInOrder(breakpointsInput, ...styles2) {
  const emptyBreakpoints = createEmptyBreakpointObject(breakpointsInput);
  const mergedOutput = [emptyBreakpoints, ...styles2].reduce((prev2, next2) => deepmerge(prev2, next2), {});
  return removeUnusedBreakpoints(Object.keys(emptyBreakpoints), mergedOutput);
}
function computeBreakpointsBase(breakpointValues, themeBreakpoints) {
  if (typeof breakpointValues !== "object") {
    return {};
  }
  const base = {};
  const breakpointsKeys = Object.keys(themeBreakpoints);
  if (Array.isArray(breakpointValues)) {
    breakpointsKeys.forEach((breakpoint, i) => {
      if (i < breakpointValues.length) {
        base[breakpoint] = true;
      }
    });
  } else {
    breakpointsKeys.forEach((breakpoint) => {
      if (breakpointValues[breakpoint] != null) {
        base[breakpoint] = true;
      }
    });
  }
  return base;
}
function resolveBreakpointValues({
  values: breakpointValues,
  breakpoints: themeBreakpoints,
  base: customBase
}) {
  const base = customBase || computeBreakpointsBase(breakpointValues, themeBreakpoints);
  const keys = Object.keys(base);
  if (keys.length === 0) {
    return breakpointValues;
  }
  let previous;
  return keys.reduce((acc, breakpoint, i) => {
    if (Array.isArray(breakpointValues)) {
      acc[breakpoint] = breakpointValues[i] != null ? breakpointValues[i] : breakpointValues[previous];
      previous = i;
    } else if (typeof breakpointValues === "object") {
      acc[breakpoint] = breakpointValues[breakpoint] != null ? breakpointValues[breakpoint] : breakpointValues[previous];
      previous = breakpoint;
    } else {
      acc[breakpoint] = breakpointValues;
    }
    return acc;
  }, {});
}
function capitalize(string) {
  if (typeof string !== "string") {
    throw new Error(formatMuiErrorMessage(7));
  }
  return string.charAt(0).toUpperCase() + string.slice(1);
}
function getPath(obj, path, checkVars = true) {
  if (!path || typeof path !== "string") {
    return null;
  }
  if (obj && obj.vars && checkVars) {
    const val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
    if (val != null) {
      return val;
    }
  }
  return path.split(".").reduce((acc, item) => {
    if (acc && acc[item] != null) {
      return acc[item];
    }
    return null;
  }, obj);
}
function getStyleValue$1(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
  let value;
  if (typeof themeMapping === "function") {
    value = themeMapping(propValueFinal);
  } else if (Array.isArray(themeMapping)) {
    value = themeMapping[propValueFinal] || userValue;
  } else {
    value = getPath(themeMapping, propValueFinal) || userValue;
  }
  if (transform) {
    value = transform(value, userValue, themeMapping);
  }
  return value;
}
function style$2(options) {
  const {
    prop,
    cssProperty = options.prop,
    themeKey,
    transform
  } = options;
  const fn2 = (props) => {
    if (props[prop] == null) {
      return null;
    }
    const propValue = props[prop];
    const theme2 = props.theme;
    const themeMapping = getPath(theme2, themeKey) || {};
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue$1(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, propValue, styleFromPropValue);
  };
  fn2.propTypes = {};
  fn2.filterProps = [prop];
  return fn2;
}
function memoize(fn2) {
  const cache = {};
  return (arg2) => {
    if (cache[arg2] === void 0) {
      cache[arg2] = fn2(arg2);
    }
    return cache[arg2];
  };
}
const properties = {
  m: "margin",
  p: "padding"
};
const directions = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
};
const aliases = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
};
const getCssProperties = memoize((prop) => {
  if (prop.length > 2) {
    if (aliases[prop]) {
      prop = aliases[prop];
    } else {
      return [prop];
    }
  }
  const [a, b] = prop.split("");
  const property = properties[a];
  const direction = directions[b] || "";
  return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
});
const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...marginKeys, ...paddingKeys];
function createUnaryUnit(theme2, themeKey, defaultValue, propName) {
  var _a2;
  const themeSpacing = (_a2 = getPath(theme2, themeKey, true)) != null ? _a2 : defaultValue;
  if (typeof themeSpacing === "number" || typeof themeSpacing === "string") {
    return (val) => {
      if (typeof val === "string") {
        return val;
      }
      if (typeof themeSpacing === "string") {
        if (themeSpacing.startsWith("var(") && val === 0) {
          return 0;
        }
        if (themeSpacing.startsWith("var(") && val === 1) {
          return themeSpacing;
        }
        return `calc(${val} * ${themeSpacing})`;
      }
      return themeSpacing * val;
    };
  }
  if (Array.isArray(themeSpacing)) {
    return (val) => {
      if (typeof val === "string") {
        return val;
      }
      const abs2 = Math.abs(val);
      const transformed = themeSpacing[abs2];
      if (val >= 0) {
        return transformed;
      }
      if (typeof transformed === "number") {
        return -transformed;
      }
      if (typeof transformed === "string" && transformed.startsWith("var(")) {
        return `calc(-1 * ${transformed})`;
      }
      return `-${transformed}`;
    };
  }
  if (typeof themeSpacing === "function") {
    return themeSpacing;
  }
  return () => void 0;
}
function createUnarySpacing(theme2) {
  return createUnaryUnit(theme2, "spacing", 8);
}
function getValue(transformer, propValue) {
  if (typeof propValue === "string" || propValue == null) {
    return propValue;
  }
  return transformer(propValue);
}
function getStyleFromPropValue(cssProperties, transformer) {
  return (propValue) => cssProperties.reduce((acc, cssProperty) => {
    acc[cssProperty] = getValue(transformer, propValue);
    return acc;
  }, {});
}
function resolveCssProperty(props, keys, prop, transformer) {
  if (!keys.includes(prop)) {
    return null;
  }
  const cssProperties = getCssProperties(prop);
  const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
  const propValue = props[prop];
  return handleBreakpoints(props, propValue, styleFromPropValue);
}
function style$1(props, keys) {
  const transformer = createUnarySpacing(props.theme);
  return Object.keys(props).map((prop) => resolveCssProperty(props, keys, prop, transformer)).reduce(merge, {});
}
function margin(props) {
  return style$1(props, marginKeys);
}
margin.propTypes = {};
margin.filterProps = marginKeys;
function padding(props) {
  return style$1(props, paddingKeys);
}
padding.propTypes = {};
padding.filterProps = paddingKeys;
function createSpacing(spacingInput = 8, transform = createUnarySpacing({
  spacing: spacingInput
})) {
  if (spacingInput.mui) {
    return spacingInput;
  }
  const spacing = (...argsInput) => {
    const args = argsInput.length === 0 ? [1] : argsInput;
    return args.map((argument) => {
      const output = transform(argument);
      return typeof output === "number" ? `${output}px` : output;
    }).join(" ");
  };
  spacing.mui = true;
  return spacing;
}
function compose(...styles2) {
  const handlers = styles2.reduce((acc, style2) => {
    style2.filterProps.forEach((prop) => {
      acc[prop] = style2;
    });
    return acc;
  }, {});
  const fn2 = (props) => {
    return Object.keys(props).reduce((acc, prop) => {
      if (handlers[prop]) {
        return merge(acc, handlers[prop](props));
      }
      return acc;
    }, {});
  };
  fn2.propTypes = {};
  fn2.filterProps = styles2.reduce((acc, style2) => acc.concat(style2.filterProps), []);
  return fn2;
}
function borderTransform(value) {
  if (typeof value !== "number") {
    return value;
  }
  return `${value}px solid`;
}
function createBorderStyle(prop, transform) {
  return style$2({
    prop,
    themeKey: "borders",
    transform
  });
}
const border = createBorderStyle("border", borderTransform);
const borderTop = createBorderStyle("borderTop", borderTransform);
const borderRight = createBorderStyle("borderRight", borderTransform);
const borderBottom = createBorderStyle("borderBottom", borderTransform);
const borderLeft = createBorderStyle("borderLeft", borderTransform);
const borderColor = createBorderStyle("borderColor");
const borderTopColor = createBorderStyle("borderTopColor");
const borderRightColor = createBorderStyle("borderRightColor");
const borderBottomColor = createBorderStyle("borderBottomColor");
const borderLeftColor = createBorderStyle("borderLeftColor");
const outline = createBorderStyle("outline", borderTransform);
const outlineColor = createBorderStyle("outlineColor");
const borderRadius = (props) => {
  if (props.borderRadius !== void 0 && props.borderRadius !== null) {
    const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4);
    const styleFromPropValue = (propValue) => ({
      borderRadius: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
  }
  return null;
};
borderRadius.propTypes = {};
borderRadius.filterProps = ["borderRadius"];
compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);
const gap = (props) => {
  if (props.gap !== void 0 && props.gap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      gap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.gap, styleFromPropValue);
  }
  return null;
};
gap.propTypes = {};
gap.filterProps = ["gap"];
const columnGap = (props) => {
  if (props.columnGap !== void 0 && props.columnGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      columnGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.columnGap, styleFromPropValue);
  }
  return null;
};
columnGap.propTypes = {};
columnGap.filterProps = ["columnGap"];
const rowGap = (props) => {
  if (props.rowGap !== void 0 && props.rowGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      rowGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.rowGap, styleFromPropValue);
  }
  return null;
};
rowGap.propTypes = {};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$2({
  prop: "gridColumn"
});
const gridRow = style$2({
  prop: "gridRow"
});
const gridAutoFlow = style$2({
  prop: "gridAutoFlow"
});
const gridAutoColumns = style$2({
  prop: "gridAutoColumns"
});
const gridAutoRows = style$2({
  prop: "gridAutoRows"
});
const gridTemplateColumns = style$2({
  prop: "gridTemplateColumns"
});
const gridTemplateRows = style$2({
  prop: "gridTemplateRows"
});
const gridTemplateAreas = style$2({
  prop: "gridTemplateAreas"
});
const gridArea = style$2({
  prop: "gridArea"
});
compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
function paletteTransform(value, userValue) {
  if (userValue === "grey") {
    return userValue;
  }
  return value;
}
const color = style$2({
  prop: "color",
  themeKey: "palette",
  transform: paletteTransform
});
const bgcolor = style$2({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
const backgroundColor = style$2({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
compose(color, bgcolor, backgroundColor);
function sizingTransform(value) {
  return value <= 1 && value !== 0 ? `${value * 100}%` : value;
}
const width = style$2({
  prop: "width",
  transform: sizingTransform
});
const maxWidth = (props) => {
  if (props.maxWidth !== void 0 && props.maxWidth !== null) {
    const styleFromPropValue = (propValue) => {
      var _a2, _b, _c, _d, _e;
      const breakpoint = ((_c = (_b = (_a2 = props.theme) == null ? void 0 : _a2.breakpoints) == null ? void 0 : _b.values) == null ? void 0 : _c[propValue]) || values$1[propValue];
      if (!breakpoint) {
        return {
          maxWidth: sizingTransform(propValue)
        };
      }
      if (((_e = (_d = props.theme) == null ? void 0 : _d.breakpoints) == null ? void 0 : _e.unit) !== "px") {
        return {
          maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
        };
      }
      return {
        maxWidth: breakpoint
      };
    };
    return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
  }
  return null;
};
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$2({
  prop: "minWidth",
  transform: sizingTransform
});
const height = style$2({
  prop: "height",
  transform: sizingTransform
});
const maxHeight = style$2({
  prop: "maxHeight",
  transform: sizingTransform
});
const minHeight = style$2({
  prop: "minHeight",
  transform: sizingTransform
});
style$2({
  prop: "size",
  cssProperty: "width",
  transform: sizingTransform
});
style$2({
  prop: "size",
  cssProperty: "height",
  transform: sizingTransform
});
const boxSizing = style$2({
  prop: "boxSizing"
});
compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const defaultSxConfig = {
  // borders
  border: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderTop: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderRight: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderBottom: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderLeft: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: borderTransform
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: borderRadius
  },
  // palette
  color: {
    themeKey: "palette",
    transform: paletteTransform
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: paletteTransform
  },
  backgroundColor: {
    themeKey: "palette",
    transform: paletteTransform
  },
  // spacing
  p: {
    style: padding
  },
  pt: {
    style: padding
  },
  pr: {
    style: padding
  },
  pb: {
    style: padding
  },
  pl: {
    style: padding
  },
  px: {
    style: padding
  },
  py: {
    style: padding
  },
  padding: {
    style: padding
  },
  paddingTop: {
    style: padding
  },
  paddingRight: {
    style: padding
  },
  paddingBottom: {
    style: padding
  },
  paddingLeft: {
    style: padding
  },
  paddingX: {
    style: padding
  },
  paddingY: {
    style: padding
  },
  paddingInline: {
    style: padding
  },
  paddingInlineStart: {
    style: padding
  },
  paddingInlineEnd: {
    style: padding
  },
  paddingBlock: {
    style: padding
  },
  paddingBlockStart: {
    style: padding
  },
  paddingBlockEnd: {
    style: padding
  },
  m: {
    style: margin
  },
  mt: {
    style: margin
  },
  mr: {
    style: margin
  },
  mb: {
    style: margin
  },
  ml: {
    style: margin
  },
  mx: {
    style: margin
  },
  my: {
    style: margin
  },
  margin: {
    style: margin
  },
  marginTop: {
    style: margin
  },
  marginRight: {
    style: margin
  },
  marginBottom: {
    style: margin
  },
  marginLeft: {
    style: margin
  },
  marginX: {
    style: margin
  },
  marginY: {
    style: margin
  },
  marginInline: {
    style: margin
  },
  marginInlineStart: {
    style: margin
  },
  marginInlineEnd: {
    style: margin
  },
  marginBlock: {
    style: margin
  },
  marginBlockStart: {
    style: margin
  },
  marginBlockEnd: {
    style: margin
  },
  // display
  displayPrint: {
    cssProperty: false,
    transform: (value) => ({
      "@media print": {
        display: value
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: gap
  },
  rowGap: {
    style: rowGap
  },
  columnGap: {
    style: columnGap
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: sizingTransform
  },
  maxWidth: {
    style: maxWidth
  },
  minWidth: {
    transform: sizingTransform
  },
  height: {
    transform: sizingTransform
  },
  maxHeight: {
    transform: sizingTransform
  },
  minHeight: {
    transform: sizingTransform
  },
  boxSizing: {},
  // typography
  font: {
    themeKey: "font"
  },
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: false,
    themeKey: "typography"
  }
};
function objectsHaveSameKeys(...objects) {
  const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
  const union = new Set(allKeys);
  return objects.every((object) => union.size === Object.keys(object).length);
}
function callIfFn(maybeFn, arg2) {
  return typeof maybeFn === "function" ? maybeFn(arg2) : maybeFn;
}
function unstable_createStyleFunctionSx() {
  function getThemeValue(prop, val, theme2, config2) {
    const props = {
      [prop]: val,
      theme: theme2
    };
    const options = config2[prop];
    if (!options) {
      return {
        [prop]: val
      };
    }
    const {
      cssProperty = prop,
      themeKey,
      transform,
      style: style2
    } = options;
    if (val == null) {
      return null;
    }
    if (themeKey === "typography" && val === "inherit") {
      return {
        [prop]: val
      };
    }
    const themeMapping = getPath(theme2, themeKey) || {};
    if (style2) {
      return style2(props);
    }
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue$1(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, val, styleFromPropValue);
  }
  function styleFunctionSx2(props) {
    var _a2;
    const {
      sx,
      theme: theme2 = {},
      nested: nested2
    } = props || {};
    if (!sx) {
      return null;
    }
    const config2 = (_a2 = theme2.unstable_sxConfig) != null ? _a2 : defaultSxConfig;
    function traverse(sxInput) {
      let sxObject = sxInput;
      if (typeof sxInput === "function") {
        sxObject = sxInput(theme2);
      } else if (typeof sxInput !== "object") {
        return sxInput;
      }
      if (!sxObject) {
        return null;
      }
      const emptyBreakpoints = createEmptyBreakpointObject(theme2.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css2 = emptyBreakpoints;
      Object.keys(sxObject).forEach((styleKey) => {
        const value = callIfFn(sxObject[styleKey], theme2);
        if (value !== null && value !== void 0) {
          if (typeof value === "object") {
            if (config2[styleKey]) {
              css2 = merge(css2, getThemeValue(styleKey, value, theme2, config2));
            } else {
              const breakpointsValues = handleBreakpoints({
                theme: theme2
              }, value, (x) => ({
                [styleKey]: x
              }));
              if (objectsHaveSameKeys(breakpointsValues, value)) {
                css2[styleKey] = styleFunctionSx2({
                  sx: value,
                  theme: theme2,
                  nested: true
                });
              } else {
                css2 = merge(css2, breakpointsValues);
              }
            }
          } else {
            css2 = merge(css2, getThemeValue(styleKey, value, theme2, config2));
          }
        }
      });
      if (!nested2 && theme2.modularCssLayers) {
        return {
          "@layer sx": sortContainerQueries(theme2, removeUnusedBreakpoints(breakpointsKeys, css2))
        };
      }
      return sortContainerQueries(theme2, removeUnusedBreakpoints(breakpointsKeys, css2));
    }
    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }
  return styleFunctionSx2;
}
const styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ["sx"];
function applyStyles$2(key, styles2) {
  var _a2;
  const theme2 = this;
  if (theme2.vars) {
    if (!((_a2 = theme2.colorSchemes) == null ? void 0 : _a2[key]) || typeof theme2.getColorSchemeSelector !== "function") {
      return {};
    }
    let selector = theme2.getColorSchemeSelector(key);
    if (selector === "&") {
      return styles2;
    }
    if (selector.includes("data-") || selector.includes(".")) {
      selector = `*:where(${selector.replace(/\s*&$/, "")}) &`;
    }
    return {
      [selector]: styles2
    };
  }
  if (theme2.palette.mode === key) {
    return styles2;
  }
  return {};
}
function createTheme$1(options = {}, ...args) {
  const _a2 = options, {
    breakpoints: breakpointsInput = {},
    palette: paletteInput = {},
    spacing: spacingInput,
    shape: shapeInput = {}
  } = _a2, other = __objRest(_a2, [
    "breakpoints",
    "palette",
    "spacing",
    "shape"
  ]);
  const breakpoints = createBreakpoints(breakpointsInput);
  const spacing = createSpacing(spacingInput);
  let muiTheme = deepmerge({
    breakpoints,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: __spreadValues({
      mode: "light"
    }, paletteInput),
    spacing,
    shape: __spreadValues(__spreadValues({}, shape), shapeInput)
  }, other);
  muiTheme = cssContainerQueries(muiTheme);
  muiTheme.applyStyles = applyStyles$2;
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = __spreadValues(__spreadValues({}, defaultSxConfig), other == null ? void 0 : other.unstable_sxConfig);
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}
const React$20 = window["React"];
function isObjectEmpty$2(obj) {
  return Object.keys(obj).length === 0;
}
function useTheme$3(defaultTheme2 = null) {
  const contextTheme = React$20.useContext(ThemeContext$1);
  return !contextTheme || isObjectEmpty$2(contextTheme) ? defaultTheme2 : contextTheme;
}
const systemDefaultTheme$1 = createTheme$1();
function useTheme$2(defaultTheme2 = systemDefaultTheme$1) {
  return useTheme$3(defaultTheme2);
}
function wrapGlobalLayer(styles2) {
  const serialized = internal_serializeStyles(styles2);
  if (styles2 !== serialized && serialized.styles) {
    if (!serialized.styles.match(/^@layer\s+[^{]*$/)) {
      serialized.styles = `@layer global{${serialized.styles}}`;
    }
    return serialized;
  }
  return styles2;
}
function GlobalStyles$2({
  styles: styles2,
  themeId,
  defaultTheme: defaultTheme2 = {}
}) {
  const upperTheme = useTheme$2(defaultTheme2);
  const resolvedTheme = themeId ? upperTheme[themeId] || upperTheme : upperTheme;
  let globalStyles = typeof styles2 === "function" ? styles2(resolvedTheme) : styles2;
  if (resolvedTheme.modularCssLayers) {
    if (Array.isArray(globalStyles)) {
      globalStyles = globalStyles.map((styleArg) => {
        if (typeof styleArg === "function") {
          return wrapGlobalLayer(styleArg(resolvedTheme));
        }
        return wrapGlobalLayer(styleArg);
      });
    } else {
      globalStyles = wrapGlobalLayer(globalStyles);
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$3, {
    styles: globalStyles
  });
}
const splitProps = (props) => {
  var _a2, _b;
  const result = {
    systemProps: {},
    otherProps: {}
  };
  const config2 = (_b = (_a2 = props == null ? void 0 : props.theme) == null ? void 0 : _a2.unstable_sxConfig) != null ? _b : defaultSxConfig;
  Object.keys(props).forEach((prop) => {
    if (config2[prop]) {
      result.systemProps[prop] = props[prop];
    } else {
      result.otherProps[prop] = props[prop];
    }
  });
  return result;
};
function extendSxProp$1(props) {
  const _a2 = props, {
    sx: inSx
  } = _a2, other = __objRest(_a2, [
    "sx"
  ]);
  const {
    systemProps,
    otherProps
  } = splitProps(other);
  let finalSx;
  if (Array.isArray(inSx)) {
    finalSx = [systemProps, ...inSx];
  } else if (typeof inSx === "function") {
    finalSx = (...args) => {
      const result = inSx(...args);
      if (!isPlainObject$2(result)) {
        return systemProps;
      }
      return __spreadValues(__spreadValues({}, systemProps), result);
    };
  } else {
    finalSx = __spreadValues(__spreadValues({}, systemProps), inSx);
  }
  return __spreadProps(__spreadValues({}, otherProps), {
    sx: finalSx
  });
}
const defaultGenerator = (componentName) => componentName;
const createClassNameGenerator = () => {
  let generate = defaultGenerator;
  return {
    configure(generator) {
      generate = generator;
    },
    generate(componentName) {
      return generate(componentName);
    },
    reset() {
      generate = defaultGenerator;
    }
  };
};
const ClassNameGenerator = createClassNameGenerator();
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
const React$1$ = window["React"];
function createBox(options = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2,
    defaultClassName = "MuiBox-root",
    generateClassName
  } = options;
  const BoxRoot = styled$2("div", {
    shouldForwardProp: (prop) => prop !== "theme" && prop !== "sx" && prop !== "as"
  })(styleFunctionSx);
  const Box2 = /* @__PURE__ */ React$1$.forwardRef(function Box3(inProps, ref) {
    const theme2 = useTheme$2(defaultTheme2);
    const _a2 = extendSxProp$1(inProps), {
      className,
      component = "div"
    } = _a2, other = __objRest(_a2, [
      "className",
      "component"
    ]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(BoxRoot, __spreadValues({
      as: component,
      ref,
      className: clsx(className, generateClassName ? generateClassName(defaultClassName) : defaultClassName),
      theme: themeId ? theme2[themeId] || theme2 : theme2
    }, other));
  });
  return Box2;
}
const globalStateClasses = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
  const globalStateClass = globalStateClasses[slot];
  return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator.generate(componentName)}-${slot}`;
}
function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
  const result = {};
  slots.forEach((slot) => {
    result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
  });
  return result;
}
function preprocessStyles(input) {
  const _a2 = input, {
    variants
  } = _a2, style2 = __objRest(_a2, [
    "variants"
  ]);
  const result = {
    variants,
    style: internal_serializeStyles(style2),
    isProcessed: true
  };
  if (result.style === style2) {
    return result;
  }
  if (variants) {
    variants.forEach((variant) => {
      if (typeof variant.style !== "function") {
        variant.style = internal_serializeStyles(variant.style);
      }
    });
  }
  return result;
}
const systemDefaultTheme = createTheme$1();
function shouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
function shallowLayer(serialized, layerName) {
  if (layerName && serialized && typeof serialized === "object" && serialized.styles && !serialized.styles.startsWith("@layer")) {
    serialized.styles = `@layer ${layerName}{${String(serialized.styles)}}`;
  }
  return serialized;
}
function defaultOverridesResolver(slot) {
  if (!slot) {
    return null;
  }
  return (_props, styles2) => styles2[slot];
}
function attachTheme(props, themeId, defaultTheme2) {
  props.theme = isObjectEmpty$1(props.theme) ? defaultTheme2 : props.theme[themeId] || props.theme;
}
function processStyle(props, style2, layerName) {
  const resolvedStyle = typeof style2 === "function" ? style2(props) : style2;
  if (Array.isArray(resolvedStyle)) {
    return resolvedStyle.flatMap((subStyle) => processStyle(props, subStyle, layerName));
  }
  if (Array.isArray(resolvedStyle == null ? void 0 : resolvedStyle.variants)) {
    let rootStyle;
    if (resolvedStyle.isProcessed) {
      rootStyle = layerName ? shallowLayer(resolvedStyle.style, layerName) : resolvedStyle.style;
    } else {
      const _a2 = resolvedStyle, {
        variants
      } = _a2, otherStyles = __objRest(_a2, [
        "variants"
      ]);
      rootStyle = layerName ? shallowLayer(internal_serializeStyles(otherStyles), layerName) : otherStyles;
    }
    return processStyleVariants(props, resolvedStyle.variants, [rootStyle], layerName);
  }
  if (resolvedStyle == null ? void 0 : resolvedStyle.isProcessed) {
    return layerName ? shallowLayer(internal_serializeStyles(resolvedStyle.style), layerName) : resolvedStyle.style;
  }
  return layerName ? shallowLayer(internal_serializeStyles(resolvedStyle), layerName) : resolvedStyle;
}
function processStyleVariants(props, variants, results = [], layerName = void 0) {
  var _a2;
  let mergedState;
  variantLoop: for (let i = 0; i < variants.length; i += 1) {
    const variant = variants[i];
    if (typeof variant.props === "function") {
      mergedState != null ? mergedState : mergedState = __spreadProps(__spreadValues(__spreadValues({}, props), props.ownerState), {
        ownerState: props.ownerState
      });
      if (!variant.props(mergedState)) {
        continue;
      }
    } else {
      for (const key in variant.props) {
        if (props[key] !== variant.props[key] && ((_a2 = props.ownerState) == null ? void 0 : _a2[key]) !== variant.props[key]) {
          continue variantLoop;
        }
      }
    }
    if (typeof variant.style === "function") {
      mergedState != null ? mergedState : mergedState = __spreadProps(__spreadValues(__spreadValues({}, props), props.ownerState), {
        ownerState: props.ownerState
      });
      results.push(layerName ? shallowLayer(internal_serializeStyles(variant.style(mergedState)), layerName) : variant.style(mergedState));
    } else {
      results.push(layerName ? shallowLayer(internal_serializeStyles(variant.style), layerName) : variant.style);
    }
  }
  return results;
}
function createStyled2(input = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2 = systemDefaultTheme,
    rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
    slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp
  } = input;
  function styleAttachTheme(props) {
    attachTheme(props, themeId, defaultTheme2);
  }
  const styled2 = (tag, inputOptions = {}) => {
    internal_mutateStyles(tag, (styles2) => styles2.filter((style2) => style2 !== styleFunctionSx));
    const _a2 = inputOptions, {
      name: componentName,
      slot: componentSlot,
      skipVariantsResolver: inputSkipVariantsResolver,
      skipSx: inputSkipSx,
      overridesResolver: overridesResolver2 = defaultOverridesResolver(lowercaseFirstLetter(componentSlot))
    } = _a2, options = __objRest(_a2, [
      "name",
      "slot",
      "skipVariantsResolver",
      "skipSx",
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      "overridesResolver"
    ]);
    const layerName = componentName && componentName.startsWith("Mui") || !!componentSlot ? "components" : "custom";
    const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
    );
    const skipSx = inputSkipSx || false;
    let shouldForwardPropOption = shouldForwardProp;
    if (componentSlot === "Root" || componentSlot === "root") {
      shouldForwardPropOption = rootShouldForwardProp2;
    } else if (componentSlot) {
      shouldForwardPropOption = slotShouldForwardProp2;
    } else if (isStringTag(tag)) {
      shouldForwardPropOption = void 0;
    }
    const defaultStyledResolver = styled$2(tag, __spreadValues({
      shouldForwardProp: shouldForwardPropOption,
      label: generateStyledLabel()
    }, options));
    const transformStyle = (style2) => {
      if (style2.__emotion_real === style2) {
        return style2;
      }
      if (typeof style2 === "function") {
        return function styleFunctionProcessor(props) {
          return processStyle(props, style2, props.theme.modularCssLayers ? layerName : void 0);
        };
      }
      if (isPlainObject$2(style2)) {
        const serialized = preprocessStyles(style2);
        return function styleObjectProcessor(props) {
          if (!serialized.variants) {
            return props.theme.modularCssLayers ? shallowLayer(serialized.style, layerName) : serialized.style;
          }
          return processStyle(props, serialized, props.theme.modularCssLayers ? layerName : void 0);
        };
      }
      return style2;
    };
    const muiStyledResolver = (...expressionsInput) => {
      const expressionsHead = [];
      const expressionsBody = expressionsInput.map(transformStyle);
      const expressionsTail = [];
      expressionsHead.push(styleAttachTheme);
      if (componentName && overridesResolver2) {
        expressionsTail.push(function styleThemeOverrides(props) {
          var _a3, _b;
          const theme2 = props.theme;
          const styleOverrides = (_b = (_a3 = theme2.components) == null ? void 0 : _a3[componentName]) == null ? void 0 : _b.styleOverrides;
          if (!styleOverrides) {
            return null;
          }
          const resolvedStyleOverrides = {};
          for (const slotKey in styleOverrides) {
            resolvedStyleOverrides[slotKey] = processStyle(props, styleOverrides[slotKey], props.theme.modularCssLayers ? "theme" : void 0);
          }
          return overridesResolver2(props, resolvedStyleOverrides);
        });
      }
      if (componentName && !skipVariantsResolver) {
        expressionsTail.push(function styleThemeVariants(props) {
          var _a3, _b;
          const theme2 = props.theme;
          const themeVariants = (_b = (_a3 = theme2 == null ? void 0 : theme2.components) == null ? void 0 : _a3[componentName]) == null ? void 0 : _b.variants;
          if (!themeVariants) {
            return null;
          }
          return processStyleVariants(props, themeVariants, [], props.theme.modularCssLayers ? "theme" : void 0);
        });
      }
      if (!skipSx) {
        expressionsTail.push(styleFunctionSx);
      }
      if (Array.isArray(expressionsBody[0])) {
        const inputStrings = expressionsBody.shift();
        const placeholdersHead = new Array(expressionsHead.length).fill("");
        const placeholdersTail = new Array(expressionsTail.length).fill("");
        let outputStrings;
        {
          outputStrings = [...placeholdersHead, ...inputStrings, ...placeholdersTail];
          outputStrings.raw = [...placeholdersHead, ...inputStrings.raw, ...placeholdersTail];
        }
        expressionsHead.unshift(outputStrings);
      }
      const expressions = [...expressionsHead, ...expressionsBody, ...expressionsTail];
      const Component = defaultStyledResolver(...expressions);
      if (tag.muiName) {
        Component.muiName = tag.muiName;
      }
      return Component;
    };
    if (defaultStyledResolver.withConfig) {
      muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
    }
    return muiStyledResolver;
  };
  return styled2;
}
function generateStyledLabel(componentName, componentSlot) {
  let label;
  return label;
}
function isObjectEmpty$1(object) {
  for (const _ in object) {
    return false;
  }
  return true;
}
function isStringTag(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96;
}
function lowercaseFirstLetter(string) {
  if (!string) {
    return string;
  }
  return string.charAt(0).toLowerCase() + string.slice(1);
}
const styled$1 = createStyled2();
function resolveProps(defaultProps2, props, mergeClassNameAndStyle = false) {
  const output = __spreadValues({}, props);
  for (const key in defaultProps2) {
    if (Object.prototype.hasOwnProperty.call(defaultProps2, key)) {
      const propName = key;
      if (propName === "components" || propName === "slots") {
        output[propName] = __spreadValues(__spreadValues({}, defaultProps2[propName]), output[propName]);
      } else if (propName === "componentsProps" || propName === "slotProps") {
        const defaultSlotProps = defaultProps2[propName];
        const slotProps = props[propName];
        if (!slotProps) {
          output[propName] = defaultSlotProps || {};
        } else if (!defaultSlotProps) {
          output[propName] = slotProps;
        } else {
          output[propName] = __spreadValues({}, slotProps);
          for (const slotKey in defaultSlotProps) {
            if (Object.prototype.hasOwnProperty.call(defaultSlotProps, slotKey)) {
              const slotPropName = slotKey;
              output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName], mergeClassNameAndStyle);
            }
          }
        }
      } else if (propName === "className" && mergeClassNameAndStyle && props.className) {
        output.className = clsx(defaultProps2 == null ? void 0 : defaultProps2.className, props == null ? void 0 : props.className);
      } else if (propName === "style" && mergeClassNameAndStyle && props.style) {
        output.style = __spreadValues(__spreadValues({}, defaultProps2 == null ? void 0 : defaultProps2.style), props == null ? void 0 : props.style);
      } else if (output[propName] === void 0) {
        output[propName] = defaultProps2[propName];
      }
    }
  }
  return output;
}
function getThemeProps$1(params) {
  const {
    theme: theme2,
    name: name2,
    props
  } = params;
  if (!theme2 || !theme2.components || !theme2.components[name2] || !theme2.components[name2].defaultProps) {
    return props;
  }
  return resolveProps(theme2.components[name2].defaultProps, props);
}
function useThemeProps({
  props,
  name: name2,
  defaultTheme: defaultTheme2,
  themeId
}) {
  let theme2 = useTheme$2(defaultTheme2);
  if (themeId) {
    theme2 = theme2[themeId] || theme2;
  }
  return getThemeProps$1({
    theme: theme2,
    name: name2,
    props
  });
}
const React$1_ = window["React"];
const useEnhancedEffect = typeof window !== "undefined" ? React$1_.useLayoutEffect : React$1_.useEffect;
function clamp(val, min2 = Number.MIN_SAFE_INTEGER, max2 = Number.MAX_SAFE_INTEGER) {
  return Math.max(min2, Math.min(val, max2));
}
function clampWrapper(value, min2 = 0, max2 = 1) {
  return clamp(value, min2, max2);
}
function hexToRgb(color2) {
  color2 = color2.slice(1);
  const re = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
  let colors = color2.match(re);
  if (colors && colors[0].length === 1) {
    colors = colors.map((n) => n + n);
  }
  return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n, index2) => {
    return index2 < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1e3) / 1e3;
  }).join(", ")})` : "";
}
function decomposeColor(color2) {
  if (color2.type) {
    return color2;
  }
  if (color2.charAt(0) === "#") {
    return decomposeColor(hexToRgb(color2));
  }
  const marker = color2.indexOf("(");
  const type = color2.substring(0, marker);
  if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(type)) {
    throw new Error(formatMuiErrorMessage(9, color2));
  }
  let values2 = color2.substring(marker + 1, color2.length - 1);
  let colorSpace;
  if (type === "color") {
    values2 = values2.split(" ");
    colorSpace = values2.shift();
    if (values2.length === 4 && values2[3].charAt(0) === "/") {
      values2[3] = values2[3].slice(1);
    }
    if (!["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(colorSpace)) {
      throw new Error(formatMuiErrorMessage(10, colorSpace));
    }
  } else {
    values2 = values2.split(",");
  }
  values2 = values2.map((value) => parseFloat(value));
  return {
    type,
    values: values2,
    colorSpace
  };
}
const colorChannel = (color2) => {
  const decomposedColor = decomposeColor(color2);
  return decomposedColor.values.slice(0, 3).map((val, idx) => decomposedColor.type.includes("hsl") && idx !== 0 ? `${val}%` : val).join(" ");
};
const private_safeColorChannel = (color2, warning2) => {
  try {
    return colorChannel(color2);
  } catch (error) {
    return color2;
  }
};
function recomposeColor(color2) {
  const {
    type,
    colorSpace
  } = color2;
  let {
    values: values2
  } = color2;
  if (type.includes("rgb")) {
    values2 = values2.map((n, i) => i < 3 ? parseInt(n, 10) : n);
  } else if (type.includes("hsl")) {
    values2[1] = `${values2[1]}%`;
    values2[2] = `${values2[2]}%`;
  }
  if (type.includes("color")) {
    values2 = `${colorSpace} ${values2.join(" ")}`;
  } else {
    values2 = `${values2.join(", ")}`;
  }
  return `${type}(${values2})`;
}
function hslToRgb(color2) {
  color2 = decomposeColor(color2);
  const {
    values: values2
  } = color2;
  const h = values2[0];
  const s = values2[1] / 100;
  const l = values2[2] / 100;
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  let type = "rgb";
  const rgb = [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
  if (color2.type === "hsla") {
    type += "a";
    rgb.push(values2[3]);
  }
  return recomposeColor({
    type,
    values: rgb
  });
}
function getLuminance(color2) {
  color2 = decomposeColor(color2);
  let rgb = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor(hslToRgb(color2)).values : color2.values;
  rgb = rgb.map((val) => {
    if (color2.type !== "color") {
      val /= 255;
    }
    return val <= 0.03928 ? val / 12.92 : __pow((val + 0.055) / 1.055, 2.4);
  });
  return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}
function getContrastRatio(foreground, background) {
  const lumA = getLuminance(foreground);
  const lumB = getLuminance(background);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
function alpha(color2, value) {
  color2 = decomposeColor(color2);
  value = clampWrapper(value);
  if (color2.type === "rgb" || color2.type === "hsl") {
    color2.type += "a";
  }
  if (color2.type === "color") {
    color2.values[3] = `/${value}`;
  } else {
    color2.values[3] = value;
  }
  return recomposeColor(color2);
}
function private_safeAlpha(color2, value, warning2) {
  try {
    return alpha(color2, value);
  } catch (error) {
    return color2;
  }
}
function darken(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.includes("hsl")) {
    color2.values[2] *= 1 - coefficient;
  } else if (color2.type.includes("rgb") || color2.type.includes("color")) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] *= 1 - coefficient;
    }
  }
  return recomposeColor(color2);
}
function private_safeDarken(color2, coefficient, warning2) {
  try {
    return darken(color2, coefficient);
  } catch (error) {
    return color2;
  }
}
function lighten(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.includes("hsl")) {
    color2.values[2] += (100 - color2.values[2]) * coefficient;
  } else if (color2.type.includes("rgb")) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] += (255 - color2.values[i]) * coefficient;
    }
  } else if (color2.type.includes("color")) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] += (1 - color2.values[i]) * coefficient;
    }
  }
  return recomposeColor(color2);
}
function private_safeLighten(color2, coefficient, warning2) {
  try {
    return lighten(color2, coefficient);
  } catch (error) {
    return color2;
  }
}
function emphasize(color2, coefficient = 0.15) {
  return getLuminance(color2) > 0.5 ? darken(color2, coefficient) : lighten(color2, coefficient);
}
function private_safeEmphasize(color2, coefficient, warning2) {
  try {
    return emphasize(color2, coefficient);
  } catch (error) {
    return color2;
  }
}
const React$1Z = window["React"];
const ThemeContext = /* @__PURE__ */ React$1Z.createContext(null);
const React$1Y = window["React"];
function useTheme$1() {
  const theme2 = React$1Y.useContext(ThemeContext);
  return theme2;
}
const hasSymbol = typeof Symbol === "function" && Symbol.for;
const nested = hasSymbol ? Symbol.for("mui.nested") : "__THEME_NESTED__";
const React$1X = window["React"];
function mergeOuterLocalTheme(outerTheme, localTheme) {
  if (typeof localTheme === "function") {
    const mergedTheme = localTheme(outerTheme);
    return mergedTheme;
  }
  return __spreadValues(__spreadValues({}, outerTheme), localTheme);
}
function ThemeProvider$2(props) {
  const {
    children,
    theme: localTheme
  } = props;
  const outerTheme = useTheme$1();
  const theme2 = React$1X.useMemo(() => {
    const output = outerTheme === null ? __spreadValues({}, localTheme) : mergeOuterLocalTheme(outerTheme, localTheme);
    if (output != null) {
      output[nested] = outerTheme !== null;
    }
    return output;
  }, [localTheme, outerTheme]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeContext.Provider, {
    value: theme2,
    children
  });
}
const React$1W = window["React"];
const RtlContext = /* @__PURE__ */ React$1W.createContext();
function RtlProvider(_a2) {
  var _b = _a2, {
    value
  } = _b, props = __objRest(_b, [
    "value"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RtlContext.Provider, __spreadValues({
    value: value != null ? value : true
  }, props));
}
const useRtl = () => {
  const value = React$1W.useContext(RtlContext);
  return value != null ? value : false;
};
const React$1V = window["React"];
const PropsContext = /* @__PURE__ */ React$1V.createContext(void 0);
function DefaultPropsProvider({
  value,
  children
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PropsContext.Provider, {
    value,
    children
  });
}
function getThemeProps(params) {
  const {
    theme: theme2,
    name: name2,
    props
  } = params;
  if (!theme2 || !theme2.components || !theme2.components[name2]) {
    return props;
  }
  const config2 = theme2.components[name2];
  if (config2.defaultProps) {
    return resolveProps(config2.defaultProps, props, theme2.components.mergeClassNameAndStyle);
  }
  if (!config2.styleOverrides && !config2.variants) {
    return resolveProps(config2, props, theme2.components.mergeClassNameAndStyle);
  }
  return props;
}
function useDefaultProps$1({
  props,
  name: name2
}) {
  const ctx = React$1V.useContext(PropsContext);
  return getThemeProps({
    props,
    name: name2,
    theme: {
      components: ctx
    }
  });
}
const React$1U = window["React"];
let globalId = 0;
function useGlobalId(idOverride) {
  const [defaultId, setDefaultId] = React$1U.useState(idOverride);
  const id = idOverride || defaultId;
  React$1U.useEffect(() => {
    if (defaultId == null) {
      globalId += 1;
      setDefaultId(`mui-${globalId}`);
    }
  }, [defaultId]);
  return id;
}
const safeReact = __spreadValues({}, React$1U);
const maybeReactUseId = safeReact.useId;
function useId(idOverride) {
  if (maybeReactUseId !== void 0) {
    const reactId = maybeReactUseId();
    return idOverride != null ? idOverride : reactId;
  }
  return useGlobalId(idOverride);
}
function useLayerOrder(theme2) {
  const upperTheme = useTheme$3();
  const id = useId() || "";
  const {
    modularCssLayers
  } = theme2;
  let layerOrder = "mui.global, mui.components, mui.theme, mui.custom, mui.sx";
  if (!modularCssLayers || upperTheme !== null) {
    layerOrder = "";
  } else if (typeof modularCssLayers === "string") {
    layerOrder = modularCssLayers.replace(/mui(?!\.)/g, layerOrder);
  } else {
    layerOrder = `@layer ${layerOrder};`;
  }
  useEnhancedEffect(() => {
    var _a2, _b;
    const head2 = document.querySelector("head");
    if (!head2) {
      return;
    }
    const firstChild = head2.firstChild;
    if (layerOrder) {
      if (firstChild && ((_a2 = firstChild.hasAttribute) == null ? void 0 : _a2.call(firstChild, "data-mui-layer-order")) && firstChild.getAttribute("data-mui-layer-order") === id) {
        return;
      }
      const styleElement = document.createElement("style");
      styleElement.setAttribute("data-mui-layer-order", id);
      styleElement.textContent = layerOrder;
      head2.prepend(styleElement);
    } else {
      (_b = head2.querySelector(`style[data-mui-layer-order="${id}"]`)) == null ? void 0 : _b.remove();
    }
  }, [layerOrder, id]);
  if (!layerOrder) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$2, {
    styles: layerOrder
  });
}
const React$1T = window["React"];
const EMPTY_THEME = {};
function useThemeScoping(themeId, upperTheme, localTheme, isPrivate = false) {
  return React$1T.useMemo(() => {
    const resolvedTheme = themeId ? upperTheme[themeId] || upperTheme : upperTheme;
    if (typeof localTheme === "function") {
      const mergedTheme = localTheme(resolvedTheme);
      const result = themeId ? __spreadProps(__spreadValues({}, upperTheme), {
        [themeId]: mergedTheme
      }) : mergedTheme;
      if (isPrivate) {
        return () => result;
      }
      return result;
    }
    return themeId ? __spreadProps(__spreadValues({}, upperTheme), {
      [themeId]: localTheme
    }) : __spreadValues(__spreadValues({}, upperTheme), localTheme);
  }, [themeId, upperTheme, localTheme, isPrivate]);
}
function ThemeProvider$1(props) {
  const {
    children,
    theme: localTheme,
    themeId
  } = props;
  const upperTheme = useTheme$3(EMPTY_THEME);
  const upperPrivateTheme = useTheme$1() || EMPTY_THEME;
  const engineTheme = useThemeScoping(themeId, upperTheme, localTheme);
  const privateTheme = useThemeScoping(themeId, upperPrivateTheme, localTheme, true);
  const rtlValue = (themeId ? engineTheme[themeId] : engineTheme).direction === "rtl";
  const layerOrder = useLayerOrder(engineTheme);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider$2, {
    theme: privateTheme,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeContext$1.Provider, {
      value: engineTheme,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(RtlProvider, {
        value: rtlValue,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DefaultPropsProvider, {
          value: themeId ? engineTheme[themeId].components : engineTheme.components,
          children: [layerOrder, children]
        })
      })
    })
  });
}
const arg = {
  theme: void 0
};
function unstable_memoTheme(styleFn) {
  let lastValue;
  let lastTheme;
  return function styleMemoized(props) {
    let value = lastValue;
    if (value === void 0 || props.theme !== lastTheme) {
      arg.theme = props.theme;
      value = preprocessStyles(styleFn(arg));
      lastValue = value;
      lastTheme = props.theme;
    }
    return value;
  };
}
const DEFAULT_MODE_STORAGE_KEY = "mode";
const DEFAULT_COLOR_SCHEME_STORAGE_KEY = "color-scheme";
const DEFAULT_ATTRIBUTE = "data-color-scheme";
function InitColorSchemeScript(options) {
  const {
    defaultMode = "system",
    defaultLightColorScheme = "light",
    defaultDarkColorScheme = "dark",
    modeStorageKey = DEFAULT_MODE_STORAGE_KEY,
    colorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY,
    attribute: initialAttribute = DEFAULT_ATTRIBUTE,
    colorSchemeNode = "document.documentElement",
    nonce
  } = options || {};
  let setter = "";
  let attribute = initialAttribute;
  if (initialAttribute === "class") {
    attribute = ".%s";
  }
  if (initialAttribute === "data") {
    attribute = "[data-%s]";
  }
  if (attribute.startsWith(".")) {
    const selector = attribute.substring(1);
    setter += `${colorSchemeNode}.classList.remove('${selector}'.replace('%s', light), '${selector}'.replace('%s', dark));
      ${colorSchemeNode}.classList.add('${selector}'.replace('%s', colorScheme));`;
  }
  const matches = attribute.match(/\[([^[\]]+)\]/);
  if (matches) {
    const [attr, value] = matches[1].split("=");
    if (!value) {
      setter += `${colorSchemeNode}.removeAttribute('${attr}'.replace('%s', light));
      ${colorSchemeNode}.removeAttribute('${attr}'.replace('%s', dark));`;
    }
    setter += `
      ${colorSchemeNode}.setAttribute('${attr}'.replace('%s', colorScheme), ${value ? `${value}.replace('%s', colorScheme)` : '""'});`;
  } else {
    setter += `${colorSchemeNode}.setAttribute('${attribute}', colorScheme);`;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("script", {
    suppressHydrationWarning: true,
    nonce: typeof window === "undefined" ? nonce : "",
    dangerouslySetInnerHTML: {
      __html: `(function() {
try {
  let colorScheme = '';
  const mode = localStorage.getItem('${modeStorageKey}') || '${defaultMode}';
  const dark = localStorage.getItem('${colorSchemeStorageKey}-dark') || '${defaultDarkColorScheme}';
  const light = localStorage.getItem('${colorSchemeStorageKey}-light') || '${defaultLightColorScheme}';
  if (mode === 'system') {
    // handle system mode
    const mql = window.matchMedia('(prefers-color-scheme: dark)');
    if (mql.matches) {
      colorScheme = dark
    } else {
      colorScheme = light
    }
  }
  if (mode === 'light') {
    colorScheme = light;
  }
  if (mode === 'dark') {
    colorScheme = dark;
  }
  if (colorScheme) {
    ${setter}
  }
} catch(e){}})();`
    }
  }, "mui-color-scheme-init");
}
function noop$5() {
}
const localStorageManager = ({
  key,
  storageWindow
}) => {
  if (!storageWindow && typeof window !== "undefined") {
    storageWindow = window;
  }
  return {
    get(defaultValue) {
      if (typeof window === "undefined") {
        return void 0;
      }
      if (!storageWindow) {
        return defaultValue;
      }
      let value;
      try {
        value = storageWindow.localStorage.getItem(key);
      } catch (e) {
      }
      return value || defaultValue;
    },
    set: (value) => {
      if (storageWindow) {
        try {
          storageWindow.localStorage.setItem(key, value);
        } catch (e) {
        }
      }
    },
    subscribe: (handler) => {
      if (!storageWindow) {
        return noop$5;
      }
      const listener = (event) => {
        const value = event.newValue;
        if (event.key === key) {
          handler(value);
        }
      };
      storageWindow.addEventListener("storage", listener);
      return () => {
        storageWindow.removeEventListener("storage", listener);
      };
    }
  };
};
const React$1S = window["React"];
function noop$4() {
}
function getSystemMode(mode) {
  if (typeof window !== "undefined" && typeof window.matchMedia === "function" && mode === "system") {
    const mql = window.matchMedia("(prefers-color-scheme: dark)");
    if (mql.matches) {
      return "dark";
    }
    return "light";
  }
  return void 0;
}
function processState(state, callback) {
  if (state.mode === "light" || state.mode === "system" && state.systemMode === "light") {
    return callback("light");
  }
  if (state.mode === "dark" || state.mode === "system" && state.systemMode === "dark") {
    return callback("dark");
  }
  return void 0;
}
function getColorScheme(state) {
  return processState(state, (mode) => {
    if (mode === "light") {
      return state.lightColorScheme;
    }
    if (mode === "dark") {
      return state.darkColorScheme;
    }
    return void 0;
  });
}
function useCurrentColorScheme(options) {
  const {
    defaultMode = "light",
    defaultLightColorScheme,
    defaultDarkColorScheme,
    supportedColorSchemes = [],
    modeStorageKey = DEFAULT_MODE_STORAGE_KEY,
    colorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY,
    storageWindow = typeof window === "undefined" ? void 0 : window,
    storageManager = localStorageManager,
    noSsr = false
  } = options;
  const joinedColorSchemes = supportedColorSchemes.join(",");
  const isMultiSchemes = supportedColorSchemes.length > 1;
  const modeStorage = React$1S.useMemo(() => storageManager == null ? void 0 : storageManager({
    key: modeStorageKey,
    storageWindow
  }), [storageManager, modeStorageKey, storageWindow]);
  const lightStorage = React$1S.useMemo(() => storageManager == null ? void 0 : storageManager({
    key: `${colorSchemeStorageKey}-light`,
    storageWindow
  }), [storageManager, colorSchemeStorageKey, storageWindow]);
  const darkStorage = React$1S.useMemo(() => storageManager == null ? void 0 : storageManager({
    key: `${colorSchemeStorageKey}-dark`,
    storageWindow
  }), [storageManager, colorSchemeStorageKey, storageWindow]);
  const [state, setState] = React$1S.useState(() => {
    const initialMode = (modeStorage == null ? void 0 : modeStorage.get(defaultMode)) || defaultMode;
    const lightColorScheme = (lightStorage == null ? void 0 : lightStorage.get(defaultLightColorScheme)) || defaultLightColorScheme;
    const darkColorScheme = (darkStorage == null ? void 0 : darkStorage.get(defaultDarkColorScheme)) || defaultDarkColorScheme;
    return {
      mode: initialMode,
      systemMode: getSystemMode(initialMode),
      lightColorScheme,
      darkColorScheme
    };
  });
  const [isClient, setIsClient] = React$1S.useState(noSsr || !isMultiSchemes);
  React$1S.useEffect(() => {
    setIsClient(true);
  }, []);
  const colorScheme = getColorScheme(state);
  const setMode2 = React$1S.useCallback((mode) => {
    setState((currentState) => {
      if (mode === currentState.mode) {
        return currentState;
      }
      const newMode = mode != null ? mode : defaultMode;
      modeStorage == null ? void 0 : modeStorage.set(newMode);
      return __spreadProps(__spreadValues({}, currentState), {
        mode: newMode,
        systemMode: getSystemMode(newMode)
      });
    });
  }, [modeStorage, defaultMode]);
  const setColorScheme = React$1S.useCallback((value) => {
    if (!value) {
      setState((currentState) => {
        lightStorage == null ? void 0 : lightStorage.set(defaultLightColorScheme);
        darkStorage == null ? void 0 : darkStorage.set(defaultDarkColorScheme);
        return __spreadProps(__spreadValues({}, currentState), {
          lightColorScheme: defaultLightColorScheme,
          darkColorScheme: defaultDarkColorScheme
        });
      });
    } else if (typeof value === "string") {
      if (value && !joinedColorSchemes.includes(value)) {
        console.error(`\`${value}\` does not exist in \`theme.colorSchemes\`.`);
      } else {
        setState((currentState) => {
          const newState = __spreadValues({}, currentState);
          processState(currentState, (mode) => {
            if (mode === "light") {
              lightStorage == null ? void 0 : lightStorage.set(value);
              newState.lightColorScheme = value;
            }
            if (mode === "dark") {
              darkStorage == null ? void 0 : darkStorage.set(value);
              newState.darkColorScheme = value;
            }
          });
          return newState;
        });
      }
    } else {
      setState((currentState) => {
        const newState = __spreadValues({}, currentState);
        const newLightColorScheme = value.light === null ? defaultLightColorScheme : value.light;
        const newDarkColorScheme = value.dark === null ? defaultDarkColorScheme : value.dark;
        if (newLightColorScheme) {
          if (!joinedColorSchemes.includes(newLightColorScheme)) {
            console.error(`\`${newLightColorScheme}\` does not exist in \`theme.colorSchemes\`.`);
          } else {
            newState.lightColorScheme = newLightColorScheme;
            lightStorage == null ? void 0 : lightStorage.set(newLightColorScheme);
          }
        }
        if (newDarkColorScheme) {
          if (!joinedColorSchemes.includes(newDarkColorScheme)) {
            console.error(`\`${newDarkColorScheme}\` does not exist in \`theme.colorSchemes\`.`);
          } else {
            newState.darkColorScheme = newDarkColorScheme;
            darkStorage == null ? void 0 : darkStorage.set(newDarkColorScheme);
          }
        }
        return newState;
      });
    }
  }, [joinedColorSchemes, lightStorage, darkStorage, defaultLightColorScheme, defaultDarkColorScheme]);
  const handleMediaQuery = React$1S.useCallback((event) => {
    if (state.mode === "system") {
      setState((currentState) => {
        const systemMode = (event == null ? void 0 : event.matches) ? "dark" : "light";
        if (currentState.systemMode === systemMode) {
          return currentState;
        }
        return __spreadProps(__spreadValues({}, currentState), {
          systemMode
        });
      });
    }
  }, [state.mode]);
  const mediaListener = React$1S.useRef(handleMediaQuery);
  mediaListener.current = handleMediaQuery;
  React$1S.useEffect(() => {
    if (typeof window.matchMedia !== "function" || !isMultiSchemes) {
      return void 0;
    }
    const handler = (...args) => mediaListener.current(...args);
    const media = window.matchMedia("(prefers-color-scheme: dark)");
    media.addListener(handler);
    handler(media);
    return () => {
      media.removeListener(handler);
    };
  }, [isMultiSchemes]);
  React$1S.useEffect(() => {
    if (isMultiSchemes) {
      const unsubscribeMode = (modeStorage == null ? void 0 : modeStorage.subscribe((value) => {
        if (!value || ["light", "dark", "system"].includes(value)) {
          setMode2(value || defaultMode);
        }
      })) || noop$4;
      const unsubscribeLight = (lightStorage == null ? void 0 : lightStorage.subscribe((value) => {
        if (!value || joinedColorSchemes.match(value)) {
          setColorScheme({
            light: value
          });
        }
      })) || noop$4;
      const unsubscribeDark = (darkStorage == null ? void 0 : darkStorage.subscribe((value) => {
        if (!value || joinedColorSchemes.match(value)) {
          setColorScheme({
            dark: value
          });
        }
      })) || noop$4;
      return () => {
        unsubscribeMode();
        unsubscribeLight();
        unsubscribeDark();
      };
    }
    return void 0;
  }, [setColorScheme, setMode2, joinedColorSchemes, defaultMode, storageWindow, isMultiSchemes, modeStorage, lightStorage, darkStorage]);
  return __spreadProps(__spreadValues({}, state), {
    mode: isClient ? state.mode : void 0,
    systemMode: isClient ? state.systemMode : void 0,
    colorScheme: isClient ? colorScheme : void 0,
    setMode: setMode2,
    setColorScheme
  });
}
const React$1R = window["React"];
const DISABLE_CSS_TRANSITION = "*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
function createCssVarsProvider(options) {
  const {
    themeId,
    /**
     * This `theme` object needs to follow a certain structure to
     * be used correctly by the finel `CssVarsProvider`. It should have a
     * `colorSchemes` key with the light and dark (and any other) palette.
     * It should also ideally have a vars object created using `prepareCssVars`.
     */
    theme: defaultTheme2 = {},
    modeStorageKey: defaultModeStorageKey = DEFAULT_MODE_STORAGE_KEY,
    colorSchemeStorageKey: defaultColorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY,
    disableTransitionOnChange: designSystemTransitionOnChange = false,
    defaultColorScheme,
    resolveTheme
  } = options;
  const defaultContext = {
    allColorSchemes: [],
    colorScheme: void 0,
    darkColorScheme: void 0,
    lightColorScheme: void 0,
    mode: void 0,
    setColorScheme: () => {
    },
    setMode: () => {
    },
    systemMode: void 0
  };
  const ColorSchemeContext = /* @__PURE__ */ React$1R.createContext(void 0);
  const useColorScheme = () => React$1R.useContext(ColorSchemeContext) || defaultContext;
  const defaultColorSchemes = {};
  const defaultComponents = {};
  function CssVarsProvider2(props) {
    var _a2, _b, _c, _d;
    const {
      children,
      theme: themeProp,
      modeStorageKey = defaultModeStorageKey,
      colorSchemeStorageKey = defaultColorSchemeStorageKey,
      disableTransitionOnChange = designSystemTransitionOnChange,
      storageManager,
      storageWindow = typeof window === "undefined" ? void 0 : window,
      documentNode = typeof document === "undefined" ? void 0 : document,
      colorSchemeNode = typeof document === "undefined" ? void 0 : document.documentElement,
      disableNestedContext = false,
      disableStyleSheetGeneration = false,
      defaultMode: initialMode = "system",
      forceThemeRerender = false,
      noSsr
    } = props;
    const hasMounted = React$1R.useRef(false);
    const upperTheme = useTheme$1();
    const ctx = React$1R.useContext(ColorSchemeContext);
    const nested2 = !!ctx && !disableNestedContext;
    const initialTheme = React$1R.useMemo(() => {
      if (themeProp) {
        return themeProp;
      }
      return typeof defaultTheme2 === "function" ? defaultTheme2() : defaultTheme2;
    }, [themeProp]);
    const scopedTheme = initialTheme[themeId];
    const restThemeProp = scopedTheme || initialTheme;
    const {
      colorSchemes = defaultColorSchemes,
      components = defaultComponents,
      cssVarPrefix
    } = restThemeProp;
    const joinedColorSchemes = Object.keys(colorSchemes).filter((k) => !!colorSchemes[k]).join(",");
    const allColorSchemes = React$1R.useMemo(() => joinedColorSchemes.split(","), [joinedColorSchemes]);
    const defaultLightColorScheme2 = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.light;
    const defaultDarkColorScheme2 = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.dark;
    const defaultMode = colorSchemes[defaultLightColorScheme2] && colorSchemes[defaultDarkColorScheme2] ? initialMode : ((_b = (_a2 = colorSchemes[restThemeProp.defaultColorScheme]) == null ? void 0 : _a2.palette) == null ? void 0 : _b.mode) || ((_c = restThemeProp.palette) == null ? void 0 : _c.mode);
    const {
      mode: stateMode,
      setMode: setMode2,
      systemMode,
      lightColorScheme,
      darkColorScheme,
      colorScheme: stateColorScheme,
      setColorScheme
    } = useCurrentColorScheme({
      supportedColorSchemes: allColorSchemes,
      defaultLightColorScheme: defaultLightColorScheme2,
      defaultDarkColorScheme: defaultDarkColorScheme2,
      modeStorageKey,
      colorSchemeStorageKey,
      defaultMode,
      storageManager,
      storageWindow,
      noSsr
    });
    let mode = stateMode;
    let colorScheme = stateColorScheme;
    if (nested2) {
      mode = ctx.mode;
      colorScheme = ctx.colorScheme;
    }
    let calculatedColorScheme = colorScheme || restThemeProp.defaultColorScheme;
    if (restThemeProp.vars && !forceThemeRerender) {
      calculatedColorScheme = restThemeProp.defaultColorScheme;
    }
    const memoTheme2 = React$1R.useMemo(() => {
      var _a3;
      const themeVars = ((_a3 = restThemeProp.generateThemeVars) == null ? void 0 : _a3.call(restThemeProp)) || restThemeProp.vars;
      const theme2 = __spreadProps(__spreadValues({}, restThemeProp), {
        components,
        colorSchemes,
        cssVarPrefix,
        vars: themeVars
      });
      if (typeof theme2.generateSpacing === "function") {
        theme2.spacing = theme2.generateSpacing();
      }
      if (calculatedColorScheme) {
        const scheme = colorSchemes[calculatedColorScheme];
        if (scheme && typeof scheme === "object") {
          Object.keys(scheme).forEach((schemeKey) => {
            if (scheme[schemeKey] && typeof scheme[schemeKey] === "object") {
              theme2[schemeKey] = __spreadValues(__spreadValues({}, theme2[schemeKey]), scheme[schemeKey]);
            } else {
              theme2[schemeKey] = scheme[schemeKey];
            }
          });
        }
      }
      return resolveTheme ? resolveTheme(theme2) : theme2;
    }, [restThemeProp, calculatedColorScheme, components, colorSchemes, cssVarPrefix]);
    const colorSchemeSelector = restThemeProp.colorSchemeSelector;
    useEnhancedEffect(() => {
      if (colorScheme && colorSchemeNode && colorSchemeSelector && colorSchemeSelector !== "media") {
        const selector = colorSchemeSelector;
        let rule = colorSchemeSelector;
        if (selector === "class") {
          rule = `.%s`;
        }
        if (selector === "data") {
          rule = `[data-%s]`;
        }
        if ((selector == null ? void 0 : selector.startsWith("data-")) && !selector.includes("%s")) {
          rule = `[${selector}="%s"]`;
        }
        if (rule.startsWith(".")) {
          colorSchemeNode.classList.remove(...allColorSchemes.map((scheme) => rule.substring(1).replace("%s", scheme)));
          colorSchemeNode.classList.add(rule.substring(1).replace("%s", colorScheme));
        } else {
          const matches = rule.replace("%s", colorScheme).match(/\[([^\]]+)\]/);
          if (matches) {
            const [attr, value] = matches[1].split("=");
            if (!value) {
              allColorSchemes.forEach((scheme) => {
                colorSchemeNode.removeAttribute(attr.replace(colorScheme, scheme));
              });
            }
            colorSchemeNode.setAttribute(attr, value ? value.replace(/"|'/g, "") : "");
          } else {
            colorSchemeNode.setAttribute(rule, colorScheme);
          }
        }
      }
    }, [colorScheme, colorSchemeSelector, colorSchemeNode, allColorSchemes]);
    React$1R.useEffect(() => {
      let timer;
      if (disableTransitionOnChange && hasMounted.current && documentNode) {
        const css2 = documentNode.createElement("style");
        css2.appendChild(documentNode.createTextNode(DISABLE_CSS_TRANSITION));
        documentNode.head.appendChild(css2);
        (() => window.getComputedStyle(documentNode.body))();
        timer = setTimeout(() => {
          documentNode.head.removeChild(css2);
        }, 1);
      }
      return () => {
        clearTimeout(timer);
      };
    }, [colorScheme, disableTransitionOnChange, documentNode]);
    React$1R.useEffect(() => {
      hasMounted.current = true;
      return () => {
        hasMounted.current = false;
      };
    }, []);
    const contextValue = React$1R.useMemo(() => ({
      allColorSchemes,
      colorScheme,
      darkColorScheme,
      lightColorScheme,
      mode,
      setColorScheme,
      setMode: setMode2,
      systemMode
    }), [allColorSchemes, colorScheme, darkColorScheme, lightColorScheme, mode, setColorScheme, setMode2, systemMode, memoTheme2.colorSchemeSelector]);
    let shouldGenerateStyleSheet = true;
    if (disableStyleSheetGeneration || restThemeProp.cssVariables === false || nested2 && (upperTheme == null ? void 0 : upperTheme.cssVarPrefix) === cssVarPrefix) {
      shouldGenerateStyleSheet = false;
    }
    const element = /* @__PURE__ */ jsxRuntimeExports.jsxs(React$1R.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider$1, {
        themeId: scopedTheme ? themeId : void 0,
        theme: memoTheme2,
        children
      }), shouldGenerateStyleSheet && /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$3, {
        styles: ((_d = memoTheme2.generateStyleSheets) == null ? void 0 : _d.call(memoTheme2)) || []
      })]
    });
    if (nested2) {
      return element;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ColorSchemeContext.Provider, {
      value: contextValue,
      children: element
    });
  }
  const defaultLightColorScheme = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.light;
  const defaultDarkColorScheme = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.dark;
  const getInitColorSchemeScript = (params) => InitColorSchemeScript(__spreadValues({
    colorSchemeStorageKey: defaultColorSchemeStorageKey,
    defaultLightColorScheme,
    defaultDarkColorScheme,
    modeStorageKey: defaultModeStorageKey
  }, params));
  return {
    CssVarsProvider: CssVarsProvider2,
    useColorScheme,
    getInitColorSchemeScript
  };
}
function createGetCssVar$1(prefix2 = "") {
  function appendVar(...vars) {
    if (!vars.length) {
      return "";
    }
    const value = vars[0];
    if (typeof value === "string" && !value.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/)) {
      return `, var(--${prefix2 ? `${prefix2}-` : ""}${value}${appendVar(...vars.slice(1))})`;
    }
    return `, ${value}`;
  }
  const getCssVar = (field, ...fallbacks) => {
    return `var(--${prefix2 ? `${prefix2}-` : ""}${field}${appendVar(...fallbacks)})`;
  };
  return getCssVar;
}
const assignNestedKeys = (obj, keys, value, arrayKeys = []) => {
  let temp = obj;
  keys.forEach((k, index2) => {
    if (index2 === keys.length - 1) {
      if (Array.isArray(temp)) {
        temp[Number(k)] = value;
      } else if (temp && typeof temp === "object") {
        temp[k] = value;
      }
    } else if (temp && typeof temp === "object") {
      if (!temp[k]) {
        temp[k] = arrayKeys.includes(k) ? [] : {};
      }
      temp = temp[k];
    }
  });
};
const walkObjectDeep = (obj, callback, shouldSkipPaths) => {
  function recurse(object, parentKeys = [], arrayKeys = []) {
    Object.entries(object).forEach(([key, value]) => {
      if (!shouldSkipPaths || shouldSkipPaths && !shouldSkipPaths([...parentKeys, key])) {
        if (value !== void 0 && value !== null) {
          if (typeof value === "object" && Object.keys(value).length > 0) {
            recurse(value, [...parentKeys, key], Array.isArray(value) ? [...arrayKeys, key] : arrayKeys);
          } else {
            callback([...parentKeys, key], value, arrayKeys);
          }
        }
      }
    });
  }
  recurse(obj);
};
const getCssValue = (keys, value) => {
  if (typeof value === "number") {
    if (["lineHeight", "fontWeight", "opacity", "zIndex"].some((prop) => keys.includes(prop))) {
      return value;
    }
    const lastKey = keys[keys.length - 1];
    if (lastKey.toLowerCase().includes("opacity")) {
      return value;
    }
    return `${value}px`;
  }
  return value;
};
function cssVarsParser(theme2, options) {
  const {
    prefix: prefix2,
    shouldSkipGeneratingVar: shouldSkipGeneratingVar2
  } = options || {};
  const css2 = {};
  const vars = {};
  const varsWithDefaults = {};
  walkObjectDeep(
    theme2,
    (keys, value, arrayKeys) => {
      if (typeof value === "string" || typeof value === "number") {
        if (!shouldSkipGeneratingVar2 || !shouldSkipGeneratingVar2(keys, value)) {
          const cssVar = `--${prefix2 ? `${prefix2}-` : ""}${keys.join("-")}`;
          const resolvedValue = getCssValue(keys, value);
          Object.assign(css2, {
            [cssVar]: resolvedValue
          });
          assignNestedKeys(vars, keys, `var(${cssVar})`, arrayKeys);
          assignNestedKeys(varsWithDefaults, keys, `var(${cssVar}, ${resolvedValue})`, arrayKeys);
        }
      }
    },
    (keys) => keys[0] === "vars"
    // skip 'vars/*' paths
  );
  return {
    css: css2,
    vars,
    varsWithDefaults
  };
}
function prepareCssVars(theme2, parserConfig = {}) {
  const {
    getSelector = defaultGetSelector2,
    disableCssColorScheme,
    colorSchemeSelector: selector,
    enableContrastVars
  } = parserConfig;
  const _a2 = theme2, {
    colorSchemes = {},
    components,
    defaultColorScheme = "light"
  } = _a2, otherTheme = __objRest(_a2, [
    "colorSchemes",
    "components",
    "defaultColorScheme"
  ]);
  const {
    vars: rootVars,
    css: rootCss,
    varsWithDefaults: rootVarsWithDefaults
  } = cssVarsParser(otherTheme, parserConfig);
  let themeVars = rootVarsWithDefaults;
  const colorSchemesMap = {};
  const _b = colorSchemes, {
    [defaultColorScheme]: defaultScheme
  } = _b, otherColorSchemes = __objRest(_b, [
    __restKey(defaultColorScheme)
  ]);
  Object.entries(otherColorSchemes || {}).forEach(([key, scheme]) => {
    const {
      vars,
      css: css2,
      varsWithDefaults
    } = cssVarsParser(scheme, parserConfig);
    themeVars = deepmerge(themeVars, varsWithDefaults);
    colorSchemesMap[key] = {
      css: css2,
      vars
    };
  });
  if (defaultScheme) {
    const {
      css: css2,
      vars,
      varsWithDefaults
    } = cssVarsParser(defaultScheme, parserConfig);
    themeVars = deepmerge(themeVars, varsWithDefaults);
    colorSchemesMap[defaultColorScheme] = {
      css: css2,
      vars
    };
  }
  function defaultGetSelector2(colorScheme, cssObject) {
    var _a3, _b2;
    let rule = selector;
    if (selector === "class") {
      rule = ".%s";
    }
    if (selector === "data") {
      rule = "[data-%s]";
    }
    if ((selector == null ? void 0 : selector.startsWith("data-")) && !selector.includes("%s")) {
      rule = `[${selector}="%s"]`;
    }
    if (colorScheme) {
      if (rule === "media") {
        if (theme2.defaultColorScheme === colorScheme) {
          return ":root";
        }
        const mode = ((_b2 = (_a3 = colorSchemes[colorScheme]) == null ? void 0 : _a3.palette) == null ? void 0 : _b2.mode) || colorScheme;
        return {
          [`@media (prefers-color-scheme: ${mode})`]: {
            ":root": cssObject
          }
        };
      }
      if (rule) {
        if (theme2.defaultColorScheme === colorScheme) {
          return `:root, ${rule.replace("%s", String(colorScheme))}`;
        }
        return rule.replace("%s", String(colorScheme));
      }
    }
    return ":root";
  }
  const generateThemeVars = () => {
    let vars = __spreadValues({}, rootVars);
    Object.entries(colorSchemesMap).forEach(([, {
      vars: schemeVars
    }]) => {
      vars = deepmerge(vars, schemeVars);
    });
    return vars;
  };
  const generateStyleSheets = () => {
    var _b2, _c;
    const stylesheets = [];
    const colorScheme = theme2.defaultColorScheme || "light";
    function insertStyleSheet(key, css2) {
      if (Object.keys(css2).length) {
        stylesheets.push(typeof key === "string" ? {
          [key]: __spreadValues({}, css2)
        } : key);
      }
    }
    insertStyleSheet(getSelector(void 0, __spreadValues({}, rootCss)), rootCss);
    const _a3 = colorSchemesMap, {
      [colorScheme]: defaultSchemeVal
    } = _a3, other = __objRest(_a3, [
      __restKey(colorScheme)
    ]);
    if (defaultSchemeVal) {
      const {
        css: css2
      } = defaultSchemeVal;
      const cssColorSheme = (_c = (_b2 = colorSchemes[colorScheme]) == null ? void 0 : _b2.palette) == null ? void 0 : _c.mode;
      const finalCss = !disableCssColorScheme && cssColorSheme ? __spreadValues({
        colorScheme: cssColorSheme
      }, css2) : __spreadValues({}, css2);
      insertStyleSheet(getSelector(colorScheme, __spreadValues({}, finalCss)), finalCss);
    }
    Object.entries(other).forEach(([key, {
      css: css2
    }]) => {
      var _a4, _b3;
      const cssColorSheme = (_b3 = (_a4 = colorSchemes[key]) == null ? void 0 : _a4.palette) == null ? void 0 : _b3.mode;
      const finalCss = !disableCssColorScheme && cssColorSheme ? __spreadValues({
        colorScheme: cssColorSheme
      }, css2) : __spreadValues({}, css2);
      insertStyleSheet(getSelector(key, __spreadValues({}, finalCss)), finalCss);
    });
    if (enableContrastVars) {
      stylesheets.push({
        ":root": {
          // use double underscore to indicate that these are private variables
          "--__l-threshold": "0.7",
          "--__l": "clamp(0, (l / var(--__l-threshold) - 1) * -infinity, 1)",
          "--__a": "clamp(0.87, (l / var(--__l-threshold) - 1) * -infinity, 1)"
          // 0.87 is the default alpha value for black text.
        }
      });
    }
    return stylesheets;
  };
  return {
    vars: themeVars,
    generateThemeVars,
    generateStyleSheets
  };
}
function createGetColorSchemeSelector(selector) {
  return function getColorSchemeSelector(colorScheme) {
    if (selector === "media") {
      return `@media (prefers-color-scheme: ${colorScheme})`;
    }
    if (selector) {
      if (selector.startsWith("data-") && !selector.includes("%s")) {
        return `[${selector}="${colorScheme}"] &`;
      }
      if (selector === "class") {
        return `.${colorScheme} &`;
      }
      if (selector === "data") {
        return `[data-${colorScheme}] &`;
      }
      return `${selector.replace("%s", colorScheme)} &`;
    }
    return "&";
  };
}
function composeClasses(slots, getUtilityClass, classes = void 0) {
  const output = {};
  for (const slotName in slots) {
    const slot = slots[slotName];
    let buffer = "";
    let start2 = true;
    for (let i = 0; i < slot.length; i += 1) {
      const value = slot[i];
      if (value) {
        buffer += (start2 === true ? "" : " ") + getUtilityClass(value);
        start2 = false;
        if (classes && classes[value]) {
          buffer += " " + classes[value];
        }
      }
    }
    output[slotName] = buffer;
  }
  return output;
}
const React$1Q = window["React"];
const defaultTheme$4 = createTheme$1();
const defaultCreateStyledComponent$2 = styled$1("div", {
  name: "MuiContainer",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`maxWidth${capitalize(String(ownerState.maxWidth))}`], ownerState.fixed && styles2.fixed, ownerState.disableGutters && styles2.disableGutters];
  }
});
const useThemePropsDefault$2 = (inProps) => useThemeProps({
  props: inProps,
  name: "MuiContainer",
  defaultTheme: defaultTheme$4
});
const useUtilityClasses$12 = (ownerState, componentName) => {
  const getContainerUtilityClass = (slot) => {
    return generateUtilityClass(componentName, slot);
  };
  const {
    classes,
    fixed,
    disableGutters,
    maxWidth: maxWidth2
  } = ownerState;
  const slots = {
    root: ["root", maxWidth2 && `maxWidth${capitalize(String(maxWidth2))}`, fixed && "fixed", disableGutters && "disableGutters"]
  };
  return composeClasses(slots, getContainerUtilityClass, classes);
};
function createContainer(options = {}) {
  const {
    // This will allow adding custom styled fn (for example for custom sx style function)
    createStyledComponent = defaultCreateStyledComponent$2,
    useThemeProps: useThemeProps2 = useThemePropsDefault$2,
    componentName = "MuiContainer"
  } = options;
  const ContainerRoot = createStyledComponent(({
    theme: theme2,
    ownerState
  }) => __spreadValues({
    width: "100%",
    marginLeft: "auto",
    boxSizing: "border-box",
    marginRight: "auto"
  }, !ownerState.disableGutters && {
    paddingLeft: theme2.spacing(2),
    paddingRight: theme2.spacing(2),
    // @ts-ignore module augmentation fails if custom breakpoints are used
    [theme2.breakpoints.up("sm")]: {
      paddingLeft: theme2.spacing(3),
      paddingRight: theme2.spacing(3)
    }
  }), ({
    theme: theme2,
    ownerState
  }) => ownerState.fixed && Object.keys(theme2.breakpoints.values).reduce((acc, breakpointValueKey) => {
    const breakpoint = breakpointValueKey;
    const value = theme2.breakpoints.values[breakpoint];
    if (value !== 0) {
      acc[theme2.breakpoints.up(breakpoint)] = {
        maxWidth: `${value}${theme2.breakpoints.unit}`
      };
    }
    return acc;
  }, {}), ({
    theme: theme2,
    ownerState
  }) => __spreadValues(__spreadValues({}, ownerState.maxWidth === "xs" && {
    // @ts-ignore module augmentation fails if custom breakpoints are used
    [theme2.breakpoints.up("xs")]: {
      // @ts-ignore module augmentation fails if custom breakpoints are used
      maxWidth: Math.max(theme2.breakpoints.values.xs, 444)
    }
  }), ownerState.maxWidth && // @ts-ignore module augmentation fails if custom breakpoints are used
  ownerState.maxWidth !== "xs" && {
    // @ts-ignore module augmentation fails if custom breakpoints are used
    [theme2.breakpoints.up(ownerState.maxWidth)]: {
      // @ts-ignore module augmentation fails if custom breakpoints are used
      maxWidth: `${theme2.breakpoints.values[ownerState.maxWidth]}${theme2.breakpoints.unit}`
    }
  }));
  const Container2 = /* @__PURE__ */ React$1Q.forwardRef(function Container22(inProps, ref) {
    const props = useThemeProps2(inProps);
    const _a2 = props, {
      className,
      component = "div",
      disableGutters = false,
      fixed = false,
      maxWidth: maxWidth2 = "lg",
      classes: classesProp
    } = _a2, other = __objRest(_a2, [
      "className",
      "component",
      "disableGutters",
      "fixed",
      "maxWidth",
      "classes"
    ]);
    const ownerState = __spreadProps(__spreadValues({}, props), {
      component,
      disableGutters,
      fixed,
      maxWidth: maxWidth2
    });
    const classes = useUtilityClasses$12(ownerState, componentName);
    return (
      // @ts-ignore theme is injected by the styled util
      /* @__PURE__ */ jsxRuntimeExports.jsx(ContainerRoot, __spreadValues({
        as: component,
        ownerState,
        className: clsx(classes.root, className),
        ref
      }, other))
    );
  });
  return Container2;
}
const React$1P = window["React"];
function isMuiElement(element, muiNames) {
  var _a2, _b, _c, _d;
  return /* @__PURE__ */ React$1P.isValidElement(element) && muiNames.indexOf(
    // For server components `muiName` is available in element.type._payload.value.muiName
    // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
    // eslint-disable-next-line no-underscore-dangle
    (_d = element.type.muiName) != null ? _d : (_c = (_b = (_a2 = element.type) == null ? void 0 : _a2._payload) == null ? void 0 : _b.value) == null ? void 0 : _c.muiName
  ) !== -1;
}
const filterBreakpointKeys = (breakpointsKeys, responsiveKeys) => breakpointsKeys.filter((key) => responsiveKeys.includes(key));
const traverseBreakpoints = (breakpoints, responsive, iterator) => {
  const smallestBreakpoint = breakpoints.keys[0];
  if (Array.isArray(responsive)) {
    responsive.forEach((breakpointValue, index2) => {
      iterator((responsiveStyles, style2) => {
        if (index2 <= breakpoints.keys.length - 1) {
          if (index2 === 0) {
            Object.assign(responsiveStyles, style2);
          } else {
            responsiveStyles[breakpoints.up(breakpoints.keys[index2])] = style2;
          }
        }
      }, breakpointValue);
    });
  } else if (responsive && typeof responsive === "object") {
    const keys = Object.keys(responsive).length > breakpoints.keys.length ? breakpoints.keys : filterBreakpointKeys(breakpoints.keys, Object.keys(responsive));
    keys.forEach((key) => {
      if (breakpoints.keys.includes(key)) {
        const breakpointValue = responsive[key];
        if (breakpointValue !== void 0) {
          iterator((responsiveStyles, style2) => {
            if (smallestBreakpoint === key) {
              Object.assign(responsiveStyles, style2);
            } else {
              responsiveStyles[breakpoints.up(key)] = style2;
            }
          }, breakpointValue);
        }
      }
    });
  } else if (typeof responsive === "number" || typeof responsive === "string") {
    iterator((responsiveStyles, style2) => {
      Object.assign(responsiveStyles, style2);
    }, responsive);
  }
};
function getSelfSpacingVar(axis) {
  return `--Grid-${axis}Spacing`;
}
function getParentSpacingVar(axis) {
  return `--Grid-parent-${axis}Spacing`;
}
const selfColumnsVar = "--Grid-columns";
const parentColumnsVar = "--Grid-parent-columns";
const generateGridSizeStyles = ({
  theme: theme2,
  ownerState
}) => {
  const styles2 = {};
  traverseBreakpoints(theme2.breakpoints, ownerState.size, (appendStyle, value) => {
    let style2 = {};
    if (value === "grow") {
      style2 = {
        flexBasis: 0,
        flexGrow: 1,
        maxWidth: "100%"
      };
    }
    if (value === "auto") {
      style2 = {
        flexBasis: "auto",
        flexGrow: 0,
        flexShrink: 0,
        maxWidth: "none",
        width: "auto"
      };
    }
    if (typeof value === "number") {
      style2 = {
        flexGrow: 0,
        flexBasis: "auto",
        width: `calc(100% * ${value} / var(${parentColumnsVar}) - (var(${parentColumnsVar}) - ${value}) * (var(${getParentSpacingVar("column")}) / var(${parentColumnsVar})))`
      };
    }
    appendStyle(styles2, style2);
  });
  return styles2;
};
const generateGridOffsetStyles = ({
  theme: theme2,
  ownerState
}) => {
  const styles2 = {};
  traverseBreakpoints(theme2.breakpoints, ownerState.offset, (appendStyle, value) => {
    let style2 = {};
    if (value === "auto") {
      style2 = {
        marginLeft: "auto"
      };
    }
    if (typeof value === "number") {
      style2 = {
        marginLeft: value === 0 ? "0px" : `calc(100% * ${value} / var(${parentColumnsVar}) + var(${getParentSpacingVar("column")}) * ${value} / var(${parentColumnsVar}))`
      };
    }
    appendStyle(styles2, style2);
  });
  return styles2;
};
const generateGridColumnsStyles = ({
  theme: theme2,
  ownerState
}) => {
  if (!ownerState.container) {
    return {};
  }
  const styles2 = {
    [selfColumnsVar]: 12
  };
  traverseBreakpoints(theme2.breakpoints, ownerState.columns, (appendStyle, value) => {
    const columns = value != null ? value : 12;
    appendStyle(styles2, {
      [selfColumnsVar]: columns,
      "> *": {
        [parentColumnsVar]: columns
      }
    });
  });
  return styles2;
};
const generateGridRowSpacingStyles = ({
  theme: theme2,
  ownerState
}) => {
  if (!ownerState.container) {
    return {};
  }
  const styles2 = {};
  traverseBreakpoints(theme2.breakpoints, ownerState.rowSpacing, (appendStyle, value) => {
    var _a2;
    const spacing = typeof value === "string" ? value : (_a2 = theme2.spacing) == null ? void 0 : _a2.call(theme2, value);
    appendStyle(styles2, {
      [getSelfSpacingVar("row")]: spacing,
      "> *": {
        [getParentSpacingVar("row")]: spacing
      }
    });
  });
  return styles2;
};
const generateGridColumnSpacingStyles = ({
  theme: theme2,
  ownerState
}) => {
  if (!ownerState.container) {
    return {};
  }
  const styles2 = {};
  traverseBreakpoints(theme2.breakpoints, ownerState.columnSpacing, (appendStyle, value) => {
    var _a2;
    const spacing = typeof value === "string" ? value : (_a2 = theme2.spacing) == null ? void 0 : _a2.call(theme2, value);
    appendStyle(styles2, {
      [getSelfSpacingVar("column")]: spacing,
      "> *": {
        [getParentSpacingVar("column")]: spacing
      }
    });
  });
  return styles2;
};
const generateGridDirectionStyles = ({
  theme: theme2,
  ownerState
}) => {
  if (!ownerState.container) {
    return {};
  }
  const styles2 = {};
  traverseBreakpoints(theme2.breakpoints, ownerState.direction, (appendStyle, value) => {
    appendStyle(styles2, {
      flexDirection: value
    });
  });
  return styles2;
};
const generateGridStyles = ({
  ownerState
}) => {
  return __spreadValues({
    minWidth: 0,
    boxSizing: "border-box"
  }, ownerState.container && __spreadProps(__spreadValues({
    display: "flex",
    flexWrap: "wrap"
  }, ownerState.wrap && ownerState.wrap !== "wrap" && {
    flexWrap: ownerState.wrap
  }), {
    gap: `var(${getSelfSpacingVar("row")}) var(${getSelfSpacingVar("column")})`
  }));
};
const generateSizeClassNames = (size) => {
  const classNames = [];
  Object.entries(size).forEach(([key, value]) => {
    if (value !== false && value !== void 0) {
      classNames.push(`grid-${key}-${String(value)}`);
    }
  });
  return classNames;
};
const generateSpacingClassNames = (spacing, smallestBreakpoint = "xs") => {
  function isValidSpacing(val) {
    if (val === void 0) {
      return false;
    }
    return typeof val === "string" && !Number.isNaN(Number(val)) || typeof val === "number" && val > 0;
  }
  if (isValidSpacing(spacing)) {
    return [`spacing-${smallestBreakpoint}-${String(spacing)}`];
  }
  if (typeof spacing === "object" && !Array.isArray(spacing)) {
    const classNames = [];
    Object.entries(spacing).forEach(([key, value]) => {
      if (isValidSpacing(value)) {
        classNames.push(`spacing-${key}-${String(value)}`);
      }
    });
    return classNames;
  }
  return [];
};
const generateDirectionClasses = (direction) => {
  if (direction === void 0) {
    return [];
  }
  if (typeof direction === "object") {
    return Object.entries(direction).map(([key, value]) => `direction-${key}-${value}`);
  }
  return [`direction-xs-${String(direction)}`];
};
function deleteLegacyGridProps(props, breakpoints) {
  if (props.item !== void 0) {
    delete props.item;
  }
  if (props.zeroMinWidth !== void 0) {
    delete props.zeroMinWidth;
  }
  breakpoints.keys.forEach((breakpoint) => {
    if (props[breakpoint] !== void 0) {
      delete props[breakpoint];
    }
  });
}
const React$1O = window["React"];
const defaultTheme$3 = createTheme$1();
const defaultCreateStyledComponent$1 = styled$1("div", {
  name: "MuiGrid",
  slot: "Root"
});
function useThemePropsDefault$1(props) {
  return useThemeProps({
    props,
    name: "MuiGrid",
    defaultTheme: defaultTheme$3
  });
}
function createGrid(options = {}) {
  const {
    // This will allow adding custom styled fn (for example for custom sx style function)
    createStyledComponent = defaultCreateStyledComponent$1,
    useThemeProps: useThemeProps2 = useThemePropsDefault$1,
    useTheme: useTheme2 = useTheme$2,
    componentName = "MuiGrid"
  } = options;
  const useUtilityClasses2 = (ownerState, theme2) => {
    const {
      container,
      direction,
      spacing,
      wrap,
      size
    } = ownerState;
    const slots = {
      root: ["root", container && "container", wrap !== "wrap" && `wrap-xs-${String(wrap)}`, ...generateDirectionClasses(direction), ...generateSizeClassNames(size), ...container ? generateSpacingClassNames(spacing, theme2.breakpoints.keys[0]) : []]
    };
    return composeClasses(slots, (slot) => generateUtilityClass(componentName, slot), {});
  };
  function parseResponsiveProp(propValue, breakpoints, shouldUseValue = () => true) {
    const parsedProp = {};
    if (propValue === null) {
      return parsedProp;
    }
    if (Array.isArray(propValue)) {
      propValue.forEach((value, index2) => {
        if (value !== null && shouldUseValue(value) && breakpoints.keys[index2]) {
          parsedProp[breakpoints.keys[index2]] = value;
        }
      });
    } else if (typeof propValue === "object") {
      Object.keys(propValue).forEach((key) => {
        const value = propValue[key];
        if (value !== null && value !== void 0 && shouldUseValue(value)) {
          parsedProp[key] = value;
        }
      });
    } else {
      parsedProp[breakpoints.keys[0]] = propValue;
    }
    return parsedProp;
  }
  const GridRoot = createStyledComponent(generateGridColumnsStyles, generateGridColumnSpacingStyles, generateGridRowSpacingStyles, generateGridSizeStyles, generateGridDirectionStyles, generateGridStyles, generateGridOffsetStyles);
  const Grid2 = /* @__PURE__ */ React$1O.forwardRef(function Grid22(inProps, ref) {
    var _b, _c, _d, _e, _f, _g;
    const theme2 = useTheme2();
    const themeProps = useThemeProps2(inProps);
    const props = extendSxProp$1(themeProps);
    deleteLegacyGridProps(props, theme2.breakpoints);
    const _a2 = props, {
      className,
      children,
      columns: columnsProp = 12,
      container = false,
      component = "div",
      direction = "row",
      wrap = "wrap",
      size: sizeProp = {},
      offset: offsetProp = {},
      spacing: spacingProp = 0,
      rowSpacing: rowSpacingProp = spacingProp,
      columnSpacing: columnSpacingProp = spacingProp,
      unstable_level: level = 0
    } = _a2, other = __objRest(_a2, [
      "className",
      "children",
      "columns",
      "container",
      "component",
      "direction",
      "wrap",
      "size",
      "offset",
      "spacing",
      "rowSpacing",
      "columnSpacing",
      "unstable_level"
    ]);
    const size = parseResponsiveProp(sizeProp, theme2.breakpoints, (val) => val !== false);
    const offset2 = parseResponsiveProp(offsetProp, theme2.breakpoints);
    const columns = (_b = inProps.columns) != null ? _b : level ? void 0 : columnsProp;
    const spacing = (_c = inProps.spacing) != null ? _c : level ? void 0 : spacingProp;
    const rowSpacing = (_e = (_d = inProps.rowSpacing) != null ? _d : inProps.spacing) != null ? _e : level ? void 0 : rowSpacingProp;
    const columnSpacing = (_g = (_f = inProps.columnSpacing) != null ? _f : inProps.spacing) != null ? _g : level ? void 0 : columnSpacingProp;
    const ownerState = __spreadProps(__spreadValues({}, props), {
      level,
      columns,
      container,
      direction,
      wrap,
      spacing,
      rowSpacing,
      columnSpacing,
      size,
      offset: offset2
    });
    const classes = useUtilityClasses2(ownerState, theme2);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridRoot, __spreadProps(__spreadValues({
      ref,
      as: component,
      ownerState,
      className: clsx(classes.root, className)
    }, other), {
      children: React$1O.Children.map(children, (child) => {
        var _a3, _b2;
        if (/* @__PURE__ */ React$1O.isValidElement(child) && isMuiElement(child, ["Grid"]) && container && child.props.container) {
          return /* @__PURE__ */ React$1O.cloneElement(child, {
            unstable_level: (_b2 = (_a3 = child.props) == null ? void 0 : _a3.unstable_level) != null ? _b2 : level + 1
          });
        }
        return child;
      })
    }));
  });
  Grid2.muiName = "Grid";
  return Grid2;
}
const React$1N = window["React"];
const defaultTheme$2 = createTheme$1();
const defaultCreateStyledComponent = styled$1("div", {
  name: "MuiStack",
  slot: "Root"
});
function useThemePropsDefault(props) {
  return useThemeProps({
    props,
    name: "MuiStack",
    defaultTheme: defaultTheme$2
  });
}
function joinChildren(children, separator) {
  const childrenArray = React$1N.Children.toArray(children).filter(Boolean);
  return childrenArray.reduce((output, child, index2) => {
    output.push(child);
    if (index2 < childrenArray.length - 1) {
      output.push(/* @__PURE__ */ React$1N.cloneElement(separator, {
        key: `separator-${index2}`
      }));
    }
    return output;
  }, []);
}
const getSideFromDirection = (direction) => {
  return {
    row: "Left",
    "row-reverse": "Right",
    column: "Top",
    "column-reverse": "Bottom"
  }[direction];
};
const style = ({
  ownerState,
  theme: theme2
}) => {
  let styles2 = __spreadValues({
    display: "flex",
    flexDirection: "column"
  }, handleBreakpoints({
    theme: theme2
  }, resolveBreakpointValues({
    values: ownerState.direction,
    breakpoints: theme2.breakpoints.values
  }), (propValue) => ({
    flexDirection: propValue
  })));
  if (ownerState.spacing) {
    const transformer = createUnarySpacing(theme2);
    const base = Object.keys(theme2.breakpoints.values).reduce((acc, breakpoint) => {
      if (typeof ownerState.spacing === "object" && ownerState.spacing[breakpoint] != null || typeof ownerState.direction === "object" && ownerState.direction[breakpoint] != null) {
        acc[breakpoint] = true;
      }
      return acc;
    }, {});
    const directionValues = resolveBreakpointValues({
      values: ownerState.direction,
      base
    });
    const spacingValues = resolveBreakpointValues({
      values: ownerState.spacing,
      base
    });
    if (typeof directionValues === "object") {
      Object.keys(directionValues).forEach((breakpoint, index2, breakpoints) => {
        const directionValue = directionValues[breakpoint];
        if (!directionValue) {
          const previousDirectionValue = index2 > 0 ? directionValues[breakpoints[index2 - 1]] : "column";
          directionValues[breakpoint] = previousDirectionValue;
        }
      });
    }
    const styleFromPropValue = (propValue, breakpoint) => {
      if (ownerState.useFlexGap) {
        return {
          gap: getValue(transformer, propValue)
        };
      }
      return {
        // The useFlexGap={false} implement relies on each child to give up control of the margin.
        // We need to reset the margin to avoid double spacing.
        "& > :not(style):not(style)": {
          margin: 0
        },
        "& > :not(style) ~ :not(style)": {
          [`margin${getSideFromDirection(breakpoint ? directionValues[breakpoint] : ownerState.direction)}`]: getValue(transformer, propValue)
        }
      };
    };
    styles2 = deepmerge(styles2, handleBreakpoints({
      theme: theme2
    }, spacingValues, styleFromPropValue));
  }
  styles2 = mergeBreakpointsInOrder(theme2.breakpoints, styles2);
  return styles2;
};
function createStack(options = {}) {
  const {
    // This will allow adding custom styled fn (for example for custom sx style function)
    createStyledComponent = defaultCreateStyledComponent,
    useThemeProps: useThemeProps2 = useThemePropsDefault,
    componentName = "MuiStack"
  } = options;
  const useUtilityClasses2 = () => {
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, (slot) => generateUtilityClass(componentName, slot), {});
  };
  const StackRoot = createStyledComponent(style);
  const Stack2 = /* @__PURE__ */ React$1N.forwardRef(function Grid2(inProps, ref) {
    const themeProps = useThemeProps2(inProps);
    const props = extendSxProp$1(themeProps);
    const _a2 = props, {
      component = "div",
      direction = "column",
      spacing = 0,
      divider,
      children,
      className,
      useFlexGap = false
    } = _a2, other = __objRest(_a2, [
      "component",
      "direction",
      "spacing",
      "divider",
      "children",
      "className",
      "useFlexGap"
    ]);
    const ownerState = {
      direction,
      spacing,
      useFlexGap
    };
    const classes = useUtilityClasses2();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(StackRoot, __spreadProps(__spreadValues({
      as: component,
      ownerState,
      ref,
      className: clsx(classes.root, className)
    }, other), {
      children: divider ? joinChildren(children, divider) : children
    }));
  });
  return Stack2;
}
function getLight() {
  return {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: common.white,
      default: common.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
}
const light = getLight();
function getDark() {
  return {
    text: {
      primary: common.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: common.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
}
const dark = getDark();
function addLightOrDark(intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === "light") {
      intent.light = lighten(intent.main, tonalOffsetLight);
    } else if (direction === "dark") {
      intent.dark = darken(intent.main, tonalOffsetDark);
    }
  }
}
function mixLightOrDark(colorSpace, intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === "light") {
      intent.light = `color-mix(in ${colorSpace}, ${intent.main}, #fff ${(tonalOffsetLight * 100).toFixed(0)}%)`;
    } else if (direction === "dark") {
      intent.dark = `color-mix(in ${colorSpace}, ${intent.main}, #000 ${(tonalOffsetDark * 100).toFixed(0)}%)`;
    }
  }
}
function getDefaultPrimary(mode = "light") {
  if (mode === "dark") {
    return {
      main: blue[200],
      light: blue[50],
      dark: blue[400]
    };
  }
  return {
    main: blue[700],
    light: blue[400],
    dark: blue[800]
  };
}
function getDefaultSecondary(mode = "light") {
  if (mode === "dark") {
    return {
      main: purple[200],
      light: purple[50],
      dark: purple[400]
    };
  }
  return {
    main: purple[500],
    light: purple[300],
    dark: purple[700]
  };
}
function getDefaultError(mode = "light") {
  if (mode === "dark") {
    return {
      main: red[500],
      light: red[300],
      dark: red[700]
    };
  }
  return {
    main: red[700],
    light: red[400],
    dark: red[800]
  };
}
function getDefaultInfo(mode = "light") {
  if (mode === "dark") {
    return {
      main: lightBlue[400],
      light: lightBlue[300],
      dark: lightBlue[700]
    };
  }
  return {
    main: lightBlue[700],
    light: lightBlue[500],
    dark: lightBlue[900]
  };
}
function getDefaultSuccess(mode = "light") {
  if (mode === "dark") {
    return {
      main: green[400],
      light: green[300],
      dark: green[700]
    };
  }
  return {
    main: green[800],
    light: green[500],
    dark: green[900]
  };
}
function getDefaultWarning(mode = "light") {
  if (mode === "dark") {
    return {
      main: orange[400],
      light: orange[300],
      dark: orange[700]
    };
  }
  return {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: orange[500],
    dark: orange[900]
  };
}
function contrastColor(background) {
  return `oklch(from ${background} var(--__l) 0 h / var(--__a))`;
}
function createPalette(palette) {
  const _a2 = palette, {
    mode = "light",
    contrastThreshold = 3,
    tonalOffset = 0.2,
    colorSpace
  } = _a2, other = __objRest(_a2, [
    "mode",
    "contrastThreshold",
    "tonalOffset",
    "colorSpace"
  ]);
  const primary = palette.primary || getDefaultPrimary(mode);
  const secondary = palette.secondary || getDefaultSecondary(mode);
  const error = palette.error || getDefaultError(mode);
  const info = palette.info || getDefaultInfo(mode);
  const success = palette.success || getDefaultSuccess(mode);
  const warning2 = palette.warning || getDefaultWarning(mode);
  function getContrastText(background) {
    if (colorSpace) {
      return contrastColor(background);
    }
    const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    return contrastText;
  }
  const augmentColor = ({
    color: color2,
    name: name2,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    color2 = __spreadValues({}, color2);
    if (!color2.main && color2[mainShade]) {
      color2.main = color2[mainShade];
    }
    if (!color2.hasOwnProperty("main")) {
      throw new Error(formatMuiErrorMessage(11, name2 ? ` (${name2})` : "", mainShade));
    }
    if (typeof color2.main !== "string") {
      throw new Error(formatMuiErrorMessage(12, name2 ? ` (${name2})` : "", JSON.stringify(color2.main)));
    }
    if (colorSpace) {
      mixLightOrDark(colorSpace, color2, "light", lightShade, tonalOffset);
      mixLightOrDark(colorSpace, color2, "dark", darkShade, tonalOffset);
    } else {
      addLightOrDark(color2, "light", lightShade, tonalOffset);
      addLightOrDark(color2, "dark", darkShade, tonalOffset);
    }
    if (!color2.contrastText) {
      color2.contrastText = getContrastText(color2.main);
    }
    return color2;
  };
  let modeHydrated;
  if (mode === "light") {
    modeHydrated = getLight();
  } else if (mode === "dark") {
    modeHydrated = getDark();
  }
  const paletteOutput = deepmerge(__spreadValues({
    // A collection of common colors.
    common: __spreadValues({}, common),
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode,
    // The colors used to represent primary interface elements for a user.
    primary: augmentColor({
      color: primary,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: augmentColor({
      color: secondary,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: augmentColor({
      color: error,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: augmentColor({
      color: warning2,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: augmentColor({
      color: info,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: augmentColor({
      color: success,
      name: "success"
    }),
    // The grey colors.
    grey,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText,
    // Generate a rich color object.
    augmentColor,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset
  }, modeHydrated), other);
  return paletteOutput;
}
function prepareTypographyVars(typography) {
  const vars = {};
  const entries = Object.entries(typography);
  entries.forEach((entry) => {
    const [key, value] = entry;
    if (typeof value === "object") {
      vars[key] = `${value.fontStyle ? `${value.fontStyle} ` : ""}${value.fontVariant ? `${value.fontVariant} ` : ""}${value.fontWeight ? `${value.fontWeight} ` : ""}${value.fontStretch ? `${value.fontStretch} ` : ""}${value.fontSize || ""}${value.lineHeight ? `/${value.lineHeight} ` : ""}${value.fontFamily || ""}`;
    }
  });
  return vars;
}
function createMixins(breakpoints, mixins) {
  return __spreadValues({
    toolbar: {
      minHeight: 56,
      [breakpoints.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [breakpoints.up("sm")]: {
        minHeight: 64
      }
    }
  }, mixins);
}
function round$2(value) {
  return Math.round(value * 1e5) / 1e5;
}
const caseAllCaps = {
  textTransform: "uppercase"
};
const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(palette, typography) {
  const _a2 = typeof typography === "function" ? typography(palette) : typography, {
    fontFamily = defaultFontFamily,
    fontSize: fontSize = 14,
    fontWeightLight: fontWeightLight = 300,
    fontWeightRegular = 400,
    fontWeightMedium = 500,
    fontWeightBold = 700,
    htmlFontSize: htmlFontSize = 16,
    allVariants: allVariants,
    pxToRem: pxToRem2
  } = _a2, other = __objRest(_a2, [
    "fontFamily",
    // The default font size of the Material Specification.
    "fontSize",
    // px
    "fontWeightLight",
    "fontWeightRegular",
    "fontWeightMedium",
    "fontWeightBold",
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    "htmlFontSize",
    // Apply the CSS properties to all the variants.
    "allVariants",
    "pxToRem"
  ]);
  const coef = fontSize / 14;
  const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
  const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) => __spreadValues(__spreadValues(__spreadValues({
    fontFamily,
    fontWeight,
    fontSize: pxToRem(size),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight
  }, fontFamily === defaultFontFamily ? {
    letterSpacing: `${round$2(letterSpacing / size)}em`
  } : {}), casing), allVariants);
  const variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return deepmerge(__spreadValues({
    htmlFontSize,
    pxToRem,
    fontFamily,
    fontSize,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold
  }, variants), other, {
    clone: false
    // No need to clone deep
  });
}
const shadowKeyUmbraOpacity = 0.2;
const shadowKeyPenumbraOpacity = 0.14;
const shadowAmbientShadowOpacity = 0.12;
function createShadow(...px) {
  return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
}
const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
const easing = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
const duration = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function formatMs(milliseconds) {
  return `${Math.round(milliseconds)}ms`;
}
function getAutoHeightDuration(height2) {
  if (!height2) {
    return 0;
  }
  const constant = height2 / 36;
  return Math.min(Math.round((4 + 15 * __pow(constant, 0.25) + constant / 5) * 10), 3e3);
}
function createTransitions(inputTransitions) {
  const mergedEasing = __spreadValues(__spreadValues({}, easing), inputTransitions.easing);
  const mergedDuration = __spreadValues(__spreadValues({}, duration), inputTransitions.duration);
  const create = (props = ["all"], options = {}) => {
    const _a2 = options, {
      duration: durationOption = mergedDuration.standard,
      easing: easingOption = mergedEasing.easeInOut,
      delay = 0
    } = _a2, other = __objRest(_a2, [
      "duration",
      "easing",
      "delay"
    ]);
    return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
  };
  return __spreadProps(__spreadValues({
    getAutoHeightDuration,
    create
  }, inputTransitions), {
    easing: mergedEasing,
    duration: mergedDuration
  });
}
const zIndex = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
function isSerializable(val) {
  return isPlainObject$2(val) || typeof val === "undefined" || typeof val === "string" || typeof val === "boolean" || typeof val === "number" || Array.isArray(val);
}
function stringifyTheme(baseTheme = {}) {
  const serializableTheme = __spreadValues({}, baseTheme);
  function serializeTheme(object) {
    const array = Object.entries(object);
    for (let index2 = 0; index2 < array.length; index2++) {
      const [key, value] = array[index2];
      if (!isSerializable(value) || key.startsWith("unstable_")) {
        delete object[key];
      } else if (isPlainObject$2(value)) {
        object[key] = __spreadValues({}, value);
        serializeTheme(object[key]);
      }
    }
  }
  serializeTheme(serializableTheme);
  return `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(serializableTheme, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
}
function coefficientToPercentage(coefficient) {
  if (typeof coefficient === "number") {
    return `${(coefficient * 100).toFixed(0)}%`;
  }
  return `calc((${coefficient}) * 100%)`;
}
const parseAddition = (str) => {
  if (!Number.isNaN(+str)) {
    return +str;
  }
  const numbers = str.match(/\d*\.?\d+/g);
  if (!numbers) {
    return 0;
  }
  let sum = 0;
  for (let i = 0; i < numbers.length; i += 1) {
    sum += +numbers[i];
  }
  return sum;
};
function attachColorManipulators(theme2) {
  Object.assign(theme2, {
    alpha(color2, coefficient) {
      const obj = this || theme2;
      if (obj.colorSpace) {
        return `oklch(from ${color2} l c h / ${typeof coefficient === "string" ? `calc(${coefficient})` : coefficient})`;
      }
      if (obj.vars) {
        return `rgba(${color2.replace(/var\(--([^,\s)]+)(?:,[^)]+)?\)+/g, "var(--$1Channel)")} / ${typeof coefficient === "string" ? `calc(${coefficient})` : coefficient})`;
      }
      return alpha(color2, parseAddition(coefficient));
    },
    lighten(color2, coefficient) {
      const obj = this || theme2;
      if (obj.colorSpace) {
        return `color-mix(in ${obj.colorSpace}, ${color2}, #fff ${coefficientToPercentage(coefficient)})`;
      }
      return lighten(color2, coefficient);
    },
    darken(color2, coefficient) {
      const obj = this || theme2;
      if (obj.colorSpace) {
        return `color-mix(in ${obj.colorSpace}, ${color2}, #000 ${coefficientToPercentage(coefficient)})`;
      }
      return darken(color2, coefficient);
    }
  });
}
function createThemeNoVars(options = {}, ...args) {
  const _a2 = options, {
    breakpoints: breakpointsInput,
    mixins: mixinsInput = {},
    spacing: spacingInput,
    palette: paletteInput = {},
    transitions: transitionsInput = {},
    typography: typographyInput = {},
    shape: shapeInput,
    colorSpace
  } = _a2, other = __objRest(_a2, [
    "breakpoints",
    "mixins",
    "spacing",
    "palette",
    "transitions",
    "typography",
    "shape",
    "colorSpace"
  ]);
  if (options.vars && // The error should throw only for the root theme creation because user is not allowed to use a custom node `vars`.
  // `generateThemeVars` is the closest identifier for checking that the `options` is a result of `createTheme` with CSS variables so that user can create new theme for nested ThemeProvider.
  options.generateThemeVars === void 0) {
    throw new Error(formatMuiErrorMessage(20));
  }
  const palette = createPalette(__spreadProps(__spreadValues({}, paletteInput), {
    colorSpace
  }));
  const systemTheme = createTheme$1(options);
  let muiTheme = deepmerge(systemTheme, {
    mixins: createMixins(systemTheme.breakpoints, mixinsInput),
    palette,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: shadows.slice(),
    typography: createTypography(palette, typographyInput),
    transitions: createTransitions(transitionsInput),
    zIndex: __spreadValues({}, zIndex)
  });
  muiTheme = deepmerge(muiTheme, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = __spreadValues(__spreadValues({}, defaultSxConfig), other == null ? void 0 : other.unstable_sxConfig);
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  muiTheme.toRuntimeSource = stringifyTheme;
  attachColorManipulators(muiTheme);
  return muiTheme;
}
function getOverlayAlpha(elevation) {
  let alphaValue;
  if (elevation < 1) {
    alphaValue = 5.11916 * __pow(elevation, 2);
  } else {
    alphaValue = 4.5 * Math.log(elevation + 1) + 2;
  }
  return Math.round(alphaValue * 10) / 1e3;
}
const defaultDarkOverlays = [...Array(25)].map((_, index2) => {
  if (index2 === 0) {
    return "none";
  }
  const overlay = getOverlayAlpha(index2);
  return `linear-gradient(rgba(255 255 255 / ${overlay}), rgba(255 255 255 / ${overlay}))`;
});
function getOpacity(mode) {
  return {
    inputPlaceholder: mode === "dark" ? 0.5 : 0.42,
    inputUnderline: mode === "dark" ? 0.7 : 0.42,
    switchTrackDisabled: mode === "dark" ? 0.2 : 0.12,
    switchTrack: mode === "dark" ? 0.3 : 0.38
  };
}
function getOverlays(mode) {
  return mode === "dark" ? defaultDarkOverlays : [];
}
function createColorScheme(options) {
  const _a2 = options, {
    palette: paletteInput = {
      mode: "light"
    },
    opacity: opacity,
    overlays,
    colorSpace
  } = _a2, other = __objRest(_a2, [
    "palette",
    // need to cast to avoid module augmentation test
    "opacity",
    "overlays",
    "colorSpace"
  ]);
  const palette = createPalette(__spreadProps(__spreadValues({}, paletteInput), {
    colorSpace
  }));
  return __spreadValues({
    palette,
    opacity: __spreadValues(__spreadValues({}, getOpacity(palette.mode)), opacity),
    overlays: overlays || getOverlays(palette.mode)
  }, other);
}
function shouldSkipGeneratingVar(keys) {
  var _a2;
  return !!keys[0].match(/(cssVarPrefix|colorSchemeSelector|modularCssLayers|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!keys[0].match(/sxConfig$/) || // ends with sxConfig
  keys[0] === "palette" && !!((_a2 = keys[1]) == null ? void 0 : _a2.match(/(mode|contrastThreshold|tonalOffset)/));
}
const excludeVariablesFromRoot = (cssVarPrefix) => [...[...Array(25)].map((_, index2) => `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}overlays-${index2}`), `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkBg`, `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkColor`];
const defaultGetSelector = (theme2) => (colorScheme, css2) => {
  const root = theme2.rootSelector || ":root";
  const selector = theme2.colorSchemeSelector;
  let rule = selector;
  if (selector === "class") {
    rule = ".%s";
  }
  if (selector === "data") {
    rule = "[data-%s]";
  }
  if ((selector == null ? void 0 : selector.startsWith("data-")) && !selector.includes("%s")) {
    rule = `[${selector}="%s"]`;
  }
  if (theme2.defaultColorScheme === colorScheme) {
    if (colorScheme === "dark") {
      const excludedVariables = {};
      excludeVariablesFromRoot(theme2.cssVarPrefix).forEach((cssVar) => {
        excludedVariables[cssVar] = css2[cssVar];
        delete css2[cssVar];
      });
      if (rule === "media") {
        return {
          [root]: css2,
          [`@media (prefers-color-scheme: dark)`]: {
            [root]: excludedVariables
          }
        };
      }
      if (rule) {
        return {
          [rule.replace("%s", colorScheme)]: excludedVariables,
          [`${root}, ${rule.replace("%s", colorScheme)}`]: css2
        };
      }
      return {
        [root]: __spreadValues(__spreadValues({}, css2), excludedVariables)
      };
    }
    if (rule && rule !== "media") {
      return `${root}, ${rule.replace("%s", String(colorScheme))}`;
    }
  } else if (colorScheme) {
    if (rule === "media") {
      return {
        [`@media (prefers-color-scheme: ${String(colorScheme)})`]: {
          [root]: css2
        }
      };
    }
    if (rule) {
      return rule.replace("%s", String(colorScheme));
    }
  }
  return root;
};
function assignNode(obj, keys) {
  keys.forEach((k) => {
    if (!obj[k]) {
      obj[k] = {};
    }
  });
}
function setColor(obj, key, defaultValue) {
  if (!obj[key] && defaultValue) {
    obj[key] = defaultValue;
  }
}
function toRgb(color2) {
  if (typeof color2 !== "string" || !color2.startsWith("hsl")) {
    return color2;
  }
  return hslToRgb(color2);
}
function setColorChannel(obj, key) {
  if (!(`${key}Channel` in obj)) {
    obj[`${key}Channel`] = private_safeColorChannel(toRgb(obj[key]));
  }
}
function getSpacingVal(spacingInput) {
  if (typeof spacingInput === "number") {
    return `${spacingInput}px`;
  }
  if (typeof spacingInput === "string" || typeof spacingInput === "function" || Array.isArray(spacingInput)) {
    return spacingInput;
  }
  return "8px";
}
const silent = (fn2) => {
  try {
    return fn2();
  } catch (error) {
  }
  return void 0;
};
const createGetCssVar = (cssVarPrefix = "mui") => createGetCssVar$1(cssVarPrefix);
function attachColorScheme$1(colorSpace, colorSchemes, scheme, restTheme, colorScheme) {
  if (!scheme) {
    return void 0;
  }
  scheme = scheme === true ? {} : scheme;
  const mode = colorScheme === "dark" ? "dark" : "light";
  if (!restTheme) {
    colorSchemes[colorScheme] = createColorScheme(__spreadProps(__spreadValues({}, scheme), {
      palette: __spreadValues({
        mode
      }, scheme == null ? void 0 : scheme.palette),
      colorSpace
    }));
    return void 0;
  }
  const _a2 = createThemeNoVars(__spreadProps(__spreadValues({}, restTheme), {
    palette: __spreadValues({
      mode
    }, scheme == null ? void 0 : scheme.palette),
    colorSpace
  })), {
    palette
  } = _a2, muiTheme = __objRest(_a2, [
    "palette"
  ]);
  colorSchemes[colorScheme] = __spreadProps(__spreadValues({}, scheme), {
    palette,
    opacity: __spreadValues(__spreadValues({}, getOpacity(mode)), scheme == null ? void 0 : scheme.opacity),
    overlays: (scheme == null ? void 0 : scheme.overlays) || getOverlays(mode)
  });
  return muiTheme;
}
function createThemeWithVars(options = {}, ...args) {
  const _a2 = options, {
    colorSchemes: colorSchemesInput = {
      light: true
    },
    defaultColorScheme: defaultColorSchemeInput,
    disableCssColorScheme = false,
    cssVarPrefix = "mui",
    nativeColor = false,
    shouldSkipGeneratingVar: shouldSkipGeneratingVar$1 = shouldSkipGeneratingVar,
    colorSchemeSelector: selector = colorSchemesInput.light && colorSchemesInput.dark ? "media" : void 0,
    rootSelector = ":root"
  } = _a2, input = __objRest(_a2, [
    "colorSchemes",
    "defaultColorScheme",
    "disableCssColorScheme",
    "cssVarPrefix",
    "nativeColor",
    "shouldSkipGeneratingVar",
    "colorSchemeSelector",
    "rootSelector"
  ]);
  const firstColorScheme = Object.keys(colorSchemesInput)[0];
  const defaultColorScheme = defaultColorSchemeInput || (colorSchemesInput.light && firstColorScheme !== "light" ? "light" : firstColorScheme);
  const getCssVar = createGetCssVar(cssVarPrefix);
  const _b = colorSchemesInput, {
    [defaultColorScheme]: defaultSchemeInput,
    light: builtInLight,
    dark: builtInDark
  } = _b, customColorSchemes = __objRest(_b, [
    __restKey(defaultColorScheme),
    "light",
    "dark"
  ]);
  const colorSchemes = __spreadValues({}, customColorSchemes);
  let defaultScheme = defaultSchemeInput;
  if (defaultColorScheme === "dark" && !("dark" in colorSchemesInput) || defaultColorScheme === "light" && !("light" in colorSchemesInput)) {
    defaultScheme = true;
  }
  if (!defaultScheme) {
    throw new Error(formatMuiErrorMessage(21, defaultColorScheme));
  }
  let colorSpace;
  if (nativeColor) {
    colorSpace = "oklch";
  }
  const muiTheme = attachColorScheme$1(colorSpace, colorSchemes, defaultScheme, input, defaultColorScheme);
  if (builtInLight && !colorSchemes.light) {
    attachColorScheme$1(colorSpace, colorSchemes, builtInLight, void 0, "light");
  }
  if (builtInDark && !colorSchemes.dark) {
    attachColorScheme$1(colorSpace, colorSchemes, builtInDark, void 0, "dark");
  }
  let theme2 = __spreadProps(__spreadValues({
    defaultColorScheme
  }, muiTheme), {
    cssVarPrefix,
    colorSchemeSelector: selector,
    rootSelector,
    getCssVar,
    colorSchemes,
    font: __spreadValues(__spreadValues({}, prepareTypographyVars(muiTheme.typography)), muiTheme.font),
    spacing: getSpacingVal(input.spacing)
  });
  Object.keys(theme2.colorSchemes).forEach((key) => {
    const palette = theme2.colorSchemes[key].palette;
    const setCssVarColor = (cssVar) => {
      const tokens = cssVar.split("-");
      const color2 = tokens[1];
      const colorToken = tokens[2];
      return getCssVar(cssVar, palette[color2][colorToken]);
    };
    if (palette.mode === "light") {
      setColor(palette.common, "background", "#fff");
      setColor(palette.common, "onBackground", "#000");
    }
    if (palette.mode === "dark") {
      setColor(palette.common, "background", "#000");
      setColor(palette.common, "onBackground", "#fff");
    }
    function colorMix(method, color2, coefficient) {
      if (colorSpace) {
        let mixer;
        if (method === private_safeAlpha) {
          mixer = `transparent ${((1 - coefficient) * 100).toFixed(0)}%`;
        }
        if (method === private_safeDarken) {
          mixer = `#000 ${(coefficient * 100).toFixed(0)}%`;
        }
        if (method === private_safeLighten) {
          mixer = `#fff ${(coefficient * 100).toFixed(0)}%`;
        }
        return `color-mix(in ${colorSpace}, ${color2}, ${mixer})`;
      }
      return method(color2, coefficient);
    }
    assignNode(palette, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]);
    if (palette.mode === "light") {
      setColor(palette.Alert, "errorColor", colorMix(private_safeDarken, palette.error.light, 0.6));
      setColor(palette.Alert, "infoColor", colorMix(private_safeDarken, palette.info.light, 0.6));
      setColor(palette.Alert, "successColor", colorMix(private_safeDarken, palette.success.light, 0.6));
      setColor(palette.Alert, "warningColor", colorMix(private_safeDarken, palette.warning.light, 0.6));
      setColor(palette.Alert, "errorFilledBg", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoFilledBg", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successFilledBg", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningFilledBg", setCssVarColor("palette-warning-main"));
      setColor(palette.Alert, "errorFilledColor", silent(() => palette.getContrastText(palette.error.main)));
      setColor(palette.Alert, "infoFilledColor", silent(() => palette.getContrastText(palette.info.main)));
      setColor(palette.Alert, "successFilledColor", silent(() => palette.getContrastText(palette.success.main)));
      setColor(palette.Alert, "warningFilledColor", silent(() => palette.getContrastText(palette.warning.main)));
      setColor(palette.Alert, "errorStandardBg", colorMix(private_safeLighten, palette.error.light, 0.9));
      setColor(palette.Alert, "infoStandardBg", colorMix(private_safeLighten, palette.info.light, 0.9));
      setColor(palette.Alert, "successStandardBg", colorMix(private_safeLighten, palette.success.light, 0.9));
      setColor(palette.Alert, "warningStandardBg", colorMix(private_safeLighten, palette.warning.light, 0.9));
      setColor(palette.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successIconColor", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
      setColor(palette.AppBar, "defaultBg", setCssVarColor("palette-grey-100"));
      setColor(palette.Avatar, "defaultBg", setCssVarColor("palette-grey-400"));
      setColor(palette.Button, "inheritContainedBg", setCssVarColor("palette-grey-300"));
      setColor(palette.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-A100"));
      setColor(palette.Chip, "defaultBorder", setCssVarColor("palette-grey-400"));
      setColor(palette.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultIconColor", setCssVarColor("palette-grey-700"));
      setColor(palette.FilledInput, "bg", "rgba(0, 0, 0, 0.06)");
      setColor(palette.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)");
      setColor(palette.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)");
      setColor(palette.LinearProgress, "primaryBg", colorMix(private_safeLighten, palette.primary.main, 0.62));
      setColor(palette.LinearProgress, "secondaryBg", colorMix(private_safeLighten, palette.secondary.main, 0.62));
      setColor(palette.LinearProgress, "errorBg", colorMix(private_safeLighten, palette.error.main, 0.62));
      setColor(palette.LinearProgress, "infoBg", colorMix(private_safeLighten, palette.info.main, 0.62));
      setColor(palette.LinearProgress, "successBg", colorMix(private_safeLighten, palette.success.main, 0.62));
      setColor(palette.LinearProgress, "warningBg", colorMix(private_safeLighten, palette.warning.main, 0.62));
      setColor(palette.Skeleton, "bg", colorSpace ? colorMix(private_safeAlpha, palette.text.primary, 0.11) : `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.11)`);
      setColor(palette.Slider, "primaryTrack", colorMix(private_safeLighten, palette.primary.main, 0.62));
      setColor(palette.Slider, "secondaryTrack", colorMix(private_safeLighten, palette.secondary.main, 0.62));
      setColor(palette.Slider, "errorTrack", colorMix(private_safeLighten, palette.error.main, 0.62));
      setColor(palette.Slider, "infoTrack", colorMix(private_safeLighten, palette.info.main, 0.62));
      setColor(palette.Slider, "successTrack", colorMix(private_safeLighten, palette.success.main, 0.62));
      setColor(palette.Slider, "warningTrack", colorMix(private_safeLighten, palette.warning.main, 0.62));
      const snackbarContentBackground = colorSpace ? colorMix(private_safeDarken, palette.background.default, 0.6825) : private_safeEmphasize(palette.background.default, 0.8);
      setColor(palette.SnackbarContent, "bg", snackbarContentBackground);
      setColor(palette.SnackbarContent, "color", silent(() => colorSpace ? dark.text.primary : palette.getContrastText(snackbarContentBackground)));
      setColor(palette.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette.background.paper, 0.15));
      setColor(palette.StepConnector, "border", setCssVarColor("palette-grey-400"));
      setColor(palette.StepContent, "border", setCssVarColor("palette-grey-400"));
      setColor(palette.Switch, "defaultColor", setCssVarColor("palette-common-white"));
      setColor(palette.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-100"));
      setColor(palette.Switch, "primaryDisabledColor", colorMix(private_safeLighten, palette.primary.main, 0.62));
      setColor(palette.Switch, "secondaryDisabledColor", colorMix(private_safeLighten, palette.secondary.main, 0.62));
      setColor(palette.Switch, "errorDisabledColor", colorMix(private_safeLighten, palette.error.main, 0.62));
      setColor(palette.Switch, "infoDisabledColor", colorMix(private_safeLighten, palette.info.main, 0.62));
      setColor(palette.Switch, "successDisabledColor", colorMix(private_safeLighten, palette.success.main, 0.62));
      setColor(palette.Switch, "warningDisabledColor", colorMix(private_safeLighten, palette.warning.main, 0.62));
      setColor(palette.TableCell, "border", colorMix(private_safeLighten, colorMix(private_safeAlpha, palette.divider, 1), 0.88));
      setColor(palette.Tooltip, "bg", colorMix(private_safeAlpha, palette.grey[700], 0.92));
    }
    if (palette.mode === "dark") {
      setColor(palette.Alert, "errorColor", colorMix(private_safeLighten, palette.error.light, 0.6));
      setColor(palette.Alert, "infoColor", colorMix(private_safeLighten, palette.info.light, 0.6));
      setColor(palette.Alert, "successColor", colorMix(private_safeLighten, palette.success.light, 0.6));
      setColor(palette.Alert, "warningColor", colorMix(private_safeLighten, palette.warning.light, 0.6));
      setColor(palette.Alert, "errorFilledBg", setCssVarColor("palette-error-dark"));
      setColor(palette.Alert, "infoFilledBg", setCssVarColor("palette-info-dark"));
      setColor(palette.Alert, "successFilledBg", setCssVarColor("palette-success-dark"));
      setColor(palette.Alert, "warningFilledBg", setCssVarColor("palette-warning-dark"));
      setColor(palette.Alert, "errorFilledColor", silent(() => palette.getContrastText(palette.error.dark)));
      setColor(palette.Alert, "infoFilledColor", silent(() => palette.getContrastText(palette.info.dark)));
      setColor(palette.Alert, "successFilledColor", silent(() => palette.getContrastText(palette.success.dark)));
      setColor(palette.Alert, "warningFilledColor", silent(() => palette.getContrastText(palette.warning.dark)));
      setColor(palette.Alert, "errorStandardBg", colorMix(private_safeDarken, palette.error.light, 0.9));
      setColor(palette.Alert, "infoStandardBg", colorMix(private_safeDarken, palette.info.light, 0.9));
      setColor(palette.Alert, "successStandardBg", colorMix(private_safeDarken, palette.success.light, 0.9));
      setColor(palette.Alert, "warningStandardBg", colorMix(private_safeDarken, palette.warning.light, 0.9));
      setColor(palette.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successIconColor", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
      setColor(palette.AppBar, "defaultBg", setCssVarColor("palette-grey-900"));
      setColor(palette.AppBar, "darkBg", setCssVarColor("palette-background-paper"));
      setColor(palette.AppBar, "darkColor", setCssVarColor("palette-text-primary"));
      setColor(palette.Avatar, "defaultBg", setCssVarColor("palette-grey-600"));
      setColor(palette.Button, "inheritContainedBg", setCssVarColor("palette-grey-800"));
      setColor(palette.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultBorder", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-300"));
      setColor(palette.Chip, "defaultIconColor", setCssVarColor("palette-grey-300"));
      setColor(palette.FilledInput, "bg", "rgba(255, 255, 255, 0.09)");
      setColor(palette.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)");
      setColor(palette.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)");
      setColor(palette.LinearProgress, "primaryBg", colorMix(private_safeDarken, palette.primary.main, 0.5));
      setColor(palette.LinearProgress, "secondaryBg", colorMix(private_safeDarken, palette.secondary.main, 0.5));
      setColor(palette.LinearProgress, "errorBg", colorMix(private_safeDarken, palette.error.main, 0.5));
      setColor(palette.LinearProgress, "infoBg", colorMix(private_safeDarken, palette.info.main, 0.5));
      setColor(palette.LinearProgress, "successBg", colorMix(private_safeDarken, palette.success.main, 0.5));
      setColor(palette.LinearProgress, "warningBg", colorMix(private_safeDarken, palette.warning.main, 0.5));
      setColor(palette.Skeleton, "bg", colorSpace ? colorMix(private_safeAlpha, palette.text.primary, 0.13) : `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.13)`);
      setColor(palette.Slider, "primaryTrack", colorMix(private_safeDarken, palette.primary.main, 0.5));
      setColor(palette.Slider, "secondaryTrack", colorMix(private_safeDarken, palette.secondary.main, 0.5));
      setColor(palette.Slider, "errorTrack", colorMix(private_safeDarken, palette.error.main, 0.5));
      setColor(palette.Slider, "infoTrack", colorMix(private_safeDarken, palette.info.main, 0.5));
      setColor(palette.Slider, "successTrack", colorMix(private_safeDarken, palette.success.main, 0.5));
      setColor(palette.Slider, "warningTrack", colorMix(private_safeDarken, palette.warning.main, 0.5));
      const snackbarContentBackground = colorSpace ? colorMix(private_safeLighten, palette.background.default, 0.985) : private_safeEmphasize(palette.background.default, 0.98);
      setColor(palette.SnackbarContent, "bg", snackbarContentBackground);
      setColor(palette.SnackbarContent, "color", silent(() => colorSpace ? light.text.primary : palette.getContrastText(snackbarContentBackground)));
      setColor(palette.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette.background.paper, 0.15));
      setColor(palette.StepConnector, "border", setCssVarColor("palette-grey-600"));
      setColor(palette.StepContent, "border", setCssVarColor("palette-grey-600"));
      setColor(palette.Switch, "defaultColor", setCssVarColor("palette-grey-300"));
      setColor(palette.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-600"));
      setColor(palette.Switch, "primaryDisabledColor", colorMix(private_safeDarken, palette.primary.main, 0.55));
      setColor(palette.Switch, "secondaryDisabledColor", colorMix(private_safeDarken, palette.secondary.main, 0.55));
      setColor(palette.Switch, "errorDisabledColor", colorMix(private_safeDarken, palette.error.main, 0.55));
      setColor(palette.Switch, "infoDisabledColor", colorMix(private_safeDarken, palette.info.main, 0.55));
      setColor(palette.Switch, "successDisabledColor", colorMix(private_safeDarken, palette.success.main, 0.55));
      setColor(palette.Switch, "warningDisabledColor", colorMix(private_safeDarken, palette.warning.main, 0.55));
      setColor(palette.TableCell, "border", colorMix(private_safeDarken, colorMix(private_safeAlpha, palette.divider, 1), 0.68));
      setColor(palette.Tooltip, "bg", colorMix(private_safeAlpha, palette.grey[700], 0.92));
    }
    setColorChannel(palette.background, "default");
    setColorChannel(palette.background, "paper");
    setColorChannel(palette.common, "background");
    setColorChannel(palette.common, "onBackground");
    setColorChannel(palette, "divider");
    Object.keys(palette).forEach((color2) => {
      const colors = palette[color2];
      if (color2 !== "tonalOffset" && colors && typeof colors === "object") {
        if (colors.main) {
          setColor(palette[color2], "mainChannel", private_safeColorChannel(toRgb(colors.main)));
        }
        if (colors.light) {
          setColor(palette[color2], "lightChannel", private_safeColorChannel(toRgb(colors.light)));
        }
        if (colors.dark) {
          setColor(palette[color2], "darkChannel", private_safeColorChannel(toRgb(colors.dark)));
        }
        if (colors.contrastText) {
          setColor(palette[color2], "contrastTextChannel", private_safeColorChannel(toRgb(colors.contrastText)));
        }
        if (color2 === "text") {
          setColorChannel(palette[color2], "primary");
          setColorChannel(palette[color2], "secondary");
        }
        if (color2 === "action") {
          if (colors.active) {
            setColorChannel(palette[color2], "active");
          }
          if (colors.selected) {
            setColorChannel(palette[color2], "selected");
          }
        }
      }
    });
  });
  theme2 = args.reduce((acc, argument) => deepmerge(acc, argument), theme2);
  const parserConfig = {
    prefix: cssVarPrefix,
    disableCssColorScheme,
    shouldSkipGeneratingVar: shouldSkipGeneratingVar$1,
    getSelector: defaultGetSelector(theme2),
    enableContrastVars: nativeColor
  };
  const {
    vars,
    generateThemeVars,
    generateStyleSheets
  } = prepareCssVars(theme2, parserConfig);
  theme2.vars = vars;
  Object.entries(theme2.colorSchemes[theme2.defaultColorScheme]).forEach(([key, value]) => {
    theme2[key] = value;
  });
  theme2.generateThemeVars = generateThemeVars;
  theme2.generateStyleSheets = generateStyleSheets;
  theme2.generateSpacing = function generateSpacing() {
    return createSpacing(input.spacing, createUnarySpacing(this));
  };
  theme2.getColorSchemeSelector = createGetColorSchemeSelector(selector);
  theme2.spacing = theme2.generateSpacing();
  theme2.shouldSkipGeneratingVar = shouldSkipGeneratingVar$1;
  theme2.unstable_sxConfig = __spreadValues(__spreadValues({}, defaultSxConfig), input == null ? void 0 : input.unstable_sxConfig);
  theme2.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  theme2.toRuntimeSource = stringifyTheme;
  return theme2;
}
function attachColorScheme(theme2, scheme, colorScheme) {
  if (!theme2.colorSchemes) {
    return void 0;
  }
  if (colorScheme) {
    theme2.colorSchemes[scheme] = __spreadProps(__spreadValues({}, colorScheme !== true && colorScheme), {
      palette: createPalette(__spreadProps(__spreadValues({}, colorScheme === true ? {} : colorScheme.palette), {
        mode: scheme
      }))
      // cast type to skip module augmentation test
    });
  }
}
function createTheme(options = {}, ...args) {
  const _a2 = options, {
    palette,
    cssVariables = false,
    colorSchemes: initialColorSchemes = !palette ? {
      light: true
    } : void 0,
    defaultColorScheme: initialDefaultColorScheme = palette == null ? void 0 : palette.mode
  } = _a2, other = __objRest(_a2, [
    "palette",
    "cssVariables",
    "colorSchemes",
    "defaultColorScheme"
  ]);
  const defaultColorSchemeInput = initialDefaultColorScheme || "light";
  const defaultScheme = initialColorSchemes == null ? void 0 : initialColorSchemes[defaultColorSchemeInput];
  const colorSchemesInput = __spreadValues(__spreadValues({}, initialColorSchemes), palette ? {
    [defaultColorSchemeInput]: __spreadProps(__spreadValues({}, typeof defaultScheme !== "boolean" && defaultScheme), {
      palette
    })
  } : void 0);
  if (cssVariables === false) {
    if (!("colorSchemes" in options)) {
      return createThemeNoVars(options, ...args);
    }
    let paletteOptions = palette;
    if (!("palette" in options)) {
      if (colorSchemesInput[defaultColorSchemeInput]) {
        if (colorSchemesInput[defaultColorSchemeInput] !== true) {
          paletteOptions = colorSchemesInput[defaultColorSchemeInput].palette;
        } else if (defaultColorSchemeInput === "dark") {
          paletteOptions = {
            mode: "dark"
          };
        }
      }
    }
    const theme2 = createThemeNoVars(__spreadProps(__spreadValues({}, options), {
      palette: paletteOptions
    }), ...args);
    theme2.defaultColorScheme = defaultColorSchemeInput;
    theme2.colorSchemes = colorSchemesInput;
    if (theme2.palette.mode === "light") {
      theme2.colorSchemes.light = __spreadProps(__spreadValues({}, colorSchemesInput.light !== true && colorSchemesInput.light), {
        palette: theme2.palette
      });
      attachColorScheme(theme2, "dark", colorSchemesInput.dark);
    }
    if (theme2.palette.mode === "dark") {
      theme2.colorSchemes.dark = __spreadProps(__spreadValues({}, colorSchemesInput.dark !== true && colorSchemesInput.dark), {
        palette: theme2.palette
      });
      attachColorScheme(theme2, "light", colorSchemesInput.light);
    }
    return theme2;
  }
  if (!palette && !("light" in colorSchemesInput) && defaultColorSchemeInput === "light") {
    colorSchemesInput.light = true;
  }
  return createThemeWithVars(__spreadValues(__spreadProps(__spreadValues({}, other), {
    colorSchemes: colorSchemesInput,
    defaultColorScheme: defaultColorSchemeInput
  }), typeof cssVariables !== "boolean" && cssVariables), ...args);
}
const defaultTheme$1 = createTheme();
function useTheme() {
  const theme2 = useTheme$2(defaultTheme$1);
  return theme2[THEME_ID] || theme2;
}
function slotShouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
const rootShouldForwardProp = (prop) => slotShouldForwardProp(prop) && prop !== "classes";
const styled = createStyled2({
  themeId: THEME_ID,
  defaultTheme: defaultTheme$1,
  rootShouldForwardProp
});
function ThemeProviderNoVars(_c) {
  var _d = _c, {
    theme: themeInput
  } = _d, props = __objRest(_d, [
    "theme"
  ]);
  const scopedTheme = THEME_ID in themeInput ? themeInput[THEME_ID] : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider$1, __spreadProps(__spreadValues({}, props), {
    themeId: scopedTheme ? THEME_ID : void 0,
    theme: scopedTheme || themeInput
  }));
}
const defaultConfig = {
  colorSchemeStorageKey: "mui-color-scheme",
  defaultLightColorScheme: "light",
  defaultDarkColorScheme: "dark",
  modeStorageKey: "mui-mode"
};
const {
  CssVarsProvider: InternalCssVarsProvider
} = createCssVarsProvider({
  themeId: THEME_ID,
  // @ts-ignore ignore module augmentation tests
  theme: () => createTheme({
    cssVariables: true
  }),
  colorSchemeStorageKey: defaultConfig.colorSchemeStorageKey,
  modeStorageKey: defaultConfig.modeStorageKey,
  defaultColorScheme: {
    light: defaultConfig.defaultLightColorScheme,
    dark: defaultConfig.defaultDarkColorScheme
  },
  resolveTheme: (theme2) => {
    const newTheme = __spreadProps(__spreadValues({}, theme2), {
      typography: createTypography(theme2.palette, theme2.typography)
    });
    newTheme.unstable_sx = function sx(props) {
      return styleFunctionSx({
        sx: props,
        theme: this
      });
    };
    return newTheme;
  }
});
const CssVarsProvider = InternalCssVarsProvider;
const React$1M = window["React"];
function ThemeProvider(_e) {
  var _f = _e, {
    theme: theme2
  } = _f, props = __objRest(_f, [
    "theme"
  ]);
  const noVarsTheme = React$1M.useMemo(() => {
    if (typeof theme2 === "function") {
      return theme2;
    }
    const muiTheme = THEME_ID in theme2 ? theme2[THEME_ID] : theme2;
    if (!("colorSchemes" in muiTheme)) {
      if (!("vars" in muiTheme)) {
        return __spreadProps(__spreadValues({}, theme2), {
          vars: null
        });
      }
      return theme2;
    }
    return null;
  }, [theme2]);
  if (noVarsTheme) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProviderNoVars, __spreadValues({
      theme: noVarsTheme
    }, props));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CssVarsProvider, __spreadValues({
    theme: theme2
  }, props));
}
function createChainedFunction(...funcs) {
  return funcs.reduce((acc, func) => {
    if (func == null) {
      return acc;
    }
    return function chainedFunction(...args) {
      acc.apply(this, args);
      func.apply(this, args);
    };
  }, () => {
  });
}
function GlobalStyles$1(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$2, __spreadProps(__spreadValues({}, props), {
    defaultTheme: defaultTheme$1,
    themeId: THEME_ID
  }));
}
function globalCss(styles2) {
  return function GlobalStylesWrapper(props) {
    return (
      // Pigment CSS `globalCss` support callback with theme inside an object but `GlobalStyles` support theme as a callback value.
      /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$1, {
        styles: typeof styles2 === "function" ? (theme2) => styles2(__spreadValues({
          theme: theme2
        }, props)) : styles2
      })
    );
  };
}
function internal_createExtendSxProp() {
  return extendSxProp$1;
}
const memoTheme = unstable_memoTheme;
function useDefaultProps(params) {
  return useDefaultProps$1(params);
}
function getSvgIconUtilityClass(slot) {
  return generateUtilityClass("MuiSvgIcon", slot);
}
generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const React$1L = window["React"];
const useUtilityClasses$11 = (ownerState) => {
  const {
    color: color2,
    fontSize,
    classes
  } = ownerState;
  const slots = {
    root: ["root", color2 !== "inherit" && `color${capitalize(color2)}`, `fontSize${capitalize(fontSize)}`]
  };
  return composeClasses(slots, getSvgIconUtilityClass, classes);
};
const SvgIconRoot = styled("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "inherit" && styles2[`color${capitalize(ownerState.color)}`], styles2[`fontSize${capitalize(ownerState.fontSize)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
  return {
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    flexShrink: 0,
    transition: (_e = (_a2 = theme2.transitions) == null ? void 0 : _a2.create) == null ? void 0 : _e.call(_a2, "fill", {
      duration: (_d = (_c = ((_b = theme2.vars) != null ? _b : theme2).transitions) == null ? void 0 : _c.duration) == null ? void 0 : _d.shorter
    }),
    variants: [
      {
        props: (props) => !props.hasSvgAsChild,
        style: {
          // the <svg> will define the property that has `currentColor`
          // for example heroicons uses fill="none" and stroke="currentColor"
          fill: "currentColor"
        }
      },
      {
        props: {
          fontSize: "inherit"
        },
        style: {
          fontSize: "inherit"
        }
      },
      {
        props: {
          fontSize: "small"
        },
        style: {
          fontSize: ((_g = (_f = theme2.typography) == null ? void 0 : _f.pxToRem) == null ? void 0 : _g.call(_f, 20)) || "1.25rem"
        }
      },
      {
        props: {
          fontSize: "medium"
        },
        style: {
          fontSize: ((_i = (_h = theme2.typography) == null ? void 0 : _h.pxToRem) == null ? void 0 : _i.call(_h, 24)) || "1.5rem"
        }
      },
      {
        props: {
          fontSize: "large"
        },
        style: {
          fontSize: ((_k = (_j = theme2.typography) == null ? void 0 : _j.pxToRem) == null ? void 0 : _k.call(_j, 35)) || "2.1875rem"
        }
      },
      // TODO v5 deprecate color prop, v6 remove for sx
      ...Object.entries(((_l = theme2.vars) != null ? _l : theme2).palette).filter(([, value]) => value && value.main).map(([color2]) => {
        var _a3, _b2, _c2;
        return {
          props: {
            color: color2
          },
          style: {
            color: (_c2 = (_b2 = ((_a3 = theme2.vars) != null ? _a3 : theme2).palette) == null ? void 0 : _b2[color2]) == null ? void 0 : _c2.main
          }
        };
      }),
      {
        props: {
          color: "action"
        },
        style: {
          color: (_o = (_n = ((_m = theme2.vars) != null ? _m : theme2).palette) == null ? void 0 : _n.action) == null ? void 0 : _o.active
        }
      },
      {
        props: {
          color: "disabled"
        },
        style: {
          color: (_r = (_q = ((_p = theme2.vars) != null ? _p : theme2).palette) == null ? void 0 : _q.action) == null ? void 0 : _r.disabled
        }
      },
      {
        props: {
          color: "inherit"
        },
        style: {
          color: void 0
        }
      }
    ]
  };
}));
const SvgIcon = /* @__PURE__ */ React$1L.forwardRef(function SvgIcon2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSvgIcon"
  });
  const _a2 = props, {
    children,
    className,
    color: color2 = "inherit",
    component = "svg",
    fontSize = "medium",
    htmlColor,
    inheritViewBox = false,
    titleAccess,
    viewBox = "0 0 24 24"
  } = _a2, other = __objRest(_a2, [
    "children",
    "className",
    "color",
    "component",
    "fontSize",
    "htmlColor",
    "inheritViewBox",
    "titleAccess",
    "viewBox"
  ]);
  const hasSvgAsChild = /* @__PURE__ */ React$1L.isValidElement(children) && children.type === "svg";
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: color2,
    component,
    fontSize,
    instanceFontSize: inProps.fontSize,
    inheritViewBox,
    viewBox,
    hasSvgAsChild
  });
  const more = {};
  if (!inheritViewBox) {
    more.viewBox = viewBox;
  }
  const classes = useUtilityClasses$11(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SvgIconRoot, __spreadProps(__spreadValues(__spreadValues(__spreadValues({
    as: component,
    className: clsx(classes.root, className),
    focusable: "false",
    color: htmlColor,
    "aria-hidden": titleAccess ? void 0 : true,
    role: titleAccess ? "img" : void 0,
    ref
  }, more), other), hasSvgAsChild && children.props), {
    ownerState,
    children: [hasSvgAsChild ? children.props.children : children, titleAccess ? /* @__PURE__ */ jsxRuntimeExports.jsx("title", {
      children: titleAccess
    }) : null]
  }));
});
SvgIcon.muiName = "SvgIcon";
const React$1K = window["React"];
function createSvgIcon(path, displayName) {
  function Component(props, ref) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgIcon, __spreadProps(__spreadValues({
      "data-testid": void 0,
      ref
    }, props), {
      children: path
    }));
  }
  Component.muiName = SvgIcon.muiName;
  return /* @__PURE__ */ React$1K.memo(/* @__PURE__ */ React$1K.forwardRef(Component));
}
function debounce$1(func, wait = 166) {
  let timeout;
  function debounced(...args) {
    const later = () => {
      func.apply(this, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  }
  debounced.clear = () => {
    clearTimeout(timeout);
  };
  return debounced;
}
function ownerDocument(node2) {
  return node2 && node2.ownerDocument || document;
}
function ownerWindow(node2) {
  const doc = ownerDocument(node2);
  return doc.defaultView || window;
}
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}
const React$1J = window["React"];
function useControlled(props) {
  const {
    controlled,
    default: defaultProp,
    name: name2,
    state = "value"
  } = props;
  const {
    current: isControlled
  } = React$1J.useRef(controlled !== void 0);
  const [valueState, setValue] = React$1J.useState(defaultProp);
  const value = isControlled ? controlled : valueState;
  const setValueIfUncontrolled = React$1J.useCallback((newValue) => {
    if (!isControlled) {
      setValue(newValue);
    }
  }, []);
  return [value, setValueIfUncontrolled];
}
const React$1I = window["React"];
function useEventCallback(fn2) {
  const ref = React$1I.useRef(fn2);
  useEnhancedEffect(() => {
    ref.current = fn2;
  });
  return React$1I.useRef((...args) => (
    // @ts-expect-error hide `this`
    (0, ref.current)(...args)
  )).current;
}
const React$1H = window["React"];
function useForkRef(...refs) {
  const cleanupRef = React$1H.useRef(void 0);
  const refEffect = React$1H.useCallback((instance) => {
    const cleanups = refs.map((ref) => {
      if (ref == null) {
        return null;
      }
      if (typeof ref === "function") {
        const refCallback = ref;
        const refCleanup = refCallback(instance);
        return typeof refCleanup === "function" ? refCleanup : () => {
          refCallback(null);
        };
      }
      ref.current = instance;
      return () => {
        ref.current = null;
      };
    });
    return () => {
      cleanups.forEach((refCleanup) => refCleanup == null ? void 0 : refCleanup());
    };
  }, refs);
  return React$1H.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (value) => {
      if (cleanupRef.current) {
        cleanupRef.current();
        cleanupRef.current = void 0;
      }
      if (value != null) {
        cleanupRef.current = refEffect(value);
      }
    };
  }, refs);
}
function isEventHandler(key, value) {
  const thirdCharCode = key.charCodeAt(2);
  return key[0] === "o" && key[1] === "n" && thirdCharCode >= 65 && thirdCharCode <= 90 && typeof value === "function";
}
function mergeSlotProps$1(externalSlotProps, defaultSlotProps) {
  if (!externalSlotProps) {
    return defaultSlotProps;
  }
  function extractHandlers(externalSlotPropsValue, defaultSlotPropsValue) {
    const handlers2 = {};
    Object.keys(defaultSlotPropsValue).forEach((key) => {
      if (isEventHandler(key, defaultSlotPropsValue[key]) && typeof externalSlotPropsValue[key] === "function") {
        handlers2[key] = (...args) => {
          externalSlotPropsValue[key](...args);
          defaultSlotPropsValue[key](...args);
        };
      }
    });
    return handlers2;
  }
  if (typeof externalSlotProps === "function" || typeof defaultSlotProps === "function") {
    return (ownerState) => {
      const defaultSlotPropsValue = typeof defaultSlotProps === "function" ? defaultSlotProps(ownerState) : defaultSlotProps;
      const externalSlotPropsValue = typeof externalSlotProps === "function" ? externalSlotProps(__spreadValues(__spreadValues({}, ownerState), defaultSlotPropsValue)) : externalSlotProps;
      const className2 = clsx(ownerState == null ? void 0 : ownerState.className, defaultSlotPropsValue == null ? void 0 : defaultSlotPropsValue.className, externalSlotPropsValue == null ? void 0 : externalSlotPropsValue.className);
      const handlers2 = extractHandlers(externalSlotPropsValue, defaultSlotPropsValue);
      return __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, defaultSlotPropsValue), externalSlotPropsValue), handlers2), !!className2 && {
        className: className2
      }), (defaultSlotPropsValue == null ? void 0 : defaultSlotPropsValue.style) && (externalSlotPropsValue == null ? void 0 : externalSlotPropsValue.style) && {
        style: __spreadValues(__spreadValues({}, defaultSlotPropsValue.style), externalSlotPropsValue.style)
      }), (defaultSlotPropsValue == null ? void 0 : defaultSlotPropsValue.sx) && (externalSlotPropsValue == null ? void 0 : externalSlotPropsValue.sx) && {
        sx: [...Array.isArray(defaultSlotPropsValue.sx) ? defaultSlotPropsValue.sx : [defaultSlotPropsValue.sx], ...Array.isArray(externalSlotPropsValue.sx) ? externalSlotPropsValue.sx : [externalSlotPropsValue.sx]]
      });
    };
  }
  const typedDefaultSlotProps = defaultSlotProps;
  const handlers = extractHandlers(externalSlotProps, typedDefaultSlotProps);
  const className = clsx(typedDefaultSlotProps == null ? void 0 : typedDefaultSlotProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
  return __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, defaultSlotProps), externalSlotProps), handlers), !!className && {
    className
  }), (typedDefaultSlotProps == null ? void 0 : typedDefaultSlotProps.style) && (externalSlotProps == null ? void 0 : externalSlotProps.style) && {
    style: __spreadValues(__spreadValues({}, typedDefaultSlotProps.style), externalSlotProps.style)
  }), (typedDefaultSlotProps == null ? void 0 : typedDefaultSlotProps.sx) && (externalSlotProps == null ? void 0 : externalSlotProps.sx) && {
    sx: [...Array.isArray(typedDefaultSlotProps.sx) ? typedDefaultSlotProps.sx : [typedDefaultSlotProps.sx], ...Array.isArray(externalSlotProps.sx) ? externalSlotProps.sx : [externalSlotProps.sx]]
  });
}
function _objectWithoutPropertiesLoose(r2, e) {
  if (null == r2) return {};
  var t = {};
  for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r2[n];
  }
  return t;
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, _setPrototypeOf(t, e);
}
function _inheritsLoose(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
}
const config = {
  disabled: false
};
const React$1G = window["React"];
const TransitionGroupContext = React$1G.createContext(null);
var forceReflow = function forceReflow2(node2) {
  return node2.scrollTop;
};
const React$1F = window["React"];
const ReactDOM$2 = window["ReactDOM"];
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = /* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number") {
      exit = timeout2.exit;
      enter = timeout2.enter;
      appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM$2.findDOMNode(this);
          if (node2) forceReflow(node2);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM$2.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM$2.findDOMNode(this);
    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM$2.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node2 || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ React$1F.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === "function" ? children(status, childProps) : React$1F.cloneElement(React$1F.Children.only(children), childProps))
    );
  };
  return Transition2;
})(React$1F.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};
function noop$3() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop$3,
  onEntering: noop$3,
  onEntered: noop$3,
  onExit: noop$3,
  onExiting: noop$3,
  onExited: noop$3
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
const Children = window["React"].Children;
const cloneElement = window["React"].cloneElement;
const isValidElement = window["React"].isValidElement;
function getChildMapping(children, mapFn) {
  var mapper = function mapper2(child) {
    return mapFn && isValidElement(child) ? mapFn(child) : child;
  };
  var result = /* @__PURE__ */ Object.create(null);
  if (children) Children.map(children, function(c) {
    return c;
  }).forEach(function(child) {
    result[child.key] = mapper(child);
  });
  return result;
}
function mergeChildMappings(prev2, next2) {
  prev2 = prev2 || {};
  next2 = next2 || {};
  function getValueForKey(key) {
    return key in next2 ? next2[key] : prev2[key];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev2) {
    if (prevKey in next2) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i;
  var childMapping = {};
  for (var nextKey in next2) {
    if (nextKeysPending[nextKey]) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }
  return childMapping;
}
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return cloneElement(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function(key) {
    var child = children[key];
    if (!isValidElement(child)) return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = isValidElement(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children[key] = cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children[key] = cloneElement(child, {
        in: false
      });
    } else if (hasNext && hasPrev && isValidElement(prevChild)) {
      children[key] = cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children;
}
const React$1E = window["React"];
var values = Object.values || function(obj) {
  return Object.keys(obj).map(function(k) {
    return obj[k];
  });
};
var defaultProps = {
  component: "div",
  childFactory: function childFactory(child) {
    return child;
  }
};
var TransitionGroup = /* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };
  TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };
  _proto.handleExited = function handleExited(child, node2) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping) return;
    if (child.props.onExited) {
      child.props.onExited(node2);
    }
    if (this.mounted) {
      this.setState(function(state) {
        var children = _extends({}, state.children);
        delete children[child.key];
        return {
          children
        };
      });
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component === null) {
      return /* @__PURE__ */ React$1E.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }
    return /* @__PURE__ */ React$1E.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, /* @__PURE__ */ React$1E.createElement(Component, props, children));
  };
  return TransitionGroup2;
})(React$1E.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps;
const React$1D = window["React"];
const UNINITIALIZED = {};
function useLazyRef(init, initArg) {
  const ref = React$1D.useRef(UNINITIALIZED);
  if (ref.current === UNINITIALIZED) {
    ref.current = init(initArg);
  }
  return ref;
}
const React$1C = window["React"];
const EMPTY = [];
function useOnMount(fn2) {
  React$1C.useEffect(fn2, EMPTY);
}
class Timeout {
  constructor() {
    __publicField(this, "currentId", null);
    __publicField(this, "clear", () => {
      if (this.currentId !== null) {
        clearTimeout(this.currentId);
        this.currentId = null;
      }
    });
    __publicField(this, "disposeEffect", () => {
      return this.clear;
    });
  }
  static create() {
    return new Timeout();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(delay, fn2) {
    this.clear();
    this.currentId = setTimeout(() => {
      this.currentId = null;
      fn2();
    }, delay);
  }
}
function useTimeout() {
  const timeout = useLazyRef(Timeout.create).current;
  useOnMount(timeout.disposeEffect);
  return timeout;
}
const reflow = (node2) => node2.scrollTop;
function getTransitionProps(props, options) {
  var _a2, _b;
  const {
    timeout,
    easing: easing2,
    style: style2 = {}
  } = props;
  return {
    duration: (_a2 = style2.transitionDuration) != null ? _a2 : typeof timeout === "number" ? timeout : timeout[options.mode] || 0,
    easing: (_b = style2.transitionTimingFunction) != null ? _b : typeof easing2 === "object" ? easing2[options.mode] : easing2,
    delay: style2.transitionDelay
  };
}
function getPaperUtilityClass(slot) {
  return generateUtilityClass("MuiPaper", slot);
}
generateUtilityClasses("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const React$1B = window["React"];
const useUtilityClasses$10 = (ownerState) => {
  const {
    square,
    elevation,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, !square && "rounded", variant === "elevation" && `elevation${elevation}`]
  };
  return composeClasses(slots, getPaperUtilityClass, classes);
};
const PaperRoot = styled("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], !ownerState.square && styles2.rounded, ownerState.variant === "elevation" && styles2[`elevation${ownerState.elevation}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  backgroundColor: (theme2.vars || theme2).palette.background.paper,
  color: (theme2.vars || theme2).palette.text.primary,
  transition: theme2.transitions.create("box-shadow"),
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.square,
    style: {
      borderRadius: theme2.shape.borderRadius
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      border: `1px solid ${(theme2.vars || theme2).palette.divider}`
    }
  }, {
    props: {
      variant: "elevation"
    },
    style: {
      boxShadow: "var(--Paper-shadow)",
      backgroundImage: "var(--Paper-overlay)"
    }
  }]
})));
const Paper = /* @__PURE__ */ React$1B.forwardRef(function Paper2(inProps, ref) {
  var _b;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiPaper"
  });
  const theme2 = useTheme();
  const _a2 = props, {
    className,
    component = "div",
    elevation = 1,
    square = false,
    variant = "elevation"
  } = _a2, other = __objRest(_a2, [
    "className",
    "component",
    "elevation",
    "square",
    "variant"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component,
    elevation,
    square,
    variant
  });
  const classes = useUtilityClasses$10(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PaperRoot, __spreadProps(__spreadValues({
    as: component,
    ownerState,
    className: clsx(classes.root, className),
    ref
  }, other), {
    style: __spreadValues(__spreadValues({}, variant === "elevation" && __spreadValues(__spreadValues({
      "--Paper-shadow": (theme2.vars || theme2).shadows[elevation]
    }, theme2.vars && {
      "--Paper-overlay": (_b = theme2.vars.overlays) == null ? void 0 : _b[elevation]
    }), !theme2.vars && theme2.palette.mode === "dark" && {
      "--Paper-overlay": `linear-gradient(${alpha("#fff", getOverlayAlpha(elevation))}, ${alpha("#fff", getOverlayAlpha(elevation))})`
    })), other.style)
  }));
});
function isHostComponent(element) {
  return typeof element === "string";
}
function appendOwnerState(elementType, otherProps, ownerState) {
  if (elementType === void 0 || isHostComponent(elementType)) {
    return otherProps;
  }
  return __spreadProps(__spreadValues({}, otherProps), {
    ownerState: __spreadValues(__spreadValues({}, otherProps.ownerState), ownerState)
  });
}
function resolveComponentProps(componentProps, ownerState, slotState) {
  if (typeof componentProps === "function") {
    return componentProps(ownerState, slotState);
  }
  return componentProps;
}
function extractEventHandlers(object, excludeKeys = []) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function omitEventHandlers(object) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] === "function")).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function mergeSlotProps(parameters) {
  const {
    getSlotProps,
    additionalProps,
    externalSlotProps,
    externalForwardedProps,
    className
  } = parameters;
  if (!getSlotProps) {
    const joinedClasses2 = clsx(additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
    const mergedStyle2 = __spreadValues(__spreadValues(__spreadValues({}, additionalProps == null ? void 0 : additionalProps.style), externalForwardedProps == null ? void 0 : externalForwardedProps.style), externalSlotProps == null ? void 0 : externalSlotProps.style);
    const props2 = __spreadValues(__spreadValues(__spreadValues({}, additionalProps), externalForwardedProps), externalSlotProps);
    if (joinedClasses2.length > 0) {
      props2.className = joinedClasses2;
    }
    if (Object.keys(mergedStyle2).length > 0) {
      props2.style = mergedStyle2;
    }
    return {
      props: props2,
      internalRef: void 0
    };
  }
  const eventHandlers = extractEventHandlers(__spreadValues(__spreadValues({}, externalForwardedProps), externalSlotProps));
  const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
  const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
  const internalSlotProps = getSlotProps(eventHandlers);
  const joinedClasses = clsx(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
  const mergedStyle = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, internalSlotProps == null ? void 0 : internalSlotProps.style), additionalProps == null ? void 0 : additionalProps.style), externalForwardedProps == null ? void 0 : externalForwardedProps.style), externalSlotProps == null ? void 0 : externalSlotProps.style);
  const props = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, internalSlotProps), additionalProps), otherPropsWithoutEventHandlers), componentsPropsWithoutEventHandlers);
  if (joinedClasses.length > 0) {
    props.className = joinedClasses;
  }
  if (Object.keys(mergedStyle).length > 0) {
    props.style = mergedStyle;
  }
  return {
    props,
    internalRef: internalSlotProps.ref
  };
}
function useSlot(name2, parameters) {
  const _a2 = parameters, {
    className,
    elementType: initialElementType,
    ownerState,
    externalForwardedProps,
    internalForwardedProps,
    shouldForwardComponentProp = false
  } = _a2, useSlotPropsParams = __objRest(_a2, [
    "className",
    "elementType",
    "ownerState",
    "externalForwardedProps",
    "internalForwardedProps",
    "shouldForwardComponentProp"
  ]);
  const _b = externalForwardedProps, {
    component: rootComponent,
    slots = {
      [name2]: void 0
    },
    slotProps = {
      [name2]: void 0
    }
  } = _b, other = __objRest(_b, [
    "component",
    "slots",
    "slotProps"
  ]);
  const elementType = slots[name2] || initialElementType;
  const resolvedComponentsProps = resolveComponentProps(slotProps[name2], ownerState);
  const _c = mergeSlotProps(__spreadProps(__spreadValues({
    className
  }, useSlotPropsParams), {
    externalForwardedProps: name2 === "root" ? other : void 0,
    externalSlotProps: resolvedComponentsProps
  })), {
    props: _d
  } = _c, _e = _d, {
    component: slotComponent
  } = _e, mergedProps = __objRest(_e, [
    "component"
  ]), {
    internalRef
  } = _c;
  const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, parameters.ref);
  const LeafComponent = name2 === "root" ? slotComponent || rootComponent : slotComponent;
  const props = appendOwnerState(elementType, __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, name2 === "root" && !rootComponent && !slots[name2] && internalForwardedProps), name2 !== "root" && !slots[name2] && internalForwardedProps), mergedProps), LeafComponent && !shouldForwardComponentProp && {
    as: LeafComponent
  }), LeafComponent && shouldForwardComponentProp && {
    component: LeafComponent
  }), {
    ref
  }), ownerState);
  return [elementType, props];
}
function isFocusVisible(element) {
  try {
    return element.matches(":focus-visible");
  } catch (error) {
  }
  return false;
}
const React$1A = window["React"];
class LazyRipple {
  constructor() {
    __publicField(this, "mountEffect", () => {
      if (this.shouldMount && !this.didMount) {
        if (this.ref.current !== null) {
          this.didMount = true;
          this.mounted.resolve();
        }
      }
    });
    this.ref = {
      current: null
    };
    this.mounted = null;
    this.didMount = false;
    this.shouldMount = false;
    this.setShouldMount = null;
  }
  /** React ref to the ripple instance */
  /** If the ripple component should be mounted */
  /** Promise that resolves when the ripple component is mounted */
  /** If the ripple component has been mounted */
  /** React state hook setter */
  static create() {
    return new LazyRipple();
  }
  static use() {
    const ripple = useLazyRef(LazyRipple.create).current;
    const [shouldMount, setShouldMount] = React$1A.useState(false);
    ripple.shouldMount = shouldMount;
    ripple.setShouldMount = setShouldMount;
    React$1A.useEffect(ripple.mountEffect, [shouldMount]);
    return ripple;
  }
  mount() {
    if (!this.mounted) {
      this.mounted = createControlledPromise();
      this.shouldMount = true;
      this.setShouldMount(this.shouldMount);
    }
    return this.mounted;
  }
  /* Ripple API */
  start(...args) {
    this.mount().then(() => {
      var _a2;
      return (_a2 = this.ref.current) == null ? void 0 : _a2.start(...args);
    });
  }
  stop(...args) {
    this.mount().then(() => {
      var _a2;
      return (_a2 = this.ref.current) == null ? void 0 : _a2.stop(...args);
    });
  }
  pulsate(...args) {
    this.mount().then(() => {
      var _a2;
      return (_a2 = this.ref.current) == null ? void 0 : _a2.pulsate(...args);
    });
  }
}
function useLazyRipple() {
  return LazyRipple.use();
}
function createControlledPromise() {
  let resolve;
  let reject;
  const p = new Promise((resolveFn, rejectFn) => {
    resolve = resolveFn;
    reject = rejectFn;
  });
  p.resolve = resolve;
  p.reject = reject;
  return p;
}
const React$1z = window["React"];
function Ripple(props) {
  const {
    className,
    classes,
    pulsate = false,
    rippleX,
    rippleY,
    rippleSize,
    in: inProp,
    onExited,
    timeout
  } = props;
  const [leaving, setLeaving] = React$1z.useState(false);
  const rippleClassName = clsx(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
  const rippleStyles = {
    width: rippleSize,
    height: rippleSize,
    top: -(rippleSize / 2) + rippleY,
    left: -(rippleSize / 2) + rippleX
  };
  const childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
  if (!inProp && !leaving) {
    setLeaving(true);
  }
  React$1z.useEffect(() => {
    if (!inProp && onExited != null) {
      const timeoutId = setTimeout(onExited, timeout);
      return () => {
        clearTimeout(timeoutId);
      };
    }
    return void 0;
  }, [onExited, inProp, timeout]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
    className: rippleClassName,
    style: rippleStyles,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: childClassName
    })
  });
}
const touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
const React$1y = window["React"];
const DURATION = 550;
const DELAY_RIPPLE = 80;
const enterKeyframe = keyframes`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`;
const exitKeyframe = keyframes`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`;
const pulsateKeyframe = keyframes`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`;
const TouchRippleRoot = styled("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
});
const TouchRippleRipple = styled(Ripple, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})`
  opacity: 0;
  position: absolute;

  &.${touchRippleClasses.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${enterKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${({
  theme: theme2
}) => theme2.transitions.easing.easeInOut};
  }

  &.${touchRippleClasses.ripplePulsate} {
    animation-duration: ${({
  theme: theme2
}) => theme2.transitions.duration.shorter}ms;
  }

  & .${touchRippleClasses.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${touchRippleClasses.childLeaving} {
    opacity: 0;
    animation-name: ${exitKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${({
  theme: theme2
}) => theme2.transitions.easing.easeInOut};
  }

  & .${touchRippleClasses.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${pulsateKeyframe};
    animation-duration: 2500ms;
    animation-timing-function: ${({
  theme: theme2
}) => theme2.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`;
const TouchRipple = /* @__PURE__ */ React$1y.forwardRef(function TouchRipple2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTouchRipple"
  });
  const _a2 = props, {
    center: centerProp = false,
    classes = {},
    className
  } = _a2, other = __objRest(_a2, [
    "center",
    "classes",
    "className"
  ]);
  const [ripples, setRipples] = React$1y.useState([]);
  const nextKey = React$1y.useRef(0);
  const rippleCallback = React$1y.useRef(null);
  React$1y.useEffect(() => {
    if (rippleCallback.current) {
      rippleCallback.current();
      rippleCallback.current = null;
    }
  }, [ripples]);
  const ignoringMouseDown = React$1y.useRef(false);
  const startTimer = useTimeout();
  const startTimerCommit = React$1y.useRef(null);
  const container = React$1y.useRef(null);
  const startCommit = React$1y.useCallback((params) => {
    const {
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize,
      cb
    } = params;
    setRipples((oldRipples) => [...oldRipples, /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRipple, {
      classes: {
        ripple: clsx(classes.ripple, touchRippleClasses.ripple),
        rippleVisible: clsx(classes.rippleVisible, touchRippleClasses.rippleVisible),
        ripplePulsate: clsx(classes.ripplePulsate, touchRippleClasses.ripplePulsate),
        child: clsx(classes.child, touchRippleClasses.child),
        childLeaving: clsx(classes.childLeaving, touchRippleClasses.childLeaving),
        childPulsate: clsx(classes.childPulsate, touchRippleClasses.childPulsate)
      },
      timeout: DURATION,
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize
    }, nextKey.current)]);
    nextKey.current += 1;
    rippleCallback.current = cb;
  }, [classes]);
  const start2 = React$1y.useCallback((event = {}, options = {}, cb = () => {
  }) => {
    const {
      pulsate: pulsate2 = false,
      center = centerProp || options.pulsate,
      fakeElement = false
      // For test purposes
    } = options;
    if ((event == null ? void 0 : event.type) === "mousedown" && ignoringMouseDown.current) {
      ignoringMouseDown.current = false;
      return;
    }
    if ((event == null ? void 0 : event.type) === "touchstart") {
      ignoringMouseDown.current = true;
    }
    const element = fakeElement ? null : container.current;
    const rect = element ? element.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let rippleX;
    let rippleY;
    let rippleSize;
    if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
      rippleX = Math.round(rect.width / 2);
      rippleY = Math.round(rect.height / 2);
    } else {
      const {
        clientX,
        clientY
      } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
      rippleX = Math.round(clientX - rect.left);
      rippleY = Math.round(clientY - rect.top);
    }
    if (center) {
      rippleSize = Math.sqrt((2 * __pow(rect.width, 2) + __pow(rect.height, 2)) / 3);
      if (rippleSize % 2 === 0) {
        rippleSize += 1;
      }
    } else {
      const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
      const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
      rippleSize = Math.sqrt(__pow(sizeX, 2) + __pow(sizeY, 2));
    }
    if (event == null ? void 0 : event.touches) {
      if (startTimerCommit.current === null) {
        startTimerCommit.current = () => {
          startCommit({
            pulsate: pulsate2,
            rippleX,
            rippleY,
            rippleSize,
            cb
          });
        };
        startTimer.start(DELAY_RIPPLE, () => {
          if (startTimerCommit.current) {
            startTimerCommit.current();
            startTimerCommit.current = null;
          }
        });
      }
    } else {
      startCommit({
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize,
        cb
      });
    }
  }, [centerProp, startCommit, startTimer]);
  const pulsate = React$1y.useCallback(() => {
    start2({}, {
      pulsate: true
    });
  }, [start2]);
  const stop = React$1y.useCallback((event, cb) => {
    startTimer.clear();
    if ((event == null ? void 0 : event.type) === "touchend" && startTimerCommit.current) {
      startTimerCommit.current();
      startTimerCommit.current = null;
      startTimer.start(0, () => {
        stop(event, cb);
      });
      return;
    }
    startTimerCommit.current = null;
    setRipples((oldRipples) => {
      if (oldRipples.length > 0) {
        return oldRipples.slice(1);
      }
      return oldRipples;
    });
    rippleCallback.current = cb;
  }, [startTimer]);
  React$1y.useImperativeHandle(ref, () => ({
    pulsate,
    start: start2,
    stop
  }), [pulsate, start2, stop]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRoot, __spreadProps(__spreadValues({
    className: clsx(touchRippleClasses.root, classes.root, className),
    ref: container
  }, other), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionGroup, {
      component: null,
      exit: true,
      children: ripples
    })
  }));
});
function getButtonBaseUtilityClass(slot) {
  return generateUtilityClass("MuiButtonBase", slot);
}
const buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]);
const React$1x = window["React"];
const useUtilityClasses$$ = (ownerState) => {
  const {
    disabled,
    focusVisible,
    focusVisibleClassName,
    classes
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
  };
  const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);
  if (focusVisible && focusVisibleClassName) {
    composedClasses.root += ` ${focusVisibleClassName}`;
  }
  return composedClasses;
};
const ButtonBaseRoot = styled("button", {
  name: "MuiButtonBase",
  slot: "Root"
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${buttonBaseClasses.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
});
const ButtonBase = /* @__PURE__ */ React$1x.forwardRef(function ButtonBase2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiButtonBase"
  });
  const _a2 = props, {
    action,
    centerRipple = false,
    children,
    className,
    component = "button",
    disabled = false,
    disableRipple = false,
    disableTouchRipple = false,
    focusRipple = false,
    focusVisibleClassName,
    LinkComponent = "a",
    onBlur,
    onClick,
    onContextMenu,
    onDragLeave,
    onFocus,
    onFocusVisible,
    onKeyDown,
    onKeyUp,
    onMouseDown,
    onMouseLeave,
    onMouseUp,
    onTouchEnd,
    onTouchMove,
    onTouchStart,
    tabIndex = 0,
    TouchRippleProps,
    touchRippleRef,
    type
  } = _a2, other = __objRest(_a2, [
    "action",
    "centerRipple",
    "children",
    "className",
    "component",
    "disabled",
    "disableRipple",
    "disableTouchRipple",
    "focusRipple",
    "focusVisibleClassName",
    "LinkComponent",
    "onBlur",
    "onClick",
    "onContextMenu",
    "onDragLeave",
    "onFocus",
    "onFocusVisible",
    "onKeyDown",
    "onKeyUp",
    "onMouseDown",
    "onMouseLeave",
    "onMouseUp",
    "onTouchEnd",
    "onTouchMove",
    "onTouchStart",
    "tabIndex",
    "TouchRippleProps",
    "touchRippleRef",
    "type"
  ]);
  const buttonRef = React$1x.useRef(null);
  const ripple = useLazyRipple();
  const handleRippleRef = useForkRef(ripple.ref, touchRippleRef);
  const [focusVisible, setFocusVisible] = React$1x.useState(false);
  if (disabled && focusVisible) {
    setFocusVisible(false);
  }
  React$1x.useImperativeHandle(action, () => ({
    focusVisible: () => {
      setFocusVisible(true);
      buttonRef.current.focus();
    }
  }), []);
  const enableTouchRipple = ripple.shouldMount && !disableRipple && !disabled;
  React$1x.useEffect(() => {
    if (focusVisible && focusRipple && !disableRipple) {
      ripple.pulsate();
    }
  }, [disableRipple, focusRipple, focusVisible, ripple]);
  const handleMouseDown = useRippleHandler(ripple, "start", onMouseDown, disableTouchRipple);
  const handleContextMenu = useRippleHandler(ripple, "stop", onContextMenu, disableTouchRipple);
  const handleDragLeave = useRippleHandler(ripple, "stop", onDragLeave, disableTouchRipple);
  const handleMouseUp = useRippleHandler(ripple, "stop", onMouseUp, disableTouchRipple);
  const handleMouseLeave = useRippleHandler(ripple, "stop", (event) => {
    if (focusVisible) {
      event.preventDefault();
    }
    if (onMouseLeave) {
      onMouseLeave(event);
    }
  }, disableTouchRipple);
  const handleTouchStart = useRippleHandler(ripple, "start", onTouchStart, disableTouchRipple);
  const handleTouchEnd = useRippleHandler(ripple, "stop", onTouchEnd, disableTouchRipple);
  const handleTouchMove = useRippleHandler(ripple, "stop", onTouchMove, disableTouchRipple);
  const handleBlur = useRippleHandler(ripple, "stop", (event) => {
    if (!isFocusVisible(event.target)) {
      setFocusVisible(false);
    }
    if (onBlur) {
      onBlur(event);
    }
  }, false);
  const handleFocus = useEventCallback((event) => {
    if (!buttonRef.current) {
      buttonRef.current = event.currentTarget;
    }
    if (isFocusVisible(event.target)) {
      setFocusVisible(true);
      if (onFocusVisible) {
        onFocusVisible(event);
      }
    }
    if (onFocus) {
      onFocus(event);
    }
  });
  const isNonNativeButton = () => {
    const button = buttonRef.current;
    return component && component !== "button" && !(button.tagName === "A" && button.href);
  };
  const handleKeyDown = useEventCallback((event) => {
    if (focusRipple && !event.repeat && focusVisible && event.key === " ") {
      ripple.stop(event, () => {
        ripple.start(event);
      });
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
      event.preventDefault();
      if (onClick) {
        onClick(event);
      }
    }
  });
  const handleKeyUp = useEventCallback((event) => {
    if (focusRipple && event.key === " " && focusVisible && !event.defaultPrevented) {
      ripple.stop(event, () => {
        ripple.pulsate(event);
      });
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
    if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
      onClick(event);
    }
  });
  let ComponentProp = component;
  if (ComponentProp === "button" && (other.href || other.to)) {
    ComponentProp = LinkComponent;
  }
  const buttonProps = {};
  if (ComponentProp === "button") {
    buttonProps.type = type === void 0 ? "button" : type;
    buttonProps.disabled = disabled;
  } else {
    if (!other.href && !other.to) {
      buttonProps.role = "button";
    }
    if (disabled) {
      buttonProps["aria-disabled"] = disabled;
    }
  }
  const handleRef = useForkRef(ref, buttonRef);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    centerRipple,
    component,
    disabled,
    disableRipple,
    disableTouchRipple,
    focusRipple,
    tabIndex,
    focusVisible
  });
  const classes = useUtilityClasses$$(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonBaseRoot, __spreadProps(__spreadValues(__spreadValues({
    as: ComponentProp,
    className: clsx(classes.root, className),
    ownerState,
    onBlur: handleBlur,
    onClick,
    onContextMenu: handleContextMenu,
    onFocus: handleFocus,
    onKeyDown: handleKeyDown,
    onKeyUp: handleKeyUp,
    onMouseDown: handleMouseDown,
    onMouseLeave: handleMouseLeave,
    onMouseUp: handleMouseUp,
    onDragLeave: handleDragLeave,
    onTouchEnd: handleTouchEnd,
    onTouchMove: handleTouchMove,
    onTouchStart: handleTouchStart,
    ref: handleRef,
    tabIndex: disabled ? -1 : tabIndex,
    type
  }, buttonProps), other), {
    children: [children, enableTouchRipple ? /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRipple, __spreadValues({
      ref: handleRippleRef,
      center: centerRipple
    }, TouchRippleProps)) : null]
  }));
});
function useRippleHandler(ripple, rippleAction, eventCallback, skipRippleAction = false) {
  return useEventCallback((event) => {
    if (eventCallback) {
      eventCallback(event);
    }
    if (!skipRippleAction) {
      ripple[rippleAction](event);
    }
    return true;
  });
}
function hasCorrectMainProperty(obj) {
  return typeof obj.main === "string";
}
function checkSimplePaletteColorValues(obj, additionalPropertiesToCheck = []) {
  if (!hasCorrectMainProperty(obj)) {
    return false;
  }
  for (const value of additionalPropertiesToCheck) {
    if (!obj.hasOwnProperty(value) || typeof obj[value] !== "string") {
      return false;
    }
  }
  return true;
}
function createSimplePaletteValueFilter(additionalPropertiesToCheck = []) {
  return ([, value]) => value && checkSimplePaletteColorValues(value, additionalPropertiesToCheck);
}
function getAlertUtilityClass(slot) {
  return generateUtilityClass("MuiAlert", slot);
}
const alertClasses = generateUtilityClasses("MuiAlert", ["root", "action", "icon", "message", "filled", "colorSuccess", "colorInfo", "colorWarning", "colorError", "filledSuccess", "filledInfo", "filledWarning", "filledError", "outlined", "outlinedSuccess", "outlinedInfo", "outlinedWarning", "outlinedError", "standard", "standardSuccess", "standardInfo", "standardWarning", "standardError"]);
function getCircularProgressUtilityClass(slot) {
  return generateUtilityClass("MuiCircularProgress", slot);
}
generateUtilityClasses("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "track", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);
const React$1w = window["React"];
const SIZE = 44;
const circularRotateKeyframe = keyframes`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`;
const circularDashKeyframe = keyframes`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: -126px;
  }
`;
const rotateAnimation = typeof circularRotateKeyframe !== "string" ? css`
        animation: ${circularRotateKeyframe} 1.4s linear infinite;
      ` : null;
const dashAnimation = typeof circularDashKeyframe !== "string" ? css`
        animation: ${circularDashKeyframe} 1.4s ease-in-out infinite;
      ` : null;
const useUtilityClasses$_ = (ownerState) => {
  const {
    classes,
    variant,
    color: color2,
    disableShrink
  } = ownerState;
  const slots = {
    root: ["root", variant, `color${capitalize(color2)}`],
    svg: ["svg"],
    track: ["track"],
    circle: ["circle", `circle${capitalize(variant)}`, disableShrink && "circleDisableShrink"]
  };
  return composeClasses(slots, getCircularProgressUtilityClass, classes);
};
const CircularProgressRoot = styled("span", {
  name: "MuiCircularProgress",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`color${capitalize(ownerState.color)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  display: "inline-block",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: theme2.transitions.create("transform")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: rotateAnimation || {
      animation: `${circularRotateKeyframe} 1.4s linear infinite`
    }
  }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      color: (theme2.vars || theme2).palette[color2].main
    }
  }))]
})));
const CircularProgressSVG = styled("svg", {
  name: "MuiCircularProgress",
  slot: "Svg"
})({
  display: "block"
  // Keeps the progress centered
});
const CircularProgressCircle = styled("circle", {
  name: "MuiCircularProgress",
  slot: "Circle",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.circle, styles2[`circle${capitalize(ownerState.variant)}`], ownerState.disableShrink && styles2.circleDisableShrink];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  stroke: "currentColor",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: theme2.transitions.create("stroke-dashoffset")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: {
      // Some default value that looks fine waiting for the animation to kicks in.
      strokeDasharray: "80px, 200px",
      strokeDashoffset: 0
      // Add the unit to fix a Edge 16 and below bug.
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.variant === "indeterminate" && !ownerState.disableShrink,
    style: dashAnimation || {
      // At runtime for Pigment CSS, `bufferAnimation` will be null and the generated keyframe will be used.
      animation: `${circularDashKeyframe} 1.4s ease-in-out infinite`
    }
  }]
})));
const CircularProgressTrack = styled("circle", {
  name: "MuiCircularProgress",
  slot: "Track"
})(memoTheme(({
  theme: theme2
}) => ({
  stroke: "currentColor",
  opacity: (theme2.vars || theme2).palette.action.activatedOpacity
})));
const CircularProgress = /* @__PURE__ */ React$1w.forwardRef(function CircularProgress2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCircularProgress"
  });
  const _a2 = props, {
    className,
    color: color2 = "primary",
    disableShrink = false,
    enableTrackSlot = false,
    size = 40,
    style: style2,
    thickness = 3.6,
    value = 0,
    variant = "indeterminate"
  } = _a2, other = __objRest(_a2, [
    "className",
    "color",
    "disableShrink",
    "enableTrackSlot",
    "size",
    "style",
    "thickness",
    "value",
    "variant"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: color2,
    disableShrink,
    size,
    thickness,
    value,
    variant,
    enableTrackSlot
  });
  const classes = useUtilityClasses$_(ownerState);
  const circleStyle = {};
  const rootStyle = {};
  const rootProps = {};
  if (variant === "determinate") {
    const circumference = 2 * Math.PI * ((SIZE - thickness) / 2);
    circleStyle.strokeDasharray = circumference.toFixed(3);
    rootProps["aria-valuenow"] = Math.round(value);
    circleStyle.strokeDashoffset = `${((100 - value) / 100 * circumference).toFixed(3)}px`;
    rootStyle.transform = "rotate(-90deg)";
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressRoot, __spreadProps(__spreadValues(__spreadValues({
    className: clsx(classes.root, className),
    style: __spreadValues(__spreadValues({
      width: size,
      height: size
    }, rootStyle), style2),
    ownerState,
    ref,
    role: "progressbar"
  }, rootProps), other), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CircularProgressSVG, {
      className: classes.svg,
      ownerState,
      viewBox: `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`,
      children: [enableTrackSlot ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressTrack, {
        className: classes.track,
        ownerState,
        cx: SIZE,
        cy: SIZE,
        r: (SIZE - thickness) / 2,
        fill: "none",
        strokeWidth: thickness,
        "aria-hidden": "true"
      }) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCircle, {
        className: classes.circle,
        style: circleStyle,
        ownerState,
        cx: SIZE,
        cy: SIZE,
        r: (SIZE - thickness) / 2,
        fill: "none",
        strokeWidth: thickness
      })]
    })
  }));
});
function getIconButtonUtilityClass(slot) {
  return generateUtilityClass("MuiIconButton", slot);
}
const iconButtonClasses = generateUtilityClasses("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge", "loading", "loadingIndicator", "loadingWrapper"]);
const React$1v = window["React"];
const useUtilityClasses$Z = (ownerState) => {
  const {
    classes,
    disabled,
    color: color2,
    edge,
    size,
    loading
  } = ownerState;
  const slots = {
    root: ["root", loading && "loading", disabled && "disabled", color2 !== "default" && `color${capitalize(color2)}`, edge && `edge${capitalize(edge)}`, `size${capitalize(size)}`],
    loadingIndicator: ["loadingIndicator"],
    loadingWrapper: ["loadingWrapper"]
  };
  return composeClasses(slots, getIconButtonUtilityClass, classes);
};
const IconButtonRoot = styled(ButtonBase, {
  name: "MuiIconButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.loading && styles2.loading, ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`], ownerState.edge && styles2[`edge${capitalize(ownerState.edge)}`], styles2[`size${capitalize(ownerState.size)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  textAlign: "center",
  flex: "0 0 auto",
  fontSize: theme2.typography.pxToRem(24),
  padding: 8,
  borderRadius: "50%",
  color: (theme2.vars || theme2).palette.action.active,
  transition: theme2.transitions.create("background-color", {
    duration: theme2.transitions.duration.shortest
  }),
  variants: [{
    props: (props) => !props.disableRipple,
    style: {
      "--IconButton-hoverBg": theme2.alpha((theme2.vars || theme2).palette.action.active, (theme2.vars || theme2).palette.action.hoverOpacity),
      "&:hover": {
        backgroundColor: "var(--IconButton-hoverBg)",
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }, {
    props: {
      edge: "start"
    },
    style: {
      marginLeft: -12
    }
  }, {
    props: {
      edge: "start",
      size: "small"
    },
    style: {
      marginLeft: -3
    }
  }, {
    props: {
      edge: "end"
    },
    style: {
      marginRight: -12
    }
  }, {
    props: {
      edge: "end",
      size: "small"
    },
    style: {
      marginRight: -3
    }
  }]
})), memoTheme(({
  theme: theme2
}) => ({
  variants: [{
    props: {
      color: "inherit"
    },
    style: {
      color: "inherit"
    }
  }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      color: (theme2.vars || theme2).palette[color2].main
    }
  })), ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      "--IconButton-hoverBg": theme2.alpha((theme2.vars || theme2).palette[color2].main, (theme2.vars || theme2).palette.action.hoverOpacity)
    }
  })), {
    props: {
      size: "small"
    },
    style: {
      padding: 5,
      fontSize: theme2.typography.pxToRem(18)
    }
  }, {
    props: {
      size: "large"
    },
    style: {
      padding: 12,
      fontSize: theme2.typography.pxToRem(28)
    }
  }],
  [`&.${iconButtonClasses.disabled}`]: {
    backgroundColor: "transparent",
    color: (theme2.vars || theme2).palette.action.disabled
  },
  [`&.${iconButtonClasses.loading}`]: {
    color: "transparent"
  }
})));
const IconButtonLoadingIndicator = styled("span", {
  name: "MuiIconButton",
  slot: "LoadingIndicator"
})(({
  theme: theme2
}) => ({
  display: "none",
  position: "absolute",
  visibility: "visible",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  color: (theme2.vars || theme2).palette.action.disabled,
  variants: [{
    props: {
      loading: true
    },
    style: {
      display: "flex"
    }
  }]
}));
const IconButton = /* @__PURE__ */ React$1v.forwardRef(function IconButton2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiIconButton"
  });
  const _a2 = props, {
    edge = false,
    children,
    className,
    color: color2 = "default",
    disabled = false,
    disableFocusRipple = false,
    size = "medium",
    id: idProp,
    loading = null,
    loadingIndicator: loadingIndicatorProp
  } = _a2, other = __objRest(_a2, [
    "edge",
    "children",
    "className",
    "color",
    "disabled",
    "disableFocusRipple",
    "size",
    "id",
    "loading",
    "loadingIndicator"
  ]);
  const loadingId = useId(idProp);
  const loadingIndicator = loadingIndicatorProp != null ? loadingIndicatorProp : /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {
    "aria-labelledby": loadingId,
    color: "inherit",
    size: 16
  });
  const ownerState = __spreadProps(__spreadValues({}, props), {
    edge,
    color: color2,
    disabled,
    disableFocusRipple,
    loading,
    loadingIndicator,
    size
  });
  const classes = useUtilityClasses$Z(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IconButtonRoot, __spreadProps(__spreadValues({
    id: loading ? loadingId : idProp,
    className: clsx(classes.root, className),
    centerRipple: true,
    focusRipple: !disableFocusRipple,
    disabled: disabled || loading,
    ref
  }, other), {
    ownerState,
    children: [typeof loading === "boolean" && // use plain HTML span to minimize the runtime overhead
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: classes.loadingWrapper,
      style: {
        display: "contents"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButtonLoadingIndicator, {
        className: classes.loadingIndicator,
        ownerState,
        children: loading && loadingIndicator
      })
    }), children]
  }));
});
const SuccessOutlinedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z"
}));
const ReportProblemOutlinedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z"
}));
const ErrorOutlineIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
}));
const InfoOutlinedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z"
}));
const ClearIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}));
const React$1u = window["React"];
const useUtilityClasses$Y = (ownerState) => {
  const {
    variant,
    color: color2,
    severity,
    classes
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize(color2 || severity)}`, `${variant}${capitalize(color2 || severity)}`, `${variant}`],
    icon: ["icon"],
    message: ["message"],
    action: ["action"]
  };
  return composeClasses(slots, getAlertUtilityClass, classes);
};
const AlertRoot = styled(Paper, {
  name: "MuiAlert",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize(ownerState.color || ownerState.severity)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => {
  const getColor = theme2.palette.mode === "light" ? theme2.darken : theme2.lighten;
  const getBackgroundColor = theme2.palette.mode === "light" ? theme2.lighten : theme2.darken;
  return __spreadProps(__spreadValues({}, theme2.typography.body2), {
    backgroundColor: "transparent",
    display: "flex",
    padding: "6px 16px",
    variants: [...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["light"])).map(([color2]) => ({
      props: {
        colorSeverity: color2,
        variant: "standard"
      },
      style: {
        color: theme2.vars ? theme2.vars.palette.Alert[`${color2}Color`] : getColor(theme2.palette[color2].light, 0.6),
        backgroundColor: theme2.vars ? theme2.vars.palette.Alert[`${color2}StandardBg`] : getBackgroundColor(theme2.palette[color2].light, 0.9),
        [`& .${alertClasses.icon}`]: theme2.vars ? {
          color: theme2.vars.palette.Alert[`${color2}IconColor`]
        } : {
          color: theme2.palette[color2].main
        }
      }
    })), ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["light"])).map(([color2]) => ({
      props: {
        colorSeverity: color2,
        variant: "outlined"
      },
      style: {
        color: theme2.vars ? theme2.vars.palette.Alert[`${color2}Color`] : getColor(theme2.palette[color2].light, 0.6),
        border: `1px solid ${(theme2.vars || theme2).palette[color2].light}`,
        [`& .${alertClasses.icon}`]: theme2.vars ? {
          color: theme2.vars.palette.Alert[`${color2}IconColor`]
        } : {
          color: theme2.palette[color2].main
        }
      }
    })), ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["dark"])).map(([color2]) => ({
      props: {
        colorSeverity: color2,
        variant: "filled"
      },
      style: __spreadValues({
        fontWeight: theme2.typography.fontWeightMedium
      }, theme2.vars ? {
        color: theme2.vars.palette.Alert[`${color2}FilledColor`],
        backgroundColor: theme2.vars.palette.Alert[`${color2}FilledBg`]
      } : {
        backgroundColor: theme2.palette.mode === "dark" ? theme2.palette[color2].dark : theme2.palette[color2].main,
        color: theme2.palette.getContrastText(theme2.palette[color2].main)
      })
    }))]
  });
}));
const AlertIcon = styled("div", {
  name: "MuiAlert",
  slot: "Icon"
})({
  marginRight: 12,
  padding: "7px 0",
  display: "flex",
  fontSize: 22,
  opacity: 0.9
});
const AlertMessage = styled("div", {
  name: "MuiAlert",
  slot: "Message"
})({
  padding: "8px 0",
  minWidth: 0,
  overflow: "auto"
});
const AlertAction = styled("div", {
  name: "MuiAlert",
  slot: "Action"
})({
  display: "flex",
  alignItems: "flex-start",
  padding: "4px 0 0 16px",
  marginLeft: "auto",
  marginRight: -8
});
const defaultIconMapping = {
  success: /* @__PURE__ */ jsxRuntimeExports.jsx(SuccessOutlinedIcon, {
    fontSize: "inherit"
  }),
  warning: /* @__PURE__ */ jsxRuntimeExports.jsx(ReportProblemOutlinedIcon, {
    fontSize: "inherit"
  }),
  error: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorOutlineIcon, {
    fontSize: "inherit"
  }),
  info: /* @__PURE__ */ jsxRuntimeExports.jsx(InfoOutlinedIcon, {
    fontSize: "inherit"
  })
};
const Alert = /* @__PURE__ */ React$1u.forwardRef(function Alert2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiAlert"
  });
  const _a2 = props, {
    action,
    children,
    className,
    closeText = "Close",
    color: color2,
    components = {},
    componentsProps = {},
    icon,
    iconMapping = defaultIconMapping,
    onClose,
    role = "alert",
    severity = "success",
    slotProps = {},
    slots = {},
    variant = "standard"
  } = _a2, other = __objRest(_a2, [
    "action",
    "children",
    "className",
    "closeText",
    "color",
    "components",
    "componentsProps",
    "icon",
    "iconMapping",
    "onClose",
    "role",
    "severity",
    "slotProps",
    "slots",
    "variant"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: color2,
    severity,
    variant,
    colorSeverity: color2 || severity
  });
  const classes = useUtilityClasses$Y(ownerState);
  const externalForwardedProps = {
    slots: __spreadValues({
      closeButton: components.CloseButton,
      closeIcon: components.CloseIcon
    }, slots),
    slotProps: __spreadValues(__spreadValues({}, componentsProps), slotProps)
  };
  const [RootSlot, rootSlotProps] = useSlot("root", {
    ref,
    shouldForwardComponentProp: true,
    className: clsx(classes.root, className),
    elementType: AlertRoot,
    externalForwardedProps: __spreadValues(__spreadValues({}, externalForwardedProps), other),
    ownerState,
    additionalProps: {
      role,
      elevation: 0
    }
  });
  const [IconSlot, iconSlotProps] = useSlot("icon", {
    className: classes.icon,
    elementType: AlertIcon,
    externalForwardedProps,
    ownerState
  });
  const [MessageSlot, messageSlotProps] = useSlot("message", {
    className: classes.message,
    elementType: AlertMessage,
    externalForwardedProps,
    ownerState
  });
  const [ActionSlot, actionSlotProps] = useSlot("action", {
    className: classes.action,
    elementType: AlertAction,
    externalForwardedProps,
    ownerState
  });
  const [CloseButtonSlot, closeButtonProps] = useSlot("closeButton", {
    elementType: IconButton,
    externalForwardedProps,
    ownerState
  });
  const [CloseIconSlot, closeIconProps] = useSlot("closeIcon", {
    elementType: ClearIcon,
    externalForwardedProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, __spreadProps(__spreadValues({}, rootSlotProps), {
    children: [icon !== false ? /* @__PURE__ */ jsxRuntimeExports.jsx(IconSlot, __spreadProps(__spreadValues({}, iconSlotProps), {
      children: icon || iconMapping[severity] || defaultIconMapping[severity]
    })) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(MessageSlot, __spreadProps(__spreadValues({}, messageSlotProps), {
      children
    })), action != null ? /* @__PURE__ */ jsxRuntimeExports.jsx(ActionSlot, __spreadProps(__spreadValues({}, actionSlotProps), {
      children: action
    })) : null, action == null && onClose ? /* @__PURE__ */ jsxRuntimeExports.jsx(ActionSlot, __spreadProps(__spreadValues({}, actionSlotProps), {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseButtonSlot, __spreadProps(__spreadValues({
        size: "small",
        "aria-label": closeText,
        title: closeText,
        color: "inherit",
        onClick: onClose
      }, closeButtonProps), {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIconSlot, __spreadValues({
          fontSize: "small"
        }, closeIconProps))
      }))
    })) : null]
  }));
});
function getTypographyUtilityClass(slot) {
  return generateUtilityClass("MuiTypography", slot);
}
const typographyClasses = generateUtilityClasses("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
const React$1t = window["React"];
const v6Colors$1 = {
  primary: true,
  secondary: true,
  error: true,
  info: true,
  success: true,
  warning: true,
  textPrimary: true,
  textSecondary: true,
  textDisabled: true
};
const extendSxProp = internal_createExtendSxProp();
const useUtilityClasses$X = (ownerState) => {
  const {
    align,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, ownerState.align !== "inherit" && `align${capitalize(align)}`, gutterBottom && "gutterBottom", noWrap && "noWrap", paragraph && "paragraph"]
  };
  return composeClasses(slots, getTypographyUtilityClass, classes);
};
const TypographyRoot = styled("span", {
  name: "MuiTypography",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.variant && styles2[ownerState.variant], ownerState.align !== "inherit" && styles2[`align${capitalize(ownerState.align)}`], ownerState.noWrap && styles2.noWrap, ownerState.gutterBottom && styles2.gutterBottom, ownerState.paragraph && styles2.paragraph];
  }
})(memoTheme(({
  theme: theme2
}) => {
  var _a2;
  return {
    margin: 0,
    variants: [{
      props: {
        variant: "inherit"
      },
      style: {
        // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
        font: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit"
      }
    }, ...Object.entries(theme2.typography).filter(([variant, value]) => variant !== "inherit" && value && typeof value === "object").map(([variant, value]) => ({
      props: {
        variant
      },
      style: value
    })), ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
      props: {
        color: color2
      },
      style: {
        color: (theme2.vars || theme2).palette[color2].main
      }
    })), ...Object.entries(((_a2 = theme2.palette) == null ? void 0 : _a2.text) || {}).filter(([, value]) => typeof value === "string").map(([color2]) => ({
      props: {
        color: `text${capitalize(color2)}`
      },
      style: {
        color: (theme2.vars || theme2).palette.text[color2]
      }
    })), {
      props: ({
        ownerState
      }) => ownerState.align !== "inherit",
      style: {
        textAlign: "var(--Typography-textAlign)"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.noWrap,
      style: {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.gutterBottom,
      style: {
        marginBottom: "0.35em"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.paragraph,
      style: {
        marginBottom: 16
      }
    }]
  };
}));
const defaultVariantMapping = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  body1: "p",
  body2: "p",
  inherit: "p"
};
const Typography = /* @__PURE__ */ React$1t.forwardRef(function Typography2(inProps, ref) {
  const _a2 = useDefaultProps({
    props: inProps,
    name: "MuiTypography"
  }), {
    color: color2
  } = _a2, themeProps = __objRest(_a2, [
    "color"
  ]);
  const isSxColor = !v6Colors$1[color2];
  const props = extendSxProp(__spreadValues(__spreadValues({}, themeProps), isSxColor && {
    color: color2
  }));
  const _b = props, {
    align = "inherit",
    className,
    component,
    gutterBottom = false,
    noWrap = false,
    paragraph = false,
    variant = "body1",
    variantMapping = defaultVariantMapping
  } = _b, other = __objRest(_b, [
    "align",
    "className",
    "component",
    "gutterBottom",
    "noWrap",
    "paragraph",
    "variant",
    "variantMapping"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    align,
    color: color2,
    className,
    component,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    variantMapping
  });
  const Component = component || (paragraph ? "p" : variantMapping[variant] || defaultVariantMapping[variant]) || "span";
  const classes = useUtilityClasses$X(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TypographyRoot, __spreadProps(__spreadValues({
    as: Component,
    ref,
    className: clsx(classes.root, className)
  }, other), {
    ownerState,
    style: __spreadValues(__spreadValues({}, align !== "inherit" && {
      "--Typography-textAlign": align
    }), other.style)
  }));
});
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node2) {
  if (node2 == null) {
    return window;
  }
  if (node2.toString() !== "[object Window]") {
    var ownerDocument2 = node2.ownerDocument;
    return ownerDocument2 ? ownerDocument2.defaultView || window : window;
  }
  return node2;
}
function isElement(node2) {
  var OwnElement = getWindow(node2).Element;
  return node2 instanceof OwnElement || node2 instanceof Element;
}
function isHTMLElement$1(node2) {
  var OwnElement = getWindow(node2).HTMLElement;
  return node2 instanceof OwnElement || node2 instanceof HTMLElement;
}
function isShadowRoot(node2) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node2).ShadowRoot;
  return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name2) {
    var style2 = state.styles[name2] || {};
    var attributes = state.attributes[name2] || {};
    var element = state.elements[name2];
    if (!isHTMLElement$1(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style2);
    Object.keys(attributes).forEach(function(name3) {
      var value = attributes[name3];
      if (value === false) {
        element.removeAttribute(name3);
      } else {
        element.setAttribute(name3, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name2) {
      var element = state.elements[name2];
      var attributes = state.attributes[name2] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name2) ? state.styles[name2] : initialStyles[name2]);
      var style2 = styleProperties.reduce(function(style3, property) {
        style3[property] = "";
        return style3;
      }, {});
      if (!isHTMLElement$1(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max = Math.max;
var min = Math.min;
var round$1 = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement$1(element)) {
    scaleX = element.offsetWidth > 0 ? round$1(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round$1(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width2 = clientRect.width / scaleX;
  var height2 = clientRect.height / scaleY;
  return {
    width: width2,
    height: height2,
    top: y,
    right: x + width2,
    bottom: y + height2,
    left: x,
    x,
    y
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width2 = element.offsetWidth;
  var height2 = element.offsetHeight;
  if (Math.abs(clientRect.width - width2) <= 1) {
    width2 = clientRect.width;
  }
  if (Math.abs(clientRect.height - height2) <= 1) {
    height2 = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width2,
    height: height2
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next2 = child;
    do {
      if (next2 && parent.isSameNode(next2)) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    } while (next2);
  }
  return false;
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement$1(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement$1(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement$1(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css2 = getComputedStyle(currentNode);
    if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding2, state) {
  padding2 = typeof padding2 === "function" ? padding2(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding2;
  return mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name2 = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name2] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
const arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round$1(x * dpr) / dpr || 0,
    y: round$1(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle(offsetParent).position !== "static" && position2 === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position2
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node2) {
  var win = getWindow(node2);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html2 = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width2 = html2.clientWidth;
  var height2 = html2.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width2 = visualViewport.width;
    height2 = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width: width2,
    height: height2,
    x: x + getWindowScrollBarX(element),
    y
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html2 = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body2 = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width2 = max(html2.scrollWidth, html2.clientWidth, body2 ? body2.scrollWidth : 0, body2 ? body2.clientWidth : 0);
  var height2 = max(html2.scrollHeight, html2.clientHeight, body2 ? body2.scrollHeight : 0, body2 ? body2.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle(body2 || html2).direction === "rtl") {
    x += max(html2.clientWidth, body2 ? body2.clientWidth : 0) - width2;
  }
  return {
    width: width2,
    height: height2,
    x,
    y
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node2) {
  if (["html", "body", "#document"].indexOf(getNodeName(node2)) >= 0) {
    return node2.ownerDocument.body;
  }
  if (isHTMLElement$1(node2) && isScrollParent(node2)) {
    return node2;
  }
  return getScrollParent(getParentNode(node2));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement$1(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding2 = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding2 = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding: padding2
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name2 = _ref.name;
  if (state.modifiersData[name2]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding2 = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding: padding2,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding: padding2
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name2]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
const flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name2 = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name2] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
const hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name2 = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name2] = data;
}
const offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref) {
  var state = _ref.state, name2 = _ref.name;
  state.modifiersData[name2] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    placement: state.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name2 = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding2 = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding: padding2,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$1 = offset2 + overflow[mainSide];
    var max$1 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name2] = data;
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node2) {
  if (node2 === getWindow(node2) || !isHTMLElement$1(node2)) {
    return getWindowScroll(node2);
  } else {
    return getHTMLElementScroll(node2);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round$1(rect.width) / element.offsetWidth || 1;
  var scaleY = round$1(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  var offsetParentIsScaled = isHTMLElement$1(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var DEFAULT_OPTIONS$1 = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS$1 : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS$1, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
          if (state.reset === true) {
            state.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name2 = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name: name2,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name2 = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name: name2,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
function useSlotProps(parameters) {
  var _b;
  const _a2 = parameters, {
    elementType,
    externalSlotProps,
    ownerState,
    skipResolvingSlotProps = false
  } = _a2, other = __objRest(_a2, [
    "elementType",
    "externalSlotProps",
    "ownerState",
    "skipResolvingSlotProps"
  ]);
  const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps(externalSlotProps, ownerState);
  const {
    props: mergedProps,
    internalRef
  } = mergeSlotProps(__spreadProps(__spreadValues({}, other), {
    externalSlotProps: resolvedComponentsProps
  }));
  const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_b = parameters.additionalProps) == null ? void 0 : _b.ref);
  const props = appendOwnerState(elementType, __spreadProps(__spreadValues({}, mergedProps), {
    ref
  }), ownerState);
  return props;
}
const React$1s = window["React"];
function getReactElementRef(element) {
  var _a2;
  if (parseInt(React$1s.version, 10) >= 19) {
    return ((_a2 = element == null ? void 0 : element.props) == null ? void 0 : _a2.ref) || null;
  }
  return (element == null ? void 0 : element.ref) || null;
}
const React$1r = window["React"];
const ReactDOM$1 = window["ReactDOM"];
function getContainer$1(container) {
  return typeof container === "function" ? container() : container;
}
const Portal = /* @__PURE__ */ React$1r.forwardRef(function Portal2(props, forwardedRef) {
  const {
    children,
    container,
    disablePortal = false
  } = props;
  const [mountNode, setMountNode] = React$1r.useState(null);
  const handleRef = useForkRef(/* @__PURE__ */ React$1r.isValidElement(children) ? getReactElementRef(children) : null, forwardedRef);
  useEnhancedEffect(() => {
    if (!disablePortal) {
      setMountNode(getContainer$1(container) || document.body);
    }
  }, [container, disablePortal]);
  useEnhancedEffect(() => {
    if (mountNode && !disablePortal) {
      setRef(forwardedRef, mountNode);
      return () => {
        setRef(forwardedRef, null);
      };
    }
    return void 0;
  }, [forwardedRef, mountNode, disablePortal]);
  if (disablePortal) {
    if (/* @__PURE__ */ React$1r.isValidElement(children)) {
      const newProps = {
        ref: handleRef
      };
      return /* @__PURE__ */ React$1r.cloneElement(children, newProps);
    }
    return children;
  }
  return mountNode ? /* @__PURE__ */ ReactDOM$1.createPortal(children, mountNode) : mountNode;
});
function getPopperUtilityClass(slot) {
  return generateUtilityClass("MuiPopper", slot);
}
generateUtilityClasses("MuiPopper", ["root"]);
const React$1q = window["React"];
function flipPlacement(placement, direction) {
  if (direction === "ltr") {
    return placement;
  }
  switch (placement) {
    case "bottom-end":
      return "bottom-start";
    case "bottom-start":
      return "bottom-end";
    case "top-end":
      return "top-start";
    case "top-start":
      return "top-end";
    default:
      return placement;
  }
}
function resolveAnchorEl$1(anchorEl) {
  return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
function isHTMLElement(element) {
  return element.nodeType !== void 0;
}
const useUtilityClasses$W = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getPopperUtilityClass, classes);
};
const defaultPopperOptions = {};
const PopperTooltip = /* @__PURE__ */ React$1q.forwardRef(function PopperTooltip2(props, forwardedRef) {
  var _b;
  const _a2 = props, {
    anchorEl,
    children,
    direction,
    disablePortal,
    modifiers,
    open,
    placement: initialPlacement,
    popperOptions,
    popperRef: popperRefProp,
    slotProps = {},
    slots = {},
    TransitionProps,
    ownerState: ownerStateProp
  } = _a2, other = __objRest(_a2, [
    "anchorEl",
    "children",
    "direction",
    "disablePortal",
    "modifiers",
    "open",
    "placement",
    "popperOptions",
    "popperRef",
    "slotProps",
    "slots",
    "TransitionProps",
    // @ts-ignore internal logic
    "ownerState"
  ]);
  const tooltipRef = React$1q.useRef(null);
  const ownRef = useForkRef(tooltipRef, forwardedRef);
  const popperRef = React$1q.useRef(null);
  const handlePopperRef = useForkRef(popperRef, popperRefProp);
  const handlePopperRefRef = React$1q.useRef(handlePopperRef);
  useEnhancedEffect(() => {
    handlePopperRefRef.current = handlePopperRef;
  }, [handlePopperRef]);
  React$1q.useImperativeHandle(popperRefProp, () => popperRef.current, []);
  const rtlPlacement = flipPlacement(initialPlacement, direction);
  const [placement, setPlacement] = React$1q.useState(rtlPlacement);
  const [resolvedAnchorElement, setResolvedAnchorElement] = React$1q.useState(resolveAnchorEl$1(anchorEl));
  React$1q.useEffect(() => {
    if (popperRef.current) {
      popperRef.current.forceUpdate();
    }
  });
  React$1q.useEffect(() => {
    if (anchorEl) {
      setResolvedAnchorElement(resolveAnchorEl$1(anchorEl));
    }
  }, [anchorEl]);
  useEnhancedEffect(() => {
    if (!resolvedAnchorElement || !open) {
      return void 0;
    }
    const handlePopperUpdate = (data) => {
      setPlacement(data.placement);
    };
    let popperModifiers = [{
      name: "preventOverflow",
      options: {
        altBoundary: disablePortal
      }
    }, {
      name: "flip",
      options: {
        altBoundary: disablePortal
      }
    }, {
      name: "onUpdate",
      enabled: true,
      phase: "afterWrite",
      fn: ({
        state
      }) => {
        handlePopperUpdate(state);
      }
    }];
    if (modifiers != null) {
      popperModifiers = popperModifiers.concat(modifiers);
    }
    if (popperOptions && popperOptions.modifiers != null) {
      popperModifiers = popperModifiers.concat(popperOptions.modifiers);
    }
    const popper2 = createPopper(resolvedAnchorElement, tooltipRef.current, __spreadProps(__spreadValues({
      placement: rtlPlacement
    }, popperOptions), {
      modifiers: popperModifiers
    }));
    handlePopperRefRef.current(popper2);
    return () => {
      popper2.destroy();
      handlePopperRefRef.current(null);
    };
  }, [resolvedAnchorElement, disablePortal, modifiers, open, popperOptions, rtlPlacement]);
  const childProps = {
    placement
  };
  if (TransitionProps !== null) {
    childProps.TransitionProps = TransitionProps;
  }
  const classes = useUtilityClasses$W(props);
  const Root = (_b = slots.root) != null ? _b : "div";
  const rootProps = useSlotProps({
    elementType: Root,
    externalSlotProps: slotProps.root,
    externalForwardedProps: other,
    additionalProps: {
      role: "tooltip",
      ref: ownRef
    },
    ownerState: props,
    className: classes.root
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root, __spreadProps(__spreadValues({}, rootProps), {
    children: typeof children === "function" ? children(childProps) : children
  }));
});
const Popper$1 = /* @__PURE__ */ React$1q.forwardRef(function Popper2(props, forwardedRef) {
  const _a2 = props, {
    anchorEl,
    children,
    container: containerProp,
    direction = "ltr",
    disablePortal = false,
    keepMounted = false,
    modifiers,
    open,
    placement = "bottom",
    popperOptions = defaultPopperOptions,
    popperRef,
    style: style2,
    transition = false,
    slotProps = {},
    slots = {}
  } = _a2, other = __objRest(_a2, [
    "anchorEl",
    "children",
    "container",
    "direction",
    "disablePortal",
    "keepMounted",
    "modifiers",
    "open",
    "placement",
    "popperOptions",
    "popperRef",
    "style",
    "transition",
    "slotProps",
    "slots"
  ]);
  const [exited, setExited] = React$1q.useState(true);
  const handleEnter = () => {
    setExited(false);
  };
  const handleExited = () => {
    setExited(true);
  };
  if (!keepMounted && !open && (!transition || exited)) {
    return null;
  }
  let container;
  if (containerProp) {
    container = containerProp;
  } else if (anchorEl) {
    const resolvedAnchorEl = resolveAnchorEl$1(anchorEl);
    container = resolvedAnchorEl && isHTMLElement(resolvedAnchorEl) ? ownerDocument(resolvedAnchorEl).body : ownerDocument(null).body;
  }
  const display = !open && keepMounted && (!transition || exited) ? "none" : void 0;
  const transitionProps = transition ? {
    in: open,
    onEnter: handleEnter,
    onExited: handleExited
  } : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
    disablePortal,
    container,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopperTooltip, __spreadProps(__spreadValues({
      anchorEl,
      direction,
      disablePortal,
      modifiers,
      ref: forwardedRef,
      open: transition ? !exited : open,
      placement,
      popperOptions,
      popperRef,
      slotProps,
      slots
    }, other), {
      style: __spreadValues({
        // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
        position: "fixed",
        // Fix Popper.js display issue
        top: 0,
        left: 0,
        display
      }, style2),
      TransitionProps: transitionProps,
      children
    }))
  });
});
const React$1p = window["React"];
const PopperRoot = styled(Popper$1, {
  name: "MuiPopper",
  slot: "Root"
})({});
const Popper = /* @__PURE__ */ React$1p.forwardRef(function Popper22(inProps, ref) {
  var _b;
  const isRtl = useRtl();
  const props = useDefaultProps({
    props: inProps,
    name: "MuiPopper"
  });
  const _a2 = props, {
    anchorEl,
    component,
    components,
    componentsProps,
    container,
    disablePortal,
    keepMounted,
    modifiers,
    open,
    placement,
    popperOptions,
    popperRef,
    transition,
    slots,
    slotProps
  } = _a2, other = __objRest(_a2, [
    "anchorEl",
    "component",
    "components",
    "componentsProps",
    "container",
    "disablePortal",
    "keepMounted",
    "modifiers",
    "open",
    "placement",
    "popperOptions",
    "popperRef",
    "transition",
    "slots",
    "slotProps"
  ]);
  const RootComponent = (_b = slots == null ? void 0 : slots.root) != null ? _b : components == null ? void 0 : components.Root;
  const otherProps = __spreadValues({
    anchorEl,
    container,
    disablePortal,
    keepMounted,
    modifiers,
    open,
    placement,
    popperOptions,
    popperRef,
    transition
  }, other);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperRoot, __spreadProps(__spreadValues({
    as: component,
    direction: isRtl ? "rtl" : "ltr",
    slots: {
      root: RootComponent
    },
    slotProps: slotProps != null ? slotProps : componentsProps
  }, otherProps), {
    ref
  }));
});
const CancelIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"
}));
function getChipUtilityClass(slot) {
  return generateUtilityClass("MuiChip", slot);
}
const chipClasses = generateUtilityClasses("MuiChip", ["root", "sizeSmall", "sizeMedium", "colorDefault", "colorError", "colorInfo", "colorPrimary", "colorSecondary", "colorSuccess", "colorWarning", "disabled", "clickable", "clickableColorPrimary", "clickableColorSecondary", "deletable", "deletableColorPrimary", "deletableColorSecondary", "outlined", "filled", "outlinedPrimary", "outlinedSecondary", "filledPrimary", "filledSecondary", "avatar", "avatarSmall", "avatarMedium", "avatarColorPrimary", "avatarColorSecondary", "icon", "iconSmall", "iconMedium", "iconColorPrimary", "iconColorSecondary", "label", "labelSmall", "labelMedium", "deleteIcon", "deleteIconSmall", "deleteIconMedium", "deleteIconColorPrimary", "deleteIconColorSecondary", "deleteIconOutlinedColorPrimary", "deleteIconOutlinedColorSecondary", "deleteIconFilledColorPrimary", "deleteIconFilledColorSecondary", "focusVisible"]);
const React$1o = window["React"];
const useUtilityClasses$V = (ownerState) => {
  const {
    classes,
    disabled,
    size,
    color: color2,
    iconColor,
    onDelete,
    clickable,
    variant
  } = ownerState;
  const slots = {
    root: ["root", variant, disabled && "disabled", `size${capitalize(size)}`, `color${capitalize(color2)}`, clickable && "clickable", clickable && `clickableColor${capitalize(color2)}`, onDelete && "deletable", onDelete && `deletableColor${capitalize(color2)}`, `${variant}${capitalize(color2)}`],
    label: ["label", `label${capitalize(size)}`],
    avatar: ["avatar", `avatar${capitalize(size)}`, `avatarColor${capitalize(color2)}`],
    icon: ["icon", `icon${capitalize(size)}`, `iconColor${capitalize(iconColor)}`],
    deleteIcon: ["deleteIcon", `deleteIcon${capitalize(size)}`, `deleteIconColor${capitalize(color2)}`, `deleteIcon${capitalize(variant)}Color${capitalize(color2)}`]
  };
  return composeClasses(slots, getChipUtilityClass, classes);
};
const ChipRoot = styled("div", {
  name: "MuiChip",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      color: color2,
      iconColor,
      clickable,
      onDelete,
      size,
      variant
    } = ownerState;
    return [{
      [`& .${chipClasses.avatar}`]: styles2.avatar
    }, {
      [`& .${chipClasses.avatar}`]: styles2[`avatar${capitalize(size)}`]
    }, {
      [`& .${chipClasses.avatar}`]: styles2[`avatarColor${capitalize(color2)}`]
    }, {
      [`& .${chipClasses.icon}`]: styles2.icon
    }, {
      [`& .${chipClasses.icon}`]: styles2[`icon${capitalize(size)}`]
    }, {
      [`& .${chipClasses.icon}`]: styles2[`iconColor${capitalize(iconColor)}`]
    }, {
      [`& .${chipClasses.deleteIcon}`]: styles2.deleteIcon
    }, {
      [`& .${chipClasses.deleteIcon}`]: styles2[`deleteIcon${capitalize(size)}`]
    }, {
      [`& .${chipClasses.deleteIcon}`]: styles2[`deleteIconColor${capitalize(color2)}`]
    }, {
      [`& .${chipClasses.deleteIcon}`]: styles2[`deleteIcon${capitalize(variant)}Color${capitalize(color2)}`]
    }, styles2.root, styles2[`size${capitalize(size)}`], styles2[`color${capitalize(color2)}`], clickable && styles2.clickable, clickable && color2 !== "default" && styles2[`clickableColor${capitalize(color2)})`], onDelete && styles2.deletable, onDelete && color2 !== "default" && styles2[`deletableColor${capitalize(color2)}`], styles2[variant], styles2[`${variant}${capitalize(color2)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => {
  const textColor = theme2.palette.mode === "light" ? theme2.palette.grey[700] : theme2.palette.grey[300];
  return {
    maxWidth: "100%",
    fontFamily: theme2.typography.fontFamily,
    fontSize: theme2.typography.pxToRem(13),
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    height: 32,
    lineHeight: 1.5,
    color: (theme2.vars || theme2).palette.text.primary,
    backgroundColor: (theme2.vars || theme2).palette.action.selected,
    borderRadius: 32 / 2,
    whiteSpace: "nowrap",
    transition: theme2.transitions.create(["background-color", "box-shadow"]),
    // reset cursor explicitly in case ButtonBase is used
    cursor: "unset",
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    textDecoration: "none",
    border: 0,
    // Remove `button` border
    padding: 0,
    // Remove `button` padding
    verticalAlign: "middle",
    boxSizing: "border-box",
    [`&.${chipClasses.disabled}`]: {
      opacity: (theme2.vars || theme2).palette.action.disabledOpacity,
      pointerEvents: "none"
    },
    [`& .${chipClasses.avatar}`]: {
      marginLeft: 5,
      marginRight: -6,
      width: 24,
      height: 24,
      color: theme2.vars ? theme2.vars.palette.Chip.defaultAvatarColor : textColor,
      fontSize: theme2.typography.pxToRem(12)
    },
    [`& .${chipClasses.avatarColorPrimary}`]: {
      color: (theme2.vars || theme2).palette.primary.contrastText,
      backgroundColor: (theme2.vars || theme2).palette.primary.dark
    },
    [`& .${chipClasses.avatarColorSecondary}`]: {
      color: (theme2.vars || theme2).palette.secondary.contrastText,
      backgroundColor: (theme2.vars || theme2).palette.secondary.dark
    },
    [`& .${chipClasses.avatarSmall}`]: {
      marginLeft: 4,
      marginRight: -4,
      width: 18,
      height: 18,
      fontSize: theme2.typography.pxToRem(10)
    },
    [`& .${chipClasses.icon}`]: {
      marginLeft: 5,
      marginRight: -6
    },
    [`& .${chipClasses.deleteIcon}`]: {
      WebkitTapHighlightColor: "transparent",
      color: theme2.alpha((theme2.vars || theme2).palette.text.primary, 0.26),
      fontSize: 22,
      cursor: "pointer",
      margin: "0 5px 0 -6px",
      "&:hover": {
        color: theme2.alpha((theme2.vars || theme2).palette.text.primary, 0.4)
      }
    },
    variants: [{
      props: {
        size: "small"
      },
      style: {
        height: 24,
        [`& .${chipClasses.icon}`]: {
          fontSize: 18,
          marginLeft: 4,
          marginRight: -4
        },
        [`& .${chipClasses.deleteIcon}`]: {
          fontSize: 16,
          marginRight: 4,
          marginLeft: -4
        }
      }
    }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["contrastText"])).map(([color2]) => {
      return {
        props: {
          color: color2
        },
        style: {
          backgroundColor: (theme2.vars || theme2).palette[color2].main,
          color: (theme2.vars || theme2).palette[color2].contrastText,
          [`& .${chipClasses.deleteIcon}`]: {
            color: theme2.alpha((theme2.vars || theme2).palette[color2].contrastText, 0.7),
            "&:hover, &:active": {
              color: (theme2.vars || theme2).palette[color2].contrastText
            }
          }
        }
      };
    }), {
      props: (props) => props.iconColor === props.color,
      style: {
        [`& .${chipClasses.icon}`]: {
          color: theme2.vars ? theme2.vars.palette.Chip.defaultIconColor : textColor
        }
      }
    }, {
      props: (props) => props.iconColor === props.color && props.color !== "default",
      style: {
        [`& .${chipClasses.icon}`]: {
          color: "inherit"
        }
      }
    }, {
      props: {
        onDelete: true
      },
      style: {
        [`&.${chipClasses.focusVisible}`]: {
          backgroundColor: theme2.alpha((theme2.vars || theme2).palette.action.selected, `${(theme2.vars || theme2).palette.action.selectedOpacity} + ${(theme2.vars || theme2).palette.action.focusOpacity}`)
        }
      }
    }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["dark"])).map(([color2]) => {
      return {
        props: {
          color: color2,
          onDelete: true
        },
        style: {
          [`&.${chipClasses.focusVisible}`]: {
            background: (theme2.vars || theme2).palette[color2].dark
          }
        }
      };
    }), {
      props: {
        clickable: true
      },
      style: {
        userSelect: "none",
        WebkitTapHighlightColor: "transparent",
        cursor: "pointer",
        "&:hover": {
          backgroundColor: theme2.alpha((theme2.vars || theme2).palette.action.selected, `${(theme2.vars || theme2).palette.action.selectedOpacity} + ${(theme2.vars || theme2).palette.action.hoverOpacity}`)
        },
        [`&.${chipClasses.focusVisible}`]: {
          backgroundColor: theme2.alpha((theme2.vars || theme2).palette.action.selected, `${(theme2.vars || theme2).palette.action.selectedOpacity} + ${(theme2.vars || theme2).palette.action.focusOpacity}`)
        },
        "&:active": {
          boxShadow: (theme2.vars || theme2).shadows[1]
        }
      }
    }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["dark"])).map(([color2]) => ({
      props: {
        color: color2,
        clickable: true
      },
      style: {
        [`&:hover, &.${chipClasses.focusVisible}`]: {
          backgroundColor: (theme2.vars || theme2).palette[color2].dark
        }
      }
    })), {
      props: {
        variant: "outlined"
      },
      style: {
        backgroundColor: "transparent",
        border: theme2.vars ? `1px solid ${theme2.vars.palette.Chip.defaultBorder}` : `1px solid ${theme2.palette.mode === "light" ? theme2.palette.grey[400] : theme2.palette.grey[700]}`,
        [`&.${chipClasses.clickable}:hover`]: {
          backgroundColor: (theme2.vars || theme2).palette.action.hover
        },
        [`&.${chipClasses.focusVisible}`]: {
          backgroundColor: (theme2.vars || theme2).palette.action.focus
        },
        [`& .${chipClasses.avatar}`]: {
          marginLeft: 4
        },
        [`& .${chipClasses.avatarSmall}`]: {
          marginLeft: 2
        },
        [`& .${chipClasses.icon}`]: {
          marginLeft: 4
        },
        [`& .${chipClasses.iconSmall}`]: {
          marginLeft: 2
        },
        [`& .${chipClasses.deleteIcon}`]: {
          marginRight: 5
        },
        [`& .${chipClasses.deleteIconSmall}`]: {
          marginRight: 3
        }
      }
    }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
      props: {
        variant: "outlined",
        color: color2
      },
      style: {
        color: (theme2.vars || theme2).palette[color2].main,
        border: `1px solid ${theme2.alpha((theme2.vars || theme2).palette[color2].main, 0.7)}`,
        [`&.${chipClasses.clickable}:hover`]: {
          backgroundColor: theme2.alpha((theme2.vars || theme2).palette[color2].main, (theme2.vars || theme2).palette.action.hoverOpacity)
        },
        [`&.${chipClasses.focusVisible}`]: {
          backgroundColor: theme2.alpha((theme2.vars || theme2).palette[color2].main, (theme2.vars || theme2).palette.action.focusOpacity)
        },
        [`& .${chipClasses.deleteIcon}`]: {
          color: theme2.alpha((theme2.vars || theme2).palette[color2].main, 0.7),
          "&:hover, &:active": {
            color: (theme2.vars || theme2).palette[color2].main
          }
        }
      }
    }))]
  };
}));
const ChipLabel = styled("span", {
  name: "MuiChip",
  slot: "Label",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      size
    } = ownerState;
    return [styles2.label, styles2[`label${capitalize(size)}`]];
  }
})({
  overflow: "hidden",
  textOverflow: "ellipsis",
  paddingLeft: 12,
  paddingRight: 12,
  whiteSpace: "nowrap",
  variants: [{
    props: {
      variant: "outlined"
    },
    style: {
      paddingLeft: 11,
      paddingRight: 11
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      paddingLeft: 8,
      paddingRight: 8
    }
  }, {
    props: {
      size: "small",
      variant: "outlined"
    },
    style: {
      paddingLeft: 7,
      paddingRight: 7
    }
  }]
});
function isDeleteKeyboardEvent(keyboardEvent) {
  return keyboardEvent.key === "Backspace" || keyboardEvent.key === "Delete";
}
const Chip = /* @__PURE__ */ React$1o.forwardRef(function Chip2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiChip"
  });
  const _a2 = props, {
    avatar: avatarProp,
    className,
    clickable: clickableProp,
    color: color2 = "default",
    component: ComponentProp,
    deleteIcon: deleteIconProp,
    disabled = false,
    icon: iconProp,
    label,
    onClick,
    onDelete,
    onKeyDown,
    onKeyUp,
    size = "medium",
    variant = "filled",
    tabIndex,
    skipFocusWhenDisabled = false,
    slots: slots = {},
    slotProps = {}
  } = _a2, other = __objRest(_a2, [
    "avatar",
    "className",
    "clickable",
    "color",
    "component",
    "deleteIcon",
    "disabled",
    "icon",
    "label",
    "onClick",
    "onDelete",
    "onKeyDown",
    "onKeyUp",
    "size",
    "variant",
    "tabIndex",
    "skipFocusWhenDisabled",
    // TODO v6: Rename to `focusableWhenDisabled`.
    "slots",
    "slotProps"
  ]);
  const chipRef = React$1o.useRef(null);
  const handleRef = useForkRef(chipRef, ref);
  const handleDeleteIconClick = (event) => {
    event.stopPropagation();
    if (onDelete) {
      onDelete(event);
    }
  };
  const handleKeyDown = (event) => {
    if (event.currentTarget === event.target && isDeleteKeyboardEvent(event)) {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  };
  const handleKeyUp = (event) => {
    if (event.currentTarget === event.target) {
      if (onDelete && isDeleteKeyboardEvent(event)) {
        onDelete(event);
      }
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
  };
  const clickable = clickableProp !== false && onClick ? true : clickableProp;
  const component = clickable || onDelete ? ButtonBase : ComponentProp || "div";
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component,
    disabled,
    size,
    color: color2,
    iconColor: /* @__PURE__ */ React$1o.isValidElement(iconProp) ? iconProp.props.color || color2 : color2,
    onDelete: !!onDelete,
    clickable,
    variant
  });
  const classes = useUtilityClasses$V(ownerState);
  const moreProps = component === ButtonBase ? __spreadValues({
    component: ComponentProp || "div",
    focusVisibleClassName: classes.focusVisible
  }, onDelete && {
    disableRipple: true
  }) : {};
  let deleteIcon = null;
  if (onDelete) {
    deleteIcon = deleteIconProp && /* @__PURE__ */ React$1o.isValidElement(deleteIconProp) ? /* @__PURE__ */ React$1o.cloneElement(deleteIconProp, {
      className: clsx(deleteIconProp.props.className, classes.deleteIcon),
      onClick: handleDeleteIconClick
    }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CancelIcon, {
      className: classes.deleteIcon,
      onClick: handleDeleteIconClick
    });
  }
  let avatar = null;
  if (avatarProp && /* @__PURE__ */ React$1o.isValidElement(avatarProp)) {
    avatar = /* @__PURE__ */ React$1o.cloneElement(avatarProp, {
      className: clsx(classes.avatar, avatarProp.props.className)
    });
  }
  let icon = null;
  if (iconProp && /* @__PURE__ */ React$1o.isValidElement(iconProp)) {
    icon = /* @__PURE__ */ React$1o.cloneElement(iconProp, {
      className: clsx(classes.icon, iconProp.props.className)
    });
  }
  const externalForwardedProps = {
    slots,
    slotProps
  };
  const [RootSlot, rootProps] = useSlot("root", {
    elementType: ChipRoot,
    externalForwardedProps: __spreadValues(__spreadValues({}, externalForwardedProps), other),
    ownerState,
    // The `component` prop is preserved because `Chip` relies on it for internal logic. If `shouldForwardComponentProp` were `false`, `useSlot` would remove the `component` prop, potentially breaking the component's behavior.
    shouldForwardComponentProp: true,
    ref: handleRef,
    className: clsx(classes.root, className),
    additionalProps: __spreadValues({
      disabled: clickable && disabled ? true : void 0,
      tabIndex: skipFocusWhenDisabled && disabled ? -1 : tabIndex
    }, moreProps),
    getSlotProps: (handlers) => __spreadProps(__spreadValues({}, handlers), {
      onClick: (event) => {
        var _a3;
        (_a3 = handlers.onClick) == null ? void 0 : _a3.call(handlers, event);
        onClick == null ? void 0 : onClick(event);
      },
      onKeyDown: (event) => {
        var _a3;
        (_a3 = handlers.onKeyDown) == null ? void 0 : _a3.call(handlers, event);
        handleKeyDown(event);
      },
      onKeyUp: (event) => {
        var _a3;
        (_a3 = handlers.onKeyUp) == null ? void 0 : _a3.call(handlers, event);
        handleKeyUp(event);
      }
    })
  });
  const [LabelSlot, labelProps] = useSlot("label", {
    elementType: ChipLabel,
    externalForwardedProps,
    ownerState,
    className: classes.label
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, __spreadProps(__spreadValues({
    as: component
  }, rootProps), {
    children: [avatar || icon, /* @__PURE__ */ jsxRuntimeExports.jsx(LabelSlot, __spreadProps(__spreadValues({}, labelProps), {
      children: label
    })), deleteIcon]
  }));
});
const React$1n = window["React"];
function getStyleValue(value) {
  return parseInt(value, 10) || 0;
}
const styles$4 = {
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: "hidden",
    // Remove from the content flow
    position: "absolute",
    // Ignore the scrollbar width
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: "translateZ(0)"
  }
};
function isObjectEmpty(object) {
  for (const _ in object) {
    return false;
  }
  return true;
}
function isEmpty$1(obj) {
  return isObjectEmpty(obj) || obj.outerHeightStyle === 0 && !obj.overflowing;
}
const TextareaAutosize = /* @__PURE__ */ React$1n.forwardRef(function TextareaAutosize2(props, forwardedRef) {
  const _a2 = props, {
    onChange,
    maxRows,
    minRows = 1,
    style: style2,
    value
  } = _a2, other = __objRest(_a2, [
    "onChange",
    "maxRows",
    "minRows",
    "style",
    "value"
  ]);
  const {
    current: isControlled
  } = React$1n.useRef(value != null);
  const textareaRef = React$1n.useRef(null);
  const handleRef = useForkRef(forwardedRef, textareaRef);
  const heightRef = React$1n.useRef(null);
  const hiddenTextareaRef = React$1n.useRef(null);
  const calculateTextareaStyles = React$1n.useCallback(() => {
    const textarea = textareaRef.current;
    const hiddenTextarea = hiddenTextareaRef.current;
    if (!textarea || !hiddenTextarea) {
      return void 0;
    }
    const containerWindow = ownerWindow(textarea);
    const computedStyle = containerWindow.getComputedStyle(textarea);
    if (computedStyle.width === "0px") {
      return {
        outerHeightStyle: 0,
        overflowing: false
      };
    }
    hiddenTextarea.style.width = computedStyle.width;
    hiddenTextarea.value = textarea.value || props.placeholder || "x";
    if (hiddenTextarea.value.slice(-1) === "\n") {
      hiddenTextarea.value += " ";
    }
    const boxSizing2 = computedStyle.boxSizing;
    const padding2 = getStyleValue(computedStyle.paddingBottom) + getStyleValue(computedStyle.paddingTop);
    const border2 = getStyleValue(computedStyle.borderBottomWidth) + getStyleValue(computedStyle.borderTopWidth);
    const innerHeight = hiddenTextarea.scrollHeight;
    hiddenTextarea.value = "x";
    const singleRowHeight = hiddenTextarea.scrollHeight;
    let outerHeight = innerHeight;
    if (minRows) {
      outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
    }
    if (maxRows) {
      outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
    }
    outerHeight = Math.max(outerHeight, singleRowHeight);
    const outerHeightStyle = outerHeight + (boxSizing2 === "border-box" ? padding2 + border2 : 0);
    const overflowing = Math.abs(outerHeight - innerHeight) <= 1;
    return {
      outerHeightStyle,
      overflowing
    };
  }, [maxRows, minRows, props.placeholder]);
  const didHeightChange = useEventCallback(() => {
    const textarea = textareaRef.current;
    const textareaStyles = calculateTextareaStyles();
    if (!textarea || !textareaStyles || isEmpty$1(textareaStyles)) {
      return false;
    }
    const outerHeightStyle = textareaStyles.outerHeightStyle;
    return heightRef.current != null && heightRef.current !== outerHeightStyle;
  });
  const syncHeight = React$1n.useCallback(() => {
    const textarea = textareaRef.current;
    const textareaStyles = calculateTextareaStyles();
    if (!textarea || !textareaStyles || isEmpty$1(textareaStyles)) {
      return;
    }
    const outerHeightStyle = textareaStyles.outerHeightStyle;
    if (heightRef.current !== outerHeightStyle) {
      heightRef.current = outerHeightStyle;
      textarea.style.height = `${outerHeightStyle}px`;
    }
    textarea.style.overflow = textareaStyles.overflowing ? "hidden" : "";
  }, [calculateTextareaStyles]);
  const frameRef = React$1n.useRef(-1);
  useEnhancedEffect(() => {
    const debouncedHandleResize = debounce$1(syncHeight);
    const textarea = textareaRef == null ? void 0 : textareaRef.current;
    if (!textarea) {
      return void 0;
    }
    const containerWindow = ownerWindow(textarea);
    containerWindow.addEventListener("resize", debouncedHandleResize);
    let resizeObserver;
    if (typeof ResizeObserver !== "undefined") {
      resizeObserver = new ResizeObserver(() => {
        if (didHeightChange()) {
          resizeObserver.unobserve(textarea);
          cancelAnimationFrame(frameRef.current);
          syncHeight();
          frameRef.current = requestAnimationFrame(() => {
            resizeObserver.observe(textarea);
          });
        }
      });
      resizeObserver.observe(textarea);
    }
    return () => {
      debouncedHandleResize.clear();
      cancelAnimationFrame(frameRef.current);
      containerWindow.removeEventListener("resize", debouncedHandleResize);
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    };
  }, [calculateTextareaStyles, syncHeight, didHeightChange]);
  useEnhancedEffect(() => {
    syncHeight();
  });
  const handleChange = (event) => {
    if (!isControlled) {
      syncHeight();
    }
    const textarea = event.target;
    const countOfCharacters = textarea.value.length;
    const isLastCharacterNewLine = textarea.value.endsWith("\n");
    const isEndOfTheLine = textarea.selectionStart === countOfCharacters;
    if (isLastCharacterNewLine && isEndOfTheLine) {
      textarea.setSelectionRange(countOfCharacters, countOfCharacters);
    }
    if (onChange) {
      onChange(event);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(React$1n.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("textarea", __spreadValues({
      value,
      onChange: handleChange,
      ref: handleRef,
      rows: minRows,
      style: style2
    }, other)), /* @__PURE__ */ jsxRuntimeExports.jsx("textarea", {
      "aria-hidden": true,
      className: props.className,
      readOnly: true,
      ref: hiddenTextareaRef,
      tabIndex: -1,
      style: __spreadProps(__spreadValues(__spreadValues({}, styles$4.shadow), style2), {
        paddingTop: 0,
        paddingBottom: 0
      })
    })]
  });
});
function formControlState({
  props,
  states,
  muiFormControl
}) {
  return states.reduce((acc, state) => {
    acc[state] = props[state];
    if (muiFormControl) {
      if (typeof props[state] === "undefined") {
        acc[state] = muiFormControl[state];
      }
    }
    return acc;
  }, {});
}
const React$1m = window["React"];
const FormControlContext = /* @__PURE__ */ React$1m.createContext(void 0);
const React$1l = window["React"];
function useFormControl() {
  return React$1l.useContext(FormControlContext);
}
function hasValue(value) {
  return value != null && !(Array.isArray(value) && value.length === 0);
}
function isFilled(obj, SSR = false) {
  return obj && (hasValue(obj.value) && obj.value !== "" || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== "");
}
function isAdornedStart(obj) {
  return obj.startAdornment;
}
function getInputBaseUtilityClass(slot) {
  return generateUtilityClass("MuiInputBase", slot);
}
const inputBaseClasses = generateUtilityClasses("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
var _InputGlobalStyles;
const React$1k = window["React"];
const rootOverridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.formControl && styles2.formControl, ownerState.startAdornment && styles2.adornedStart, ownerState.endAdornment && styles2.adornedEnd, ownerState.error && styles2.error, ownerState.size === "small" && styles2.sizeSmall, ownerState.multiline && styles2.multiline, ownerState.color && styles2[`color${capitalize(ownerState.color)}`], ownerState.fullWidth && styles2.fullWidth, ownerState.hiddenLabel && styles2.hiddenLabel];
};
const inputOverridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.input, ownerState.size === "small" && styles2.inputSizeSmall, ownerState.multiline && styles2.inputMultiline, ownerState.type === "search" && styles2.inputTypeSearch, ownerState.startAdornment && styles2.inputAdornedStart, ownerState.endAdornment && styles2.inputAdornedEnd, ownerState.hiddenLabel && styles2.inputHiddenLabel];
};
const useUtilityClasses$U = (ownerState) => {
  const {
    classes,
    color: color2,
    disabled,
    error,
    endAdornment,
    focused,
    formControl,
    fullWidth,
    hiddenLabel,
    multiline,
    readOnly,
    size,
    startAdornment,
    type
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize(color2)}`, disabled && "disabled", error && "error", fullWidth && "fullWidth", focused && "focused", formControl && "formControl", size && size !== "medium" && `size${capitalize(size)}`, multiline && "multiline", startAdornment && "adornedStart", endAdornment && "adornedEnd", hiddenLabel && "hiddenLabel", readOnly && "readOnly"],
    input: ["input", disabled && "disabled", type === "search" && "inputTypeSearch", multiline && "inputMultiline", size === "small" && "inputSizeSmall", hiddenLabel && "inputHiddenLabel", startAdornment && "inputAdornedStart", endAdornment && "inputAdornedEnd", readOnly && "readOnly"]
  };
  return composeClasses(slots, getInputBaseUtilityClass, classes);
};
const InputBaseRoot = styled("div", {
  name: "MuiInputBase",
  slot: "Root",
  overridesResolver: rootOverridesResolver
})(memoTheme(({
  theme: theme2
}) => __spreadProps(__spreadValues({}, theme2.typography.body1), {
  color: (theme2.vars || theme2).palette.text.primary,
  lineHeight: "1.4375em",
  // 23px
  boxSizing: "border-box",
  // Prevent padding issue with fullWidth.
  position: "relative",
  cursor: "text",
  display: "inline-flex",
  alignItems: "center",
  [`&.${inputBaseClasses.disabled}`]: {
    color: (theme2.vars || theme2).palette.text.disabled,
    cursor: "default"
  },
  variants: [{
    props: ({
      ownerState
    }) => ownerState.multiline,
    style: {
      padding: "4px 0 5px"
    }
  }, {
    props: ({
      ownerState,
      size
    }) => ownerState.multiline && size === "small",
    style: {
      paddingTop: 1
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.fullWidth,
    style: {
      width: "100%"
    }
  }]
})));
const InputBaseInput = styled("input", {
  name: "MuiInputBase",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(memoTheme(({
  theme: theme2
}) => {
  const light2 = theme2.palette.mode === "light";
  const placeholder = __spreadProps(__spreadValues({
    color: "currentColor"
  }, theme2.vars ? {
    opacity: theme2.vars.opacity.inputPlaceholder
  } : {
    opacity: light2 ? 0.42 : 0.5
  }), {
    transition: theme2.transitions.create("opacity", {
      duration: theme2.transitions.duration.shorter
    })
  });
  const placeholderHidden = {
    opacity: "0 !important"
  };
  const placeholderVisible = theme2.vars ? {
    opacity: theme2.vars.opacity.inputPlaceholder
  } : {
    opacity: light2 ? 0.42 : 0.5
  };
  return {
    font: "inherit",
    letterSpacing: "inherit",
    color: "currentColor",
    padding: "4px 0 5px",
    border: 0,
    boxSizing: "content-box",
    background: "none",
    height: "1.4375em",
    // Reset 23pxthe native input line-height
    margin: 0,
    // Reset for Safari
    WebkitTapHighlightColor: "transparent",
    display: "block",
    // Make the flex item shrink with Firefox
    minWidth: 0,
    width: "100%",
    "&::-webkit-input-placeholder": placeholder,
    "&::-moz-placeholder": placeholder,
    // Firefox 19+
    "&::-ms-input-placeholder": placeholder,
    // Edge
    "&:focus": {
      outline: 0
    },
    // Reset Firefox invalid required input style
    "&:invalid": {
      boxShadow: "none"
    },
    "&::-webkit-search-decoration": {
      // Remove the padding when type=search.
      WebkitAppearance: "none"
    },
    // Show and hide the placeholder logic
    [`label[data-shrink=false] + .${inputBaseClasses.formControl} &`]: {
      "&::-webkit-input-placeholder": placeholderHidden,
      "&::-moz-placeholder": placeholderHidden,
      // Firefox 19+
      "&::-ms-input-placeholder": placeholderHidden,
      // Edge
      "&:focus::-webkit-input-placeholder": placeholderVisible,
      "&:focus::-moz-placeholder": placeholderVisible,
      // Firefox 19+
      "&:focus::-ms-input-placeholder": placeholderVisible
      // Edge
    },
    [`&.${inputBaseClasses.disabled}`]: {
      opacity: 1,
      // Reset iOS opacity
      WebkitTextFillColor: (theme2.vars || theme2).palette.text.disabled
      // Fix opacity Safari bug
    },
    variants: [{
      props: ({
        ownerState
      }) => !ownerState.disableInjectingGlobalStyles,
      style: {
        animationName: "mui-auto-fill-cancel",
        animationDuration: "10ms",
        "&:-webkit-autofill": {
          animationDuration: "5000s",
          animationName: "mui-auto-fill"
        }
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        paddingTop: 1
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.multiline,
      style: {
        height: "auto",
        resize: "none",
        padding: 0,
        paddingTop: 0
      }
    }, {
      props: {
        type: "search"
      },
      style: {
        MozAppearance: "textfield"
        // Improve type search style.
      }
    }]
  };
}));
const InputGlobalStyles = globalCss({
  "@keyframes mui-auto-fill": {
    from: {
      display: "block"
    }
  },
  "@keyframes mui-auto-fill-cancel": {
    from: {
      display: "block"
    }
  }
});
const InputBase = /* @__PURE__ */ React$1k.forwardRef(function InputBase2(inProps, ref) {
  var _b;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiInputBase"
  });
  const _a2 = props, {
    "aria-describedby": ariaDescribedby,
    autoComplete,
    autoFocus,
    className,
    color: color2,
    components = {},
    componentsProps = {},
    defaultValue,
    disabled,
    disableInjectingGlobalStyles,
    endAdornment,
    error,
    fullWidth = false,
    id,
    inputComponent = "input",
    inputProps: inputPropsProp = {},
    inputRef: inputRefProp,
    margin: margin2,
    maxRows,
    minRows,
    multiline = false,
    name: name2,
    onBlur,
    onChange,
    onClick,
    onFocus,
    onKeyDown,
    onKeyUp,
    placeholder,
    readOnly,
    renderSuffix,
    rows,
    size,
    slotProps = {},
    slots = {},
    startAdornment,
    type = "text",
    value: valueProp
  } = _a2, other = __objRest(_a2, [
    "aria-describedby",
    "autoComplete",
    "autoFocus",
    "className",
    "color",
    "components",
    "componentsProps",
    "defaultValue",
    "disabled",
    "disableInjectingGlobalStyles",
    "endAdornment",
    "error",
    "fullWidth",
    "id",
    "inputComponent",
    "inputProps",
    "inputRef",
    "margin",
    "maxRows",
    "minRows",
    "multiline",
    "name",
    "onBlur",
    "onChange",
    "onClick",
    "onFocus",
    "onKeyDown",
    "onKeyUp",
    "placeholder",
    "readOnly",
    "renderSuffix",
    "rows",
    "size",
    "slotProps",
    "slots",
    "startAdornment",
    "type",
    "value"
  ]);
  const value = inputPropsProp.value != null ? inputPropsProp.value : valueProp;
  const {
    current: isControlled
  } = React$1k.useRef(value != null);
  const inputRef = React$1k.useRef();
  const handleInputRefWarning = React$1k.useCallback((instance) => {
  }, []);
  const handleInputRef = useForkRef(inputRef, inputRefProp, inputPropsProp.ref, handleInputRefWarning);
  const [focused, setFocused] = React$1k.useState(false);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
  });
  fcs.focused = muiFormControl ? muiFormControl.focused : focused;
  React$1k.useEffect(() => {
    if (!muiFormControl && disabled && focused) {
      setFocused(false);
      if (onBlur) {
        onBlur();
      }
    }
  }, [muiFormControl, disabled, focused, onBlur]);
  const onFilled = muiFormControl && muiFormControl.onFilled;
  const onEmpty = muiFormControl && muiFormControl.onEmpty;
  const checkDirty = React$1k.useCallback((obj) => {
    if (isFilled(obj)) {
      if (onFilled) {
        onFilled();
      }
    } else if (onEmpty) {
      onEmpty();
    }
  }, [onFilled, onEmpty]);
  useEnhancedEffect(() => {
    if (isControlled) {
      checkDirty({
        value
      });
    }
  }, [value, checkDirty, isControlled]);
  const handleFocus = (event) => {
    if (onFocus) {
      onFocus(event);
    }
    if (inputPropsProp.onFocus) {
      inputPropsProp.onFocus(event);
    }
    if (muiFormControl && muiFormControl.onFocus) {
      muiFormControl.onFocus(event);
    } else {
      setFocused(true);
    }
  };
  const handleBlur = (event) => {
    if (onBlur) {
      onBlur(event);
    }
    if (inputPropsProp.onBlur) {
      inputPropsProp.onBlur(event);
    }
    if (muiFormControl && muiFormControl.onBlur) {
      muiFormControl.onBlur(event);
    } else {
      setFocused(false);
    }
  };
  const handleChange = (event, ...args) => {
    if (!isControlled) {
      const element = event.target || inputRef.current;
      if (element == null) {
        throw new Error(formatMuiErrorMessage(1));
      }
      checkDirty({
        value: element.value
      });
    }
    if (inputPropsProp.onChange) {
      inputPropsProp.onChange(event, ...args);
    }
    if (onChange) {
      onChange(event, ...args);
    }
  };
  React$1k.useEffect(() => {
    checkDirty(inputRef.current);
  }, []);
  const handleClick = (event) => {
    if (inputRef.current && event.currentTarget === event.target) {
      inputRef.current.focus();
    }
    if (onClick) {
      onClick(event);
    }
  };
  let InputComponent = inputComponent;
  let inputProps = inputPropsProp;
  if (multiline && InputComponent === "input") {
    if (rows) {
      inputProps = __spreadValues({
        type: void 0,
        minRows: rows,
        maxRows: rows
      }, inputProps);
    } else {
      inputProps = __spreadValues({
        type: void 0,
        maxRows,
        minRows
      }, inputProps);
    }
    InputComponent = TextareaAutosize;
  }
  const handleAutoFill = (event) => {
    checkDirty(event.animationName === "mui-auto-fill-cancel" ? inputRef.current : {
      value: "x"
    });
  };
  React$1k.useEffect(() => {
    if (muiFormControl) {
      muiFormControl.setAdornedStart(Boolean(startAdornment));
    }
  }, [muiFormControl, startAdornment]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: fcs.color || "primary",
    disabled: fcs.disabled,
    endAdornment,
    error: fcs.error,
    focused: fcs.focused,
    formControl: muiFormControl,
    fullWidth,
    hiddenLabel: fcs.hiddenLabel,
    multiline,
    size: fcs.size,
    startAdornment,
    type
  });
  const classes = useUtilityClasses$U(ownerState);
  const Root = slots.root || components.Root || InputBaseRoot;
  const rootProps = slotProps.root || componentsProps.root || {};
  const Input3 = slots.input || components.Input || InputBaseInput;
  inputProps = __spreadValues(__spreadValues({}, inputProps), (_b = slotProps.input) != null ? _b : componentsProps.input);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(React$1k.Fragment, {
    children: [!disableInjectingGlobalStyles && typeof InputGlobalStyles === "function" && // For Emotion/Styled-components, InputGlobalStyles will be a function
    // For Pigment CSS, this has no effect because the InputGlobalStyles will be null.
    (_InputGlobalStyles || (_InputGlobalStyles = /* @__PURE__ */ jsxRuntimeExports.jsx(InputGlobalStyles, {}))), /* @__PURE__ */ jsxRuntimeExports.jsxs(Root, __spreadProps(__spreadValues(__spreadValues(__spreadProps(__spreadValues({}, rootProps), {
      ref,
      onClick: handleClick
    }), other), !isHostComponent(Root) && {
      ownerState: __spreadValues(__spreadValues({}, ownerState), rootProps.ownerState)
    }), {
      className: clsx(classes.root, rootProps.className, className, readOnly && "MuiInputBase-readOnly"),
      children: [startAdornment, /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext.Provider, {
        value: null,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input3, __spreadProps(__spreadValues(__spreadValues({
          "aria-invalid": fcs.error,
          "aria-describedby": ariaDescribedby,
          autoComplete,
          autoFocus,
          defaultValue,
          disabled: fcs.disabled,
          id,
          onAnimationStart: handleAutoFill,
          name: name2,
          placeholder,
          readOnly,
          required: fcs.required,
          rows,
          value,
          onKeyDown,
          onKeyUp,
          type
        }, inputProps), !isHostComponent(Input3) && {
          as: InputComponent,
          ownerState: __spreadValues(__spreadValues({}, ownerState), inputProps.ownerState)
        }), {
          ref: handleInputRef,
          className: clsx(classes.input, inputProps.className, readOnly && "MuiInputBase-readOnly"),
          onBlur: handleBlur,
          onChange: handleChange,
          onFocus: handleFocus
        }))
      }), endAdornment, renderSuffix ? renderSuffix(__spreadProps(__spreadValues({}, fcs), {
        startAdornment
      })) : null]
    }))]
  });
});
function getInputUtilityClass(slot) {
  return generateUtilityClass("MuiInput", slot);
}
const inputClasses = __spreadValues(__spreadValues({}, inputBaseClasses), generateUtilityClasses("MuiInput", ["root", "underline", "input"]));
function getOutlinedInputUtilityClass(slot) {
  return generateUtilityClass("MuiOutlinedInput", slot);
}
const outlinedInputClasses = __spreadValues(__spreadValues({}, inputBaseClasses), generateUtilityClasses("MuiOutlinedInput", ["root", "notchedOutline", "input"]));
function getFilledInputUtilityClass(slot) {
  return generateUtilityClass("MuiFilledInput", slot);
}
const filledInputClasses = __spreadValues(__spreadValues({}, inputBaseClasses), generateUtilityClasses("MuiFilledInput", ["root", "underline", "input", "adornedStart", "adornedEnd", "sizeSmall", "multiline", "hiddenLabel"]));
const ArrowDropDownIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M7 10l5 5 5-5z"
}));
const Person = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"
}));
function getAvatarUtilityClass(slot) {
  return generateUtilityClass("MuiAvatar", slot);
}
generateUtilityClasses("MuiAvatar", ["root", "colorDefault", "circular", "rounded", "square", "img", "fallback"]);
const React$1j = window["React"];
const useUtilityClasses$T = (ownerState) => {
  const {
    classes,
    variant,
    colorDefault
  } = ownerState;
  const slots = {
    root: ["root", variant, colorDefault && "colorDefault"],
    img: ["img"],
    fallback: ["fallback"]
  };
  return composeClasses(slots, getAvatarUtilityClass, classes);
};
const AvatarRoot = styled("div", {
  name: "MuiAvatar",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], ownerState.colorDefault && styles2.colorDefault];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  position: "relative",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  flexShrink: 0,
  width: 40,
  height: 40,
  fontFamily: theme2.typography.fontFamily,
  fontSize: theme2.typography.pxToRem(20),
  lineHeight: 1,
  borderRadius: "50%",
  overflow: "hidden",
  userSelect: "none",
  variants: [{
    props: {
      variant: "rounded"
    },
    style: {
      borderRadius: (theme2.vars || theme2).shape.borderRadius
    }
  }, {
    props: {
      variant: "square"
    },
    style: {
      borderRadius: 0
    }
  }, {
    props: {
      colorDefault: true
    },
    style: __spreadValues({
      color: (theme2.vars || theme2).palette.background.default
    }, theme2.vars ? {
      backgroundColor: theme2.vars.palette.Avatar.defaultBg
    } : __spreadValues({
      backgroundColor: theme2.palette.grey[400]
    }, theme2.applyStyles("dark", {
      backgroundColor: theme2.palette.grey[600]
    })))
  }]
})));
const AvatarImg = styled("img", {
  name: "MuiAvatar",
  slot: "Img"
})({
  width: "100%",
  height: "100%",
  textAlign: "center",
  // Handle non-square image.
  objectFit: "cover",
  // Hide alt text.
  color: "transparent",
  // Hide the image broken icon, only works on Chrome.
  textIndent: 1e4
});
const AvatarFallback = styled(Person, {
  name: "MuiAvatar",
  slot: "Fallback"
})({
  width: "75%",
  height: "75%"
});
function useLoaded({
  crossOrigin,
  referrerPolicy,
  src,
  srcSet
}) {
  const [loaded, setLoaded] = React$1j.useState(false);
  React$1j.useEffect(() => {
    if (!src && !srcSet) {
      return void 0;
    }
    setLoaded(false);
    let active = true;
    const image = new Image();
    image.onload = () => {
      if (!active) {
        return;
      }
      setLoaded("loaded");
    };
    image.onerror = () => {
      if (!active) {
        return;
      }
      setLoaded("error");
    };
    image.crossOrigin = crossOrigin;
    image.referrerPolicy = referrerPolicy;
    image.src = src;
    if (srcSet) {
      image.srcset = srcSet;
    }
    return () => {
      active = false;
    };
  }, [crossOrigin, referrerPolicy, src, srcSet]);
  return loaded;
}
const Avatar$1 = /* @__PURE__ */ React$1j.forwardRef(function Avatar2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiAvatar"
  });
  const _a2 = props, {
    alt,
    children: childrenProp,
    className,
    component = "div",
    slots = {},
    slotProps = {},
    imgProps,
    sizes,
    src,
    srcSet,
    variant = "circular"
  } = _a2, other = __objRest(_a2, [
    "alt",
    "children",
    "className",
    "component",
    "slots",
    "slotProps",
    "imgProps",
    "sizes",
    "src",
    "srcSet",
    "variant"
  ]);
  let children = null;
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component,
    variant
  });
  const loaded = useLoaded(__spreadProps(__spreadValues(__spreadValues({}, imgProps), typeof slotProps.img === "function" ? slotProps.img(ownerState) : slotProps.img), {
    src,
    srcSet
  }));
  const hasImg = src || srcSet;
  const hasImgNotFailing = hasImg && loaded !== "error";
  ownerState.colorDefault = !hasImgNotFailing;
  delete ownerState.ownerState;
  const classes = useUtilityClasses$T(ownerState);
  const [RootSlot, rootSlotProps] = useSlot("root", {
    ref,
    className: clsx(classes.root, className),
    elementType: AvatarRoot,
    externalForwardedProps: __spreadValues({
      slots,
      slotProps,
      component
    }, other),
    ownerState
  });
  const [ImgSlot, imgSlotProps] = useSlot("img", {
    className: classes.img,
    elementType: AvatarImg,
    externalForwardedProps: {
      slots,
      slotProps: {
        img: __spreadValues(__spreadValues({}, imgProps), slotProps.img)
      }
    },
    additionalProps: {
      alt,
      src,
      srcSet,
      sizes
    },
    ownerState
  });
  const [FallbackSlot, fallbackSlotProps] = useSlot("fallback", {
    className: classes.fallback,
    elementType: AvatarFallback,
    externalForwardedProps: {
      slots,
      slotProps
    },
    shouldForwardComponentProp: true,
    ownerState
  });
  if (hasImgNotFailing) {
    children = /* @__PURE__ */ jsxRuntimeExports.jsx(ImgSlot, __spreadValues({}, imgSlotProps));
  } else if (!!childrenProp || childrenProp === 0) {
    children = childrenProp;
  } else if (hasImg && alt) {
    children = alt[0];
  } else {
    children = /* @__PURE__ */ jsxRuntimeExports.jsx(FallbackSlot, __spreadValues({}, fallbackSlotProps));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, __spreadProps(__spreadValues({}, rootSlotProps), {
    children
  }));
});
const React$1i = window["React"];
const styles$3 = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
};
const Fade = /* @__PURE__ */ React$1i.forwardRef(function Fade2(props, ref) {
  const theme2 = useTheme();
  const defaultTimeout = {
    enter: theme2.transitions.duration.enteringScreen,
    exit: theme2.transitions.duration.leavingScreen
  };
  const _a2 = props, {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = defaultTimeout,
    TransitionComponent: TransitionComponent = Transition
  } = _a2, other = __objRest(_a2, [
    "addEndListener",
    "appear",
    "children",
    "easing",
    "in",
    "onEnter",
    "onEntered",
    "onEntering",
    "onExit",
    "onExited",
    "onExiting",
    "style",
    "timeout",
    // eslint-disable-next-line react/prop-types
    "TransitionComponent"
  ]);
  const nodeRef = React$1i.useRef(null);
  const handleRef = useForkRef(nodeRef, getReactElementRef(children), ref);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    node2.style.webkitTransition = theme2.transitions.create("opacity", transitionProps);
    node2.style.transition = theme2.transitions.create("opacity", transitionProps);
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    node2.style.webkitTransition = theme2.transitions.create("opacity", transitionProps);
    node2.style.transition = theme2.transitions.create("opacity", transitionProps);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = (next2) => {
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, __spreadProps(__spreadValues({
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout
  }, other), {
    children: (state, _b) => {
      var _c = _b, {
        ownerState
      } = _c, restChildProps = __objRest(_c, [
        "ownerState"
      ]);
      return /* @__PURE__ */ React$1i.cloneElement(children, __spreadValues({
        style: __spreadValues(__spreadValues(__spreadValues({
          opacity: 0,
          visibility: state === "exited" && !inProp ? "hidden" : void 0
        }, styles$3[state]), style2), children.props.style),
        ref: handleRef
      }, restChildProps));
    }
  }));
});
function getBackdropUtilityClass(slot) {
  return generateUtilityClass("MuiBackdrop", slot);
}
generateUtilityClasses("MuiBackdrop", ["root", "invisible"]);
const React$1h = window["React"];
const useUtilityClasses$S = (ownerState) => {
  const {
    classes,
    invisible
  } = ownerState;
  const slots = {
    root: ["root", invisible && "invisible"]
  };
  return composeClasses(slots, getBackdropUtilityClass, classes);
};
const BackdropRoot = styled("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.invisible && styles2.invisible];
  }
})({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent",
  variants: [{
    props: {
      invisible: true
    },
    style: {
      backgroundColor: "transparent"
    }
  }]
});
const Backdrop = /* @__PURE__ */ React$1h.forwardRef(function Backdrop2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiBackdrop"
  });
  const _a2 = props, {
    children,
    className,
    component = "div",
    invisible = false,
    open,
    components = {},
    componentsProps = {},
    slotProps = {},
    slots = {},
    TransitionComponent: TransitionComponentProp,
    transitionDuration
  } = _a2, other = __objRest(_a2, [
    "children",
    "className",
    "component",
    "invisible",
    "open",
    "components",
    "componentsProps",
    "slotProps",
    "slots",
    "TransitionComponent",
    "transitionDuration"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component,
    invisible
  });
  const classes = useUtilityClasses$S(ownerState);
  const backwardCompatibleSlots = __spreadValues({
    transition: TransitionComponentProp,
    root: components.Root
  }, slots);
  const backwardCompatibleSlotProps = __spreadValues(__spreadValues({}, componentsProps), slotProps);
  const externalForwardedProps = {
    component,
    slots: backwardCompatibleSlots,
    slotProps: backwardCompatibleSlotProps
  };
  const [RootSlot, rootProps] = useSlot("root", {
    elementType: BackdropRoot,
    externalForwardedProps,
    className: clsx(classes.root, className),
    ownerState
  });
  const [TransitionSlot, transitionProps] = useSlot("transition", {
    elementType: Fade,
    externalForwardedProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionSlot, __spreadProps(__spreadValues(__spreadValues({
    in: open,
    timeout: transitionDuration
  }, other), transitionProps), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, __spreadProps(__spreadValues({
      "aria-hidden": true
    }, rootProps), {
      classes,
      ref,
      children
    }))
  }));
});
const boxClasses = generateUtilityClasses("MuiBox", ["root"]);
const defaultTheme = createTheme();
const Box = createBox({
  themeId: THEME_ID,
  defaultTheme,
  defaultClassName: boxClasses.root,
  generateClassName: ClassNameGenerator.generate
});
function getButtonUtilityClass(slot) {
  return generateUtilityClass("MuiButton", slot);
}
const buttonClasses = generateUtilityClasses("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge", "loading", "loadingWrapper", "loadingIconPlaceholder", "loadingIndicator", "loadingPositionCenter", "loadingPositionStart", "loadingPositionEnd"]);
const React$1g = window["React"];
const ButtonGroupContext = /* @__PURE__ */ React$1g.createContext({});
const React$1f = window["React"];
const ButtonGroupButtonContext = /* @__PURE__ */ React$1f.createContext(void 0);
const React$1e = window["React"];
const useUtilityClasses$R = (ownerState) => {
  const {
    color: color2,
    disableElevation,
    fullWidth,
    size,
    variant,
    loading,
    loadingPosition,
    classes
  } = ownerState;
  const slots = {
    root: ["root", loading && "loading", variant, `${variant}${capitalize(color2)}`, `size${capitalize(size)}`, `${variant}Size${capitalize(size)}`, `color${capitalize(color2)}`, disableElevation && "disableElevation", fullWidth && "fullWidth", loading && `loadingPosition${capitalize(loadingPosition)}`],
    startIcon: ["icon", "startIcon", `iconSize${capitalize(size)}`],
    endIcon: ["icon", "endIcon", `iconSize${capitalize(size)}`],
    loadingIndicator: ["loadingIndicator"],
    loadingWrapper: ["loadingWrapper"]
  };
  const composedClasses = composeClasses(slots, getButtonUtilityClass, classes);
  return __spreadValues(__spreadValues({}, classes), composedClasses);
};
const commonIconStyles = [{
  props: {
    size: "small"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 18
    }
  }
}, {
  props: {
    size: "medium"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 20
    }
  }
}, {
  props: {
    size: "large"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 22
    }
  }
}];
const ButtonRoot = styled(ButtonBase, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize(ownerState.color)}`], styles2[`size${capitalize(ownerState.size)}`], styles2[`${ownerState.variant}Size${capitalize(ownerState.size)}`], ownerState.color === "inherit" && styles2.colorInherit, ownerState.disableElevation && styles2.disableElevation, ownerState.fullWidth && styles2.fullWidth, ownerState.loading && styles2.loading];
  }
})(memoTheme(({
  theme: theme2
}) => {
  const inheritContainedBackgroundColor = theme2.palette.mode === "light" ? theme2.palette.grey[300] : theme2.palette.grey[800];
  const inheritContainedHoverBackgroundColor = theme2.palette.mode === "light" ? theme2.palette.grey.A100 : theme2.palette.grey[700];
  return __spreadProps(__spreadValues({}, theme2.typography.button), {
    minWidth: 64,
    padding: "6px 16px",
    border: 0,
    borderRadius: (theme2.vars || theme2).shape.borderRadius,
    transition: theme2.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
      duration: theme2.transitions.duration.short
    }),
    "&:hover": {
      textDecoration: "none"
    },
    [`&.${buttonClasses.disabled}`]: {
      color: (theme2.vars || theme2).palette.action.disabled
    },
    variants: [{
      props: {
        variant: "contained"
      },
      style: {
        color: `var(--variant-containedColor)`,
        backgroundColor: `var(--variant-containedBg)`,
        boxShadow: (theme2.vars || theme2).shadows[2],
        "&:hover": {
          boxShadow: (theme2.vars || theme2).shadows[4],
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            boxShadow: (theme2.vars || theme2).shadows[2]
          }
        },
        "&:active": {
          boxShadow: (theme2.vars || theme2).shadows[8]
        },
        [`&.${buttonClasses.focusVisible}`]: {
          boxShadow: (theme2.vars || theme2).shadows[6]
        },
        [`&.${buttonClasses.disabled}`]: {
          color: (theme2.vars || theme2).palette.action.disabled,
          boxShadow: (theme2.vars || theme2).shadows[0],
          backgroundColor: (theme2.vars || theme2).palette.action.disabledBackground
        }
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        padding: "5px 15px",
        border: "1px solid currentColor",
        borderColor: `var(--variant-outlinedBorder, currentColor)`,
        backgroundColor: `var(--variant-outlinedBg)`,
        color: `var(--variant-outlinedColor)`,
        [`&.${buttonClasses.disabled}`]: {
          border: `1px solid ${(theme2.vars || theme2).palette.action.disabledBackground}`
        }
      }
    }, {
      props: {
        variant: "text"
      },
      style: {
        padding: "6px 8px",
        color: `var(--variant-textColor)`,
        backgroundColor: `var(--variant-textBg)`
      }
    }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
      props: {
        color: color2
      },
      style: {
        "--variant-textColor": (theme2.vars || theme2).palette[color2].main,
        "--variant-outlinedColor": (theme2.vars || theme2).palette[color2].main,
        "--variant-outlinedBorder": theme2.alpha((theme2.vars || theme2).palette[color2].main, 0.5),
        "--variant-containedColor": (theme2.vars || theme2).palette[color2].contrastText,
        "--variant-containedBg": (theme2.vars || theme2).palette[color2].main,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": (theme2.vars || theme2).palette[color2].dark,
            "--variant-textBg": theme2.alpha((theme2.vars || theme2).palette[color2].main, (theme2.vars || theme2).palette.action.hoverOpacity),
            "--variant-outlinedBorder": (theme2.vars || theme2).palette[color2].main,
            "--variant-outlinedBg": theme2.alpha((theme2.vars || theme2).palette[color2].main, (theme2.vars || theme2).palette.action.hoverOpacity)
          }
        }
      }
    })), {
      props: {
        color: "inherit"
      },
      style: {
        color: "inherit",
        borderColor: "currentColor",
        "--variant-containedBg": theme2.vars ? theme2.vars.palette.Button.inheritContainedBg : inheritContainedBackgroundColor,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": theme2.vars ? theme2.vars.palette.Button.inheritContainedHoverBg : inheritContainedHoverBackgroundColor,
            "--variant-textBg": theme2.alpha((theme2.vars || theme2).palette.text.primary, (theme2.vars || theme2).palette.action.hoverOpacity),
            "--variant-outlinedBg": theme2.alpha((theme2.vars || theme2).palette.text.primary, (theme2.vars || theme2).palette.action.hoverOpacity)
          }
        }
      }
    }, {
      props: {
        size: "small",
        variant: "text"
      },
      style: {
        padding: "4px 5px",
        fontSize: theme2.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "text"
      },
      style: {
        padding: "8px 11px",
        fontSize: theme2.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "outlined"
      },
      style: {
        padding: "3px 9px",
        fontSize: theme2.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "outlined"
      },
      style: {
        padding: "7px 21px",
        fontSize: theme2.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "contained"
      },
      style: {
        padding: "4px 10px",
        fontSize: theme2.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "contained"
      },
      style: {
        padding: "8px 22px",
        fontSize: theme2.typography.pxToRem(15)
      }
    }, {
      props: {
        disableElevation: true
      },
      style: {
        boxShadow: "none",
        "&:hover": {
          boxShadow: "none"
        },
        [`&.${buttonClasses.focusVisible}`]: {
          boxShadow: "none"
        },
        "&:active": {
          boxShadow: "none"
        },
        [`&.${buttonClasses.disabled}`]: {
          boxShadow: "none"
        }
      }
    }, {
      props: {
        fullWidth: true
      },
      style: {
        width: "100%"
      }
    }, {
      props: {
        loadingPosition: "center"
      },
      style: {
        transition: theme2.transitions.create(["background-color", "box-shadow", "border-color"], {
          duration: theme2.transitions.duration.short
        }),
        [`&.${buttonClasses.loading}`]: {
          color: "transparent"
        }
      }
    }]
  });
}));
const ButtonStartIcon = styled("span", {
  name: "MuiButton",
  slot: "StartIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.startIcon, ownerState.loading && styles2.startIconLoadingStart, styles2[`iconSize${capitalize(ownerState.size)}`]];
  }
})(({
  theme: theme2
}) => ({
  display: "inherit",
  marginRight: 8,
  marginLeft: -4,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginLeft: -2
    }
  }, {
    props: {
      loadingPosition: "start",
      loading: true
    },
    style: {
      transition: theme2.transitions.create(["opacity"], {
        duration: theme2.transitions.duration.short
      }),
      opacity: 0
    }
  }, {
    props: {
      loadingPosition: "start",
      loading: true,
      fullWidth: true
    },
    style: {
      marginRight: -8
    }
  }, ...commonIconStyles]
}));
const ButtonEndIcon = styled("span", {
  name: "MuiButton",
  slot: "EndIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.endIcon, ownerState.loading && styles2.endIconLoadingEnd, styles2[`iconSize${capitalize(ownerState.size)}`]];
  }
})(({
  theme: theme2
}) => ({
  display: "inherit",
  marginRight: -4,
  marginLeft: 8,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginRight: -2
    }
  }, {
    props: {
      loadingPosition: "end",
      loading: true
    },
    style: {
      transition: theme2.transitions.create(["opacity"], {
        duration: theme2.transitions.duration.short
      }),
      opacity: 0
    }
  }, {
    props: {
      loadingPosition: "end",
      loading: true,
      fullWidth: true
    },
    style: {
      marginLeft: -8
    }
  }, ...commonIconStyles]
}));
const ButtonLoadingIndicator = styled("span", {
  name: "MuiButton",
  slot: "LoadingIndicator"
})(({
  theme: theme2
}) => ({
  display: "none",
  position: "absolute",
  visibility: "visible",
  variants: [{
    props: {
      loading: true
    },
    style: {
      display: "flex"
    }
  }, {
    props: {
      loadingPosition: "start"
    },
    style: {
      left: 14
    }
  }, {
    props: {
      loadingPosition: "start",
      size: "small"
    },
    style: {
      left: 10
    }
  }, {
    props: {
      variant: "text",
      loadingPosition: "start"
    },
    style: {
      left: 6
    }
  }, {
    props: {
      loadingPosition: "center"
    },
    style: {
      left: "50%",
      transform: "translate(-50%)",
      color: (theme2.vars || theme2).palette.action.disabled
    }
  }, {
    props: {
      loadingPosition: "end"
    },
    style: {
      right: 14
    }
  }, {
    props: {
      loadingPosition: "end",
      size: "small"
    },
    style: {
      right: 10
    }
  }, {
    props: {
      variant: "text",
      loadingPosition: "end"
    },
    style: {
      right: 6
    }
  }, {
    props: {
      loadingPosition: "start",
      fullWidth: true
    },
    style: {
      position: "relative",
      left: -10
    }
  }, {
    props: {
      loadingPosition: "end",
      fullWidth: true
    },
    style: {
      position: "relative",
      right: -10
    }
  }]
}));
const ButtonLoadingIconPlaceholder = styled("span", {
  name: "MuiButton",
  slot: "LoadingIconPlaceholder"
})({
  display: "inline-block",
  width: "1em",
  height: "1em"
});
const Button = /* @__PURE__ */ React$1e.forwardRef(function Button2(inProps, ref) {
  const contextProps = React$1e.useContext(ButtonGroupContext);
  const buttonGroupButtonContextPositionClassName = React$1e.useContext(ButtonGroupButtonContext);
  const resolvedProps = resolveProps(contextProps, inProps);
  const props = useDefaultProps({
    props: resolvedProps,
    name: "MuiButton"
  });
  const _a2 = props, {
    children,
    color: color2 = "primary",
    component = "button",
    className,
    disabled = false,
    disableElevation = false,
    disableFocusRipple = false,
    endIcon: endIconProp,
    focusVisibleClassName,
    fullWidth = false,
    id: idProp,
    loading = null,
    loadingIndicator: loadingIndicatorProp,
    loadingPosition = "center",
    size = "medium",
    startIcon: startIconProp,
    type,
    variant = "text"
  } = _a2, other = __objRest(_a2, [
    "children",
    "color",
    "component",
    "className",
    "disabled",
    "disableElevation",
    "disableFocusRipple",
    "endIcon",
    "focusVisibleClassName",
    "fullWidth",
    "id",
    "loading",
    "loadingIndicator",
    "loadingPosition",
    "size",
    "startIcon",
    "type",
    "variant"
  ]);
  const loadingId = useId(idProp);
  const loadingIndicator = loadingIndicatorProp != null ? loadingIndicatorProp : /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {
    "aria-labelledby": loadingId,
    color: "inherit",
    size: 16
  });
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: color2,
    component,
    disabled,
    disableElevation,
    disableFocusRipple,
    fullWidth,
    loading,
    loadingIndicator,
    loadingPosition,
    size,
    type,
    variant
  });
  const classes = useUtilityClasses$R(ownerState);
  const startIcon = (startIconProp || loading && loadingPosition === "start") && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonStartIcon, {
    className: classes.startIcon,
    ownerState,
    children: startIconProp || /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonLoadingIconPlaceholder, {
      className: classes.loadingIconPlaceholder,
      ownerState
    })
  });
  const endIcon = (endIconProp || loading && loadingPosition === "end") && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonEndIcon, {
    className: classes.endIcon,
    ownerState,
    children: endIconProp || /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonLoadingIconPlaceholder, {
      className: classes.loadingIconPlaceholder,
      ownerState
    })
  });
  const positionClassName = buttonGroupButtonContextPositionClassName || "";
  const loader = typeof loading === "boolean" ? (
    // use plain HTML span to minimize the runtime overhead
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: classes.loadingWrapper,
      style: {
        display: "contents"
      },
      children: loading && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonLoadingIndicator, {
        className: classes.loadingIndicator,
        ownerState,
        children: loadingIndicator
      })
    })
  ) : null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonRoot, __spreadProps(__spreadValues({
    ownerState,
    className: clsx(contextProps.className, classes.root, className, positionClassName),
    component,
    disabled: disabled || loading,
    focusRipple: !disableFocusRipple,
    focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
    ref,
    type,
    id: loading ? loadingId : idProp
  }, other), {
    classes,
    children: [startIcon, loadingPosition !== "end" && loader, children, loadingPosition === "end" && loader, endIcon]
  }));
});
const React$1d = window["React"];
function getValidReactChildren(children) {
  return React$1d.Children.toArray(children).filter((child) => /* @__PURE__ */ React$1d.isValidElement(child));
}
function getButtonGroupUtilityClass(slot) {
  return generateUtilityClass("MuiButtonGroup", slot);
}
const buttonGroupClasses = generateUtilityClasses("MuiButtonGroup", ["root", "contained", "outlined", "text", "disableElevation", "disabled", "firstButton", "fullWidth", "horizontal", "vertical", "colorPrimary", "colorSecondary", "grouped", "groupedHorizontal", "groupedVertical", "groupedText", "groupedTextHorizontal", "groupedTextVertical", "groupedTextPrimary", "groupedTextSecondary", "groupedOutlined", "groupedOutlinedHorizontal", "groupedOutlinedVertical", "groupedOutlinedPrimary", "groupedOutlinedSecondary", "groupedContained", "groupedContainedHorizontal", "groupedContainedVertical", "groupedContainedPrimary", "groupedContainedSecondary", "lastButton", "middleButton"]);
const React$1c = window["React"];
const overridesResolver$3 = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [{
    [`& .${buttonGroupClasses.grouped}`]: styles2.grouped
  }, {
    [`& .${buttonGroupClasses.grouped}`]: styles2[`grouped${capitalize(ownerState.orientation)}`]
  }, {
    [`& .${buttonGroupClasses.grouped}`]: styles2[`grouped${capitalize(ownerState.variant)}`]
  }, {
    [`& .${buttonGroupClasses.grouped}`]: styles2[`grouped${capitalize(ownerState.variant)}${capitalize(ownerState.orientation)}`]
  }, {
    [`& .${buttonGroupClasses.grouped}`]: styles2[`grouped${capitalize(ownerState.variant)}${capitalize(ownerState.color)}`]
  }, {
    [`& .${buttonGroupClasses.firstButton}`]: styles2.firstButton
  }, {
    [`& .${buttonGroupClasses.lastButton}`]: styles2.lastButton
  }, {
    [`& .${buttonGroupClasses.middleButton}`]: styles2.middleButton
  }, styles2.root, styles2[ownerState.variant], ownerState.disableElevation === true && styles2.disableElevation, ownerState.fullWidth && styles2.fullWidth, ownerState.orientation === "vertical" && styles2.vertical];
};
const useUtilityClasses$Q = (ownerState) => {
  const {
    classes,
    color: color2,
    disabled,
    disableElevation,
    fullWidth,
    orientation,
    variant
  } = ownerState;
  const slots = {
    root: ["root", variant, orientation, fullWidth && "fullWidth", disableElevation && "disableElevation", `color${capitalize(color2)}`],
    grouped: ["grouped", `grouped${capitalize(orientation)}`, `grouped${capitalize(variant)}`, `grouped${capitalize(variant)}${capitalize(orientation)}`, `grouped${capitalize(variant)}${capitalize(color2)}`, disabled && "disabled"],
    firstButton: ["firstButton"],
    lastButton: ["lastButton"],
    middleButton: ["middleButton"]
  };
  return composeClasses(slots, getButtonGroupUtilityClass, classes);
};
const ButtonGroupRoot = styled("div", {
  name: "MuiButtonGroup",
  slot: "Root",
  overridesResolver: overridesResolver$3
})(memoTheme(({
  theme: theme2
}) => ({
  display: "inline-flex",
  borderRadius: (theme2.vars || theme2).shape.borderRadius,
  variants: [{
    props: {
      variant: "contained"
    },
    style: {
      boxShadow: (theme2.vars || theme2).shadows[2]
    }
  }, {
    props: {
      disableElevation: true
    },
    style: {
      boxShadow: "none"
    }
  }, {
    props: {
      fullWidth: true
    },
    style: {
      width: "100%"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      flexDirection: "column",
      [`& .${buttonGroupClasses.lastButton},& .${buttonGroupClasses.middleButton}`]: {
        borderTopRightRadius: 0,
        borderTopLeftRadius: 0
      },
      [`& .${buttonGroupClasses.firstButton},& .${buttonGroupClasses.middleButton}`]: {
        borderBottomRightRadius: 0,
        borderBottomLeftRadius: 0
      }
    }
  }, {
    props: {
      orientation: "horizontal"
    },
    style: {
      [`& .${buttonGroupClasses.firstButton},& .${buttonGroupClasses.middleButton}`]: {
        borderTopRightRadius: 0,
        borderBottomRightRadius: 0
      },
      [`& .${buttonGroupClasses.lastButton},& .${buttonGroupClasses.middleButton}`]: {
        borderTopLeftRadius: 0,
        borderBottomLeftRadius: 0
      }
    }
  }, {
    props: {
      variant: "text",
      orientation: "horizontal"
    },
    style: {
      [`& .${buttonGroupClasses.firstButton},& .${buttonGroupClasses.middleButton}`]: {
        borderRight: theme2.vars ? `1px solid ${theme2.alpha(theme2.vars.palette.common.onBackground, 0.23)}` : `1px solid ${theme2.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)"}`,
        [`&.${buttonGroupClasses.disabled}`]: {
          borderRight: `1px solid ${(theme2.vars || theme2).palette.action.disabled}`
        }
      }
    }
  }, {
    props: {
      variant: "text",
      orientation: "vertical"
    },
    style: {
      [`& .${buttonGroupClasses.firstButton},& .${buttonGroupClasses.middleButton}`]: {
        borderBottom: theme2.vars ? `1px solid ${theme2.alpha(theme2.vars.palette.common.onBackground, 0.23)}` : `1px solid ${theme2.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)"}`,
        [`&.${buttonGroupClasses.disabled}`]: {
          borderBottom: `1px solid ${(theme2.vars || theme2).palette.action.disabled}`
        }
      }
    }
  }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).flatMap(([color2]) => [{
    props: {
      variant: "text",
      color: color2
    },
    style: {
      [`& .${buttonGroupClasses.firstButton},& .${buttonGroupClasses.middleButton}`]: {
        borderColor: theme2.alpha((theme2.vars || theme2).palette[color2].main, 0.5)
      }
    }
  }]), {
    props: {
      variant: "outlined",
      orientation: "horizontal"
    },
    style: {
      [`& .${buttonGroupClasses.firstButton},& .${buttonGroupClasses.middleButton}`]: {
        borderRightColor: "transparent",
        "&:hover": {
          borderRightColor: "currentColor"
        }
      },
      [`& .${buttonGroupClasses.lastButton},& .${buttonGroupClasses.middleButton}`]: {
        marginLeft: -1
      }
    }
  }, {
    props: {
      variant: "outlined",
      orientation: "vertical"
    },
    style: {
      [`& .${buttonGroupClasses.firstButton},& .${buttonGroupClasses.middleButton}`]: {
        borderBottomColor: "transparent",
        "&:hover": {
          borderBottomColor: "currentColor"
        }
      },
      [`& .${buttonGroupClasses.lastButton},& .${buttonGroupClasses.middleButton}`]: {
        marginTop: -1
      }
    }
  }, {
    props: {
      variant: "contained",
      orientation: "horizontal"
    },
    style: {
      [`& .${buttonGroupClasses.firstButton},& .${buttonGroupClasses.middleButton}`]: {
        borderRight: `1px solid ${(theme2.vars || theme2).palette.grey[400]}`,
        [`&.${buttonGroupClasses.disabled}`]: {
          borderRight: `1px solid ${(theme2.vars || theme2).palette.action.disabled}`
        }
      }
    }
  }, {
    props: {
      variant: "contained",
      orientation: "vertical"
    },
    style: {
      [`& .${buttonGroupClasses.firstButton},& .${buttonGroupClasses.middleButton}`]: {
        borderBottom: `1px solid ${(theme2.vars || theme2).palette.grey[400]}`,
        [`&.${buttonGroupClasses.disabled}`]: {
          borderBottom: `1px solid ${(theme2.vars || theme2).palette.action.disabled}`
        }
      }
    }
  }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["dark"])).map(([color2]) => ({
    props: {
      variant: "contained",
      color: color2
    },
    style: {
      [`& .${buttonGroupClasses.firstButton},& .${buttonGroupClasses.middleButton}`]: {
        borderColor: (theme2.vars || theme2).palette[color2].dark
      }
    }
  }))],
  [`& .${buttonGroupClasses.grouped}`]: {
    minWidth: 40,
    boxShadow: "none",
    props: {
      variant: "contained"
    },
    style: {
      "&:hover": {
        boxShadow: "none"
      }
    }
  }
})));
const ButtonGroup = /* @__PURE__ */ React$1c.forwardRef(function ButtonGroup2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiButtonGroup"
  });
  const _a2 = props, {
    children,
    className,
    color: color2 = "primary",
    component = "div",
    disabled = false,
    disableElevation = false,
    disableFocusRipple = false,
    disableRipple = false,
    fullWidth = false,
    orientation = "horizontal",
    size = "medium",
    variant = "outlined"
  } = _a2, other = __objRest(_a2, [
    "children",
    "className",
    "color",
    "component",
    "disabled",
    "disableElevation",
    "disableFocusRipple",
    "disableRipple",
    "fullWidth",
    "orientation",
    "size",
    "variant"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: color2,
    component,
    disabled,
    disableElevation,
    disableFocusRipple,
    disableRipple,
    fullWidth,
    orientation,
    size,
    variant
  });
  const classes = useUtilityClasses$Q(ownerState);
  const context = React$1c.useMemo(() => ({
    className: classes.grouped,
    color: color2,
    disabled,
    disableElevation,
    disableFocusRipple,
    disableRipple,
    fullWidth,
    size,
    variant
  }), [color2, disabled, disableElevation, disableFocusRipple, disableRipple, fullWidth, size, variant, classes.grouped]);
  const validChildren = getValidReactChildren(children);
  const childrenCount = validChildren.length;
  const getButtonPositionClassName = (index2) => {
    const isFirstButton = index2 === 0;
    const isLastButton = index2 === childrenCount - 1;
    if (isFirstButton && isLastButton) {
      return "";
    }
    if (isFirstButton) {
      return classes.firstButton;
    }
    if (isLastButton) {
      return classes.lastButton;
    }
    return classes.middleButton;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonGroupRoot, __spreadProps(__spreadValues({
    as: component,
    role: "group",
    className: clsx(classes.root, className),
    ref,
    ownerState
  }, other), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonGroupContext.Provider, {
      value: context,
      children: validChildren.map((child, index2) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonGroupButtonContext.Provider, {
          value: getButtonPositionClassName(index2),
          children: child
        }, index2);
      })
    })
  }));
});
function getCardUtilityClass(slot) {
  return generateUtilityClass("MuiCard", slot);
}
generateUtilityClasses("MuiCard", ["root"]);
const React$1b = window["React"];
const useUtilityClasses$P = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getCardUtilityClass, classes);
};
const CardRoot = styled(Paper, {
  name: "MuiCard",
  slot: "Root"
})({
  overflow: "hidden"
});
const Card = /* @__PURE__ */ React$1b.forwardRef(function Card2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCard"
  });
  const _a2 = props, {
    className,
    raised = false
  } = _a2, other = __objRest(_a2, [
    "className",
    "raised"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    raised
  });
  const classes = useUtilityClasses$P(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CardRoot, __spreadValues({
    className: clsx(classes.root, className),
    elevation: raised ? 8 : void 0,
    ref,
    ownerState
  }, other));
});
function getCardActionsUtilityClass(slot) {
  return generateUtilityClass("MuiCardActions", slot);
}
generateUtilityClasses("MuiCardActions", ["root", "spacing"]);
const React$1a = window["React"];
const useUtilityClasses$O = (ownerState) => {
  const {
    classes,
    disableSpacing
  } = ownerState;
  const slots = {
    root: ["root", !disableSpacing && "spacing"]
  };
  return composeClasses(slots, getCardActionsUtilityClass, classes);
};
const CardActionsRoot = styled("div", {
  name: "MuiCardActions",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.disableSpacing && styles2.spacing];
  }
})({
  display: "flex",
  alignItems: "center",
  padding: 8,
  variants: [{
    props: {
      disableSpacing: false
    },
    style: {
      "& > :not(style) ~ :not(style)": {
        marginLeft: 8
      }
    }
  }]
});
const CardActions = /* @__PURE__ */ React$1a.forwardRef(function CardActions2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCardActions"
  });
  const _a2 = props, {
    disableSpacing = false,
    className
  } = _a2, other = __objRest(_a2, [
    "disableSpacing",
    "className"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    disableSpacing
  });
  const classes = useUtilityClasses$O(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CardActionsRoot, __spreadValues({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
function getCardContentUtilityClass(slot) {
  return generateUtilityClass("MuiCardContent", slot);
}
generateUtilityClasses("MuiCardContent", ["root"]);
const React$19 = window["React"];
const useUtilityClasses$N = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getCardContentUtilityClass, classes);
};
const CardContentRoot = styled("div", {
  name: "MuiCardContent",
  slot: "Root"
})({
  padding: 16,
  "&:last-child": {
    paddingBottom: 24
  }
});
const CardContent = /* @__PURE__ */ React$19.forwardRef(function CardContent2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCardContent"
  });
  const _a2 = props, {
    className,
    component = "div"
  } = _a2, other = __objRest(_a2, [
    "className",
    "component"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component
  });
  const classes = useUtilityClasses$N(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CardContentRoot, __spreadValues({
    as: component,
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
function getSwitchBaseUtilityClass(slot) {
  return generateUtilityClass("PrivateSwitchBase", slot);
}
generateUtilityClasses("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]);
const React$18 = window["React"];
const useUtilityClasses$M = (ownerState) => {
  const {
    classes,
    checked,
    disabled,
    edge
  } = ownerState;
  const slots = {
    root: ["root", checked && "checked", disabled && "disabled", edge && `edge${capitalize(edge)}`],
    input: ["input"]
  };
  return composeClasses(slots, getSwitchBaseUtilityClass, classes);
};
const SwitchBaseRoot = styled(ButtonBase, {
  name: "MuiSwitchBase"
})({
  padding: 9,
  borderRadius: "50%",
  variants: [{
    props: {
      edge: "start",
      size: "small"
    },
    style: {
      marginLeft: -3
    }
  }, {
    props: ({
      edge,
      ownerState
    }) => edge === "start" && ownerState.size !== "small",
    style: {
      marginLeft: -12
    }
  }, {
    props: {
      edge: "end",
      size: "small"
    },
    style: {
      marginRight: -3
    }
  }, {
    props: ({
      edge,
      ownerState
    }) => edge === "end" && ownerState.size !== "small",
    style: {
      marginRight: -12
    }
  }]
});
const SwitchBaseInput = styled("input", {
  name: "MuiSwitchBase",
  shouldForwardProp: rootShouldForwardProp
})({
  cursor: "inherit",
  position: "absolute",
  opacity: 0,
  width: "100%",
  height: "100%",
  top: 0,
  left: 0,
  margin: 0,
  padding: 0,
  zIndex: 1
});
const SwitchBase = /* @__PURE__ */ React$18.forwardRef(function SwitchBase2(props, ref) {
  const _a2 = props, {
    autoFocus,
    checked: checkedProp,
    checkedIcon,
    defaultChecked,
    disabled: disabledProp,
    disableFocusRipple = false,
    edge = false,
    icon,
    id,
    inputProps,
    inputRef,
    name: name2,
    onBlur,
    onChange,
    onFocus,
    readOnly,
    required = false,
    tabIndex,
    type,
    value,
    slots = {},
    slotProps = {}
  } = _a2, other = __objRest(_a2, [
    "autoFocus",
    "checked",
    "checkedIcon",
    "defaultChecked",
    "disabled",
    "disableFocusRipple",
    "edge",
    "icon",
    "id",
    "inputProps",
    "inputRef",
    "name",
    "onBlur",
    "onChange",
    "onFocus",
    "readOnly",
    "required",
    "tabIndex",
    "type",
    "value",
    "slots",
    "slotProps"
  ]);
  const [checked, setCheckedState] = useControlled({
    controlled: checkedProp,
    default: Boolean(defaultChecked),
    name: "SwitchBase",
    state: "checked"
  });
  const muiFormControl = useFormControl();
  const handleFocus = (event) => {
    if (onFocus) {
      onFocus(event);
    }
    if (muiFormControl && muiFormControl.onFocus) {
      muiFormControl.onFocus(event);
    }
  };
  const handleBlur = (event) => {
    if (onBlur) {
      onBlur(event);
    }
    if (muiFormControl && muiFormControl.onBlur) {
      muiFormControl.onBlur(event);
    }
  };
  const handleInputChange = (event) => {
    if (event.nativeEvent.defaultPrevented) {
      return;
    }
    const newChecked = event.target.checked;
    setCheckedState(newChecked);
    if (onChange) {
      onChange(event, newChecked);
    }
  };
  let disabled = disabledProp;
  if (muiFormControl) {
    if (typeof disabled === "undefined") {
      disabled = muiFormControl.disabled;
    }
  }
  const hasLabelFor = type === "checkbox" || type === "radio";
  const ownerState = __spreadProps(__spreadValues({}, props), {
    checked,
    disabled,
    disableFocusRipple,
    edge
  });
  const classes = useUtilityClasses$M(ownerState);
  const externalForwardedProps = {
    slots,
    slotProps: __spreadValues({
      input: inputProps
    }, slotProps)
  };
  const [RootSlot, rootSlotProps] = useSlot("root", {
    ref,
    elementType: SwitchBaseRoot,
    className: classes.root,
    shouldForwardComponentProp: true,
    externalForwardedProps: __spreadValues(__spreadProps(__spreadValues({}, externalForwardedProps), {
      component: "span"
    }), other),
    getSlotProps: (handlers) => __spreadProps(__spreadValues({}, handlers), {
      onFocus: (event) => {
        var _a3;
        (_a3 = handlers.onFocus) == null ? void 0 : _a3.call(handlers, event);
        handleFocus(event);
      },
      onBlur: (event) => {
        var _a3;
        (_a3 = handlers.onBlur) == null ? void 0 : _a3.call(handlers, event);
        handleBlur(event);
      }
    }),
    ownerState,
    additionalProps: {
      centerRipple: true,
      focusRipple: !disableFocusRipple,
      disabled,
      role: void 0,
      tabIndex: null
    }
  });
  const [InputSlot, inputSlotProps] = useSlot("input", {
    ref: inputRef,
    elementType: SwitchBaseInput,
    className: classes.input,
    externalForwardedProps,
    getSlotProps: (handlers) => __spreadProps(__spreadValues({}, handlers), {
      onChange: (event) => {
        var _a3;
        (_a3 = handlers.onChange) == null ? void 0 : _a3.call(handlers, event);
        handleInputChange(event);
      }
    }),
    ownerState,
    additionalProps: __spreadValues({
      autoFocus,
      checked: checkedProp,
      defaultChecked,
      disabled,
      id: hasLabelFor ? id : void 0,
      name: name2,
      readOnly,
      required,
      tabIndex,
      type
    }, type === "checkbox" && value === void 0 ? {} : {
      value
    })
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, __spreadProps(__spreadValues({}, rootSlotProps), {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(InputSlot, __spreadValues({}, inputSlotProps)), checked ? checkedIcon : icon]
  }));
});
const CheckBoxOutlineBlankIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
}));
const CheckBoxIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
}));
const IndeterminateCheckBoxIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"
}));
function getCheckboxUtilityClass(slot) {
  return generateUtilityClass("MuiCheckbox", slot);
}
const checkboxClasses = generateUtilityClasses("MuiCheckbox", ["root", "checked", "disabled", "indeterminate", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium"]);
const React$17 = window["React"];
const useUtilityClasses$L = (ownerState) => {
  const {
    classes,
    indeterminate,
    color: color2,
    size
  } = ownerState;
  const slots = {
    root: ["root", indeterminate && "indeterminate", `color${capitalize(color2)}`, `size${capitalize(size)}`]
  };
  const composedClasses = composeClasses(slots, getCheckboxUtilityClass, classes);
  return __spreadValues(__spreadValues({}, classes), composedClasses);
};
const CheckboxRoot = styled(SwitchBase, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiCheckbox",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.indeterminate && styles2.indeterminate, styles2[`size${capitalize(ownerState.size)}`], ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  color: (theme2.vars || theme2).palette.text.secondary,
  variants: [{
    props: {
      color: "default",
      disableRipple: false
    },
    style: {
      "&:hover": {
        backgroundColor: theme2.alpha((theme2.vars || theme2).palette.action.active, (theme2.vars || theme2).palette.action.hoverOpacity)
      }
    }
  }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2,
      disableRipple: false
    },
    style: {
      "&:hover": {
        backgroundColor: theme2.alpha((theme2.vars || theme2).palette[color2].main, (theme2.vars || theme2).palette.action.hoverOpacity)
      }
    }
  })), ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      [`&.${checkboxClasses.checked}, &.${checkboxClasses.indeterminate}`]: {
        color: (theme2.vars || theme2).palette[color2].main
      },
      [`&.${checkboxClasses.disabled}`]: {
        color: (theme2.vars || theme2).palette.action.disabled
      }
    }
  })), {
    // Should be last to override other colors
    props: {
      disableRipple: false
    },
    style: {
      // Reset on touch devices, it doesn't add specificity
      "&:hover": {
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }]
})));
const defaultCheckedIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(CheckBoxIcon, {});
const defaultIcon$1 = /* @__PURE__ */ jsxRuntimeExports.jsx(CheckBoxOutlineBlankIcon, {});
const defaultIndeterminateIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(IndeterminateCheckBoxIcon, {});
const Checkbox = /* @__PURE__ */ React$17.forwardRef(function Checkbox2(inProps, ref) {
  var _b, _c, _d;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCheckbox"
  });
  const _a2 = props, {
    checkedIcon = defaultCheckedIcon,
    color: color2 = "primary",
    icon: iconProp = defaultIcon$1,
    indeterminate = false,
    indeterminateIcon: indeterminateIconProp = defaultIndeterminateIcon,
    inputProps,
    size = "medium",
    disableRipple = false,
    className,
    slots = {},
    slotProps = {}
  } = _a2, other = __objRest(_a2, [
    "checkedIcon",
    "color",
    "icon",
    "indeterminate",
    "indeterminateIcon",
    "inputProps",
    "size",
    "disableRipple",
    "className",
    "slots",
    "slotProps"
  ]);
  const icon = indeterminate ? indeterminateIconProp : iconProp;
  const indeterminateIcon = indeterminate ? indeterminateIconProp : checkedIcon;
  const ownerState = __spreadProps(__spreadValues({}, props), {
    disableRipple,
    color: color2,
    indeterminate,
    size
  });
  const classes = useUtilityClasses$L(ownerState);
  const externalInputProps = (_b = slotProps.input) != null ? _b : inputProps;
  const [RootSlot, rootSlotProps] = useSlot("root", {
    ref,
    elementType: CheckboxRoot,
    className: clsx(classes.root, className),
    shouldForwardComponentProp: true,
    externalForwardedProps: __spreadValues({
      slots,
      slotProps
    }, other),
    ownerState,
    additionalProps: {
      type: "checkbox",
      icon: /* @__PURE__ */ React$17.cloneElement(icon, {
        fontSize: (_c = icon.props.fontSize) != null ? _c : size
      }),
      checkedIcon: /* @__PURE__ */ React$17.cloneElement(indeterminateIcon, {
        fontSize: (_d = indeterminateIcon.props.fontSize) != null ? _d : size
      }),
      disableRipple,
      slots,
      slotProps: {
        input: mergeSlotProps$1(typeof externalInputProps === "function" ? externalInputProps(ownerState) : externalInputProps, {
          "data-indeterminate": indeterminate
        })
      }
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, __spreadProps(__spreadValues({}, rootSlotProps), {
    classes
  }));
});
const React$16 = window["React"];
function mapEventPropToEvent(eventProp) {
  return eventProp.substring(2).toLowerCase();
}
function clickedRootScrollbar(event, doc) {
  return doc.documentElement.clientWidth < event.clientX || doc.documentElement.clientHeight < event.clientY;
}
function ClickAwayListener(props) {
  const {
    children,
    disableReactTree = false,
    mouseEvent = "onClick",
    onClickAway,
    touchEvent = "onTouchEnd"
  } = props;
  const movedRef = React$16.useRef(false);
  const nodeRef = React$16.useRef(null);
  const activatedRef = React$16.useRef(false);
  const syntheticEventRef = React$16.useRef(false);
  React$16.useEffect(() => {
    setTimeout(() => {
      activatedRef.current = true;
    }, 0);
    return () => {
      activatedRef.current = false;
    };
  }, []);
  const handleRef = useForkRef(getReactElementRef(children), nodeRef);
  const handleClickAway = useEventCallback((event) => {
    const insideReactTree = syntheticEventRef.current;
    syntheticEventRef.current = false;
    const doc = ownerDocument(nodeRef.current);
    if (!activatedRef.current || !nodeRef.current || "clientX" in event && clickedRootScrollbar(event, doc)) {
      return;
    }
    if (movedRef.current) {
      movedRef.current = false;
      return;
    }
    let insideDOM;
    if (event.composedPath) {
      insideDOM = event.composedPath().includes(nodeRef.current);
    } else {
      insideDOM = !doc.documentElement.contains(
        // @ts-expect-error returns `false` as intended when not dispatched from a Node
        event.target
      ) || nodeRef.current.contains(
        // @ts-expect-error returns `false` as intended when not dispatched from a Node
        event.target
      );
    }
    if (!insideDOM && (disableReactTree || !insideReactTree)) {
      onClickAway(event);
    }
  });
  const createHandleSynthetic = (handlerName) => (event) => {
    syntheticEventRef.current = true;
    const childrenPropsHandler = children.props[handlerName];
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  };
  const childrenProps = {
    ref: handleRef
  };
  if (touchEvent !== false) {
    childrenProps[touchEvent] = createHandleSynthetic(touchEvent);
  }
  React$16.useEffect(() => {
    if (touchEvent !== false) {
      const mappedTouchEvent = mapEventPropToEvent(touchEvent);
      const doc = ownerDocument(nodeRef.current);
      const handleTouchMove = () => {
        movedRef.current = true;
      };
      doc.addEventListener(mappedTouchEvent, handleClickAway);
      doc.addEventListener("touchmove", handleTouchMove);
      return () => {
        doc.removeEventListener(mappedTouchEvent, handleClickAway);
        doc.removeEventListener("touchmove", handleTouchMove);
      };
    }
    return void 0;
  }, [handleClickAway, touchEvent]);
  if (mouseEvent !== false) {
    childrenProps[mouseEvent] = createHandleSynthetic(mouseEvent);
  }
  React$16.useEffect(() => {
    if (mouseEvent !== false) {
      const mappedMouseEvent = mapEventPropToEvent(mouseEvent);
      const doc = ownerDocument(nodeRef.current);
      doc.addEventListener(mappedMouseEvent, handleClickAway);
      return () => {
        doc.removeEventListener(mappedMouseEvent, handleClickAway);
      };
    }
    return void 0;
  }, [handleClickAway, mouseEvent]);
  return /* @__PURE__ */ React$16.cloneElement(children, childrenProps);
}
const Container = createContainer({
  createStyledComponent: styled("div", {
    name: "MuiContainer",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, styles2[`maxWidth${capitalize(String(ownerState.maxWidth))}`], ownerState.fixed && styles2.fixed, ownerState.disableGutters && styles2.disableGutters];
    }
  }),
  useThemeProps: (inProps) => useDefaultProps({
    props: inProps,
    name: "MuiContainer"
  })
});
const React$15 = window["React"];
const isDynamicSupport = typeof globalCss({}) === "function";
const html = (theme2, enableColorScheme) => __spreadValues({
  WebkitFontSmoothing: "antialiased",
  // Antialiasing.
  MozOsxFontSmoothing: "grayscale",
  // Antialiasing.
  // Change from `box-sizing: content-box` so that `width`
  // is not affected by `padding` or `border`.
  boxSizing: "border-box",
  // Fix font resize problem in iOS
  WebkitTextSizeAdjust: "100%"
}, enableColorScheme && !theme2.vars && {
  colorScheme: theme2.palette.mode
});
const body = (theme2) => __spreadProps(__spreadValues({
  color: (theme2.vars || theme2).palette.text.primary
}, theme2.typography.body1), {
  backgroundColor: (theme2.vars || theme2).palette.background.default,
  "@media print": {
    // Save printer ink.
    backgroundColor: (theme2.vars || theme2).palette.common.white
  }
});
const styles$2 = (theme2, enableColorScheme = false) => {
  var _a2, _b;
  const colorSchemeStyles = {};
  if (enableColorScheme && theme2.colorSchemes && typeof theme2.getColorSchemeSelector === "function") {
    Object.entries(theme2.colorSchemes).forEach(([key, scheme]) => {
      var _a3, _b2;
      const selector = theme2.getColorSchemeSelector(key);
      if (selector.startsWith("@")) {
        colorSchemeStyles[selector] = {
          ":root": {
            colorScheme: (_a3 = scheme.palette) == null ? void 0 : _a3.mode
          }
        };
      } else {
        colorSchemeStyles[selector.replace(/\s*&/, "")] = {
          colorScheme: (_b2 = scheme.palette) == null ? void 0 : _b2.mode
        };
      }
    });
  }
  let defaultStyles = __spreadValues({
    html: html(theme2, enableColorScheme),
    "*, *::before, *::after": {
      boxSizing: "inherit"
    },
    "strong, b": {
      fontWeight: theme2.typography.fontWeightBold
    },
    body: __spreadProps(__spreadValues({
      margin: 0
    }, body(theme2)), {
      // Add support for document.body.requestFullScreen().
      // Other elements, if background transparent, are not supported.
      "&::backdrop": {
        backgroundColor: (theme2.vars || theme2).palette.background.default
      }
    })
  }, colorSchemeStyles);
  const themeOverrides = (_b = (_a2 = theme2.components) == null ? void 0 : _a2.MuiCssBaseline) == null ? void 0 : _b.styleOverrides;
  if (themeOverrides) {
    defaultStyles = [defaultStyles, themeOverrides];
  }
  return defaultStyles;
};
const SELECTOR = "mui-ecs";
const staticStyles = (theme2) => {
  const result = styles$2(theme2, false);
  const baseStyles = Array.isArray(result) ? result[0] : result;
  if (!theme2.vars && baseStyles) {
    baseStyles.html[`:root:has(${SELECTOR})`] = {
      colorScheme: theme2.palette.mode
    };
  }
  if (theme2.colorSchemes) {
    Object.entries(theme2.colorSchemes).forEach(([key, scheme]) => {
      var _a2, _b;
      const selector = theme2.getColorSchemeSelector(key);
      if (selector.startsWith("@")) {
        baseStyles[selector] = {
          [`:root:not(:has(.${SELECTOR}))`]: {
            colorScheme: (_a2 = scheme.palette) == null ? void 0 : _a2.mode
          }
        };
      } else {
        baseStyles[selector.replace(/\s*&/, "")] = {
          [`&:not(:has(.${SELECTOR}))`]: {
            colorScheme: (_b = scheme.palette) == null ? void 0 : _b.mode
          }
        };
      }
    });
  }
  return result;
};
const GlobalStyles = globalCss(isDynamicSupport ? ({
  theme: theme2,
  enableColorScheme
}) => styles$2(theme2, enableColorScheme) : ({
  theme: theme2
}) => staticStyles(theme2));
function CssBaseline(inProps) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCssBaseline"
  });
  const {
    children,
    enableColorScheme = false
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(React$15.Fragment, {
    children: [isDynamicSupport && /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles, {
      enableColorScheme
    }), !isDynamicSupport && !enableColorScheme && /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: SELECTOR,
      style: {
        display: "none"
      }
    }), children]
  });
}
function getScrollbarSize(win = window) {
  const documentWidth = win.document.documentElement.clientWidth;
  return win.innerWidth - documentWidth;
}
function isOverflowing(container) {
  const doc = ownerDocument(container);
  if (doc.body === container) {
    return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
  }
  return container.scrollHeight > container.clientHeight;
}
function ariaHidden(element, hide2) {
  if (hide2) {
    element.setAttribute("aria-hidden", "true");
  } else {
    element.removeAttribute("aria-hidden");
  }
}
function getPaddingRight(element) {
  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
}
function isAriaHiddenForbiddenOnElement(element) {
  const forbiddenTagNames = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"];
  const isForbiddenTagName = forbiddenTagNames.includes(element.tagName);
  const isInputHidden = element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
  return isForbiddenTagName || isInputHidden;
}
function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, hide2) {
  const blacklist = [mountElement, currentElement, ...elementsToExclude];
  [].forEach.call(container.children, (element) => {
    const isNotExcludedElement = !blacklist.includes(element);
    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
    if (isNotExcludedElement && isNotForbiddenElement) {
      ariaHidden(element, hide2);
    }
  });
}
function findIndexOf(items, callback) {
  let idx = -1;
  items.some((item, index2) => {
    if (callback(item)) {
      idx = index2;
      return true;
    }
    return false;
  });
  return idx;
}
function handleContainer(containerInfo, props) {
  const restoreStyle = [];
  const container = containerInfo.container;
  if (!props.disableScrollLock) {
    if (isOverflowing(container)) {
      const scrollbarSize = getScrollbarSize(ownerWindow(container));
      restoreStyle.push({
        value: container.style.paddingRight,
        property: "padding-right",
        el: container
      });
      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
      const fixedElements2 = ownerDocument(container).querySelectorAll(".mui-fixed");
      [].forEach.call(fixedElements2, (element) => {
        restoreStyle.push({
          value: element.style.paddingRight,
          property: "padding-right",
          el: element
        });
        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
      });
    }
    let scrollContainer;
    if (container.parentNode instanceof DocumentFragment) {
      scrollContainer = ownerDocument(container).body;
    } else {
      const parent = container.parentElement;
      const containerWindow = ownerWindow(container);
      scrollContainer = (parent == null ? void 0 : parent.nodeName) === "HTML" && containerWindow.getComputedStyle(parent).overflowY === "scroll" ? parent : container;
    }
    restoreStyle.push({
      value: scrollContainer.style.overflow,
      property: "overflow",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowX,
      property: "overflow-x",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowY,
      property: "overflow-y",
      el: scrollContainer
    });
    scrollContainer.style.overflow = "hidden";
  }
  const restore = () => {
    restoreStyle.forEach(({
      value,
      el,
      property
    }) => {
      if (value) {
        el.style.setProperty(property, value);
      } else {
        el.style.removeProperty(property);
      }
    });
  };
  return restore;
}
function getHiddenSiblings(container) {
  const hiddenSiblings = [];
  [].forEach.call(container.children, (element) => {
    if (element.getAttribute("aria-hidden") === "true") {
      hiddenSiblings.push(element);
    }
  });
  return hiddenSiblings;
}
class ModalManager {
  constructor() {
    this.modals = [];
    this.containers = [];
  }
  add(modal, container) {
    let modalIndex = this.modals.indexOf(modal);
    if (modalIndex !== -1) {
      return modalIndex;
    }
    modalIndex = this.modals.length;
    this.modals.push(modal);
    if (modal.modalRef) {
      ariaHidden(modal.modalRef, false);
    }
    const hiddenSiblings = getHiddenSiblings(container);
    ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
    const containerIndex = findIndexOf(this.containers, (item) => item.container === container);
    if (containerIndex !== -1) {
      this.containers[containerIndex].modals.push(modal);
      return modalIndex;
    }
    this.containers.push({
      modals: [modal],
      container,
      restore: null,
      hiddenSiblings
    });
    return modalIndex;
  }
  mount(modal, props) {
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.includes(modal));
    const containerInfo = this.containers[containerIndex];
    if (!containerInfo.restore) {
      containerInfo.restore = handleContainer(containerInfo, props);
    }
  }
  remove(modal, ariaHiddenState = true) {
    const modalIndex = this.modals.indexOf(modal);
    if (modalIndex === -1) {
      return modalIndex;
    }
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.includes(modal));
    const containerInfo = this.containers[containerIndex];
    containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
    this.modals.splice(modalIndex, 1);
    if (containerInfo.modals.length === 0) {
      if (containerInfo.restore) {
        containerInfo.restore();
      }
      if (modal.modalRef) {
        ariaHidden(modal.modalRef, ariaHiddenState);
      }
      ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
      this.containers.splice(containerIndex, 1);
    } else {
      const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
      if (nextTop.modalRef) {
        ariaHidden(nextTop.modalRef, false);
      }
    }
    return modalIndex;
  }
  isTopModal(modal) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
  }
}
const React$14 = window["React"];
const candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function getTabIndex(node2) {
  const tabindexAttr = parseInt(node2.getAttribute("tabindex") || "", 10);
  if (!Number.isNaN(tabindexAttr)) {
    return tabindexAttr;
  }
  if (node2.contentEditable === "true" || (node2.nodeName === "AUDIO" || node2.nodeName === "VIDEO" || node2.nodeName === "DETAILS") && node2.getAttribute("tabindex") === null) {
    return 0;
  }
  return node2.tabIndex;
}
function isNonTabbableRadio(node2) {
  if (node2.tagName !== "INPUT" || node2.type !== "radio") {
    return false;
  }
  if (!node2.name) {
    return false;
  }
  const getRadio = (selector) => node2.ownerDocument.querySelector(`input[type="radio"]${selector}`);
  let roving = getRadio(`[name="${node2.name}"]:checked`);
  if (!roving) {
    roving = getRadio(`[name="${node2.name}"]`);
  }
  return roving !== node2;
}
function isNodeMatchingSelectorFocusable(node2) {
  if (node2.disabled || node2.tagName === "INPUT" && node2.type === "hidden" || isNonTabbableRadio(node2)) {
    return false;
  }
  return true;
}
function defaultGetTabbable(root) {
  const regularTabNodes = [];
  const orderedTabNodes = [];
  Array.from(root.querySelectorAll(candidatesSelector)).forEach((node2, i) => {
    const nodeTabIndex = getTabIndex(node2);
    if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node2)) {
      return;
    }
    if (nodeTabIndex === 0) {
      regularTabNodes.push(node2);
    } else {
      orderedTabNodes.push({
        documentOrder: i,
        tabIndex: nodeTabIndex,
        node: node2
      });
    }
  });
  return orderedTabNodes.sort((a, b) => a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex).map((a) => a.node).concat(regularTabNodes);
}
function defaultIsEnabled() {
  return true;
}
function FocusTrap(props) {
  const {
    children,
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableRestoreFocus = false,
    getTabbable = defaultGetTabbable,
    isEnabled = defaultIsEnabled,
    open
  } = props;
  const ignoreNextEnforceFocus = React$14.useRef(false);
  const sentinelStart = React$14.useRef(null);
  const sentinelEnd = React$14.useRef(null);
  const nodeToRestore = React$14.useRef(null);
  const reactFocusEventTarget = React$14.useRef(null);
  const activated = React$14.useRef(false);
  const rootRef = React$14.useRef(null);
  const handleRef = useForkRef(getReactElementRef(children), rootRef);
  const lastKeydown = React$14.useRef(null);
  React$14.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    activated.current = !disableAutoFocus;
  }, [disableAutoFocus, open]);
  React$14.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    if (!rootRef.current.contains(doc.activeElement)) {
      if (!rootRef.current.hasAttribute("tabIndex")) {
        rootRef.current.setAttribute("tabIndex", "-1");
      }
      if (activated.current) {
        rootRef.current.focus();
      }
    }
    return () => {
      if (!disableRestoreFocus) {
        if (nodeToRestore.current && nodeToRestore.current.focus) {
          ignoreNextEnforceFocus.current = true;
          nodeToRestore.current.focus();
        }
        nodeToRestore.current = null;
      }
    };
  }, [open]);
  React$14.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    const loopFocus = (nativeEvent) => {
      lastKeydown.current = nativeEvent;
      if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== "Tab") {
        return;
      }
      if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
        ignoreNextEnforceFocus.current = true;
        if (sentinelEnd.current) {
          sentinelEnd.current.focus();
        }
      }
    };
    const contain = () => {
      var _a2, _b;
      const rootElement = rootRef.current;
      if (rootElement === null) {
        return;
      }
      if (!doc.hasFocus() || !isEnabled() || ignoreNextEnforceFocus.current) {
        ignoreNextEnforceFocus.current = false;
        return;
      }
      if (rootElement.contains(doc.activeElement)) {
        return;
      }
      if (disableEnforceFocus && doc.activeElement !== sentinelStart.current && doc.activeElement !== sentinelEnd.current) {
        return;
      }
      if (doc.activeElement !== reactFocusEventTarget.current) {
        reactFocusEventTarget.current = null;
      } else if (reactFocusEventTarget.current !== null) {
        return;
      }
      if (!activated.current) {
        return;
      }
      let tabbable = [];
      if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
        tabbable = getTabbable(rootRef.current);
      }
      if (tabbable.length > 0) {
        const isShiftTab = Boolean(((_a2 = lastKeydown.current) == null ? void 0 : _a2.shiftKey) && ((_b = lastKeydown.current) == null ? void 0 : _b.key) === "Tab");
        const focusNext = tabbable[0];
        const focusPrevious = tabbable[tabbable.length - 1];
        if (typeof focusNext !== "string" && typeof focusPrevious !== "string") {
          if (isShiftTab) {
            focusPrevious.focus();
          } else {
            focusNext.focus();
          }
        }
      } else {
        rootElement.focus();
      }
    };
    doc.addEventListener("focusin", contain);
    doc.addEventListener("keydown", loopFocus, true);
    const interval = setInterval(() => {
      if (doc.activeElement && doc.activeElement.tagName === "BODY") {
        contain();
      }
    }, 50);
    return () => {
      clearInterval(interval);
      doc.removeEventListener("focusin", contain);
      doc.removeEventListener("keydown", loopFocus, true);
    };
  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);
  const onFocus = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
    reactFocusEventTarget.current = event.target;
    const childrenPropsHandler = children.props.onFocus;
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  };
  const handleFocusSentinel = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(React$14.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelStart,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ React$14.cloneElement(children, {
      ref: handleRef,
      onFocus
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelEnd,
      "data-testid": "sentinelEnd"
    })]
  });
}
const React$13 = window["React"];
function getContainer(container) {
  return typeof container === "function" ? container() : container;
}
function getHasTransition(children) {
  return children ? children.props.hasOwnProperty("in") : false;
}
const noop$2 = () => {
};
const manager = new ModalManager();
function useModal(parameters) {
  const {
    container,
    disableEscapeKeyDown = false,
    disableScrollLock = false,
    closeAfterTransition = false,
    onTransitionEnter,
    onTransitionExited,
    children,
    onClose,
    open,
    rootRef
  } = parameters;
  const modal = React$13.useRef({});
  const mountNodeRef = React$13.useRef(null);
  const modalRef = React$13.useRef(null);
  const handleRef = useForkRef(modalRef, rootRef);
  const [exited, setExited] = React$13.useState(!open);
  const hasTransition = getHasTransition(children);
  let ariaHiddenProp = true;
  if (parameters["aria-hidden"] === "false" || parameters["aria-hidden"] === false) {
    ariaHiddenProp = false;
  }
  const getDoc = () => ownerDocument(mountNodeRef.current);
  const getModal = () => {
    modal.current.modalRef = modalRef.current;
    modal.current.mount = mountNodeRef.current;
    return modal.current;
  };
  const handleMounted = () => {
    manager.mount(getModal(), {
      disableScrollLock
    });
    if (modalRef.current) {
      modalRef.current.scrollTop = 0;
    }
  };
  const handleOpen = useEventCallback(() => {
    const resolvedContainer = getContainer(container) || getDoc().body;
    manager.add(getModal(), resolvedContainer);
    if (modalRef.current) {
      handleMounted();
    }
  });
  const isTopModal = () => manager.isTopModal(getModal());
  const handlePortalRef = useEventCallback((node2) => {
    mountNodeRef.current = node2;
    if (!node2) {
      return;
    }
    if (open && isTopModal()) {
      handleMounted();
    } else if (modalRef.current) {
      ariaHidden(modalRef.current, ariaHiddenProp);
    }
  });
  const handleClose = React$13.useCallback(() => {
    manager.remove(getModal(), ariaHiddenProp);
  }, [ariaHiddenProp]);
  React$13.useEffect(() => {
    return () => {
      handleClose();
    };
  }, [handleClose]);
  React$13.useEffect(() => {
    if (open) {
      handleOpen();
    } else if (!hasTransition || !closeAfterTransition) {
      handleClose();
    }
  }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
  const createHandleKeyDown = (otherHandlers) => (event) => {
    var _a2;
    (_a2 = otherHandlers.onKeyDown) == null ? void 0 : _a2.call(otherHandlers, event);
    if (event.key !== "Escape" || event.which === 229 || // Wait until IME is settled.
    !isTopModal()) {
      return;
    }
    if (!disableEscapeKeyDown) {
      event.stopPropagation();
      if (onClose) {
        onClose(event, "escapeKeyDown");
      }
    }
  };
  const createHandleBackdropClick = (otherHandlers) => (event) => {
    var _a2;
    (_a2 = otherHandlers.onClick) == null ? void 0 : _a2.call(otherHandlers, event);
    if (event.target !== event.currentTarget) {
      return;
    }
    if (onClose) {
      onClose(event, "backdropClick");
    }
  };
  const getRootProps = (otherHandlers = {}) => {
    const propsEventHandlers = extractEventHandlers(parameters);
    delete propsEventHandlers.onTransitionEnter;
    delete propsEventHandlers.onTransitionExited;
    const externalEventHandlers = __spreadValues(__spreadValues({}, propsEventHandlers), otherHandlers);
    return __spreadProps(__spreadValues({
      /*
       * Marking an element with the role presentation indicates to assistive technology
       * that this element should be ignored; it exists to support the web application and
       * is not meant for humans to interact with directly.
       * https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-static-element-interactions.md
       */
      role: "presentation"
    }, externalEventHandlers), {
      onKeyDown: createHandleKeyDown(externalEventHandlers),
      ref: handleRef
    });
  };
  const getBackdropProps = (otherHandlers = {}) => {
    const externalEventHandlers = otherHandlers;
    return __spreadProps(__spreadValues({
      "aria-hidden": true
    }, externalEventHandlers), {
      onClick: createHandleBackdropClick(externalEventHandlers),
      open
    });
  };
  const getTransitionProps2 = () => {
    var _a2, _b;
    const handleEnter = () => {
      setExited(false);
      if (onTransitionEnter) {
        onTransitionEnter();
      }
    };
    const handleExited = () => {
      setExited(true);
      if (onTransitionExited) {
        onTransitionExited();
      }
      if (closeAfterTransition) {
        handleClose();
      }
    };
    return {
      onEnter: createChainedFunction(handleEnter, (_a2 = children == null ? void 0 : children.props.onEnter) != null ? _a2 : noop$2),
      onExited: createChainedFunction(handleExited, (_b = children == null ? void 0 : children.props.onExited) != null ? _b : noop$2)
    };
  };
  return {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    rootRef: handleRef,
    portalRef: handlePortalRef,
    isTopModal,
    exited,
    hasTransition
  };
}
function getModalUtilityClass(slot) {
  return generateUtilityClass("MuiModal", slot);
}
generateUtilityClasses("MuiModal", ["root", "hidden", "backdrop"]);
const React$12 = window["React"];
const useUtilityClasses$K = (ownerState) => {
  const {
    open,
    exited,
    classes
  } = ownerState;
  const slots = {
    root: ["root", !open && exited && "hidden"],
    backdrop: ["backdrop"]
  };
  return composeClasses(slots, getModalUtilityClass, classes);
};
const ModalRoot = styled("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.open && ownerState.exited && styles2.hidden];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  position: "fixed",
  zIndex: (theme2.vars || theme2).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.open && ownerState.exited,
    style: {
      visibility: "hidden"
    }
  }]
})));
const ModalBackdrop = styled(Backdrop, {
  name: "MuiModal",
  slot: "Backdrop"
})({
  zIndex: -1
});
const Modal = /* @__PURE__ */ React$12.forwardRef(function Modal2(inProps, ref) {
  const props = useDefaultProps({
    name: "MuiModal",
    props: inProps
  });
  const _a2 = props, {
    BackdropComponent = ModalBackdrop,
    BackdropProps,
    classes: classesProp,
    className,
    closeAfterTransition = false,
    children,
    container,
    component,
    components = {},
    componentsProps = {},
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableEscapeKeyDown = false,
    disablePortal = false,
    disableRestoreFocus = false,
    disableScrollLock = false,
    hideBackdrop = false,
    keepMounted = false,
    onClose,
    onTransitionEnter,
    onTransitionExited,
    open,
    slotProps = {},
    slots = {},
    theme: theme2
  } = _a2, other = __objRest(_a2, [
    "BackdropComponent",
    "BackdropProps",
    "classes",
    "className",
    "closeAfterTransition",
    "children",
    "container",
    "component",
    "components",
    "componentsProps",
    "disableAutoFocus",
    "disableEnforceFocus",
    "disableEscapeKeyDown",
    "disablePortal",
    "disableRestoreFocus",
    "disableScrollLock",
    "hideBackdrop",
    "keepMounted",
    "onClose",
    "onTransitionEnter",
    "onTransitionExited",
    "open",
    "slotProps",
    "slots",
    // eslint-disable-next-line react/prop-types
    "theme"
  ]);
  const propsWithDefaults = __spreadProps(__spreadValues({}, props), {
    closeAfterTransition,
    disableAutoFocus,
    disableEnforceFocus,
    disableEscapeKeyDown,
    disablePortal,
    disableRestoreFocus,
    disableScrollLock,
    hideBackdrop,
    keepMounted
  });
  const {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    portalRef,
    isTopModal,
    exited,
    hasTransition
  } = useModal(__spreadProps(__spreadValues({}, propsWithDefaults), {
    rootRef: ref
  }));
  const ownerState = __spreadProps(__spreadValues({}, propsWithDefaults), {
    exited
  });
  const classes = useUtilityClasses$K(ownerState);
  const childProps = {};
  if (children.props.tabIndex === void 0) {
    childProps.tabIndex = "-1";
  }
  if (hasTransition) {
    const {
      onEnter,
      onExited
    } = getTransitionProps2();
    childProps.onEnter = onEnter;
    childProps.onExited = onExited;
  }
  const externalForwardedProps = {
    slots: __spreadValues({
      root: components.Root,
      backdrop: components.Backdrop
    }, slots),
    slotProps: __spreadValues(__spreadValues({}, componentsProps), slotProps)
  };
  const [RootSlot, rootProps] = useSlot("root", {
    ref,
    elementType: ModalRoot,
    externalForwardedProps: __spreadProps(__spreadValues(__spreadValues({}, externalForwardedProps), other), {
      component
    }),
    getSlotProps: getRootProps,
    ownerState,
    className: clsx(className, classes == null ? void 0 : classes.root, !ownerState.open && ownerState.exited && (classes == null ? void 0 : classes.hidden))
  });
  const [BackdropSlot, backdropProps] = useSlot("backdrop", {
    ref: BackdropProps == null ? void 0 : BackdropProps.ref,
    elementType: BackdropComponent,
    externalForwardedProps,
    shouldForwardComponentProp: true,
    additionalProps: BackdropProps,
    getSlotProps: (otherHandlers) => {
      return getBackdropProps(__spreadProps(__spreadValues({}, otherHandlers), {
        onClick: (event) => {
          if (otherHandlers == null ? void 0 : otherHandlers.onClick) {
            otherHandlers.onClick(event);
          }
        }
      }));
    },
    className: clsx(BackdropProps == null ? void 0 : BackdropProps.className, classes == null ? void 0 : classes.backdrop),
    ownerState
  });
  if (!keepMounted && !open && (!hasTransition || exited)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
    ref: portalRef,
    container,
    disablePortal,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, __spreadProps(__spreadValues({}, rootProps), {
      children: [!hideBackdrop && BackdropComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropSlot, __spreadValues({}, backdropProps)) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap, {
        disableEnforceFocus,
        disableAutoFocus,
        disableRestoreFocus,
        isEnabled: isTopModal,
        open,
        children: /* @__PURE__ */ React$12.cloneElement(children, childProps)
      })]
    }))
  });
});
function getDialogUtilityClass(slot) {
  return generateUtilityClass("MuiDialog", slot);
}
const dialogClasses = generateUtilityClasses("MuiDialog", ["root", "scrollPaper", "scrollBody", "container", "paper", "paperScrollPaper", "paperScrollBody", "paperWidthFalse", "paperWidthXs", "paperWidthSm", "paperWidthMd", "paperWidthLg", "paperWidthXl", "paperFullWidth", "paperFullScreen"]);
const React$11 = window["React"];
const DialogContext = /* @__PURE__ */ React$11.createContext({});
const React$10 = window["React"];
const DialogBackdrop = styled(Backdrop, {
  name: "MuiDialog",
  slot: "Backdrop",
  overrides: (props, styles2) => styles2.backdrop
})({
  // Improve scrollable dialog support.
  zIndex: -1
});
const useUtilityClasses$J = (ownerState) => {
  const {
    classes,
    scroll,
    maxWidth: maxWidth2,
    fullWidth,
    fullScreen
  } = ownerState;
  const slots = {
    root: ["root"],
    container: ["container", `scroll${capitalize(scroll)}`],
    paper: ["paper", `paperScroll${capitalize(scroll)}`, `paperWidth${capitalize(String(maxWidth2))}`, fullWidth && "paperFullWidth", fullScreen && "paperFullScreen"]
  };
  return composeClasses(slots, getDialogUtilityClass, classes);
};
const DialogRoot = styled(Modal, {
  name: "MuiDialog",
  slot: "Root"
})({
  "@media print": {
    // Use !important to override the Modal inline-style.
    position: "absolute !important"
  }
});
const DialogContainer = styled("div", {
  name: "MuiDialog",
  slot: "Container",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.container, styles2[`scroll${capitalize(ownerState.scroll)}`]];
  }
})({
  height: "100%",
  "@media print": {
    height: "auto"
  },
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  variants: [{
    props: {
      scroll: "paper"
    },
    style: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center"
    }
  }, {
    props: {
      scroll: "body"
    },
    style: {
      overflowY: "auto",
      overflowX: "hidden",
      textAlign: "center",
      "&::after": {
        content: '""',
        display: "inline-block",
        verticalAlign: "middle",
        height: "100%",
        width: "0"
      }
    }
  }]
});
const DialogPaper = styled(Paper, {
  name: "MuiDialog",
  slot: "Paper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.paper, styles2[`scrollPaper${capitalize(ownerState.scroll)}`], styles2[`paperWidth${capitalize(String(ownerState.maxWidth))}`], ownerState.fullWidth && styles2.paperFullWidth, ownerState.fullScreen && styles2.paperFullScreen];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  margin: 32,
  position: "relative",
  overflowY: "auto",
  "@media print": {
    overflowY: "visible",
    boxShadow: "none"
  },
  variants: [{
    props: {
      scroll: "paper"
    },
    style: {
      display: "flex",
      flexDirection: "column",
      maxHeight: "calc(100% - 64px)"
    }
  }, {
    props: {
      scroll: "body"
    },
    style: {
      display: "inline-block",
      verticalAlign: "middle",
      textAlign: "initial"
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.maxWidth,
    style: {
      maxWidth: "calc(100% - 64px)"
    }
  }, {
    props: {
      maxWidth: "xs"
    },
    style: {
      maxWidth: theme2.breakpoints.unit === "px" ? Math.max(theme2.breakpoints.values.xs, 444) : `max(${theme2.breakpoints.values.xs}${theme2.breakpoints.unit}, 444px)`,
      [`&.${dialogClasses.paperScrollBody}`]: {
        [theme2.breakpoints.down(Math.max(theme2.breakpoints.values.xs, 444) + 32 * 2)]: {
          maxWidth: "calc(100% - 64px)"
        }
      }
    }
  }, ...Object.keys(theme2.breakpoints.values).filter((maxWidth2) => maxWidth2 !== "xs").map((maxWidth2) => ({
    props: {
      maxWidth: maxWidth2
    },
    style: {
      maxWidth: `${theme2.breakpoints.values[maxWidth2]}${theme2.breakpoints.unit}`,
      [`&.${dialogClasses.paperScrollBody}`]: {
        [theme2.breakpoints.down(theme2.breakpoints.values[maxWidth2] + 32 * 2)]: {
          maxWidth: "calc(100% - 64px)"
        }
      }
    }
  })), {
    props: ({
      ownerState
    }) => ownerState.fullWidth,
    style: {
      width: "calc(100% - 64px)"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.fullScreen,
    style: {
      margin: 0,
      width: "100%",
      maxWidth: "100%",
      height: "100%",
      maxHeight: "none",
      borderRadius: 0,
      [`&.${dialogClasses.paperScrollBody}`]: {
        margin: 0,
        maxWidth: "100%"
      }
    }
  }]
})));
const Dialog = /* @__PURE__ */ React$10.forwardRef(function Dialog2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDialog"
  });
  const theme2 = useTheme();
  const defaultTransitionDuration = {
    enter: theme2.transitions.duration.enteringScreen,
    exit: theme2.transitions.duration.leavingScreen
  };
  const _a2 = props, {
    "aria-describedby": ariaDescribedby,
    "aria-labelledby": ariaLabelledbyProp,
    "aria-modal": ariaModal = true,
    BackdropComponent,
    BackdropProps,
    children,
    className,
    disableEscapeKeyDown = false,
    fullScreen = false,
    fullWidth = false,
    maxWidth: maxWidth2 = "sm",
    onClick,
    onClose,
    open,
    PaperComponent = Paper,
    PaperProps = {},
    scroll = "paper",
    slots = {},
    slotProps = {},
    TransitionComponent = Fade,
    transitionDuration = defaultTransitionDuration,
    TransitionProps
  } = _a2, other = __objRest(_a2, [
    "aria-describedby",
    "aria-labelledby",
    "aria-modal",
    "BackdropComponent",
    "BackdropProps",
    "children",
    "className",
    "disableEscapeKeyDown",
    "fullScreen",
    "fullWidth",
    "maxWidth",
    "onClick",
    "onClose",
    "open",
    "PaperComponent",
    "PaperProps",
    "scroll",
    "slots",
    "slotProps",
    "TransitionComponent",
    "transitionDuration",
    "TransitionProps"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    disableEscapeKeyDown,
    fullScreen,
    fullWidth,
    maxWidth: maxWidth2,
    scroll
  });
  const classes = useUtilityClasses$J(ownerState);
  const backdropClick = React$10.useRef();
  const handleMouseDown = (event) => {
    backdropClick.current = event.target === event.currentTarget;
  };
  const handleBackdropClick = (event) => {
    if (onClick) {
      onClick(event);
    }
    if (!backdropClick.current) {
      return;
    }
    backdropClick.current = null;
    if (onClose) {
      onClose(event, "backdropClick");
    }
  };
  const ariaLabelledby = useId(ariaLabelledbyProp);
  const dialogContextValue = React$10.useMemo(() => {
    return {
      titleId: ariaLabelledby
    };
  }, [ariaLabelledby]);
  const backwardCompatibleSlots = __spreadValues({
    transition: TransitionComponent
  }, slots);
  const backwardCompatibleSlotProps = __spreadValues({
    transition: TransitionProps,
    paper: PaperProps,
    backdrop: BackdropProps
  }, slotProps);
  const externalForwardedProps = {
    slots: backwardCompatibleSlots,
    slotProps: backwardCompatibleSlotProps
  };
  const [RootSlot, rootSlotProps] = useSlot("root", {
    elementType: DialogRoot,
    shouldForwardComponentProp: true,
    externalForwardedProps,
    ownerState,
    className: clsx(classes.root, className),
    ref
  });
  const [BackdropSlot, backdropSlotProps] = useSlot("backdrop", {
    elementType: DialogBackdrop,
    shouldForwardComponentProp: true,
    externalForwardedProps,
    ownerState
  });
  const [PaperSlot, paperSlotProps] = useSlot("paper", {
    elementType: DialogPaper,
    shouldForwardComponentProp: true,
    externalForwardedProps,
    ownerState,
    className: clsx(classes.paper, PaperProps.className)
  });
  const [ContainerSlot, containerSlotProps] = useSlot("container", {
    elementType: DialogContainer,
    externalForwardedProps,
    ownerState,
    className: classes.container
  });
  const [TransitionSlot, transitionSlotProps] = useSlot("transition", {
    elementType: Fade,
    externalForwardedProps,
    ownerState,
    additionalProps: {
      appear: true,
      in: open,
      timeout: transitionDuration,
      role: "presentation"
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, __spreadProps(__spreadValues(__spreadValues({
    closeAfterTransition: true,
    slots: {
      backdrop: BackdropSlot
    },
    slotProps: {
      backdrop: __spreadValues({
        transitionDuration,
        as: BackdropComponent
      }, backdropSlotProps)
    },
    disableEscapeKeyDown,
    onClose,
    open,
    onClick: handleBackdropClick
  }, rootSlotProps), other), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionSlot, __spreadProps(__spreadValues({}, transitionSlotProps), {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ContainerSlot, __spreadProps(__spreadValues({
        onMouseDown: handleMouseDown
      }, containerSlotProps), {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaperSlot, __spreadProps(__spreadValues({
          as: PaperComponent,
          elevation: 24,
          role: "dialog",
          "aria-describedby": ariaDescribedby,
          "aria-labelledby": ariaLabelledby,
          "aria-modal": ariaModal
        }, paperSlotProps), {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContext.Provider, {
            value: dialogContextValue,
            children
          })
        }))
      }))
    }))
  }));
});
function getDialogActionsUtilityClass(slot) {
  return generateUtilityClass("MuiDialogActions", slot);
}
generateUtilityClasses("MuiDialogActions", ["root", "spacing"]);
const React$$ = window["React"];
const useUtilityClasses$I = (ownerState) => {
  const {
    classes,
    disableSpacing
  } = ownerState;
  const slots = {
    root: ["root", !disableSpacing && "spacing"]
  };
  return composeClasses(slots, getDialogActionsUtilityClass, classes);
};
const DialogActionsRoot = styled("div", {
  name: "MuiDialogActions",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.disableSpacing && styles2.spacing];
  }
})({
  display: "flex",
  alignItems: "center",
  padding: 8,
  justifyContent: "flex-end",
  flex: "0 0 auto",
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.disableSpacing,
    style: {
      "& > :not(style) ~ :not(style)": {
        marginLeft: 8
      }
    }
  }]
});
const DialogActions = /* @__PURE__ */ React$$.forwardRef(function DialogActions2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDialogActions"
  });
  const _a2 = props, {
    className,
    disableSpacing = false
  } = _a2, other = __objRest(_a2, [
    "className",
    "disableSpacing"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    disableSpacing
  });
  const classes = useUtilityClasses$I(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActionsRoot, __spreadValues({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
function getDialogContentUtilityClass(slot) {
  return generateUtilityClass("MuiDialogContent", slot);
}
generateUtilityClasses("MuiDialogContent", ["root", "dividers"]);
function getDialogTitleUtilityClass(slot) {
  return generateUtilityClass("MuiDialogTitle", slot);
}
const dialogTitleClasses = generateUtilityClasses("MuiDialogTitle", ["root"]);
const React$_ = window["React"];
const useUtilityClasses$H = (ownerState) => {
  const {
    classes,
    dividers
  } = ownerState;
  const slots = {
    root: ["root", dividers && "dividers"]
  };
  return composeClasses(slots, getDialogContentUtilityClass, classes);
};
const DialogContentRoot = styled("div", {
  name: "MuiDialogContent",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.dividers && styles2.dividers];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  flex: "1 1 auto",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch",
  overflowY: "auto",
  padding: "20px 24px",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.dividers,
    style: {
      padding: "16px 24px",
      borderTop: `1px solid ${(theme2.vars || theme2).palette.divider}`,
      borderBottom: `1px solid ${(theme2.vars || theme2).palette.divider}`
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.dividers,
    style: {
      [`.${dialogTitleClasses.root} + &`]: {
        paddingTop: 0
      }
    }
  }]
})));
const DialogContent = /* @__PURE__ */ React$_.forwardRef(function DialogContent2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDialogContent"
  });
  const _a2 = props, {
    className,
    dividers = false
  } = _a2, other = __objRest(_a2, [
    "className",
    "dividers"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    dividers
  });
  const classes = useUtilityClasses$H(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentRoot, __spreadValues({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
function getDialogContentTextUtilityClass(slot) {
  return generateUtilityClass("MuiDialogContentText", slot);
}
generateUtilityClasses("MuiDialogContentText", ["root"]);
const React$Z = window["React"];
const useUtilityClasses$G = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  const composedClasses = composeClasses(slots, getDialogContentTextUtilityClass, classes);
  return __spreadValues(__spreadValues({}, classes), composedClasses);
};
const DialogContentTextRoot = styled(Typography, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiDialogContentText",
  slot: "Root"
})({});
const DialogContentText = /* @__PURE__ */ React$Z.forwardRef(function DialogContentText2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDialogContentText"
  });
  const _a2 = props, {
    children,
    className
  } = _a2, ownerState = __objRest(_a2, [
    "children",
    "className"
  ]);
  const classes = useUtilityClasses$G(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentTextRoot, __spreadProps(__spreadValues({
    component: "p",
    variant: "body1",
    color: "textSecondary",
    ref,
    ownerState,
    className: clsx(classes.root, className)
  }, props), {
    classes
  }));
});
const React$Y = window["React"];
const useUtilityClasses$F = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getDialogTitleUtilityClass, classes);
};
const DialogTitleRoot = styled(Typography, {
  name: "MuiDialogTitle",
  slot: "Root"
})({
  padding: "16px 24px",
  flex: "0 0 auto"
});
const DialogTitle = /* @__PURE__ */ React$Y.forwardRef(function DialogTitle2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDialogTitle"
  });
  const _a2 = props, {
    className,
    id: idProp
  } = _a2, other = __objRest(_a2, [
    "className",
    "id"
  ]);
  const ownerState = props;
  const classes = useUtilityClasses$F(ownerState);
  const {
    titleId = idProp
  } = React$Y.useContext(DialogContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitleRoot, __spreadValues({
    component: "h2",
    className: clsx(classes.root, className),
    ownerState,
    ref,
    variant: "h6",
    id: idProp != null ? idProp : titleId
  }, other));
});
function getDividerUtilityClass(slot) {
  return generateUtilityClass("MuiDivider", slot);
}
const dividerClasses = generateUtilityClasses("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]);
const React$X = window["React"];
const useUtilityClasses$E = (ownerState) => {
  const {
    absolute,
    children,
    classes,
    flexItem,
    light: light2,
    orientation,
    textAlign,
    variant
  } = ownerState;
  const slots = {
    root: ["root", absolute && "absolute", variant, light2 && "light", orientation === "vertical" && "vertical", flexItem && "flexItem", children && "withChildren", children && orientation === "vertical" && "withChildrenVertical", textAlign === "right" && orientation !== "vertical" && "textAlignRight", textAlign === "left" && orientation !== "vertical" && "textAlignLeft"],
    wrapper: ["wrapper", orientation === "vertical" && "wrapperVertical"]
  };
  return composeClasses(slots, getDividerUtilityClass, classes);
};
const DividerRoot = styled("div", {
  name: "MuiDivider",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.absolute && styles2.absolute, styles2[ownerState.variant], ownerState.light && styles2.light, ownerState.orientation === "vertical" && styles2.vertical, ownerState.flexItem && styles2.flexItem, ownerState.children && styles2.withChildren, ownerState.children && ownerState.orientation === "vertical" && styles2.withChildrenVertical, ownerState.textAlign === "right" && ownerState.orientation !== "vertical" && styles2.textAlignRight, ownerState.textAlign === "left" && ownerState.orientation !== "vertical" && styles2.textAlignLeft];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  margin: 0,
  // Reset browser default style.
  flexShrink: 0,
  borderWidth: 0,
  borderStyle: "solid",
  borderColor: (theme2.vars || theme2).palette.divider,
  borderBottomWidth: "thin",
  variants: [{
    props: {
      absolute: true
    },
    style: {
      position: "absolute",
      bottom: 0,
      left: 0,
      width: "100%"
    }
  }, {
    props: {
      light: true
    },
    style: {
      borderColor: theme2.alpha((theme2.vars || theme2).palette.divider, 0.08)
    }
  }, {
    props: {
      variant: "inset"
    },
    style: {
      marginLeft: 72
    }
  }, {
    props: {
      variant: "middle",
      orientation: "horizontal"
    },
    style: {
      marginLeft: theme2.spacing(2),
      marginRight: theme2.spacing(2)
    }
  }, {
    props: {
      variant: "middle",
      orientation: "vertical"
    },
    style: {
      marginTop: theme2.spacing(1),
      marginBottom: theme2.spacing(1)
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      borderBottomWidth: 0,
      borderRightWidth: "thin"
    }
  }, {
    props: {
      flexItem: true
    },
    style: {
      alignSelf: "stretch",
      height: "auto"
    }
  }, {
    props: ({
      ownerState
    }) => !!ownerState.children,
    style: {
      display: "flex",
      textAlign: "center",
      border: 0,
      borderTopStyle: "solid",
      borderLeftStyle: "solid",
      "&::before, &::after": {
        content: '""',
        alignSelf: "center"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.children && ownerState.orientation !== "vertical",
    style: {
      "&::before, &::after": {
        width: "100%",
        borderTop: `thin solid ${(theme2.vars || theme2).palette.divider}`,
        borderTopStyle: "inherit"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.orientation === "vertical" && ownerState.children,
    style: {
      flexDirection: "column",
      "&::before, &::after": {
        height: "100%",
        borderLeft: `thin solid ${(theme2.vars || theme2).palette.divider}`,
        borderLeftStyle: "inherit"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.textAlign === "right" && ownerState.orientation !== "vertical",
    style: {
      "&::before": {
        width: "90%"
      },
      "&::after": {
        width: "10%"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.textAlign === "left" && ownerState.orientation !== "vertical",
    style: {
      "&::before": {
        width: "10%"
      },
      "&::after": {
        width: "90%"
      }
    }
  }]
})));
const DividerWrapper = styled("span", {
  name: "MuiDivider",
  slot: "Wrapper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.wrapper, ownerState.orientation === "vertical" && styles2.wrapperVertical];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  display: "inline-block",
  paddingLeft: `calc(${theme2.spacing(1)} * 1.2)`,
  paddingRight: `calc(${theme2.spacing(1)} * 1.2)`,
  whiteSpace: "nowrap",
  variants: [{
    props: {
      orientation: "vertical"
    },
    style: {
      paddingTop: `calc(${theme2.spacing(1)} * 1.2)`,
      paddingBottom: `calc(${theme2.spacing(1)} * 1.2)`
    }
  }]
})));
const Divider = /* @__PURE__ */ React$X.forwardRef(function Divider2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDivider"
  });
  const _a2 = props, {
    absolute = false,
    children,
    className,
    orientation = "horizontal",
    component = children || orientation === "vertical" ? "div" : "hr",
    flexItem = false,
    light: light2 = false,
    role = component !== "hr" ? "separator" : void 0,
    textAlign = "center",
    variant = "fullWidth"
  } = _a2, other = __objRest(_a2, [
    "absolute",
    "children",
    "className",
    "orientation",
    "component",
    "flexItem",
    "light",
    "role",
    "textAlign",
    "variant"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    absolute,
    component,
    flexItem,
    light: light2,
    orientation,
    role,
    textAlign,
    variant
  });
  const classes = useUtilityClasses$E(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DividerRoot, __spreadProps(__spreadValues({
    as: component,
    className: clsx(classes.root, className),
    role,
    ref,
    ownerState,
    "aria-orientation": role === "separator" && (component !== "hr" || orientation === "vertical") ? orientation : void 0
  }, other), {
    children: children ? /* @__PURE__ */ jsxRuntimeExports.jsx(DividerWrapper, {
      className: classes.wrapper,
      ownerState,
      children
    }) : null
  }));
});
if (Divider) {
  Divider.muiSkipListHighlight = true;
}
function getFabUtilityClass(slot) {
  return generateUtilityClass("MuiFab", slot);
}
const fabClasses = generateUtilityClasses("MuiFab", ["root", "primary", "secondary", "extended", "circular", "focusVisible", "disabled", "colorInherit", "sizeSmall", "sizeMedium", "sizeLarge", "info", "error", "warning", "success"]);
const React$W = window["React"];
const useUtilityClasses$D = (ownerState) => {
  const {
    color: color2,
    variant,
    classes,
    size
  } = ownerState;
  const slots = {
    root: ["root", variant, `size${capitalize(size)}`, color2 === "inherit" ? "colorInherit" : color2]
  };
  const composedClasses = composeClasses(slots, getFabUtilityClass, classes);
  return __spreadValues(__spreadValues({}, classes), composedClasses);
};
const FabRoot = styled(ButtonBase, {
  name: "MuiFab",
  slot: "Root",
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`size${capitalize(ownerState.size)}`], ownerState.color === "inherit" && styles2.colorInherit, styles2[capitalize(ownerState.size)], styles2[ownerState.color]];
  }
})(memoTheme(({
  theme: theme2
}) => {
  var _a2, _b;
  return __spreadProps(__spreadValues({}, theme2.typography.button), {
    minHeight: 36,
    transition: theme2.transitions.create(["background-color", "box-shadow", "border-color"], {
      duration: theme2.transitions.duration.short
    }),
    borderRadius: "50%",
    padding: 0,
    minWidth: 0,
    width: 56,
    height: 56,
    zIndex: (theme2.vars || theme2).zIndex.fab,
    boxShadow: (theme2.vars || theme2).shadows[6],
    "&:active": {
      boxShadow: (theme2.vars || theme2).shadows[12]
    },
    color: theme2.vars ? theme2.vars.palette.grey[900] : (_b = (_a2 = theme2.palette).getContrastText) == null ? void 0 : _b.call(_a2, theme2.palette.grey[300]),
    backgroundColor: (theme2.vars || theme2).palette.grey[300],
    "&:hover": {
      backgroundColor: (theme2.vars || theme2).palette.grey.A100,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: (theme2.vars || theme2).palette.grey[300]
      },
      textDecoration: "none"
    },
    [`&.${fabClasses.focusVisible}`]: {
      boxShadow: (theme2.vars || theme2).shadows[6]
    },
    variants: [{
      props: {
        size: "small"
      },
      style: {
        width: 40,
        height: 40
      }
    }, {
      props: {
        size: "medium"
      },
      style: {
        width: 48,
        height: 48
      }
    }, {
      props: {
        variant: "extended"
      },
      style: {
        borderRadius: 48 / 2,
        padding: "0 16px",
        width: "auto",
        minHeight: "auto",
        minWidth: 48,
        height: 48
      }
    }, {
      props: {
        variant: "extended",
        size: "small"
      },
      style: {
        width: "auto",
        padding: "0 8px",
        borderRadius: 34 / 2,
        minWidth: 34,
        height: 34
      }
    }, {
      props: {
        variant: "extended",
        size: "medium"
      },
      style: {
        width: "auto",
        padding: "0 16px",
        borderRadius: 40 / 2,
        minWidth: 40,
        height: 40
      }
    }, {
      props: {
        color: "inherit"
      },
      style: {
        color: "inherit"
      }
    }]
  });
}), memoTheme(({
  theme: theme2
}) => ({
  variants: [...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["dark", "contrastText"])).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      color: (theme2.vars || theme2).palette[color2].contrastText,
      backgroundColor: (theme2.vars || theme2).palette[color2].main,
      "&:hover": {
        backgroundColor: (theme2.vars || theme2).palette[color2].dark,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: (theme2.vars || theme2).palette[color2].main
        }
      }
    }
  }))]
})), memoTheme(({
  theme: theme2
}) => ({
  [`&.${fabClasses.disabled}`]: {
    color: (theme2.vars || theme2).palette.action.disabled,
    boxShadow: (theme2.vars || theme2).shadows[0],
    backgroundColor: (theme2.vars || theme2).palette.action.disabledBackground
  }
})));
const Fab = /* @__PURE__ */ React$W.forwardRef(function Fab2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFab"
  });
  const _a2 = props, {
    children,
    className,
    color: color2 = "default",
    component = "button",
    disabled = false,
    disableFocusRipple = false,
    focusVisibleClassName,
    size = "large",
    variant = "circular"
  } = _a2, other = __objRest(_a2, [
    "children",
    "className",
    "color",
    "component",
    "disabled",
    "disableFocusRipple",
    "focusVisibleClassName",
    "size",
    "variant"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: color2,
    component,
    disabled,
    disableFocusRipple,
    size,
    variant
  });
  const classes = useUtilityClasses$D(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FabRoot, __spreadProps(__spreadValues({
    className: clsx(classes.root, className),
    component,
    disabled,
    focusRipple: !disableFocusRipple,
    focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
    ownerState,
    ref
  }, other), {
    classes,
    children
  }));
});
const React$V = window["React"];
const useUtilityClasses$C = (ownerState) => {
  const {
    classes,
    disableUnderline,
    startAdornment,
    endAdornment,
    size,
    hiddenLabel,
    multiline
  } = ownerState;
  const slots = {
    root: ["root", !disableUnderline && "underline", startAdornment && "adornedStart", endAdornment && "adornedEnd", size === "small" && `size${capitalize(size)}`, hiddenLabel && "hiddenLabel", multiline && "multiline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getFilledInputUtilityClass, classes);
  return __spreadValues(__spreadValues({}, classes), composedClasses);
};
const FilledInputRoot = styled(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiFilledInput",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
  }
})(memoTheme(({
  theme: theme2
}) => {
  const light2 = theme2.palette.mode === "light";
  const bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  const backgroundColor2 = light2 ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)";
  const hoverBackground = light2 ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)";
  const disabledBackground = light2 ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
  return {
    position: "relative",
    backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.bg : backgroundColor2,
    borderTopLeftRadius: (theme2.vars || theme2).shape.borderRadius,
    borderTopRightRadius: (theme2.vars || theme2).shape.borderRadius,
    transition: theme2.transitions.create("background-color", {
      duration: theme2.transitions.duration.shorter,
      easing: theme2.transitions.easing.easeOut
    }),
    "&:hover": {
      backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.hoverBg : hoverBackground,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.bg : backgroundColor2
      }
    },
    [`&.${filledInputClasses.focused}`]: {
      backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.bg : backgroundColor2
    },
    [`&.${filledInputClasses.disabled}`]: {
      backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.disabledBg : disabledBackground
    },
    variants: [{
      props: ({
        ownerState
      }) => !ownerState.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: theme2.transitions.create("transform", {
            duration: theme2.transitions.duration.shorter,
            easing: theme2.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${filledInputClasses.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${filledInputClasses.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (theme2.vars || theme2).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${theme2.vars ? theme2.alpha(theme2.vars.palette.common.onBackground, theme2.vars.opacity.inputUnderline) : bottomLineColor}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: theme2.transitions.create("border-bottom-color", {
            duration: theme2.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${filledInputClasses.disabled}, .${filledInputClasses.error}):before`]: {
          borderBottom: `1px solid ${(theme2.vars || theme2).palette.text.primary}`
        },
        [`&.${filledInputClasses.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => {
      var _a2;
      return {
        props: {
          disableUnderline: false,
          color: color2
        },
        style: {
          "&::after": {
            borderBottom: `2px solid ${(_a2 = (theme2.vars || theme2).palette[color2]) == null ? void 0 : _a2.main}`
          }
        }
      };
    }), {
      props: ({
        ownerState
      }) => ownerState.startAdornment,
      style: {
        paddingLeft: 12
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.endAdornment,
      style: {
        paddingRight: 12
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.multiline,
      style: {
        padding: "25px 12px 8px"
      }
    }, {
      props: ({
        ownerState,
        size
      }) => ownerState.multiline && size === "small",
      style: {
        paddingTop: 21,
        paddingBottom: 4
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.multiline && ownerState.hiddenLabel,
      style: {
        paddingTop: 16,
        paddingBottom: 17
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.multiline && ownerState.hiddenLabel && ownerState.size === "small",
      style: {
        paddingTop: 8,
        paddingBottom: 9
      }
    }]
  };
}));
const FilledInputInput = styled(InputBaseInput, {
  name: "MuiFilledInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(memoTheme(({
  theme: theme2
}) => __spreadProps(__spreadValues(__spreadValues({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12
}, !theme2.vars && {
  "&:-webkit-autofill": {
    WebkitBoxShadow: theme2.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
    WebkitTextFillColor: theme2.palette.mode === "light" ? null : "#fff",
    caretColor: theme2.palette.mode === "light" ? null : "#fff",
    borderTopLeftRadius: "inherit",
    borderTopRightRadius: "inherit"
  }
}), theme2.vars && {
  "&:-webkit-autofill": {
    borderTopLeftRadius: "inherit",
    borderTopRightRadius: "inherit"
  },
  [theme2.getColorSchemeSelector("dark")]: {
    "&:-webkit-autofill": {
      WebkitBoxShadow: "0 0 0 100px #266798 inset",
      WebkitTextFillColor: "#fff",
      caretColor: "#fff"
    }
  }
}), {
  variants: [{
    props: {
      size: "small"
    },
    style: {
      paddingTop: 21,
      paddingBottom: 4
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.hiddenLabel,
    style: {
      paddingTop: 16,
      paddingBottom: 17
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.endAdornment,
    style: {
      paddingRight: 0
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.hiddenLabel && ownerState.size === "small",
    style: {
      paddingTop: 8,
      paddingBottom: 9
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.multiline,
    style: {
      paddingTop: 0,
      paddingBottom: 0,
      paddingLeft: 0,
      paddingRight: 0
    }
  }]
})));
const FilledInput = /* @__PURE__ */ React$V.forwardRef(function FilledInput2(inProps, ref) {
  var _b, _c, _d, _e;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFilledInput"
  });
  const _a2 = props, {
    disableUnderline = false,
    components = {},
    componentsProps: componentsPropsProp,
    fullWidth = false,
    hiddenLabel,
    inputComponent: inputComponent = "input",
    multiline = false,
    slotProps,
    slots = {},
    type = "text"
  } = _a2, other = __objRest(_a2, [
    "disableUnderline",
    "components",
    "componentsProps",
    "fullWidth",
    "hiddenLabel",
    // declare here to prevent spreading to DOM
    "inputComponent",
    "multiline",
    "slotProps",
    "slots",
    "type"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    disableUnderline,
    fullWidth,
    inputComponent,
    multiline,
    type
  });
  const classes = useUtilityClasses$C(props);
  const filledInputComponentsProps = {
    root: {
      ownerState
    },
    input: {
      ownerState
    }
  };
  const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge(filledInputComponentsProps, slotProps != null ? slotProps : componentsPropsProp) : filledInputComponentsProps;
  const RootSlot = (_c = (_b = slots.root) != null ? _b : components.Root) != null ? _c : FilledInputRoot;
  const InputSlot = (_e = (_d = slots.input) != null ? _d : components.Input) != null ? _e : FilledInputInput;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase, __spreadProps(__spreadValues({
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    slotProps: componentsProps,
    fullWidth,
    inputComponent,
    multiline,
    ref,
    type
  }, other), {
    classes
  }));
});
FilledInput.muiName = "Input";
function getFormControlUtilityClasses(slot) {
  return generateUtilityClass("MuiFormControl", slot);
}
generateUtilityClasses("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
const React$U = window["React"];
const useUtilityClasses$B = (ownerState) => {
  const {
    classes,
    margin: margin2,
    fullWidth
  } = ownerState;
  const slots = {
    root: ["root", margin2 !== "none" && `margin${capitalize(margin2)}`, fullWidth && "fullWidth"]
  };
  return composeClasses(slots, getFormControlUtilityClasses, classes);
};
const FormControlRoot = styled("div", {
  name: "MuiFormControl",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`margin${capitalize(ownerState.margin)}`], ownerState.fullWidth && styles2.fullWidth];
  }
})({
  display: "inline-flex",
  flexDirection: "column",
  position: "relative",
  // Reset fieldset default style.
  minWidth: 0,
  padding: 0,
  margin: 0,
  border: 0,
  verticalAlign: "top",
  // Fix alignment issue on Safari.
  variants: [{
    props: {
      margin: "normal"
    },
    style: {
      marginTop: 16,
      marginBottom: 8
    }
  }, {
    props: {
      margin: "dense"
    },
    style: {
      marginTop: 8,
      marginBottom: 4
    }
  }, {
    props: {
      fullWidth: true
    },
    style: {
      width: "100%"
    }
  }]
});
const FormControl = /* @__PURE__ */ React$U.forwardRef(function FormControl2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFormControl"
  });
  const _a2 = props, {
    children,
    className,
    color: color2 = "primary",
    component = "div",
    disabled = false,
    error = false,
    focused: visuallyFocused,
    fullWidth = false,
    hiddenLabel = false,
    margin: margin2 = "none",
    required = false,
    size = "medium",
    variant = "outlined"
  } = _a2, other = __objRest(_a2, [
    "children",
    "className",
    "color",
    "component",
    "disabled",
    "error",
    "focused",
    "fullWidth",
    "hiddenLabel",
    "margin",
    "required",
    "size",
    "variant"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: color2,
    component,
    disabled,
    error,
    fullWidth,
    hiddenLabel,
    margin: margin2,
    required,
    size,
    variant
  });
  const classes = useUtilityClasses$B(ownerState);
  const [adornedStart, setAdornedStart] = React$U.useState(() => {
    let initialAdornedStart = false;
    if (children) {
      React$U.Children.forEach(children, (child) => {
        if (!isMuiElement(child, ["Input", "Select"])) {
          return;
        }
        const input = isMuiElement(child, ["Select"]) ? child.props.input : child;
        if (input && isAdornedStart(input.props)) {
          initialAdornedStart = true;
        }
      });
    }
    return initialAdornedStart;
  });
  const [filled, setFilled] = React$U.useState(() => {
    let initialFilled = false;
    if (children) {
      React$U.Children.forEach(children, (child) => {
        if (!isMuiElement(child, ["Input", "Select"])) {
          return;
        }
        if (isFilled(child.props, true) || isFilled(child.props.inputProps, true)) {
          initialFilled = true;
        }
      });
    }
    return initialFilled;
  });
  const [focusedState, setFocused] = React$U.useState(false);
  if (disabled && focusedState) {
    setFocused(false);
  }
  const focused = visuallyFocused !== void 0 && !disabled ? visuallyFocused : focusedState;
  let registerEffect;
  React$U.useRef(false);
  const onFilled = React$U.useCallback(() => {
    setFilled(true);
  }, []);
  const onEmpty = React$U.useCallback(() => {
    setFilled(false);
  }, []);
  const childContext = React$U.useMemo(() => {
    return {
      adornedStart,
      setAdornedStart,
      color: color2,
      disabled,
      error,
      filled,
      focused,
      fullWidth,
      hiddenLabel,
      size,
      onBlur: () => {
        setFocused(false);
      },
      onFocus: () => {
        setFocused(true);
      },
      onEmpty,
      onFilled,
      registerEffect,
      required,
      variant
    };
  }, [adornedStart, color2, disabled, error, filled, focused, fullWidth, hiddenLabel, registerEffect, onEmpty, onFilled, required, size, variant]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlRoot, __spreadProps(__spreadValues({
      as: component,
      ownerState,
      className: clsx(classes.root, className),
      ref
    }, other), {
      children
    }))
  });
});
function getFormControlLabelUtilityClasses(slot) {
  return generateUtilityClass("MuiFormControlLabel", slot);
}
const formControlLabelClasses = generateUtilityClasses("MuiFormControlLabel", ["root", "labelPlacementStart", "labelPlacementTop", "labelPlacementBottom", "disabled", "label", "error", "required", "asterisk"]);
const React$T = window["React"];
const useUtilityClasses$A = (ownerState) => {
  const {
    classes,
    disabled,
    labelPlacement,
    error,
    required
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", `labelPlacement${capitalize(labelPlacement)}`, error && "error", required && "required"],
    label: ["label", disabled && "disabled"],
    asterisk: ["asterisk", error && "error"]
  };
  return composeClasses(slots, getFormControlLabelUtilityClasses, classes);
};
const FormControlLabelRoot = styled("label", {
  name: "MuiFormControlLabel",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${formControlLabelClasses.label}`]: styles2.label
    }, styles2.root, styles2[`labelPlacement${capitalize(ownerState.labelPlacement)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  display: "inline-flex",
  alignItems: "center",
  cursor: "pointer",
  // For correct alignment with the text.
  verticalAlign: "middle",
  WebkitTapHighlightColor: "transparent",
  marginLeft: -11,
  marginRight: 16,
  // used for row presentation of radio/checkbox
  [`&.${formControlLabelClasses.disabled}`]: {
    cursor: "default"
  },
  [`& .${formControlLabelClasses.label}`]: {
    [`&.${formControlLabelClasses.disabled}`]: {
      color: (theme2.vars || theme2).palette.text.disabled
    }
  },
  variants: [{
    props: {
      labelPlacement: "start"
    },
    style: {
      flexDirection: "row-reverse",
      marginRight: -11
    }
  }, {
    props: {
      labelPlacement: "top"
    },
    style: {
      flexDirection: "column-reverse"
    }
  }, {
    props: {
      labelPlacement: "bottom"
    },
    style: {
      flexDirection: "column"
    }
  }, {
    props: ({
      labelPlacement
    }) => labelPlacement === "start" || labelPlacement === "top" || labelPlacement === "bottom",
    style: {
      marginLeft: 16
      // used for row presentation of radio/checkbox
    }
  }]
})));
const AsteriskComponent$1 = styled("span", {
  name: "MuiFormControlLabel",
  slot: "Asterisk"
})(memoTheme(({
  theme: theme2
}) => ({
  [`&.${formControlLabelClasses.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  }
})));
const FormControlLabel = /* @__PURE__ */ React$T.forwardRef(function FormControlLabel2(inProps, ref) {
  var _b;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFormControlLabel"
  });
  const _a2 = props, {
    checked,
    className,
    componentsProps = {},
    control,
    disabled: disabledProp,
    disableTypography,
    inputRef,
    label: labelProp,
    labelPlacement = "end",
    name: name2,
    onChange,
    required: requiredProp,
    slots = {},
    slotProps = {},
    value
  } = _a2, other = __objRest(_a2, [
    "checked",
    "className",
    "componentsProps",
    "control",
    "disabled",
    "disableTypography",
    "inputRef",
    "label",
    "labelPlacement",
    "name",
    "onChange",
    "required",
    "slots",
    "slotProps",
    "value"
  ]);
  const muiFormControl = useFormControl();
  const disabled = (_b = disabledProp != null ? disabledProp : control.props.disabled) != null ? _b : muiFormControl == null ? void 0 : muiFormControl.disabled;
  const required = requiredProp != null ? requiredProp : control.props.required;
  const controlProps = {
    disabled,
    required
  };
  ["checked", "name", "onChange", "value", "inputRef"].forEach((key) => {
    if (typeof control.props[key] === "undefined" && typeof props[key] !== "undefined") {
      controlProps[key] = props[key];
    }
  });
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["error"]
  });
  const ownerState = __spreadProps(__spreadValues({}, props), {
    disabled,
    labelPlacement,
    required,
    error: fcs.error
  });
  const classes = useUtilityClasses$A(ownerState);
  const externalForwardedProps = {
    slots,
    slotProps: __spreadValues(__spreadValues({}, componentsProps), slotProps)
  };
  const [TypographySlot, typographySlotProps] = useSlot("typography", {
    elementType: Typography,
    externalForwardedProps,
    ownerState
  });
  let label = labelProp;
  if (label != null && label.type !== Typography && !disableTypography) {
    label = /* @__PURE__ */ jsxRuntimeExports.jsx(TypographySlot, __spreadProps(__spreadValues({
      component: "span"
    }, typographySlotProps), {
      className: clsx(classes.label, typographySlotProps == null ? void 0 : typographySlotProps.className),
      children: label
    }));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControlLabelRoot, __spreadProps(__spreadValues({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other), {
    children: [/* @__PURE__ */ React$T.cloneElement(control, controlProps), required ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
      children: [label, /* @__PURE__ */ jsxRuntimeExports.jsxs(AsteriskComponent$1, {
        ownerState,
        "aria-hidden": true,
        className: classes.asterisk,
        children: ["", "*"]
      })]
    }) : label]
  }));
});
function getFormHelperTextUtilityClasses(slot) {
  return generateUtilityClass("MuiFormHelperText", slot);
}
const formHelperTextClasses = generateUtilityClasses("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
var _span$3;
const React$S = window["React"];
const useUtilityClasses$z = (ownerState) => {
  const {
    classes,
    contained,
    size,
    disabled,
    error,
    filled,
    focused,
    required
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", error && "error", size && `size${capitalize(size)}`, contained && "contained", focused && "focused", filled && "filled", required && "required"]
  };
  return composeClasses(slots, getFormHelperTextUtilityClasses, classes);
};
const FormHelperTextRoot = styled("p", {
  name: "MuiFormHelperText",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.size && styles2[`size${capitalize(ownerState.size)}`], ownerState.contained && styles2.contained, ownerState.filled && styles2.filled];
  }
})(memoTheme(({
  theme: theme2
}) => __spreadProps(__spreadValues({
  color: (theme2.vars || theme2).palette.text.secondary
}, theme2.typography.caption), {
  textAlign: "left",
  marginTop: 3,
  marginRight: 0,
  marginBottom: 0,
  marginLeft: 0,
  [`&.${formHelperTextClasses.disabled}`]: {
    color: (theme2.vars || theme2).palette.text.disabled
  },
  [`&.${formHelperTextClasses.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginTop: 4
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.contained,
    style: {
      marginLeft: 14,
      marginRight: 14
    }
  }]
})));
const FormHelperText = /* @__PURE__ */ React$S.forwardRef(function FormHelperText2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFormHelperText"
  });
  const _a2 = props, {
    children,
    className,
    component = "p",
    disabled,
    error,
    filled,
    focused,
    margin: margin2,
    required,
    variant
  } = _a2, other = __objRest(_a2, [
    "children",
    "className",
    "component",
    "disabled",
    "error",
    "filled",
    "focused",
    "margin",
    "required",
    "variant"
  ]);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
  });
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component,
    contained: fcs.variant === "filled" || fcs.variant === "outlined",
    variant: fcs.variant,
    size: fcs.size,
    disabled: fcs.disabled,
    error: fcs.error,
    filled: fcs.filled,
    focused: fcs.focused,
    required: fcs.required
  });
  delete ownerState.ownerState;
  const classes = useUtilityClasses$z(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperTextRoot, __spreadProps(__spreadValues({
    as: component,
    className: clsx(classes.root, className),
    ref
  }, other), {
    ownerState,
    children: children === " " ? (
      // notranslate needed while Google Translate will not fix zero-width space issue
      _span$3 || (_span$3 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: "notranslate",
        "aria-hidden": true,
        children: ""
      }))
    ) : children
  }));
});
function getFormLabelUtilityClasses(slot) {
  return generateUtilityClass("MuiFormLabel", slot);
}
const formLabelClasses = generateUtilityClasses("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]);
const React$R = window["React"];
const useUtilityClasses$y = (ownerState) => {
  const {
    classes,
    color: color2,
    focused,
    disabled,
    error,
    filled,
    required
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize(color2)}`, disabled && "disabled", error && "error", filled && "filled", focused && "focused", required && "required"],
    asterisk: ["asterisk", error && "error"]
  };
  return composeClasses(slots, getFormLabelUtilityClasses, classes);
};
const FormLabelRoot = styled("label", {
  name: "MuiFormLabel",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color === "secondary" && styles2.colorSecondary, ownerState.filled && styles2.filled];
  }
})(memoTheme(({
  theme: theme2
}) => __spreadProps(__spreadValues({
  color: (theme2.vars || theme2).palette.text.secondary
}, theme2.typography.body1), {
  lineHeight: "1.4375em",
  padding: 0,
  position: "relative",
  variants: [...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      [`&.${formLabelClasses.focused}`]: {
        color: (theme2.vars || theme2).palette[color2].main
      }
    }
  })), {
    props: {},
    style: {
      [`&.${formLabelClasses.disabled}`]: {
        color: (theme2.vars || theme2).palette.text.disabled
      },
      [`&.${formLabelClasses.error}`]: {
        color: (theme2.vars || theme2).palette.error.main
      }
    }
  }]
})));
const AsteriskComponent = styled("span", {
  name: "MuiFormLabel",
  slot: "Asterisk"
})(memoTheme(({
  theme: theme2
}) => ({
  [`&.${formLabelClasses.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  }
})));
const FormLabel = /* @__PURE__ */ React$R.forwardRef(function FormLabel2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFormLabel"
  });
  const _a2 = props, {
    children,
    className,
    color: color2,
    component = "label",
    disabled,
    error,
    filled,
    focused,
    required
  } = _a2, other = __objRest(_a2, [
    "children",
    "className",
    "color",
    "component",
    "disabled",
    "error",
    "filled",
    "focused",
    "required"
  ]);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "required", "focused", "disabled", "error", "filled"]
  });
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: fcs.color || "primary",
    component,
    disabled: fcs.disabled,
    error: fcs.error,
    filled: fcs.filled,
    focused: fcs.focused,
    required: fcs.required
  });
  const classes = useUtilityClasses$y(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(FormLabelRoot, __spreadProps(__spreadValues({
    as: component,
    ownerState,
    className: clsx(classes.root, className),
    ref
  }, other), {
    children: [children, fcs.required && /* @__PURE__ */ jsxRuntimeExports.jsxs(AsteriskComponent, {
      ownerState,
      "aria-hidden": true,
      className: classes.asterisk,
      children: ["", "*"]
    })]
  }));
});
const Grid = createGrid({
  createStyledComponent: styled("div", {
    name: "MuiGrid",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.container && styles2.container];
    }
  }),
  componentName: "MuiGrid",
  useThemeProps: (inProps) => useDefaultProps({
    props: inProps,
    name: "MuiGrid"
  }),
  useTheme
});
const React$Q = window["React"];
function getScale(value) {
  return `scale(${value}, ${__pow(value, 2)})`;
}
const styles$1 = {
  entering: {
    opacity: 1,
    transform: getScale(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
};
const isWebKit154 = typeof navigator !== "undefined" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent);
const Grow = /* @__PURE__ */ React$Q.forwardRef(function Grow2(props, ref) {
  const _a2 = props, {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = "auto",
    TransitionComponent: TransitionComponent = Transition
  } = _a2, other = __objRest(_a2, [
    "addEndListener",
    "appear",
    "children",
    "easing",
    "in",
    "onEnter",
    "onEntered",
    "onEntering",
    "onExit",
    "onExited",
    "onExiting",
    "style",
    "timeout",
    // eslint-disable-next-line react/prop-types
    "TransitionComponent"
  ]);
  const timer = useTimeout();
  const autoTimeout = React$Q.useRef();
  const theme2 = useTheme();
  const nodeRef = React$Q.useRef(null);
  const handleRef = useForkRef(nodeRef, getReactElementRef(children), ref);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const {
      duration: transitionDuration,
      delay,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    let duration2;
    if (timeout === "auto") {
      duration2 = theme2.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme2.transitions.create("opacity", {
      duration: duration2,
      delay
    }), theme2.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay,
      easing: transitionTimingFunction
    })].join(",");
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const {
      duration: transitionDuration,
      delay,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    let duration2;
    if (timeout === "auto") {
      duration2 = theme2.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme2.transitions.create("opacity", {
      duration: duration2,
      delay
    }), theme2.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay: isWebKit154 ? delay : delay || duration2 * 0.333,
      easing: transitionTimingFunction
    })].join(",");
    node2.style.opacity = 0;
    node2.style.transform = getScale(0.75);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = (next2) => {
    if (timeout === "auto") {
      timer.start(autoTimeout.current || 0, next2);
    }
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, __spreadProps(__spreadValues({
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout: timeout === "auto" ? null : timeout
  }, other), {
    children: (state, _b) => {
      var _c = _b, {
        ownerState
      } = _c, restChildProps = __objRest(_c, [
        "ownerState"
      ]);
      return /* @__PURE__ */ React$Q.cloneElement(children, __spreadValues({
        style: __spreadValues(__spreadValues(__spreadValues({
          opacity: 0,
          transform: getScale(0.75),
          visibility: state === "exited" && !inProp ? "hidden" : void 0
        }, styles$1[state]), style2), children.props.style),
        ref: handleRef
      }, restChildProps));
    }
  }));
});
if (Grow) {
  Grow.muiSupportAuto = true;
}
const React$P = window["React"];
const useUtilityClasses$x = (ownerState) => {
  const {
    classes,
    disableUnderline
  } = ownerState;
  const slots = {
    root: ["root", !disableUnderline && "underline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getInputUtilityClass, classes);
  return __spreadValues(__spreadValues({}, classes), composedClasses);
};
const InputRoot = styled(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiInput",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
  }
})(memoTheme(({
  theme: theme2
}) => {
  const light2 = theme2.palette.mode === "light";
  let bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  if (theme2.vars) {
    bottomLineColor = theme2.alpha(theme2.vars.palette.common.onBackground, theme2.vars.opacity.inputUnderline);
  }
  return {
    position: "relative",
    variants: [{
      props: ({
        ownerState
      }) => ownerState.formControl,
      style: {
        "label + &": {
          marginTop: 16
        }
      }
    }, {
      props: ({
        ownerState
      }) => !ownerState.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: theme2.transitions.create("transform", {
            duration: theme2.transitions.duration.shorter,
            easing: theme2.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${inputClasses.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${inputClasses.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (theme2.vars || theme2).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${bottomLineColor}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: theme2.transitions.create("border-bottom-color", {
            duration: theme2.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${inputClasses.disabled}, .${inputClasses.error}):before`]: {
          borderBottom: `2px solid ${(theme2.vars || theme2).palette.text.primary}`,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            borderBottom: `1px solid ${bottomLineColor}`
          }
        },
        [`&.${inputClasses.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
      props: {
        color: color2,
        disableUnderline: false
      },
      style: {
        "&::after": {
          borderBottom: `2px solid ${(theme2.vars || theme2).palette[color2].main}`
        }
      }
    }))]
  };
}));
const InputInput = styled(InputBaseInput, {
  name: "MuiInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})({});
const Input = /* @__PURE__ */ React$P.forwardRef(function Input2(inProps, ref) {
  var _b, _c, _d, _e;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiInput"
  });
  const _a2 = props, {
    disableUnderline = false,
    components = {},
    componentsProps: componentsPropsProp,
    fullWidth = false,
    inputComponent = "input",
    multiline = false,
    slotProps,
    slots = {},
    type = "text"
  } = _a2, other = __objRest(_a2, [
    "disableUnderline",
    "components",
    "componentsProps",
    "fullWidth",
    "inputComponent",
    "multiline",
    "slotProps",
    "slots",
    "type"
  ]);
  const classes = useUtilityClasses$x(props);
  const ownerState = {
    disableUnderline
  };
  const inputComponentsProps = {
    root: {
      ownerState
    }
  };
  const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge(slotProps != null ? slotProps : componentsPropsProp, inputComponentsProps) : inputComponentsProps;
  const RootSlot = (_c = (_b = slots.root) != null ? _b : components.Root) != null ? _c : InputRoot;
  const InputSlot = (_e = (_d = slots.input) != null ? _d : components.Input) != null ? _e : InputInput;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase, __spreadProps(__spreadValues({
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    slotProps: componentsProps,
    fullWidth,
    inputComponent,
    multiline,
    ref,
    type
  }, other), {
    classes
  }));
});
Input.muiName = "Input";
function getInputAdornmentUtilityClass(slot) {
  return generateUtilityClass("MuiInputAdornment", slot);
}
const inputAdornmentClasses = generateUtilityClasses("MuiInputAdornment", ["root", "filled", "standard", "outlined", "positionStart", "positionEnd", "disablePointerEvents", "hiddenLabel", "sizeSmall"]);
var _span$2;
const React$O = window["React"];
const overridesResolver$2 = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, styles2[`position${capitalize(ownerState.position)}`], ownerState.disablePointerEvents === true && styles2.disablePointerEvents, styles2[ownerState.variant]];
};
const useUtilityClasses$w = (ownerState) => {
  const {
    classes,
    disablePointerEvents,
    hiddenLabel,
    position: position2,
    size,
    variant
  } = ownerState;
  const slots = {
    root: ["root", disablePointerEvents && "disablePointerEvents", position2 && `position${capitalize(position2)}`, variant, hiddenLabel && "hiddenLabel", size && `size${capitalize(size)}`]
  };
  return composeClasses(slots, getInputAdornmentUtilityClass, classes);
};
const InputAdornmentRoot = styled("div", {
  name: "MuiInputAdornment",
  slot: "Root",
  overridesResolver: overridesResolver$2
})(memoTheme(({
  theme: theme2
}) => ({
  display: "flex",
  maxHeight: "2em",
  alignItems: "center",
  whiteSpace: "nowrap",
  color: (theme2.vars || theme2).palette.action.active,
  variants: [{
    props: {
      variant: "filled"
    },
    style: {
      [`&.${inputAdornmentClasses.positionStart}&:not(.${inputAdornmentClasses.hiddenLabel})`]: {
        marginTop: 16
      }
    }
  }, {
    props: {
      position: "start"
    },
    style: {
      marginRight: 8
    }
  }, {
    props: {
      position: "end"
    },
    style: {
      marginLeft: 8
    }
  }, {
    props: {
      disablePointerEvents: true
    },
    style: {
      pointerEvents: "none"
    }
  }]
})));
const InputAdornment = /* @__PURE__ */ React$O.forwardRef(function InputAdornment2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiInputAdornment"
  });
  const _a2 = props, {
    children,
    className,
    component = "div",
    disablePointerEvents = false,
    disableTypography = false,
    position: position2,
    variant: variantProp
  } = _a2, other = __objRest(_a2, [
    "children",
    "className",
    "component",
    "disablePointerEvents",
    "disableTypography",
    "position",
    "variant"
  ]);
  const muiFormControl = useFormControl() || {};
  let variant = variantProp;
  if (variantProp && muiFormControl.variant) ;
  if (muiFormControl && !variant) {
    variant = muiFormControl.variant;
  }
  const ownerState = __spreadProps(__spreadValues({}, props), {
    hiddenLabel: muiFormControl.hiddenLabel,
    size: muiFormControl.size,
    disablePointerEvents,
    position: position2,
    variant
  });
  const classes = useUtilityClasses$w(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext.Provider, {
    value: null,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(InputAdornmentRoot, __spreadProps(__spreadValues({
      as: component,
      ownerState,
      className: clsx(classes.root, className),
      ref
    }, other), {
      children: typeof children === "string" && !disableTypography ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, {
        color: "textSecondary",
        children
      }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(React$O.Fragment, {
        children: [position2 === "start" ? (
          /* notranslate needed while Google Translate will not fix zero-width space issue */
          _span$2 || (_span$2 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
            className: "notranslate",
            "aria-hidden": true,
            children: ""
          }))
        ) : null, children]
      })
    }))
  });
});
function getInputLabelUtilityClasses(slot) {
  return generateUtilityClass("MuiInputLabel", slot);
}
generateUtilityClasses("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
const React$N = window["React"];
const useUtilityClasses$v = (ownerState) => {
  const {
    classes,
    formControl,
    size,
    shrink,
    disableAnimation,
    variant,
    required
  } = ownerState;
  const slots = {
    root: ["root", formControl && "formControl", !disableAnimation && "animated", shrink && "shrink", size && size !== "medium" && `size${capitalize(size)}`, variant],
    asterisk: [required && "asterisk"]
  };
  const composedClasses = composeClasses(slots, getInputLabelUtilityClasses, classes);
  return __spreadValues(__spreadValues({}, classes), composedClasses);
};
const InputLabelRoot = styled(FormLabel, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiInputLabel",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${formLabelClasses.asterisk}`]: styles2.asterisk
    }, styles2.root, ownerState.formControl && styles2.formControl, ownerState.size === "small" && styles2.sizeSmall, ownerState.shrink && styles2.shrink, !ownerState.disableAnimation && styles2.animated, ownerState.focused && styles2.focused, styles2[ownerState.variant]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  display: "block",
  transformOrigin: "top left",
  whiteSpace: "nowrap",
  overflow: "hidden",
  textOverflow: "ellipsis",
  maxWidth: "100%",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.formControl,
    style: {
      position: "absolute",
      left: 0,
      top: 0,
      // slight alteration to spec spacing to match visual spec result
      transform: "translate(0, 20px) scale(1)"
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      // Compensation for the `Input.inputSizeSmall` style.
      transform: "translate(0, 17px) scale(1)"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.shrink,
    style: {
      transform: "translate(0, -1.5px) scale(0.75)",
      transformOrigin: "top left",
      maxWidth: "133%"
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.disableAnimation,
    style: {
      transition: theme2.transitions.create(["color", "transform", "max-width"], {
        duration: theme2.transitions.duration.shorter,
        easing: theme2.transitions.easing.easeOut
      })
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      // Chrome's autofill feature gives the input field a yellow background.
      // Since the input field is behind the label in the HTML tree,
      // the input field is drawn last and hides the label with an opaque background color.
      // zIndex: 1 will raise the label above opaque background-colors of input.
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(12px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }
  }, {
    props: {
      variant: "filled",
      size: "small"
    },
    style: {
      transform: "translate(12px, 13px) scale(1)"
    }
  }, {
    props: ({
      variant,
      ownerState
    }) => variant === "filled" && ownerState.shrink,
    style: {
      userSelect: "none",
      pointerEvents: "auto",
      transform: "translate(12px, 7px) scale(0.75)",
      maxWidth: "calc(133% - 24px)"
    }
  }, {
    props: ({
      variant,
      ownerState,
      size
    }) => variant === "filled" && ownerState.shrink && size === "small",
    style: {
      transform: "translate(12px, 4px) scale(0.75)"
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      // see comment above on filled.zIndex
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(14px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }
  }, {
    props: {
      variant: "outlined",
      size: "small"
    },
    style: {
      transform: "translate(14px, 9px) scale(1)"
    }
  }, {
    props: ({
      variant,
      ownerState
    }) => variant === "outlined" && ownerState.shrink,
    style: {
      userSelect: "none",
      pointerEvents: "auto",
      // Theoretically, we should have (8+5)*2/0.75 = 34px
      // but it feels a better when it bleeds a bit on the left, so 32px.
      maxWidth: "calc(133% - 32px)",
      transform: "translate(14px, -9px) scale(0.75)"
    }
  }]
})));
const InputLabel = /* @__PURE__ */ React$N.forwardRef(function InputLabel2(inProps, ref) {
  const props = useDefaultProps({
    name: "MuiInputLabel",
    props: inProps
  });
  const _a2 = props, {
    disableAnimation = false,
    margin: margin2,
    shrink: shrinkProp,
    variant,
    className
  } = _a2, other = __objRest(_a2, [
    "disableAnimation",
    "margin",
    "shrink",
    "variant",
    "className"
  ]);
  const muiFormControl = useFormControl();
  let shrink = shrinkProp;
  if (typeof shrink === "undefined" && muiFormControl) {
    shrink = muiFormControl.filled || muiFormControl.focused || muiFormControl.adornedStart;
  }
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["size", "variant", "required", "focused"]
  });
  const ownerState = __spreadProps(__spreadValues({}, props), {
    disableAnimation,
    formControl: muiFormControl,
    shrink,
    size: fcs.size,
    variant: fcs.variant,
    required: fcs.required,
    focused: fcs.focused
  });
  const classes = useUtilityClasses$v(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabelRoot, __spreadProps(__spreadValues({
    "data-shrink": shrink,
    ref,
    className: clsx(classes.root, className)
  }, other), {
    ownerState,
    classes
  }));
});
function getLinearProgressUtilityClass(slot) {
  return generateUtilityClass("MuiLinearProgress", slot);
}
generateUtilityClasses("MuiLinearProgress", ["root", "colorPrimary", "colorSecondary", "determinate", "indeterminate", "buffer", "query", "dashed", "dashedColorPrimary", "dashedColorSecondary", "bar", "bar1", "bar2", "barColorPrimary", "barColorSecondary", "bar1Indeterminate", "bar1Determinate", "bar1Buffer", "bar2Indeterminate", "bar2Buffer"]);
const React$M = window["React"];
const TRANSITION_DURATION = 4;
const indeterminate1Keyframe = keyframes`
  0% {
    left: -35%;
    right: 100%;
  }

  60% {
    left: 100%;
    right: -90%;
  }

  100% {
    left: 100%;
    right: -90%;
  }
`;
const indeterminate1Animation = typeof indeterminate1Keyframe !== "string" ? css`
        animation: ${indeterminate1Keyframe} 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite;
      ` : null;
const indeterminate2Keyframe = keyframes`
  0% {
    left: -200%;
    right: 100%;
  }

  60% {
    left: 107%;
    right: -8%;
  }

  100% {
    left: 107%;
    right: -8%;
  }
`;
const indeterminate2Animation = typeof indeterminate2Keyframe !== "string" ? css`
        animation: ${indeterminate2Keyframe} 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) 1.15s infinite;
      ` : null;
const bufferKeyframe = keyframes`
  0% {
    opacity: 1;
    background-position: 0 -23px;
  }

  60% {
    opacity: 0;
    background-position: 0 -23px;
  }

  100% {
    opacity: 1;
    background-position: -200px -23px;
  }
`;
const bufferAnimation = typeof bufferKeyframe !== "string" ? css`
        animation: ${bufferKeyframe} 3s infinite linear;
      ` : null;
const useUtilityClasses$u = (ownerState) => {
  const {
    classes,
    variant,
    color: color2
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize(color2)}`, variant],
    dashed: ["dashed", `dashedColor${capitalize(color2)}`],
    bar1: ["bar", "bar1", `barColor${capitalize(color2)}`, (variant === "indeterminate" || variant === "query") && "bar1Indeterminate", variant === "determinate" && "bar1Determinate", variant === "buffer" && "bar1Buffer"],
    bar2: ["bar", "bar2", variant !== "buffer" && `barColor${capitalize(color2)}`, variant === "buffer" && `color${capitalize(color2)}`, (variant === "indeterminate" || variant === "query") && "bar2Indeterminate", variant === "buffer" && "bar2Buffer"]
  };
  return composeClasses(slots, getLinearProgressUtilityClass, classes);
};
const getColorShade = (theme2, color2) => {
  if (theme2.vars) {
    return theme2.vars.palette.LinearProgress[`${color2}Bg`];
  }
  return theme2.palette.mode === "light" ? theme2.lighten(theme2.palette[color2].main, 0.62) : theme2.darken(theme2.palette[color2].main, 0.5);
};
const LinearProgressRoot = styled("span", {
  name: "MuiLinearProgress",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`color${capitalize(ownerState.color)}`], styles2[ownerState.variant]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  position: "relative",
  overflow: "hidden",
  display: "block",
  height: 4,
  // Fix Safari's bug during composition of different paint.
  zIndex: 0,
  "@media print": {
    colorAdjust: "exact"
  },
  variants: [...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      backgroundColor: getColorShade(theme2, color2)
    }
  })), {
    props: ({
      ownerState
    }) => ownerState.color === "inherit" && ownerState.variant !== "buffer",
    style: {
      "&::before": {
        content: '""',
        position: "absolute",
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        backgroundColor: "currentColor",
        opacity: 0.3
      }
    }
  }, {
    props: {
      variant: "buffer"
    },
    style: {
      backgroundColor: "transparent"
    }
  }, {
    props: {
      variant: "query"
    },
    style: {
      transform: "rotate(180deg)"
    }
  }]
})));
const LinearProgressDashed = styled("span", {
  name: "MuiLinearProgress",
  slot: "Dashed",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.dashed, styles2[`dashedColor${capitalize(ownerState.color)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  position: "absolute",
  marginTop: 0,
  height: "100%",
  width: "100%",
  backgroundSize: "10px 10px",
  backgroundPosition: "0 -23px",
  variants: [{
    props: {
      color: "inherit"
    },
    style: {
      opacity: 0.3,
      backgroundImage: `radial-gradient(currentColor 0%, currentColor 16%, transparent 42%)`
    }
  }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => {
    const backgroundColor2 = getColorShade(theme2, color2);
    return {
      props: {
        color: color2
      },
      style: {
        backgroundImage: `radial-gradient(${backgroundColor2} 0%, ${backgroundColor2} 16%, transparent 42%)`
      }
    };
  })]
})), bufferAnimation || {
  // At runtime for Pigment CSS, `bufferAnimation` will be null and the generated keyframe will be used.
  animation: `${bufferKeyframe} 3s infinite linear`
});
const LinearProgressBar1 = styled("span", {
  name: "MuiLinearProgress",
  slot: "Bar1",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.bar, styles2.bar1, styles2[`barColor${capitalize(ownerState.color)}`], (ownerState.variant === "indeterminate" || ownerState.variant === "query") && styles2.bar1Indeterminate, ownerState.variant === "determinate" && styles2.bar1Determinate, ownerState.variant === "buffer" && styles2.bar1Buffer];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  width: "100%",
  position: "absolute",
  left: 0,
  bottom: 0,
  top: 0,
  transition: "transform 0.2s linear",
  transformOrigin: "left",
  variants: [{
    props: {
      color: "inherit"
    },
    style: {
      backgroundColor: "currentColor"
    }
  }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      backgroundColor: (theme2.vars || theme2).palette[color2].main
    }
  })), {
    props: {
      variant: "determinate"
    },
    style: {
      transition: `transform .${TRANSITION_DURATION}s linear`
    }
  }, {
    props: {
      variant: "buffer"
    },
    style: {
      zIndex: 1,
      transition: `transform .${TRANSITION_DURATION}s linear`
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.variant === "indeterminate" || ownerState.variant === "query",
    style: {
      width: "auto"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.variant === "indeterminate" || ownerState.variant === "query",
    style: indeterminate1Animation || {
      animation: `${indeterminate1Keyframe} 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite`
    }
  }]
})));
const LinearProgressBar2 = styled("span", {
  name: "MuiLinearProgress",
  slot: "Bar2",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.bar, styles2.bar2, styles2[`barColor${capitalize(ownerState.color)}`], (ownerState.variant === "indeterminate" || ownerState.variant === "query") && styles2.bar2Indeterminate, ownerState.variant === "buffer" && styles2.bar2Buffer];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  width: "100%",
  position: "absolute",
  left: 0,
  bottom: 0,
  top: 0,
  transition: "transform 0.2s linear",
  transformOrigin: "left",
  variants: [...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      "--LinearProgressBar2-barColor": (theme2.vars || theme2).palette[color2].main
    }
  })), {
    props: ({
      ownerState
    }) => ownerState.variant !== "buffer" && ownerState.color !== "inherit",
    style: {
      backgroundColor: "var(--LinearProgressBar2-barColor, currentColor)"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.variant !== "buffer" && ownerState.color === "inherit",
    style: {
      backgroundColor: "currentColor"
    }
  }, {
    props: {
      color: "inherit"
    },
    style: {
      opacity: 0.3
    }
  }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2,
      variant: "buffer"
    },
    style: {
      backgroundColor: getColorShade(theme2, color2),
      transition: `transform .${TRANSITION_DURATION}s linear`
    }
  })), {
    props: ({
      ownerState
    }) => ownerState.variant === "indeterminate" || ownerState.variant === "query",
    style: {
      width: "auto"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.variant === "indeterminate" || ownerState.variant === "query",
    style: indeterminate2Animation || {
      animation: `${indeterminate2Keyframe} 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) 1.15s infinite`
    }
  }]
})));
const LinearProgress = /* @__PURE__ */ React$M.forwardRef(function LinearProgress2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiLinearProgress"
  });
  const _a2 = props, {
    className,
    color: color2 = "primary",
    value,
    valueBuffer,
    variant = "indeterminate"
  } = _a2, other = __objRest(_a2, [
    "className",
    "color",
    "value",
    "valueBuffer",
    "variant"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: color2,
    variant
  });
  const classes = useUtilityClasses$u(ownerState);
  const isRtl = useRtl();
  const rootProps = {};
  const inlineStyles = {
    bar1: {},
    bar2: {}
  };
  if (variant === "determinate" || variant === "buffer") {
    if (value !== void 0) {
      rootProps["aria-valuenow"] = Math.round(value);
      rootProps["aria-valuemin"] = 0;
      rootProps["aria-valuemax"] = 100;
      let transform = value - 100;
      if (isRtl) {
        transform = -transform;
      }
      inlineStyles.bar1.transform = `translateX(${transform}%)`;
    }
  }
  if (variant === "buffer") {
    if (valueBuffer !== void 0) {
      let transform = (valueBuffer || 0) - 100;
      if (isRtl) {
        transform = -transform;
      }
      inlineStyles.bar2.transform = `translateX(${transform}%)`;
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(LinearProgressRoot, __spreadProps(__spreadValues(__spreadProps(__spreadValues({
    className: clsx(classes.root, className),
    ownerState,
    role: "progressbar"
  }, rootProps), {
    ref
  }), other), {
    children: [variant === "buffer" ? /* @__PURE__ */ jsxRuntimeExports.jsx(LinearProgressDashed, {
      className: classes.dashed,
      ownerState
    }) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(LinearProgressBar1, {
      className: classes.bar1,
      ownerState,
      style: inlineStyles.bar1
    }), variant === "determinate" ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(LinearProgressBar2, {
      className: classes.bar2,
      ownerState,
      style: inlineStyles.bar2
    })]
  }));
});
function getLinkUtilityClass(slot) {
  return generateUtilityClass("MuiLink", slot);
}
const linkClasses = generateUtilityClasses("MuiLink", ["root", "underlineNone", "underlineHover", "underlineAlways", "button", "focusVisible"]);
const getTextDecoration = ({
  theme: theme2,
  ownerState
}) => {
  const transformedColor = ownerState.color;
  if ("colorSpace" in theme2 && theme2.colorSpace) {
    const color3 = getPath(theme2, `palette.${transformedColor}.main`) || getPath(theme2, `palette.${transformedColor}`) || ownerState.color;
    return theme2.alpha(color3, 0.4);
  }
  const color2 = getPath(theme2, `palette.${transformedColor}.main`, false) || getPath(theme2, `palette.${transformedColor}`, false) || ownerState.color;
  const channelColor = getPath(theme2, `palette.${transformedColor}.mainChannel`) || getPath(theme2, `palette.${transformedColor}Channel`);
  if ("vars" in theme2 && channelColor) {
    return `rgba(${channelColor} / 0.4)`;
  }
  return alpha(color2, 0.4);
};
const React$L = window["React"];
const v6Colors = {
  primary: true,
  secondary: true,
  error: true,
  info: true,
  success: true,
  warning: true,
  textPrimary: true,
  textSecondary: true,
  textDisabled: true
};
const useUtilityClasses$t = (ownerState) => {
  const {
    classes,
    component,
    focusVisible,
    underline
  } = ownerState;
  const slots = {
    root: ["root", `underline${capitalize(underline)}`, component === "button" && "button", focusVisible && "focusVisible"]
  };
  return composeClasses(slots, getLinkUtilityClass, classes);
};
const LinkRoot = styled(Typography, {
  name: "MuiLink",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`underline${capitalize(ownerState.underline)}`], ownerState.component === "button" && styles2.button];
  }
})(memoTheme(({
  theme: theme2
}) => {
  return {
    variants: [{
      props: {
        underline: "none"
      },
      style: {
        textDecoration: "none"
      }
    }, {
      props: {
        underline: "hover"
      },
      style: {
        textDecoration: "none",
        "&:hover": {
          textDecoration: "underline"
        }
      }
    }, {
      props: {
        underline: "always"
      },
      style: {
        textDecoration: "underline",
        "&:hover": {
          textDecorationColor: "inherit"
        }
      }
    }, {
      props: ({
        underline,
        ownerState
      }) => underline === "always" && ownerState.color !== "inherit",
      style: {
        textDecorationColor: "var(--Link-underlineColor)"
      }
    }, {
      props: ({
        underline,
        ownerState
      }) => underline === "always" && ownerState.color === "inherit",
      style: theme2.colorSpace ? {
        textDecorationColor: theme2.alpha("currentColor", 0.4)
      } : null
    }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
      props: {
        underline: "always",
        color: color2
      },
      style: {
        "--Link-underlineColor": theme2.alpha((theme2.vars || theme2).palette[color2].main, 0.4)
      }
    })), {
      props: {
        underline: "always",
        color: "textPrimary"
      },
      style: {
        "--Link-underlineColor": theme2.alpha((theme2.vars || theme2).palette.text.primary, 0.4)
      }
    }, {
      props: {
        underline: "always",
        color: "textSecondary"
      },
      style: {
        "--Link-underlineColor": theme2.alpha((theme2.vars || theme2).palette.text.secondary, 0.4)
      }
    }, {
      props: {
        underline: "always",
        color: "textDisabled"
      },
      style: {
        "--Link-underlineColor": (theme2.vars || theme2).palette.text.disabled
      }
    }, {
      props: {
        component: "button"
      },
      style: {
        position: "relative",
        WebkitTapHighlightColor: "transparent",
        backgroundColor: "transparent",
        // Reset default value
        // We disable the focus ring for mouse, touch and keyboard users.
        outline: 0,
        border: 0,
        margin: 0,
        // Remove the margin in Safari
        borderRadius: 0,
        padding: 0,
        // Remove the padding in Firefox
        cursor: "pointer",
        userSelect: "none",
        verticalAlign: "middle",
        MozAppearance: "none",
        // Reset
        WebkitAppearance: "none",
        // Reset
        "&::-moz-focus-inner": {
          borderStyle: "none"
          // Remove Firefox dotted outline.
        },
        [`&.${linkClasses.focusVisible}`]: {
          outline: "auto"
        }
      }
    }]
  };
}));
const Link$1 = /* @__PURE__ */ React$L.forwardRef(function Link2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiLink"
  });
  const theme2 = useTheme();
  const _a2 = props, {
    className,
    color: color2 = "primary",
    component = "a",
    onBlur,
    onFocus,
    TypographyClasses,
    underline = "always",
    variant = "inherit",
    sx
  } = _a2, other = __objRest(_a2, [
    "className",
    "color",
    "component",
    "onBlur",
    "onFocus",
    "TypographyClasses",
    "underline",
    "variant",
    "sx"
  ]);
  const [focusVisible, setFocusVisible] = React$L.useState(false);
  const handleBlur = (event) => {
    if (!isFocusVisible(event.target)) {
      setFocusVisible(false);
    }
    if (onBlur) {
      onBlur(event);
    }
  };
  const handleFocus = (event) => {
    if (isFocusVisible(event.target)) {
      setFocusVisible(true);
    }
    if (onFocus) {
      onFocus(event);
    }
  };
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: color2,
    component,
    focusVisible,
    underline,
    variant
  });
  const classes = useUtilityClasses$t(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LinkRoot, __spreadProps(__spreadValues({
    color: color2,
    className: clsx(classes.root, className),
    classes: TypographyClasses,
    component,
    onBlur: handleBlur,
    onFocus: handleFocus,
    ref,
    ownerState,
    variant
  }, other), {
    sx: [...v6Colors[color2] === void 0 ? [{
      color: color2
    }] : [], ...Array.isArray(sx) ? sx : [sx]],
    style: __spreadValues(__spreadValues({}, other.style), underline === "always" && color2 !== "inherit" && !v6Colors[color2] && {
      "--Link-underlineColor": getTextDecoration({
        theme: theme2,
        ownerState
      })
    })
  }));
});
const React$K = window["React"];
const ListContext = /* @__PURE__ */ React$K.createContext({});
function getListUtilityClass(slot) {
  return generateUtilityClass("MuiList", slot);
}
generateUtilityClasses("MuiList", ["root", "padding", "dense", "subheader"]);
const React$J = window["React"];
const useUtilityClasses$s = (ownerState) => {
  const {
    classes,
    disablePadding,
    dense,
    subheader
  } = ownerState;
  const slots = {
    root: ["root", !disablePadding && "padding", dense && "dense", subheader && "subheader"]
  };
  return composeClasses(slots, getListUtilityClass, classes);
};
const ListRoot = styled("ul", {
  name: "MuiList",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.disablePadding && styles2.padding, ownerState.dense && styles2.dense, ownerState.subheader && styles2.subheader];
  }
})({
  listStyle: "none",
  margin: 0,
  padding: 0,
  position: "relative",
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.disablePadding,
    style: {
      paddingTop: 8,
      paddingBottom: 8
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.subheader,
    style: {
      paddingTop: 0
    }
  }]
});
const List$1 = /* @__PURE__ */ React$J.forwardRef(function List2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiList"
  });
  const _a2 = props, {
    children,
    className,
    component = "ul",
    dense = false,
    disablePadding = false,
    subheader
  } = _a2, other = __objRest(_a2, [
    "children",
    "className",
    "component",
    "dense",
    "disablePadding",
    "subheader"
  ]);
  const context = React$J.useMemo(() => ({
    dense
  }), [dense]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component,
    dense,
    disablePadding
  });
  const classes = useUtilityClasses$s(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext.Provider, {
    value: context,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, __spreadProps(__spreadValues({
      as: component,
      className: clsx(classes.root, className),
      ref,
      ownerState
    }, other), {
      children: [subheader, children]
    }))
  });
});
function getListItemUtilityClass(slot) {
  return generateUtilityClass("MuiListItem", slot);
}
generateUtilityClasses("MuiListItem", ["root", "container", "dense", "alignItemsFlexStart", "divider", "gutters", "padding", "secondaryAction"]);
const listItemButtonClasses = generateUtilityClasses("MuiListItemButton", ["root", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "selected"]);
function getListItemSecondaryActionClassesUtilityClass(slot) {
  return generateUtilityClass("MuiListItemSecondaryAction", slot);
}
generateUtilityClasses("MuiListItemSecondaryAction", ["root", "disableGutters"]);
const React$I = window["React"];
const useUtilityClasses$r = (ownerState) => {
  const {
    disableGutters,
    classes
  } = ownerState;
  const slots = {
    root: ["root", disableGutters && "disableGutters"]
  };
  return composeClasses(slots, getListItemSecondaryActionClassesUtilityClass, classes);
};
const ListItemSecondaryActionRoot = styled("div", {
  name: "MuiListItemSecondaryAction",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.disableGutters && styles2.disableGutters];
  }
})({
  position: "absolute",
  right: 16,
  top: "50%",
  transform: "translateY(-50%)",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.disableGutters,
    style: {
      right: 0
    }
  }]
});
const ListItemSecondaryAction = /* @__PURE__ */ React$I.forwardRef(function ListItemSecondaryAction2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiListItemSecondaryAction"
  });
  const _a2 = props, {
    className
  } = _a2, other = __objRest(_a2, [
    "className"
  ]);
  const context = React$I.useContext(ListContext);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    disableGutters: context.disableGutters
  });
  const classes = useUtilityClasses$r(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemSecondaryActionRoot, __spreadValues({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
ListItemSecondaryAction.muiName = "ListItemSecondaryAction";
const React$H = window["React"];
const overridesResolver$1 = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.dense && styles2.dense, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters, !ownerState.disablePadding && styles2.padding, ownerState.hasSecondaryAction && styles2.secondaryAction];
};
const useUtilityClasses$q = (ownerState) => {
  const {
    alignItems,
    classes,
    dense,
    disableGutters,
    disablePadding,
    divider,
    hasSecondaryAction
  } = ownerState;
  const slots = {
    root: ["root", dense && "dense", !disableGutters && "gutters", !disablePadding && "padding", divider && "divider", alignItems === "flex-start" && "alignItemsFlexStart", hasSecondaryAction && "secondaryAction"],
    container: ["container"]
  };
  return composeClasses(slots, getListItemUtilityClass, classes);
};
const ListItemRoot = styled("div", {
  name: "MuiListItem",
  slot: "Root",
  overridesResolver: overridesResolver$1
})(memoTheme(({
  theme: theme2
}) => ({
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  width: "100%",
  boxSizing: "border-box",
  textAlign: "left",
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.disablePadding,
    style: {
      paddingTop: 8,
      paddingBottom: 8
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.disablePadding && ownerState.dense,
    style: {
      paddingTop: 4,
      paddingBottom: 4
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.disablePadding && !ownerState.disableGutters,
    style: {
      paddingLeft: 16,
      paddingRight: 16
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.disablePadding && !!ownerState.secondaryAction,
    style: {
      // Add some space to avoid collision as `ListItemSecondaryAction`
      // is absolutely positioned.
      paddingRight: 48
    }
  }, {
    props: ({
      ownerState
    }) => !!ownerState.secondaryAction,
    style: {
      [`& > .${listItemButtonClasses.root}`]: {
        paddingRight: 48
      }
    }
  }, {
    props: {
      alignItems: "flex-start"
    },
    style: {
      alignItems: "flex-start"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.divider,
    style: {
      borderBottom: `1px solid ${(theme2.vars || theme2).palette.divider}`,
      backgroundClip: "padding-box"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.button,
    style: {
      transition: theme2.transitions.create("background-color", {
        duration: theme2.transitions.duration.shortest
      }),
      "&:hover": {
        textDecoration: "none",
        backgroundColor: (theme2.vars || theme2).palette.action.hover,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.hasSecondaryAction,
    style: {
      // Add some space to avoid collision as `ListItemSecondaryAction`
      // is absolutely positioned.
      paddingRight: 48
    }
  }]
})));
const ListItemContainer = styled("li", {
  name: "MuiListItem",
  slot: "Container"
})({
  position: "relative"
});
const ListItem = /* @__PURE__ */ React$H.forwardRef(function ListItem2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiListItem"
  });
  const _a2 = props, {
    alignItems = "center",
    children: childrenProp,
    className,
    component: componentProp,
    components = {},
    componentsProps = {},
    ContainerComponent = "li",
    ContainerProps: _b = {}
  } = _a2, _c = _b, {
    className: ContainerClassName
  } = _c, ContainerProps = __objRest(_c, [
    "className"
  ]), _d = _a2, {
    dense = false,
    disableGutters = false,
    disablePadding = false,
    divider = false,
    secondaryAction,
    slotProps = {},
    slots = {}
  } = _d, other = __objRest(_d, [
    "alignItems",
    "children",
    "className",
    "component",
    "components",
    "componentsProps",
    "ContainerComponent",
    "ContainerProps",
    "dense",
    "disableGutters",
    "disablePadding",
    "divider",
    "secondaryAction",
    "slotProps",
    "slots"
  ]);
  const context = React$H.useContext(ListContext);
  const childContext = React$H.useMemo(() => ({
    dense: dense || context.dense || false,
    alignItems,
    disableGutters
  }), [alignItems, context.dense, dense, disableGutters]);
  const listItemRef = React$H.useRef(null);
  const children = React$H.Children.toArray(childrenProp);
  const hasSecondaryAction = children.length && isMuiElement(children[children.length - 1], ["ListItemSecondaryAction"]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    alignItems,
    dense: childContext.dense,
    disableGutters,
    disablePadding,
    divider,
    hasSecondaryAction
  });
  const classes = useUtilityClasses$q(ownerState);
  const handleRef = useForkRef(listItemRef, ref);
  const Root = slots.root || components.Root || ListItemRoot;
  const rootProps = slotProps.root || componentsProps.root || {};
  const componentProps = __spreadValues({
    className: clsx(classes.root, rootProps.className, className)
  }, other);
  let Component = componentProp || "li";
  if (hasSecondaryAction) {
    Component = !componentProps.component && !componentProp ? "div" : Component;
    if (ContainerComponent === "li") {
      if (Component === "li") {
        Component = "div";
      } else if (componentProps.component === "li") {
        componentProps.component = "div";
      }
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext.Provider, {
      value: childContext,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItemContainer, __spreadProps(__spreadValues({
        as: ContainerComponent,
        className: clsx(classes.container, ContainerClassName),
        ref: handleRef,
        ownerState
      }, ContainerProps), {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Root, __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, rootProps), !isHostComponent(Root) && {
          as: Component,
          ownerState: __spreadValues(__spreadValues({}, ownerState), rootProps.ownerState)
        }), componentProps), {
          children
        })), children.pop()]
      }))
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Root, __spreadProps(__spreadValues(__spreadValues(__spreadProps(__spreadValues({}, rootProps), {
      as: Component,
      ref: handleRef
    }), !isHostComponent(Root) && {
      ownerState: __spreadValues(__spreadValues({}, ownerState), rootProps.ownerState)
    }), componentProps), {
      children: [children, secondaryAction && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemSecondaryAction, {
        children: secondaryAction
      })]
    }))
  });
});
function getListItemAvatarUtilityClass(slot) {
  return generateUtilityClass("MuiListItemAvatar", slot);
}
generateUtilityClasses("MuiListItemAvatar", ["root", "alignItemsFlexStart"]);
const React$G = window["React"];
const useUtilityClasses$p = (ownerState) => {
  const {
    alignItems,
    classes
  } = ownerState;
  const slots = {
    root: ["root", alignItems === "flex-start" && "alignItemsFlexStart"]
  };
  return composeClasses(slots, getListItemAvatarUtilityClass, classes);
};
const ListItemAvatarRoot = styled("div", {
  name: "MuiListItemAvatar",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart];
  }
})({
  minWidth: 56,
  flexShrink: 0,
  variants: [{
    props: {
      alignItems: "flex-start"
    },
    style: {
      marginTop: 8
    }
  }]
});
const ListItemAvatar = /* @__PURE__ */ React$G.forwardRef(function ListItemAvatar2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiListItemAvatar"
  });
  const _a2 = props, {
    className
  } = _a2, other = __objRest(_a2, [
    "className"
  ]);
  const context = React$G.useContext(ListContext);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    alignItems: context.alignItems
  });
  const classes = useUtilityClasses$p(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemAvatarRoot, __spreadValues({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
function getListItemIconUtilityClass(slot) {
  return generateUtilityClass("MuiListItemIcon", slot);
}
const listItemIconClasses = generateUtilityClasses("MuiListItemIcon", ["root", "alignItemsFlexStart"]);
const React$F = window["React"];
const useUtilityClasses$o = (ownerState) => {
  const {
    alignItems,
    classes
  } = ownerState;
  const slots = {
    root: ["root", alignItems === "flex-start" && "alignItemsFlexStart"]
  };
  return composeClasses(slots, getListItemIconUtilityClass, classes);
};
const ListItemIconRoot = styled("div", {
  name: "MuiListItemIcon",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  minWidth: 56,
  color: (theme2.vars || theme2).palette.action.active,
  flexShrink: 0,
  display: "inline-flex",
  variants: [{
    props: {
      alignItems: "flex-start"
    },
    style: {
      marginTop: 8
    }
  }]
})));
const ListItemIcon = /* @__PURE__ */ React$F.forwardRef(function ListItemIcon2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiListItemIcon"
  });
  const _a2 = props, {
    className
  } = _a2, other = __objRest(_a2, [
    "className"
  ]);
  const context = React$F.useContext(ListContext);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    alignItems: context.alignItems
  });
  const classes = useUtilityClasses$o(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIconRoot, __spreadValues({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
function getListItemTextUtilityClass(slot) {
  return generateUtilityClass("MuiListItemText", slot);
}
const listItemTextClasses = generateUtilityClasses("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]);
const React$E = window["React"];
const useUtilityClasses$n = (ownerState) => {
  const {
    classes,
    inset,
    primary,
    secondary,
    dense
  } = ownerState;
  const slots = {
    root: ["root", inset && "inset", dense && "dense", primary && secondary && "multiline"],
    primary: ["primary"],
    secondary: ["secondary"]
  };
  return composeClasses(slots, getListItemTextUtilityClass, classes);
};
const ListItemTextRoot = styled("div", {
  name: "MuiListItemText",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${listItemTextClasses.primary}`]: styles2.primary
    }, {
      [`& .${listItemTextClasses.secondary}`]: styles2.secondary
    }, styles2.root, ownerState.inset && styles2.inset, ownerState.primary && ownerState.secondary && styles2.multiline, ownerState.dense && styles2.dense];
  }
})({
  flex: "1 1 auto",
  minWidth: 0,
  marginTop: 4,
  marginBottom: 4,
  [`.${typographyClasses.root}:where(& .${listItemTextClasses.primary})`]: {
    display: "block"
  },
  [`.${typographyClasses.root}:where(& .${listItemTextClasses.secondary})`]: {
    display: "block"
  },
  variants: [{
    props: ({
      ownerState
    }) => ownerState.primary && ownerState.secondary,
    style: {
      marginTop: 6,
      marginBottom: 6
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.inset,
    style: {
      paddingLeft: 56
    }
  }]
});
const ListItemText = /* @__PURE__ */ React$E.forwardRef(function ListItemText2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiListItemText"
  });
  const _a2 = props, {
    children,
    className,
    disableTypography = false,
    inset = false,
    primary: primaryProp,
    primaryTypographyProps,
    secondary: secondaryProp,
    secondaryTypographyProps,
    slots = {},
    slotProps = {}
  } = _a2, other = __objRest(_a2, [
    "children",
    "className",
    "disableTypography",
    "inset",
    "primary",
    "primaryTypographyProps",
    "secondary",
    "secondaryTypographyProps",
    "slots",
    "slotProps"
  ]);
  const {
    dense
  } = React$E.useContext(ListContext);
  let primary = primaryProp != null ? primaryProp : children;
  let secondary = secondaryProp;
  const ownerState = __spreadProps(__spreadValues({}, props), {
    disableTypography,
    inset,
    primary: !!primary,
    secondary: !!secondary,
    dense
  });
  const classes = useUtilityClasses$n(ownerState);
  const externalForwardedProps = {
    slots,
    slotProps: __spreadValues({
      primary: primaryTypographyProps,
      secondary: secondaryTypographyProps
    }, slotProps)
  };
  const [RootSlot, rootSlotProps] = useSlot("root", {
    className: clsx(classes.root, className),
    elementType: ListItemTextRoot,
    externalForwardedProps: __spreadValues(__spreadValues({}, externalForwardedProps), other),
    ownerState,
    ref
  });
  const [PrimarySlot, primarySlotProps] = useSlot("primary", {
    className: classes.primary,
    elementType: Typography,
    externalForwardedProps,
    ownerState
  });
  const [SecondarySlot, secondarySlotProps] = useSlot("secondary", {
    className: classes.secondary,
    elementType: Typography,
    externalForwardedProps,
    ownerState
  });
  if (primary != null && primary.type !== Typography && !disableTypography) {
    primary = /* @__PURE__ */ jsxRuntimeExports.jsx(PrimarySlot, __spreadProps(__spreadValues({
      variant: dense ? "body2" : "body1",
      component: (primarySlotProps == null ? void 0 : primarySlotProps.variant) ? void 0 : "span"
    }, primarySlotProps), {
      children: primary
    }));
  }
  if (secondary != null && secondary.type !== Typography && !disableTypography) {
    secondary = /* @__PURE__ */ jsxRuntimeExports.jsx(SecondarySlot, __spreadProps(__spreadValues({
      variant: "body2",
      color: "textSecondary"
    }, secondarySlotProps), {
      children: secondary
    }));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, __spreadProps(__spreadValues({}, rootSlotProps), {
    children: [primary, secondary]
  }));
});
const React$D = window["React"];
function nextItem$1(list, item, disableListWrap) {
  if (list === item) {
    return list.firstChild;
  }
  if (item && item.nextElementSibling) {
    return item.nextElementSibling;
  }
  return disableListWrap ? null : list.firstChild;
}
function previousItem$1(list, item, disableListWrap) {
  if (list === item) {
    return disableListWrap ? list.firstChild : list.lastChild;
  }
  if (item && item.previousElementSibling) {
    return item.previousElementSibling;
  }
  return disableListWrap ? null : list.lastChild;
}
function textCriteriaMatches(nextFocus, textCriteria) {
  if (textCriteria === void 0) {
    return true;
  }
  let text = nextFocus.innerText;
  if (text === void 0) {
    text = nextFocus.textContent;
  }
  text = text.trim().toLowerCase();
  if (text.length === 0) {
    return false;
  }
  if (textCriteria.repeating) {
    return text[0] === textCriteria.keys[0];
  }
  return text.startsWith(textCriteria.keys.join(""));
}
function moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
  let wrappedOnce = false;
  let nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);
  while (nextFocus) {
    if (nextFocus === list.firstChild) {
      if (wrappedOnce) {
        return false;
      }
      wrappedOnce = true;
    }
    const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
    if (!nextFocus.hasAttribute("tabindex") || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {
      nextFocus = traversalFunction(list, nextFocus, disableListWrap);
    } else {
      nextFocus.focus();
      return true;
    }
  }
  return false;
}
const MenuList = /* @__PURE__ */ React$D.forwardRef(function MenuList2(props, ref) {
  const _a2 = props, {
    actions: actions,
    autoFocus = false,
    autoFocusItem = false,
    children,
    className,
    disabledItemsFocusable = false,
    disableListWrap = false,
    onKeyDown,
    variant = "selectedMenu"
  } = _a2, other = __objRest(_a2, [
    // private
    // eslint-disable-next-line react/prop-types
    "actions",
    "autoFocus",
    "autoFocusItem",
    "children",
    "className",
    "disabledItemsFocusable",
    "disableListWrap",
    "onKeyDown",
    "variant"
  ]);
  const listRef = React$D.useRef(null);
  const textCriteriaRef = React$D.useRef({
    keys: [],
    repeating: true,
    previousKeyMatched: true,
    lastTime: null
  });
  useEnhancedEffect(() => {
    if (autoFocus) {
      listRef.current.focus();
    }
  }, [autoFocus]);
  React$D.useImperativeHandle(actions, () => ({
    adjustStyleForScrollbar: (containerElement, {
      direction
    }) => {
      const noExplicitWidth = !listRef.current.style.width;
      if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
        const scrollbarSize = `${getScrollbarSize(ownerWindow(containerElement))}px`;
        listRef.current.style[direction === "rtl" ? "paddingLeft" : "paddingRight"] = scrollbarSize;
        listRef.current.style.width = `calc(100% + ${scrollbarSize})`;
      }
      return listRef.current;
    }
  }), []);
  const handleKeyDown = (event) => {
    const list = listRef.current;
    const key = event.key;
    const isModifierKeyPressed = event.ctrlKey || event.metaKey || event.altKey;
    if (isModifierKeyPressed) {
      if (onKeyDown) {
        onKeyDown(event);
      }
      return;
    }
    const currentFocus = ownerDocument(list).activeElement;
    if (key === "ArrowDown") {
      event.preventDefault();
      moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem$1);
    } else if (key === "ArrowUp") {
      event.preventDefault();
      moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem$1);
    } else if (key === "Home") {
      event.preventDefault();
      moveFocus$1(list, null, disableListWrap, disabledItemsFocusable, nextItem$1);
    } else if (key === "End") {
      event.preventDefault();
      moveFocus$1(list, null, disableListWrap, disabledItemsFocusable, previousItem$1);
    } else if (key.length === 1) {
      const criteria = textCriteriaRef.current;
      const lowerKey = key.toLowerCase();
      const currTime = performance.now();
      if (criteria.keys.length > 0) {
        if (currTime - criteria.lastTime > 500) {
          criteria.keys = [];
          criteria.repeating = true;
          criteria.previousKeyMatched = true;
        } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
          criteria.repeating = false;
        }
      }
      criteria.lastTime = currTime;
      criteria.keys.push(lowerKey);
      const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);
      if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus$1(list, currentFocus, false, disabledItemsFocusable, nextItem$1, criteria))) {
        event.preventDefault();
      } else {
        criteria.previousKeyMatched = false;
      }
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  };
  const handleRef = useForkRef(listRef, ref);
  let activeItemIndex = -1;
  React$D.Children.forEach(children, (child, index2) => {
    if (!/* @__PURE__ */ React$D.isValidElement(child)) {
      if (activeItemIndex === index2) {
        activeItemIndex += 1;
        if (activeItemIndex >= children.length) {
          activeItemIndex = -1;
        }
      }
      return;
    }
    if (!child.props.disabled) {
      if (variant === "selectedMenu" && child.props.selected) {
        activeItemIndex = index2;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index2;
      }
    }
    if (activeItemIndex === index2 && (child.props.disabled || child.props.muiSkipListHighlight || child.type.muiSkipListHighlight)) {
      activeItemIndex += 1;
      if (activeItemIndex >= children.length) {
        activeItemIndex = -1;
      }
    }
  });
  const items = React$D.Children.map(children, (child, index2) => {
    if (index2 === activeItemIndex) {
      const newChildProps = {};
      if (autoFocusItem) {
        newChildProps.autoFocus = true;
      }
      if (child.props.tabIndex === void 0 && variant === "selectedMenu") {
        newChildProps.tabIndex = 0;
      }
      return /* @__PURE__ */ React$D.cloneElement(child, newChildProps);
    }
    return child;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(List$1, __spreadProps(__spreadValues({
    role: "menu",
    ref: handleRef,
    className,
    onKeyDown: handleKeyDown,
    tabIndex: autoFocus ? 0 : -1
  }, other), {
    children: items
  }));
});
function getPopoverUtilityClass(slot) {
  return generateUtilityClass("MuiPopover", slot);
}
generateUtilityClasses("MuiPopover", ["root", "paper"]);
const React$C = window["React"];
function getOffsetTop(rect, vertical) {
  let offset2 = 0;
  if (typeof vertical === "number") {
    offset2 = vertical;
  } else if (vertical === "center") {
    offset2 = rect.height / 2;
  } else if (vertical === "bottom") {
    offset2 = rect.height;
  }
  return offset2;
}
function getOffsetLeft(rect, horizontal) {
  let offset2 = 0;
  if (typeof horizontal === "number") {
    offset2 = horizontal;
  } else if (horizontal === "center") {
    offset2 = rect.width / 2;
  } else if (horizontal === "right") {
    offset2 = rect.width;
  }
  return offset2;
}
function getTransformOriginValue(transformOrigin) {
  return [transformOrigin.horizontal, transformOrigin.vertical].map((n) => typeof n === "number" ? `${n}px` : n).join(" ");
}
function resolveAnchorEl(anchorEl) {
  return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
const useUtilityClasses$m = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    paper: ["paper"]
  };
  return composeClasses(slots, getPopoverUtilityClass, classes);
};
const PopoverRoot = styled(Modal, {
  name: "MuiPopover",
  slot: "Root"
})({});
const PopoverPaper = styled(Paper, {
  name: "MuiPopover",
  slot: "Paper"
})({
  position: "absolute",
  overflowY: "auto",
  overflowX: "hidden",
  // So we see the popover when it's empty.
  // It's most likely on issue on userland.
  minWidth: 16,
  minHeight: 16,
  maxWidth: "calc(100% - 32px)",
  maxHeight: "calc(100% - 32px)",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
});
const Popover = /* @__PURE__ */ React$C.forwardRef(function Popover2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiPopover"
  });
  const _a2 = props, {
    action,
    anchorEl,
    anchorOrigin = {
      vertical: "top",
      horizontal: "left"
    },
    anchorPosition,
    anchorReference = "anchorEl",
    children,
    className,
    container: containerProp,
    elevation = 8,
    marginThreshold = 16,
    open,
    PaperProps: PaperPropsProp = {},
    slots: slots = {},
    slotProps = {},
    transformOrigin = {
      vertical: "top",
      horizontal: "left"
    },
    TransitionComponent,
    transitionDuration: transitionDurationProp = "auto",
    TransitionProps = {},
    disableScrollLock: disableScrollLock = false
  } = _a2, other = __objRest(_a2, [
    "action",
    "anchorEl",
    "anchorOrigin",
    "anchorPosition",
    "anchorReference",
    "children",
    "className",
    "container",
    "elevation",
    "marginThreshold",
    "open",
    "PaperProps",
    // TODO: remove in v7
    "slots",
    "slotProps",
    "transformOrigin",
    "TransitionComponent",
    // TODO: remove in v7
    "transitionDuration",
    "TransitionProps",
    // TODO: remove in v7
    "disableScrollLock"
  ]);
  const paperRef = React$C.useRef();
  const ownerState = __spreadProps(__spreadValues({}, props), {
    anchorOrigin,
    anchorReference,
    elevation,
    marginThreshold,
    transformOrigin,
    TransitionComponent,
    transitionDuration: transitionDurationProp,
    TransitionProps
  });
  const classes = useUtilityClasses$m(ownerState);
  const getAnchorOffset = React$C.useCallback(() => {
    if (anchorReference === "anchorPosition") {
      return anchorPosition;
    }
    const resolvedAnchorEl = resolveAnchorEl(anchorEl);
    const anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument(paperRef.current).body;
    const anchorRect = anchorElement.getBoundingClientRect();
    return {
      top: anchorRect.top + getOffsetTop(anchorRect, anchorOrigin.vertical),
      left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
    };
  }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]);
  const getTransformOrigin = React$C.useCallback((elemRect) => {
    return {
      vertical: getOffsetTop(elemRect, transformOrigin.vertical),
      horizontal: getOffsetLeft(elemRect, transformOrigin.horizontal)
    };
  }, [transformOrigin.horizontal, transformOrigin.vertical]);
  const getPositioningStyle = React$C.useCallback((element) => {
    const elemRect = {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
    const elemTransformOrigin = getTransformOrigin(elemRect);
    if (anchorReference === "none") {
      return {
        top: null,
        left: null,
        transformOrigin: getTransformOriginValue(elemTransformOrigin)
      };
    }
    const anchorOffset = getAnchorOffset();
    let top2 = anchorOffset.top - elemTransformOrigin.vertical;
    let left2 = anchorOffset.left - elemTransformOrigin.horizontal;
    const bottom2 = top2 + elemRect.height;
    const right2 = left2 + elemRect.width;
    const containerWindow = ownerWindow(resolveAnchorEl(anchorEl));
    const heightThreshold = containerWindow.innerHeight - marginThreshold;
    const widthThreshold = containerWindow.innerWidth - marginThreshold;
    if (marginThreshold !== null && top2 < marginThreshold) {
      const diff = top2 - marginThreshold;
      top2 -= diff;
      elemTransformOrigin.vertical += diff;
    } else if (marginThreshold !== null && bottom2 > heightThreshold) {
      const diff = bottom2 - heightThreshold;
      top2 -= diff;
      elemTransformOrigin.vertical += diff;
    }
    if (marginThreshold !== null && left2 < marginThreshold) {
      const diff = left2 - marginThreshold;
      left2 -= diff;
      elemTransformOrigin.horizontal += diff;
    } else if (right2 > widthThreshold) {
      const diff = right2 - widthThreshold;
      left2 -= diff;
      elemTransformOrigin.horizontal += diff;
    }
    return {
      top: `${Math.round(top2)}px`,
      left: `${Math.round(left2)}px`,
      transformOrigin: getTransformOriginValue(elemTransformOrigin)
    };
  }, [anchorEl, anchorReference, getAnchorOffset, getTransformOrigin, marginThreshold]);
  const [isPositioned, setIsPositioned] = React$C.useState(open);
  const setPositioningStyles = React$C.useCallback(() => {
    const element = paperRef.current;
    if (!element) {
      return;
    }
    const positioning = getPositioningStyle(element);
    if (positioning.top !== null) {
      element.style.setProperty("top", positioning.top);
    }
    if (positioning.left !== null) {
      element.style.left = positioning.left;
    }
    element.style.transformOrigin = positioning.transformOrigin;
    setIsPositioned(true);
  }, [getPositioningStyle]);
  React$C.useEffect(() => {
    if (disableScrollLock) {
      window.addEventListener("scroll", setPositioningStyles);
    }
    return () => window.removeEventListener("scroll", setPositioningStyles);
  }, [anchorEl, disableScrollLock, setPositioningStyles]);
  const handleEntering = () => {
    setPositioningStyles();
  };
  const handleExited = () => {
    setIsPositioned(false);
  };
  React$C.useEffect(() => {
    if (open) {
      setPositioningStyles();
    }
  });
  React$C.useImperativeHandle(action, () => open ? {
    updatePosition: () => {
      setPositioningStyles();
    }
  } : null, [open, setPositioningStyles]);
  React$C.useEffect(() => {
    if (!open) {
      return void 0;
    }
    const handleResize = debounce$1(() => {
      setPositioningStyles();
    });
    const containerWindow = ownerWindow(resolveAnchorEl(anchorEl));
    containerWindow.addEventListener("resize", handleResize);
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
    };
  }, [anchorEl, open, setPositioningStyles]);
  let transitionDuration = transitionDurationProp;
  const externalForwardedProps = {
    slots: __spreadValues({
      transition: TransitionComponent
    }, slots),
    slotProps: __spreadValues({
      transition: TransitionProps,
      paper: PaperPropsProp
    }, slotProps)
  };
  const [TransitionSlot, transitionSlotProps] = useSlot("transition", {
    elementType: Grow,
    externalForwardedProps,
    ownerState,
    getSlotProps: (handlers) => __spreadProps(__spreadValues({}, handlers), {
      onEntering: (element, isAppearing) => {
        var _a3;
        (_a3 = handlers.onEntering) == null ? void 0 : _a3.call(handlers, element, isAppearing);
        handleEntering();
      },
      onExited: (element) => {
        var _a3;
        (_a3 = handlers.onExited) == null ? void 0 : _a3.call(handlers, element);
        handleExited();
      }
    }),
    additionalProps: {
      appear: true,
      in: open
    }
  });
  if (transitionDurationProp === "auto" && !TransitionSlot.muiSupportAuto) {
    transitionDuration = void 0;
  }
  const container = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl(anchorEl)).body : void 0);
  const [RootSlot, _b] = useSlot("root", {
    ref,
    elementType: PopoverRoot,
    externalForwardedProps: __spreadValues(__spreadValues({}, externalForwardedProps), other),
    shouldForwardComponentProp: true,
    additionalProps: {
      slots: {
        backdrop: slots.backdrop
      },
      slotProps: {
        backdrop: mergeSlotProps$1(typeof slotProps.backdrop === "function" ? slotProps.backdrop(ownerState) : slotProps.backdrop, {
          invisible: true
        })
      },
      container,
      open
    },
    ownerState,
    className: clsx(classes.root, className)
  }), _c = _b, {
    slots: rootSlotsProp,
    slotProps: rootSlotPropsProp
  } = _c, rootProps = __objRest(_c, [
    "slots",
    "slotProps"
  ]);
  const [PaperSlot, paperProps] = useSlot("paper", {
    ref: paperRef,
    className: classes.paper,
    elementType: PopoverPaper,
    externalForwardedProps,
    shouldForwardComponentProp: true,
    additionalProps: {
      elevation,
      style: isPositioned ? void 0 : {
        opacity: 0
      }
    },
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, __spreadProps(__spreadValues(__spreadValues({}, rootProps), !isHostComponent(RootSlot) && {
    slots: rootSlotsProp,
    slotProps: rootSlotPropsProp,
    disableScrollLock
  }), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionSlot, __spreadProps(__spreadValues({}, transitionSlotProps), {
      timeout: transitionDuration,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaperSlot, __spreadProps(__spreadValues({}, paperProps), {
        children
      }))
    }))
  }));
});
function getMenuUtilityClass(slot) {
  return generateUtilityClass("MuiMenu", slot);
}
generateUtilityClasses("MuiMenu", ["root", "paper", "list"]);
const React$B = window["React"];
const RTL_ORIGIN = {
  vertical: "top",
  horizontal: "right"
};
const LTR_ORIGIN = {
  vertical: "top",
  horizontal: "left"
};
const useUtilityClasses$l = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    paper: ["paper"],
    list: ["list"]
  };
  return composeClasses(slots, getMenuUtilityClass, classes);
};
const MenuRoot = styled(Popover, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiMenu",
  slot: "Root"
})({});
const MenuPaper = styled(PopoverPaper, {
  name: "MuiMenu",
  slot: "Paper"
})({
  // specZ: The maximum height of a simple menu should be one or more rows less than the view
  // height. This ensures a tappable area outside of the simple menu with which to dismiss
  // the menu.
  maxHeight: "calc(100% - 96px)",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch"
});
const MenuMenuList = styled(MenuList, {
  name: "MuiMenu",
  slot: "List"
})({
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
});
const Menu = /* @__PURE__ */ React$B.forwardRef(function Menu2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiMenu"
  });
  const _a2 = props, {
    autoFocus = true,
    children,
    className,
    disableAutoFocusItem = false,
    MenuListProps = {},
    onClose,
    open,
    PaperProps = {},
    PopoverClasses,
    transitionDuration = "auto",
    TransitionProps: _b = {}
  } = _a2, _c = _b, {
    onEntering
  } = _c, TransitionProps = __objRest(_c, [
    "onEntering"
  ]), _d = _a2, {
    variant = "selectedMenu",
    slots = {},
    slotProps = {}
  } = _d, other = __objRest(_d, [
    "autoFocus",
    "children",
    "className",
    "disableAutoFocusItem",
    "MenuListProps",
    "onClose",
    "open",
    "PaperProps",
    "PopoverClasses",
    "transitionDuration",
    "TransitionProps",
    "variant",
    "slots",
    "slotProps"
  ]);
  const isRtl = useRtl();
  const ownerState = __spreadProps(__spreadValues({}, props), {
    autoFocus,
    disableAutoFocusItem,
    MenuListProps,
    onEntering,
    PaperProps,
    transitionDuration,
    TransitionProps,
    variant
  });
  const classes = useUtilityClasses$l(ownerState);
  const autoFocusItem = autoFocus && !disableAutoFocusItem && open;
  const menuListActionsRef = React$B.useRef(null);
  const handleEntering = (element, isAppearing) => {
    if (menuListActionsRef.current) {
      menuListActionsRef.current.adjustStyleForScrollbar(element, {
        direction: isRtl ? "rtl" : "ltr"
      });
    }
    if (onEntering) {
      onEntering(element, isAppearing);
    }
  };
  const handleListKeyDown = (event) => {
    if (event.key === "Tab") {
      event.preventDefault();
      if (onClose) {
        onClose(event, "tabKeyDown");
      }
    }
  };
  let activeItemIndex = -1;
  React$B.Children.map(children, (child, index2) => {
    if (!/* @__PURE__ */ React$B.isValidElement(child)) {
      return;
    }
    if (!child.props.disabled) {
      if (variant === "selectedMenu" && child.props.selected) {
        activeItemIndex = index2;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index2;
      }
    }
  });
  const externalForwardedProps = {
    slots,
    slotProps: __spreadValues({
      list: MenuListProps,
      transition: TransitionProps,
      paper: PaperProps
    }, slotProps)
  };
  const rootSlotProps = useSlotProps({
    elementType: slots.root,
    externalSlotProps: slotProps.root,
    ownerState,
    className: [classes.root, className]
  });
  const [PaperSlot, paperSlotProps] = useSlot("paper", {
    className: classes.paper,
    elementType: MenuPaper,
    externalForwardedProps,
    shouldForwardComponentProp: true,
    ownerState
  });
  const [ListSlot, listSlotProps] = useSlot("list", {
    className: clsx(classes.list, MenuListProps.className),
    elementType: MenuMenuList,
    shouldForwardComponentProp: true,
    externalForwardedProps,
    getSlotProps: (handlers) => __spreadProps(__spreadValues({}, handlers), {
      onKeyDown: (event) => {
        var _a3;
        handleListKeyDown(event);
        (_a3 = handlers.onKeyDown) == null ? void 0 : _a3.call(handlers, event);
      }
    }),
    ownerState
  });
  const resolvedTransitionProps = typeof externalForwardedProps.slotProps.transition === "function" ? externalForwardedProps.slotProps.transition(ownerState) : externalForwardedProps.slotProps.transition;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRoot, __spreadProps(__spreadValues({
    onClose,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: isRtl ? "right" : "left"
    },
    transformOrigin: isRtl ? RTL_ORIGIN : LTR_ORIGIN,
    slots: __spreadValues({
      root: slots.root,
      paper: PaperSlot,
      backdrop: slots.backdrop
    }, slots.transition && {
      // TODO: pass `slots.transition` directly once `TransitionComponent` is removed from Popover
      transition: slots.transition
    }),
    slotProps: {
      root: rootSlotProps,
      paper: paperSlotProps,
      backdrop: typeof slotProps.backdrop === "function" ? slotProps.backdrop(ownerState) : slotProps.backdrop,
      transition: __spreadProps(__spreadValues({}, resolvedTransitionProps), {
        onEntering: (...args) => {
          var _a3;
          handleEntering(...args);
          (_a3 = resolvedTransitionProps == null ? void 0 : resolvedTransitionProps.onEntering) == null ? void 0 : _a3.call(resolvedTransitionProps, ...args);
        }
      })
    },
    open,
    ref,
    transitionDuration,
    ownerState
  }, other), {
    classes: PopoverClasses,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListSlot, __spreadProps(__spreadValues({
      actions: menuListActionsRef,
      autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
      autoFocusItem,
      variant
    }, listSlotProps), {
      children
    }))
  }));
});
function getMenuItemUtilityClass(slot) {
  return generateUtilityClass("MuiMenuItem", slot);
}
const menuItemClasses = generateUtilityClasses("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]);
const React$A = window["React"];
const overridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.dense && styles2.dense, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters];
};
const useUtilityClasses$k = (ownerState) => {
  const {
    disabled,
    dense,
    divider,
    disableGutters,
    selected,
    classes
  } = ownerState;
  const slots = {
    root: ["root", dense && "dense", disabled && "disabled", !disableGutters && "gutters", divider && "divider", selected && "selected"]
  };
  const composedClasses = composeClasses(slots, getMenuItemUtilityClass, classes);
  return __spreadValues(__spreadValues({}, classes), composedClasses);
};
const MenuItemRoot = styled(ButtonBase, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiMenuItem",
  slot: "Root",
  overridesResolver
})(memoTheme(({
  theme: theme2
}) => __spreadProps(__spreadValues({}, theme2.typography.body1), {
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minHeight: 48,
  paddingTop: 6,
  paddingBottom: 6,
  boxSizing: "border-box",
  whiteSpace: "nowrap",
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (theme2.vars || theme2).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${menuItemClasses.selected}`]: {
    backgroundColor: theme2.alpha((theme2.vars || theme2).palette.primary.main, (theme2.vars || theme2).palette.action.selectedOpacity),
    [`&.${menuItemClasses.focusVisible}`]: {
      backgroundColor: theme2.alpha((theme2.vars || theme2).palette.primary.main, `${(theme2.vars || theme2).palette.action.selectedOpacity} + ${(theme2.vars || theme2).palette.action.focusOpacity}`)
    }
  },
  [`&.${menuItemClasses.selected}:hover`]: {
    backgroundColor: theme2.alpha((theme2.vars || theme2).palette.primary.main, `${(theme2.vars || theme2).palette.action.selectedOpacity} + ${(theme2.vars || theme2).palette.action.hoverOpacity}`),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: theme2.alpha((theme2.vars || theme2).palette.primary.main, (theme2.vars || theme2).palette.action.selectedOpacity)
    }
  },
  [`&.${menuItemClasses.focusVisible}`]: {
    backgroundColor: (theme2.vars || theme2).palette.action.focus
  },
  [`&.${menuItemClasses.disabled}`]: {
    opacity: (theme2.vars || theme2).palette.action.disabledOpacity
  },
  [`& + .${dividerClasses.root}`]: {
    marginTop: theme2.spacing(1),
    marginBottom: theme2.spacing(1)
  },
  [`& + .${dividerClasses.inset}`]: {
    marginLeft: 52
  },
  [`& .${listItemTextClasses.root}`]: {
    marginTop: 0,
    marginBottom: 0
  },
  [`& .${listItemTextClasses.inset}`]: {
    paddingLeft: 36
  },
  [`& .${listItemIconClasses.root}`]: {
    minWidth: 36
  },
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.disableGutters,
    style: {
      paddingLeft: 16,
      paddingRight: 16
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.divider,
    style: {
      borderBottom: `1px solid ${(theme2.vars || theme2).palette.divider}`,
      backgroundClip: "padding-box"
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.dense,
    style: {
      [theme2.breakpoints.up("sm")]: {
        minHeight: "auto"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.dense,
    style: __spreadProps(__spreadValues({
      minHeight: 32,
      // https://m2.material.io/components/menus#specs > Dense
      paddingTop: 4,
      paddingBottom: 4
    }, theme2.typography.body2), {
      [`& .${listItemIconClasses.root} svg`]: {
        fontSize: "1.25rem"
      }
    })
  }]
})));
const MenuItem = /* @__PURE__ */ React$A.forwardRef(function MenuItem2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiMenuItem"
  });
  const _a2 = props, {
    autoFocus = false,
    component = "li",
    dense = false,
    divider = false,
    disableGutters = false,
    focusVisibleClassName,
    role = "menuitem",
    tabIndex: tabIndexProp,
    className
  } = _a2, other = __objRest(_a2, [
    "autoFocus",
    "component",
    "dense",
    "divider",
    "disableGutters",
    "focusVisibleClassName",
    "role",
    "tabIndex",
    "className"
  ]);
  const context = React$A.useContext(ListContext);
  const childContext = React$A.useMemo(() => ({
    dense: dense || context.dense || false,
    disableGutters
  }), [context.dense, dense, disableGutters]);
  const menuItemRef = React$A.useRef(null);
  useEnhancedEffect(() => {
    if (autoFocus) {
      if (menuItemRef.current) {
        menuItemRef.current.focus();
      }
    }
  }, [autoFocus]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    dense: childContext.dense,
    divider,
    disableGutters
  });
  const classes = useUtilityClasses$k(props);
  const handleRef = useForkRef(menuItemRef, ref);
  let tabIndex;
  if (!props.disabled) {
    tabIndex = tabIndexProp !== void 0 ? tabIndexProp : -1;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItemRoot, __spreadProps(__spreadValues({
      ref: handleRef,
      role,
      tabIndex,
      component,
      focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
      className: clsx(classes.root, className)
    }, other), {
      ownerState,
      classes
    }))
  });
});
function getNativeSelectUtilityClasses(slot) {
  return generateUtilityClass("MuiNativeSelect", slot);
}
const nativeSelectClasses = generateUtilityClasses("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
const React$z = window["React"];
const useUtilityClasses$j = (ownerState) => {
  const {
    classes,
    variant,
    disabled,
    multiple,
    open,
    error
  } = ownerState;
  const slots = {
    select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
    icon: ["icon", `icon${capitalize(variant)}`, open && "iconOpen", disabled && "disabled"]
  };
  return composeClasses(slots, getNativeSelectUtilityClasses, classes);
};
const StyledSelectSelect = styled("select", {
  name: "MuiNativeSelect"
})(({
  theme: theme2
}) => ({
  // Reset
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // When interacting quickly, the text can end up selected.
  // Native select can't be selected either.
  userSelect: "none",
  // Reset
  borderRadius: 0,
  cursor: "pointer",
  "&:focus": {
    // Reset Chrome style
    borderRadius: 0
  },
  [`&.${nativeSelectClasses.disabled}`]: {
    cursor: "default"
  },
  "&[multiple]": {
    height: "auto"
  },
  "&:not([multiple]) option, &:not([multiple]) optgroup": {
    backgroundColor: (theme2.vars || theme2).palette.background.paper
  },
  variants: [{
    props: ({
      ownerState
    }) => ownerState.variant !== "filled" && ownerState.variant !== "outlined",
    style: {
      // Bump specificity to allow extending custom inputs
      "&&&": {
        paddingRight: 24,
        minWidth: 16
        // So it doesn't collapse.
      }
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      "&&&": {
        paddingRight: 32
      }
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      borderRadius: (theme2.vars || theme2).shape.borderRadius,
      "&:focus": {
        borderRadius: (theme2.vars || theme2).shape.borderRadius
        // Reset the reset for Chrome style
      },
      "&&&": {
        paddingRight: 32
      }
    }
  }]
}));
const NativeSelectSelect = styled(StyledSelectSelect, {
  name: "MuiNativeSelect",
  slot: "Select",
  shouldForwardProp: rootShouldForwardProp,
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.select, styles2[ownerState.variant], ownerState.error && styles2.error, {
      [`&.${nativeSelectClasses.multiple}`]: styles2.multiple
    }];
  }
})({});
const StyledSelectIcon = styled("svg", {
  name: "MuiNativeSelect"
})(({
  theme: theme2
}) => ({
  // We use a position absolute over a flexbox in order to forward the pointer events
  // to the input and to support wrapping tags..
  position: "absolute",
  right: 0,
  // Center vertically, height is 1em
  top: "calc(50% - .5em)",
  // Don't block pointer events on the select under the icon.
  pointerEvents: "none",
  color: (theme2.vars || theme2).palette.action.active,
  [`&.${nativeSelectClasses.disabled}`]: {
    color: (theme2.vars || theme2).palette.action.disabled
  },
  variants: [{
    props: ({
      ownerState
    }) => ownerState.open,
    style: {
      transform: "rotate(180deg)"
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      right: 7
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      right: 7
    }
  }]
}));
const NativeSelectIcon = styled(StyledSelectIcon, {
  name: "MuiNativeSelect",
  slot: "Icon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.icon, ownerState.variant && styles2[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
  }
})({});
const NativeSelectInput = /* @__PURE__ */ React$z.forwardRef(function NativeSelectInput2(props, ref) {
  const _a2 = props, {
    className,
    disabled,
    error,
    IconComponent,
    inputRef,
    variant = "standard"
  } = _a2, other = __objRest(_a2, [
    "className",
    "disabled",
    "error",
    "IconComponent",
    "inputRef",
    "variant"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    disabled,
    variant,
    error
  });
  const classes = useUtilityClasses$j(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(React$z.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectSelect, __spreadValues({
      ownerState,
      className: clsx(classes.select, className),
      disabled,
      ref: inputRef || ref
    }, other)), props.multiple ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectIcon, {
      as: IconComponent,
      ownerState,
      className: classes.icon
    })]
  });
});
var _span$1;
const NotchedOutlineRoot$1 = styled("fieldset", {
  name: "MuiNotchedOutlined",
  shouldForwardProp: rootShouldForwardProp
})({
  textAlign: "left",
  position: "absolute",
  bottom: 0,
  right: 0,
  top: -5,
  left: 0,
  margin: 0,
  padding: "0 8px",
  pointerEvents: "none",
  borderRadius: "inherit",
  borderStyle: "solid",
  borderWidth: 1,
  overflow: "hidden",
  minWidth: "0%"
});
const NotchedOutlineLegend = styled("legend", {
  name: "MuiNotchedOutlined",
  shouldForwardProp: rootShouldForwardProp
})(memoTheme(({
  theme: theme2
}) => ({
  float: "unset",
  // Fix conflict with bootstrap
  width: "auto",
  // Fix conflict with bootstrap
  overflow: "hidden",
  // Fix Horizontal scroll when label too long
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.withLabel,
    style: {
      padding: 0,
      lineHeight: "11px",
      // sync with `height` in `legend` styles
      transition: theme2.transitions.create("width", {
        duration: 150,
        easing: theme2.transitions.easing.easeOut
      })
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.withLabel,
    style: {
      display: "block",
      // Fix conflict with normalize.css and sanitize.css
      padding: 0,
      height: 11,
      // sync with `lineHeight` in `legend` styles
      fontSize: "0.75em",
      visibility: "hidden",
      maxWidth: 0.01,
      transition: theme2.transitions.create("max-width", {
        duration: 50,
        easing: theme2.transitions.easing.easeOut
      }),
      whiteSpace: "nowrap",
      "& > span": {
        paddingLeft: 5,
        paddingRight: 5,
        display: "inline-block",
        opacity: 0,
        visibility: "visible"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.withLabel && ownerState.notched,
    style: {
      maxWidth: "100%",
      transition: theme2.transitions.create("max-width", {
        duration: 100,
        easing: theme2.transitions.easing.easeOut,
        delay: 50
      })
    }
  }]
})));
function NotchedOutline(props) {
  const _a2 = props, {
    children,
    classes,
    className,
    label,
    notched
  } = _a2, other = __objRest(_a2, [
    "children",
    "classes",
    "className",
    "label",
    "notched"
  ]);
  const withLabel = label != null && label !== "";
  const ownerState = __spreadProps(__spreadValues({}, props), {
    notched,
    withLabel
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineRoot$1, __spreadProps(__spreadValues({
    "aria-hidden": true,
    className,
    ownerState
  }, other), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineLegend, {
      ownerState,
      children: withLabel ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        children: label
      }) : (
        // notranslate needed while Google Translate will not fix zero-width space issue
        _span$1 || (_span$1 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: "notranslate",
          "aria-hidden": true,
          children: ""
        }))
      )
    })
  }));
}
const React$y = window["React"];
const useUtilityClasses$i = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    notchedOutline: ["notchedOutline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getOutlinedInputUtilityClass, classes);
  return __spreadValues(__spreadValues({}, classes), composedClasses);
};
const OutlinedInputRoot = styled(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiOutlinedInput",
  slot: "Root",
  overridesResolver: rootOverridesResolver
})(memoTheme(({
  theme: theme2
}) => {
  const borderColor2 = theme2.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    position: "relative",
    borderRadius: (theme2.vars || theme2).shape.borderRadius,
    [`&:hover .${outlinedInputClasses.notchedOutline}`]: {
      borderColor: (theme2.vars || theme2).palette.text.primary
    },
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      [`&:hover .${outlinedInputClasses.notchedOutline}`]: {
        borderColor: theme2.vars ? theme2.alpha(theme2.vars.palette.common.onBackground, 0.23) : borderColor2
      }
    },
    [`&.${outlinedInputClasses.focused} .${outlinedInputClasses.notchedOutline}`]: {
      borderWidth: 2
    },
    variants: [...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
      props: {
        color: color2
      },
      style: {
        [`&.${outlinedInputClasses.focused} .${outlinedInputClasses.notchedOutline}`]: {
          borderColor: (theme2.vars || theme2).palette[color2].main
        }
      }
    })), {
      props: {},
      // to override the above style
      style: {
        [`&.${outlinedInputClasses.error} .${outlinedInputClasses.notchedOutline}`]: {
          borderColor: (theme2.vars || theme2).palette.error.main
        },
        [`&.${outlinedInputClasses.disabled} .${outlinedInputClasses.notchedOutline}`]: {
          borderColor: (theme2.vars || theme2).palette.action.disabled
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.startAdornment,
      style: {
        paddingLeft: 14
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.endAdornment,
      style: {
        paddingRight: 14
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.multiline,
      style: {
        padding: "16.5px 14px"
      }
    }, {
      props: ({
        ownerState,
        size
      }) => ownerState.multiline && size === "small",
      style: {
        padding: "8.5px 14px"
      }
    }]
  };
}));
const NotchedOutlineRoot = styled(NotchedOutline, {
  name: "MuiOutlinedInput",
  slot: "NotchedOutline"
})(memoTheme(({
  theme: theme2
}) => {
  const borderColor2 = theme2.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    borderColor: theme2.vars ? theme2.alpha(theme2.vars.palette.common.onBackground, 0.23) : borderColor2
  };
}));
const OutlinedInputInput = styled(InputBaseInput, {
  name: "MuiOutlinedInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(memoTheme(({
  theme: theme2
}) => __spreadProps(__spreadValues(__spreadValues({
  padding: "16.5px 14px"
}, !theme2.vars && {
  "&:-webkit-autofill": {
    WebkitBoxShadow: theme2.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
    WebkitTextFillColor: theme2.palette.mode === "light" ? null : "#fff",
    caretColor: theme2.palette.mode === "light" ? null : "#fff",
    borderRadius: "inherit"
  }
}), theme2.vars && {
  "&:-webkit-autofill": {
    borderRadius: "inherit"
  },
  [theme2.getColorSchemeSelector("dark")]: {
    "&:-webkit-autofill": {
      WebkitBoxShadow: "0 0 0 100px #266798 inset",
      WebkitTextFillColor: "#fff",
      caretColor: "#fff"
    }
  }
}), {
  variants: [{
    props: {
      size: "small"
    },
    style: {
      padding: "8.5px 14px"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.multiline,
    style: {
      padding: 0
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.endAdornment,
    style: {
      paddingRight: 0
    }
  }]
})));
const OutlinedInput = /* @__PURE__ */ React$y.forwardRef(function OutlinedInput2(inProps, ref) {
  var _b, _c, _d, _e;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiOutlinedInput"
  });
  const _a2 = props, {
    components = {},
    fullWidth = false,
    inputComponent = "input",
    label,
    multiline = false,
    notched,
    slots = {},
    slotProps = {},
    type = "text"
  } = _a2, other = __objRest(_a2, [
    "components",
    "fullWidth",
    "inputComponent",
    "label",
    "multiline",
    "notched",
    "slots",
    "slotProps",
    "type"
  ]);
  const classes = useUtilityClasses$i(props);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
  });
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: fcs.color || "primary",
    disabled: fcs.disabled,
    error: fcs.error,
    focused: fcs.focused,
    formControl: muiFormControl,
    fullWidth,
    hiddenLabel: fcs.hiddenLabel,
    multiline,
    size: fcs.size,
    type
  });
  const RootSlot = (_c = (_b = slots.root) != null ? _b : components.Root) != null ? _c : OutlinedInputRoot;
  const InputSlot = (_e = (_d = slots.input) != null ? _d : components.Input) != null ? _e : OutlinedInputInput;
  const [NotchedSlot, notchedProps] = useSlot("notchedOutline", {
    elementType: NotchedOutlineRoot,
    className: classes.notchedOutline,
    shouldForwardComponentProp: true,
    ownerState,
    externalForwardedProps: {
      slots,
      slotProps
    },
    additionalProps: {
      label: label != null && label !== "" && fcs.required ? /* @__PURE__ */ jsxRuntimeExports.jsxs(React$y.Fragment, {
        children: [label, "", "*"]
      }) : label
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase, __spreadProps(__spreadValues({
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    slotProps,
    renderSuffix: (state) => /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedSlot, __spreadProps(__spreadValues({}, notchedProps), {
      notched: typeof notched !== "undefined" ? notched : Boolean(state.startAdornment || state.filled || state.focused)
    })),
    fullWidth,
    inputComponent,
    multiline,
    ref,
    type
  }, other), {
    classes: __spreadProps(__spreadValues({}, classes), {
      notchedOutline: null
    })
  }));
});
OutlinedInput.muiName = "Input";
const visuallyHidden = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  whiteSpace: "nowrap",
  width: "1px"
};
const Star = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"
}));
const StarBorder = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M22 9.24l-7.19-.62L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.63-7.03L22 9.24zM12 15.4l-3.76 2.27 1-4.28-3.32-2.88 4.38-.38L12 6.1l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.4z"
}));
function getRatingUtilityClass(slot) {
  return generateUtilityClass("MuiRating", slot);
}
const ratingClasses = generateUtilityClasses("MuiRating", ["root", "sizeSmall", "sizeMedium", "sizeLarge", "readOnly", "disabled", "focusVisible", "visuallyHidden", "pristine", "label", "labelEmptyValueActive", "icon", "iconEmpty", "iconFilled", "iconHover", "iconFocus", "iconActive", "decimal"]);
const React$x = window["React"];
const _createElement = window["React"].createElement;
function getDecimalPrecision$1(num) {
  const decimalPart = num.toString().split(".")[1];
  return decimalPart ? decimalPart.length : 0;
}
function roundValueToPrecision(value, precision) {
  if (value == null) {
    return value;
  }
  const nearest = Math.round(value / precision) * precision;
  return Number(nearest.toFixed(getDecimalPrecision$1(precision)));
}
const useUtilityClasses$h = (ownerState) => {
  const {
    classes,
    size,
    readOnly,
    disabled,
    emptyValueFocused,
    focusVisible
  } = ownerState;
  const slots = {
    root: ["root", `size${capitalize(size)}`, disabled && "disabled", focusVisible && "focusVisible", readOnly && "readOnly"],
    label: ["label", "pristine"],
    labelEmptyValue: [emptyValueFocused && "labelEmptyValueActive"],
    icon: ["icon"],
    iconEmpty: ["iconEmpty"],
    iconFilled: ["iconFilled"],
    iconHover: ["iconHover"],
    iconFocus: ["iconFocus"],
    iconActive: ["iconActive"],
    decimal: ["decimal"],
    visuallyHidden: ["visuallyHidden"]
  };
  return composeClasses(slots, getRatingUtilityClass, classes);
};
const RatingRoot = styled("span", {
  name: "MuiRating",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${ratingClasses.visuallyHidden}`]: styles2.visuallyHidden
    }, styles2.root, styles2[`size${capitalize(ownerState.size)}`], ownerState.readOnly && styles2.readOnly];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  display: "inline-flex",
  // Required to position the pristine input absolutely
  position: "relative",
  fontSize: theme2.typography.pxToRem(24),
  color: "#faaf00",
  cursor: "pointer",
  textAlign: "left",
  width: "min-content",
  WebkitTapHighlightColor: "transparent",
  [`&.${ratingClasses.disabled}`]: {
    opacity: (theme2.vars || theme2).palette.action.disabledOpacity,
    pointerEvents: "none"
  },
  [`&.${ratingClasses.focusVisible} .${ratingClasses.iconActive}`]: {
    outline: "1px solid #999"
  },
  [`& .${ratingClasses.visuallyHidden}`]: visuallyHidden,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      fontSize: theme2.typography.pxToRem(18)
    }
  }, {
    props: {
      size: "large"
    },
    style: {
      fontSize: theme2.typography.pxToRem(30)
    }
  }, {
    // TODO v6: use the .Mui-readOnly global state class
    props: ({
      ownerState
    }) => ownerState.readOnly,
    style: {
      pointerEvents: "none"
    }
  }]
})));
const RatingLabel = styled("label", {
  name: "MuiRating",
  slot: "Label",
  overridesResolver: ({
    ownerState
  }, styles2) => [styles2.label, ownerState.emptyValueFocused && styles2.labelEmptyValueActive]
})({
  cursor: "inherit",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.emptyValueFocused,
    style: {
      top: 0,
      bottom: 0,
      position: "absolute",
      outline: "1px solid #999",
      width: "100%"
    }
  }]
});
const RatingIcon = styled("span", {
  name: "MuiRating",
  slot: "Icon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.icon, ownerState.iconEmpty && styles2.iconEmpty, ownerState.iconFilled && styles2.iconFilled, ownerState.iconHover && styles2.iconHover, ownerState.iconFocus && styles2.iconFocus, ownerState.iconActive && styles2.iconActive];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  // Fit wrapper to actual icon size.
  display: "flex",
  transition: theme2.transitions.create("transform", {
    duration: theme2.transitions.duration.shortest
  }),
  // Fix mouseLeave issue.
  // https://github.com/facebook/react/issues/4492
  pointerEvents: "none",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.iconActive,
    style: {
      transform: "scale(1.2)"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.iconEmpty,
    style: {
      color: (theme2.vars || theme2).palette.action.disabled
    }
  }]
})));
const RatingDecimal = styled("span", {
  name: "MuiRating",
  slot: "Decimal",
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "iconActive",
  overridesResolver: (props, styles2) => {
    const {
      iconActive
    } = props;
    return [styles2.decimal, iconActive && styles2.iconActive];
  }
})({
  position: "relative",
  variants: [{
    props: ({
      iconActive
    }) => iconActive,
    style: {
      transform: "scale(1.2)"
    }
  }]
});
function IconContainer(props) {
  const _a2 = props, {
    value
  } = _a2, other = __objRest(_a2, [
    "value"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", __spreadValues({}, other));
}
function RatingItem(props) {
  const {
    classes,
    disabled,
    emptyIcon,
    focus,
    getLabelText,
    highlightSelectedOnly,
    hover,
    icon,
    IconContainerComponent,
    isActive,
    itemValue,
    labelProps,
    name: name2,
    onBlur,
    onChange,
    onClick,
    onFocus,
    readOnly,
    ownerState,
    ratingValue,
    ratingValueRounded,
    slots = {},
    slotProps = {}
  } = props;
  const isFilled2 = highlightSelectedOnly ? itemValue === ratingValue : itemValue <= ratingValue;
  const isHovered = itemValue <= hover;
  const isFocused = itemValue <= focus;
  const isChecked = itemValue === ratingValueRounded;
  const id = `${name2}-${useId()}`;
  const externalForwardedProps = {
    slots,
    slotProps
  };
  const [IconSlot, iconSlotProps] = useSlot("icon", {
    elementType: RatingIcon,
    className: clsx(classes.icon, isFilled2 ? classes.iconFilled : classes.iconEmpty, isHovered && classes.iconHover, isFocused && classes.iconFocus, isActive && classes.iconActive),
    externalForwardedProps,
    ownerState: __spreadProps(__spreadValues({}, ownerState), {
      iconEmpty: !isFilled2,
      iconFilled: isFilled2,
      iconHover: isHovered,
      iconFocus: isFocused,
      iconActive: isActive
    }),
    additionalProps: {
      value: itemValue
    },
    internalForwardedProps: {
      // TODO: remove this in v7 because `IconContainerComponent` is deprecated
      // only forward if `slots.icon` is NOT provided
      as: IconContainerComponent
    }
  });
  const [LabelSlot, labelSlotProps] = useSlot("label", {
    elementType: RatingLabel,
    externalForwardedProps,
    ownerState: __spreadProps(__spreadValues({}, ownerState), {
      emptyValueFocused: void 0
    }),
    additionalProps: {
      style: labelProps == null ? void 0 : labelProps.style,
      htmlFor: id
    }
  });
  const container = /* @__PURE__ */ jsxRuntimeExports.jsx(IconSlot, __spreadProps(__spreadValues({}, iconSlotProps), {
    children: emptyIcon && !isFilled2 ? emptyIcon : icon
  }));
  if (readOnly) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("span", __spreadProps(__spreadValues({}, labelProps), {
      children: container
    }));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(React$x.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(LabelSlot, __spreadProps(__spreadValues({}, labelSlotProps), {
      children: [container, /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: classes.visuallyHidden,
        children: getLabelText(itemValue)
      })]
    })), /* @__PURE__ */ jsxRuntimeExports.jsx("input", {
      className: classes.visuallyHidden,
      onFocus,
      onBlur,
      onChange,
      onClick,
      disabled,
      value: itemValue,
      id,
      type: "radio",
      name: name2,
      checked: isChecked
    })]
  });
}
const defaultIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(Star, {
  fontSize: "inherit"
});
const defaultEmptyIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(StarBorder, {
  fontSize: "inherit"
});
function defaultLabelText(value) {
  return `${value || "0"} Star${value !== 1 ? "s" : ""}`;
}
const Rating = /* @__PURE__ */ React$x.forwardRef(function Rating2(inProps, ref) {
  const props = useDefaultProps({
    name: "MuiRating",
    props: inProps
  });
  const _a2 = props, {
    component = "span",
    className,
    defaultValue = null,
    disabled = false,
    emptyIcon = defaultEmptyIcon,
    emptyLabelText = "Empty",
    getLabelText = defaultLabelText,
    highlightSelectedOnly = false,
    icon = defaultIcon,
    IconContainerComponent = IconContainer,
    max: max2 = 5,
    name: nameProp,
    onChange,
    onChangeActive,
    onMouseLeave,
    onMouseMove,
    precision = 1,
    readOnly = false,
    size = "medium",
    value: valueProp,
    slots = {},
    slotProps = {}
  } = _a2, other = __objRest(_a2, [
    "component",
    "className",
    "defaultValue",
    "disabled",
    "emptyIcon",
    "emptyLabelText",
    "getLabelText",
    "highlightSelectedOnly",
    "icon",
    "IconContainerComponent",
    "max",
    "name",
    "onChange",
    "onChangeActive",
    "onMouseLeave",
    "onMouseMove",
    "precision",
    "readOnly",
    "size",
    "value",
    "slots",
    "slotProps"
  ]);
  const name2 = useId(nameProp);
  const [valueDerived, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: "Rating"
  });
  const valueRounded = roundValueToPrecision(valueDerived, precision);
  const isRtl = useRtl();
  const [{
    hover,
    focus
  }, setState] = React$x.useState({
    hover: -1,
    focus: -1
  });
  let value = valueRounded;
  if (hover !== -1) {
    value = hover;
  }
  if (focus !== -1) {
    value = focus;
  }
  const [focusVisible, setFocusVisible] = React$x.useState(false);
  const rootRef = React$x.useRef();
  const handleRef = useForkRef(rootRef, ref);
  const handleMouseMove = (event) => {
    if (onMouseMove) {
      onMouseMove(event);
    }
    const rootNode = rootRef.current;
    const {
      right: right2,
      left: left2,
      width: containerWidth
    } = rootNode.getBoundingClientRect();
    let percent;
    if (isRtl) {
      percent = (right2 - event.clientX) / containerWidth;
    } else {
      percent = (event.clientX - left2) / containerWidth;
    }
    let newHover = roundValueToPrecision(max2 * percent + precision / 2, precision);
    newHover = clamp(newHover, precision, max2);
    setState((prev2) => prev2.hover === newHover && prev2.focus === newHover ? prev2 : {
      hover: newHover,
      focus: newHover
    });
    setFocusVisible(false);
    if (onChangeActive && hover !== newHover) {
      onChangeActive(event, newHover);
    }
  };
  const handleMouseLeave = (event) => {
    if (onMouseLeave) {
      onMouseLeave(event);
    }
    const newHover = -1;
    setState({
      hover: newHover,
      focus: newHover
    });
    if (onChangeActive && hover !== newHover) {
      onChangeActive(event, newHover);
    }
  };
  const handleChange = (event) => {
    let newValue = event.target.value === "" ? null : parseFloat(event.target.value);
    if (hover !== -1) {
      newValue = hover;
    }
    setValueState(newValue);
    if (onChange) {
      onChange(event, newValue);
    }
  };
  const handleClear = (event) => {
    if (event.clientX === 0 && event.clientY === 0) {
      return;
    }
    setState({
      hover: -1,
      focus: -1
    });
    setValueState(null);
    if (onChange && parseFloat(event.target.value) === valueRounded) {
      onChange(event, null);
    }
  };
  const handleFocus = (event) => {
    if (isFocusVisible(event.target)) {
      setFocusVisible(true);
    }
    const newFocus = parseFloat(event.target.value);
    setState((prev2) => ({
      hover: prev2.hover,
      focus: newFocus
    }));
  };
  const handleBlur = (event) => {
    if (hover !== -1) {
      return;
    }
    if (!isFocusVisible(event.target)) {
      setFocusVisible(false);
    }
    const newFocus = -1;
    setState((prev2) => ({
      hover: prev2.hover,
      focus: newFocus
    }));
  };
  const [emptyValueFocused, setEmptyValueFocused] = React$x.useState(false);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component,
    defaultValue,
    disabled,
    emptyIcon,
    emptyLabelText,
    emptyValueFocused,
    focusVisible,
    getLabelText,
    icon,
    IconContainerComponent,
    max: max2,
    precision,
    readOnly,
    size
  });
  const classes = useUtilityClasses$h(ownerState);
  const externalForwardedProps = {
    slots,
    slotProps
  };
  const [RootSlot, rootSlotProps] = useSlot("root", {
    ref: handleRef,
    className: clsx(classes.root, className),
    elementType: RatingRoot,
    externalForwardedProps: __spreadProps(__spreadValues(__spreadValues({}, externalForwardedProps), other), {
      component
    }),
    getSlotProps: (handlers) => __spreadProps(__spreadValues({}, handlers), {
      onMouseMove: (event) => {
        var _a3;
        handleMouseMove(event);
        (_a3 = handlers.onMouseMove) == null ? void 0 : _a3.call(handlers, event);
      },
      onMouseLeave: (event) => {
        var _a3;
        handleMouseLeave(event);
        (_a3 = handlers.onMouseLeave) == null ? void 0 : _a3.call(handlers, event);
      }
    }),
    ownerState,
    additionalProps: {
      role: readOnly ? "img" : null,
      "aria-label": readOnly ? getLabelText(value) : null
    }
  });
  const [LabelSlot, labelSlotProps] = useSlot("label", {
    className: clsx(classes.label, classes.labelEmptyValue),
    elementType: RatingLabel,
    externalForwardedProps,
    ownerState
  });
  const [DecimalSlot, decimalSlotProps] = useSlot("decimal", {
    className: classes.decimal,
    elementType: RatingDecimal,
    externalForwardedProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, __spreadProps(__spreadValues({}, rootSlotProps), {
    children: [Array.from(new Array(max2)).map((_, index2) => {
      const itemValue = index2 + 1;
      const ratingItemProps = {
        classes,
        disabled,
        emptyIcon,
        focus,
        getLabelText,
        highlightSelectedOnly,
        hover,
        icon,
        IconContainerComponent,
        name: name2,
        onBlur: handleBlur,
        onChange: handleChange,
        onClick: handleClear,
        onFocus: handleFocus,
        ratingValue: value,
        ratingValueRounded: valueRounded,
        readOnly,
        ownerState,
        slots,
        slotProps
      };
      const isActive = itemValue === Math.ceil(value) && (hover !== -1 || focus !== -1);
      if (precision < 1) {
        const items = Array.from(new Array(1 / precision));
        return /* @__PURE__ */ _createElement(DecimalSlot, __spreadProps(__spreadValues({}, decimalSlotProps), {
          key: itemValue,
          className: clsx(decimalSlotProps.className, isActive && classes.iconActive),
          iconActive: isActive
        }), items.map(($, indexDecimal) => {
          const itemDecimalValue = roundValueToPrecision(itemValue - 1 + (indexDecimal + 1) * precision, precision);
          return /* @__PURE__ */ jsxRuntimeExports.jsx(RatingItem, __spreadProps(__spreadValues({}, ratingItemProps), {
            // The icon is already displayed as active
            isActive: false,
            itemValue: itemDecimalValue,
            labelProps: {
              style: items.length - 1 === indexDecimal ? {} : {
                width: itemDecimalValue === value ? `${(indexDecimal + 1) * precision * 100}%` : "0%",
                overflow: "hidden",
                position: "absolute"
              }
            }
          }), itemDecimalValue);
        }));
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(RatingItem, __spreadProps(__spreadValues({}, ratingItemProps), {
        isActive,
        itemValue
      }), itemValue);
    }), !readOnly && !disabled && /* @__PURE__ */ jsxRuntimeExports.jsxs(LabelSlot, __spreadProps(__spreadValues({}, labelSlotProps), {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx("input", {
        className: classes.visuallyHidden,
        value: "",
        id: `${name2}-empty`,
        type: "radio",
        name: name2,
        checked: valueRounded == null,
        onFocus: () => setEmptyValueFocused(true),
        onBlur: () => setEmptyValueFocused(false),
        onChange: handleChange
      }), /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: classes.visuallyHidden,
        children: emptyLabelText
      })]
    }))]
  }));
});
function getSelectUtilityClasses(slot) {
  return generateUtilityClass("MuiSelect", slot);
}
const selectClasses = generateUtilityClasses("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
var _span;
const React$w = window["React"];
const SelectSelect = styled(StyledSelectSelect, {
  name: "MuiSelect",
  slot: "Select",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [
      // Win specificity over the input base
      {
        [`&.${selectClasses.select}`]: styles2.select
      },
      {
        [`&.${selectClasses.select}`]: styles2[ownerState.variant]
      },
      {
        [`&.${selectClasses.error}`]: styles2.error
      },
      {
        [`&.${selectClasses.multiple}`]: styles2.multiple
      }
    ];
  }
})({
  // Win specificity over the input base
  [`&.${selectClasses.select}`]: {
    height: "auto",
    // Resets for multiple select with chips
    minHeight: "1.4375em",
    // Required for select\text-field height consistency
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden"
  }
});
const SelectIcon = styled(StyledSelectIcon, {
  name: "MuiSelect",
  slot: "Icon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.icon, ownerState.variant && styles2[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
  }
})({});
const SelectNativeInput = styled("input", {
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "classes",
  name: "MuiSelect",
  slot: "NativeInput"
})({
  bottom: 0,
  left: 0,
  position: "absolute",
  opacity: 0,
  pointerEvents: "none",
  width: "100%",
  boxSizing: "border-box"
});
function areEqualValues(a, b) {
  if (typeof b === "object" && b !== null) {
    return a === b;
  }
  return String(a) === String(b);
}
function isEmpty(display) {
  return display == null || typeof display === "string" && !display.trim();
}
const useUtilityClasses$g = (ownerState) => {
  const {
    classes,
    variant,
    disabled,
    multiple,
    open,
    error
  } = ownerState;
  const slots = {
    select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
    icon: ["icon", `icon${capitalize(variant)}`, open && "iconOpen", disabled && "disabled"],
    nativeInput: ["nativeInput"]
  };
  return composeClasses(slots, getSelectUtilityClasses, classes);
};
const SelectInput = /* @__PURE__ */ React$w.forwardRef(function SelectInput2(props, ref) {
  var _b, _c, _d, _e;
  const _a2 = props, {
    "aria-describedby": ariaDescribedby,
    "aria-label": ariaLabel,
    autoFocus,
    autoWidth,
    children,
    className,
    defaultOpen,
    defaultValue,
    disabled,
    displayEmpty,
    error = false,
    IconComponent,
    inputRef: inputRefProp,
    labelId,
    MenuProps = {},
    multiple,
    name: name2,
    onBlur,
    onChange,
    onClose,
    onFocus,
    onOpen,
    open: openProp,
    readOnly,
    renderValue,
    required,
    SelectDisplayProps = {},
    tabIndex: tabIndexProp,
    type: type,
    value: valueProp,
    variant = "standard"
  } = _a2, other = __objRest(_a2, [
    "aria-describedby",
    "aria-label",
    "autoFocus",
    "autoWidth",
    "children",
    "className",
    "defaultOpen",
    "defaultValue",
    "disabled",
    "displayEmpty",
    "error",
    "IconComponent",
    "inputRef",
    "labelId",
    "MenuProps",
    "multiple",
    "name",
    "onBlur",
    "onChange",
    "onClose",
    "onFocus",
    "onOpen",
    "open",
    "readOnly",
    "renderValue",
    "required",
    "SelectDisplayProps",
    "tabIndex",
    // catching `type` from Input which makes no sense for SelectInput
    "type",
    "value",
    "variant"
  ]);
  const [value, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: "Select"
  });
  const [openState, setOpenState] = useControlled({
    controlled: openProp,
    default: defaultOpen,
    name: "Select"
  });
  const inputRef = React$w.useRef(null);
  const displayRef = React$w.useRef(null);
  const [displayNode, setDisplayNode] = React$w.useState(null);
  const {
    current: isOpenControlled
  } = React$w.useRef(openProp != null);
  const [menuMinWidthState, setMenuMinWidthState] = React$w.useState();
  const handleRef = useForkRef(ref, inputRefProp);
  const handleDisplayRef = React$w.useCallback((node2) => {
    displayRef.current = node2;
    if (node2) {
      setDisplayNode(node2);
    }
  }, []);
  const anchorElement = displayNode == null ? void 0 : displayNode.parentNode;
  React$w.useImperativeHandle(handleRef, () => ({
    focus: () => {
      displayRef.current.focus();
    },
    node: inputRef.current,
    value
  }), [value]);
  React$w.useEffect(() => {
    if (defaultOpen && openState && displayNode && !isOpenControlled) {
      setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
      displayRef.current.focus();
    }
  }, [displayNode, autoWidth]);
  React$w.useEffect(() => {
    if (autoFocus) {
      displayRef.current.focus();
    }
  }, [autoFocus]);
  React$w.useEffect(() => {
    if (!labelId) {
      return void 0;
    }
    const label = ownerDocument(displayRef.current).getElementById(labelId);
    if (label) {
      const handler = () => {
        if (getSelection().isCollapsed) {
          displayRef.current.focus();
        }
      };
      label.addEventListener("click", handler);
      return () => {
        label.removeEventListener("click", handler);
      };
    }
    return void 0;
  }, [labelId]);
  const update = (open2, event) => {
    if (open2) {
      if (onOpen) {
        onOpen(event);
      }
    } else if (onClose) {
      onClose(event);
    }
    if (!isOpenControlled) {
      setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
      setOpenState(open2);
    }
  };
  const handleMouseDown = (event) => {
    if (event.button !== 0) {
      return;
    }
    event.preventDefault();
    displayRef.current.focus();
    update(true, event);
  };
  const handleClose = (event) => {
    update(false, event);
  };
  const childrenArray = React$w.Children.toArray(children);
  const handleChange = (event) => {
    const child = childrenArray.find((childItem) => childItem.props.value === event.target.value);
    if (child === void 0) {
      return;
    }
    setValueState(child.props.value);
    if (onChange) {
      onChange(event, child);
    }
  };
  const handleItemClick = (child) => (event) => {
    let newValue;
    if (!event.currentTarget.hasAttribute("tabindex")) {
      return;
    }
    if (multiple) {
      newValue = Array.isArray(value) ? value.slice() : [];
      const itemIndex = value.indexOf(child.props.value);
      if (itemIndex === -1) {
        newValue.push(child.props.value);
      } else {
        newValue.splice(itemIndex, 1);
      }
    } else {
      newValue = child.props.value;
    }
    if (child.props.onClick) {
      child.props.onClick(event);
    }
    if (value !== newValue) {
      setValueState(newValue);
      if (onChange) {
        const nativeEvent = event.nativeEvent || event;
        const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
        Object.defineProperty(clonedEvent, "target", {
          writable: true,
          value: {
            value: newValue,
            name: name2
          }
        });
        onChange(clonedEvent, child);
      }
    }
    if (!multiple) {
      update(false, event);
    }
  };
  const handleKeyDown = (event) => {
    if (!readOnly) {
      const validKeys = [
        " ",
        "ArrowUp",
        "ArrowDown",
        // The native select doesn't respond to enter on macOS, but it's recommended by
        // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
        "Enter"
      ];
      if (validKeys.includes(event.key)) {
        event.preventDefault();
        update(true, event);
      }
    }
  };
  const open = displayNode !== null && openState;
  const handleBlur = (event) => {
    if (!open && onBlur) {
      Object.defineProperty(event, "target", {
        writable: true,
        value: {
          value,
          name: name2
        }
      });
      onBlur(event);
    }
  };
  delete other["aria-invalid"];
  let display;
  let displaySingle;
  const displayMultiple = [];
  let computeDisplay = false;
  if (isFilled({
    value
  }) || displayEmpty) {
    if (renderValue) {
      display = renderValue(value);
    } else {
      computeDisplay = true;
    }
  }
  const items = childrenArray.map((child) => {
    if (!/* @__PURE__ */ React$w.isValidElement(child)) {
      return null;
    }
    let selected;
    if (multiple) {
      if (!Array.isArray(value)) {
        throw new Error(formatMuiErrorMessage(2));
      }
      selected = value.some((v) => areEqualValues(v, child.props.value));
      if (selected && computeDisplay) {
        displayMultiple.push(child.props.children);
      }
    } else {
      selected = areEqualValues(value, child.props.value);
      if (selected && computeDisplay) {
        displaySingle = child.props.children;
      }
    }
    return /* @__PURE__ */ React$w.cloneElement(child, {
      "aria-selected": selected ? "true" : "false",
      onClick: handleItemClick(child),
      onKeyUp: (event) => {
        if (event.key === " ") {
          event.preventDefault();
        }
        if (child.props.onKeyUp) {
          child.props.onKeyUp(event);
        }
      },
      role: "option",
      selected,
      value: void 0,
      // The value is most likely not a valid HTML attribute.
      "data-value": child.props.value
      // Instead, we provide it as a data attribute.
    });
  });
  if (computeDisplay) {
    if (multiple) {
      if (displayMultiple.length === 0) {
        display = null;
      } else {
        display = displayMultiple.reduce((output, child, index2) => {
          output.push(child);
          if (index2 < displayMultiple.length - 1) {
            output.push(", ");
          }
          return output;
        }, []);
      }
    } else {
      display = displaySingle;
    }
  }
  let menuMinWidth = menuMinWidthState;
  if (!autoWidth && isOpenControlled && displayNode) {
    menuMinWidth = anchorElement.clientWidth;
  }
  let tabIndex;
  if (typeof tabIndexProp !== "undefined") {
    tabIndex = tabIndexProp;
  } else {
    tabIndex = disabled ? null : 0;
  }
  const buttonId = SelectDisplayProps.id || (name2 ? `mui-component-select-${name2}` : void 0);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    variant,
    value,
    open,
    error
  });
  const classes = useUtilityClasses$g(ownerState);
  const paperProps = __spreadValues(__spreadValues({}, MenuProps.PaperProps), typeof ((_b = MenuProps.slotProps) == null ? void 0 : _b.paper) === "function" ? MenuProps.slotProps.paper(ownerState) : (_c = MenuProps.slotProps) == null ? void 0 : _c.paper);
  const listProps = __spreadValues(__spreadValues({}, MenuProps.MenuListProps), typeof ((_d = MenuProps.slotProps) == null ? void 0 : _d.list) === "function" ? MenuProps.slotProps.list(ownerState) : (_e = MenuProps.slotProps) == null ? void 0 : _e.list);
  const listboxId = useId();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(React$w.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SelectSelect, __spreadProps(__spreadValues({
      as: "div",
      ref: handleDisplayRef,
      tabIndex,
      role: "combobox",
      "aria-controls": open ? listboxId : void 0,
      "aria-disabled": disabled ? "true" : void 0,
      "aria-expanded": open ? "true" : "false",
      "aria-haspopup": "listbox",
      "aria-label": ariaLabel,
      "aria-labelledby": [labelId, buttonId].filter(Boolean).join(" ") || void 0,
      "aria-describedby": ariaDescribedby,
      "aria-required": required ? "true" : void 0,
      "aria-invalid": error ? "true" : void 0,
      onKeyDown: handleKeyDown,
      onMouseDown: disabled || readOnly ? null : handleMouseDown,
      onBlur: handleBlur,
      onFocus
    }, SelectDisplayProps), {
      ownerState,
      className: clsx(SelectDisplayProps.className, classes.select, className),
      id: buttonId,
      children: isEmpty(display) ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        _span || (_span = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: "notranslate",
          "aria-hidden": true,
          children: ""
        }))
      ) : display
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectNativeInput, __spreadProps(__spreadValues({
      "aria-invalid": error,
      value: Array.isArray(value) ? value.join(",") : value,
      name: name2,
      ref: inputRef,
      "aria-hidden": true,
      onChange: handleChange,
      tabIndex: -1,
      disabled,
      className: classes.nativeInput,
      autoFocus,
      required
    }, other), {
      ownerState
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectIcon, {
      as: IconComponent,
      className: classes.icon,
      ownerState
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(Menu, __spreadProps(__spreadValues({
      id: `menu-${name2 || ""}`,
      anchorEl: anchorElement,
      open,
      onClose: handleClose,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "center"
      }
    }, MenuProps), {
      slotProps: __spreadProps(__spreadValues({}, MenuProps.slotProps), {
        list: __spreadValues({
          "aria-labelledby": labelId,
          role: "listbox",
          "aria-multiselectable": multiple ? "true" : void 0,
          disableListWrap: true,
          id: listboxId
        }, listProps),
        paper: __spreadProps(__spreadValues({}, paperProps), {
          style: __spreadValues({
            minWidth: menuMinWidth
          }, paperProps != null ? paperProps.style : null)
        })
      }),
      children: items
    }))]
  });
});
const React$v = window["React"];
const useUtilityClasses$f = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  const composedClasses = composeClasses(slots, getSelectUtilityClasses, classes);
  return __spreadValues(__spreadValues({}, classes), composedClasses);
};
const styledRootConfig = {
  name: "MuiSelect",
  slot: "Root",
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) && prop !== "variant"
};
const StyledInput = styled(Input, styledRootConfig)("");
const StyledOutlinedInput = styled(OutlinedInput, styledRootConfig)("");
const StyledFilledInput = styled(FilledInput, styledRootConfig)("");
const Select = /* @__PURE__ */ React$v.forwardRef(function Select2(inProps, ref) {
  const props = useDefaultProps({
    name: "MuiSelect",
    props: inProps
  });
  const _a2 = props, {
    autoWidth = false,
    children,
    classes: classesProp = {},
    className,
    defaultOpen = false,
    displayEmpty = false,
    IconComponent = ArrowDropDownIcon,
    id,
    input,
    inputProps,
    label,
    labelId,
    MenuProps,
    multiple = false,
    native = false,
    onClose,
    onOpen,
    open,
    renderValue,
    SelectDisplayProps,
    variant: variantProp = "outlined"
  } = _a2, other = __objRest(_a2, [
    "autoWidth",
    "children",
    "classes",
    "className",
    "defaultOpen",
    "displayEmpty",
    "IconComponent",
    "id",
    "input",
    "inputProps",
    "label",
    "labelId",
    "MenuProps",
    "multiple",
    "native",
    "onClose",
    "onOpen",
    "open",
    "renderValue",
    "SelectDisplayProps",
    "variant"
  ]);
  const inputComponent = native ? NativeSelectInput : SelectInput;
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["variant", "error"]
  });
  const variant = fcs.variant || variantProp;
  const ownerState = __spreadProps(__spreadValues({}, props), {
    variant,
    classes: classesProp
  });
  const classes = useUtilityClasses$f(ownerState);
  const _b = classes, {
    root
  } = _b, restOfClasses = __objRest(_b, [
    "root"
  ]);
  const InputComponent = input || {
    standard: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledInput, {
      ownerState
    }),
    outlined: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledOutlinedInput, {
      label,
      ownerState
    }),
    filled: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledFilledInput, {
      ownerState
    })
  }[variant];
  const inputComponentRef = useForkRef(ref, getReactElementRef(InputComponent));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(React$v.Fragment, {
    children: /* @__PURE__ */ React$v.cloneElement(InputComponent, __spreadValues(__spreadValues(__spreadProps(__spreadValues({
      // Most of the logic is implemented in `SelectInput`.
      // The `Select` component is a simple API wrapper to expose something better to play with.
      inputComponent,
      inputProps: __spreadValues(__spreadProps(__spreadValues(__spreadValues({
        children,
        error: fcs.error,
        IconComponent,
        variant,
        type: void 0,
        // We render a select. We can ignore the type provided by the `Input`.
        multiple
      }, native ? {
        id
      } : {
        autoWidth,
        defaultOpen,
        displayEmpty,
        labelId,
        MenuProps,
        onClose,
        onOpen,
        open,
        renderValue,
        SelectDisplayProps: __spreadValues({
          id
        }, SelectDisplayProps)
      }), inputProps), {
        classes: inputProps ? deepmerge(restOfClasses, inputProps.classes) : restOfClasses
      }), input ? input.props.inputProps : {})
    }, (multiple && native || displayEmpty) && variant === "outlined" ? {
      notched: true
    } : {}), {
      ref: inputComponentRef,
      className: clsx(InputComponent.props.className, className, classes.root)
    }), !input && {
      variant
    }), other))
  });
});
Select.muiName = "Select";
function areArraysEqual(array1, array2, itemComparer = (a, b) => a === b) {
  return array1.length === array2.length && array1.every((value, index2) => itemComparer(value, array2[index2]));
}
const React$u = window["React"];
const INTENTIONAL_DRAG_COUNT_THRESHOLD = 2;
function getNewValue(currentValue, step, direction, min2, max2) {
  return direction === 1 ? Math.min(currentValue + step, max2) : Math.max(currentValue - step, min2);
}
function asc(a, b) {
  return a - b;
}
function findClosest(values2, currentValue) {
  var _a2;
  const {
    index: closestIndex
  } = (_a2 = values2.reduce((acc, value, index2) => {
    const distance = Math.abs(currentValue - value);
    if (acc === null || distance < acc.distance || distance === acc.distance) {
      return {
        distance,
        index: index2
      };
    }
    return acc;
  }, null)) != null ? _a2 : {};
  return closestIndex;
}
function trackFinger(event, touchId) {
  if (touchId.current !== void 0 && event.changedTouches) {
    const touchEvent = event;
    for (let i = 0; i < touchEvent.changedTouches.length; i += 1) {
      const touch = touchEvent.changedTouches[i];
      if (touch.identifier === touchId.current) {
        return {
          x: touch.clientX,
          y: touch.clientY
        };
      }
    }
    return false;
  }
  return {
    x: event.clientX,
    y: event.clientY
  };
}
function valueToPercent(value, min2, max2) {
  return (value - min2) * 100 / (max2 - min2);
}
function percentToValue(percent, min2, max2) {
  return (max2 - min2) * percent + min2;
}
function getDecimalPrecision(num) {
  if (Math.abs(num) < 1) {
    const parts = num.toExponential().split("e-");
    const matissaDecimalPart = parts[0].split(".")[1];
    return (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(parts[1], 10);
  }
  const decimalPart = num.toString().split(".")[1];
  return decimalPart ? decimalPart.length : 0;
}
function roundValueToStep(value, step, min2) {
  const nearest = Math.round((value - min2) / step) * step + min2;
  return Number(nearest.toFixed(getDecimalPrecision(step)));
}
function setValueIndex({
  values: values2,
  newValue,
  index: index2
}) {
  const output = values2.slice();
  output[index2] = newValue;
  return output.sort(asc);
}
function focusThumb({
  sliderRef,
  activeIndex,
  setActive
}) {
  var _a2, _b, _c;
  const doc = ownerDocument(sliderRef.current);
  if (!((_a2 = sliderRef.current) == null ? void 0 : _a2.contains(doc.activeElement)) || Number((_b = doc == null ? void 0 : doc.activeElement) == null ? void 0 : _b.getAttribute("data-index")) !== activeIndex) {
    (_c = sliderRef.current) == null ? void 0 : _c.querySelector(`[type="range"][data-index="${activeIndex}"]`).focus();
  }
  if (setActive) {
    setActive(activeIndex);
  }
}
function areValuesEqual(newValue, oldValue) {
  if (typeof newValue === "number" && typeof oldValue === "number") {
    return newValue === oldValue;
  }
  if (typeof newValue === "object" && typeof oldValue === "object") {
    return areArraysEqual(newValue, oldValue);
  }
  return false;
}
const axisProps = {
  horizontal: {
    offset: (percent) => ({
      left: `${percent}%`
    }),
    leap: (percent) => ({
      width: `${percent}%`
    })
  },
  "horizontal-reverse": {
    offset: (percent) => ({
      right: `${percent}%`
    }),
    leap: (percent) => ({
      width: `${percent}%`
    })
  },
  vertical: {
    offset: (percent) => ({
      bottom: `${percent}%`
    }),
    leap: (percent) => ({
      height: `${percent}%`
    })
  }
};
const Identity$1 = (x) => x;
let cachedSupportsTouchActionNone;
function doesSupportTouchActionNone() {
  if (cachedSupportsTouchActionNone === void 0) {
    if (typeof CSS !== "undefined" && typeof CSS.supports === "function") {
      cachedSupportsTouchActionNone = CSS.supports("touch-action", "none");
    } else {
      cachedSupportsTouchActionNone = true;
    }
  }
  return cachedSupportsTouchActionNone;
}
function useSlider(parameters) {
  const {
    "aria-labelledby": ariaLabelledby,
    defaultValue,
    disabled = false,
    disableSwap = false,
    isRtl = false,
    marks: marksProp = false,
    max: max2 = 100,
    min: min2 = 0,
    name: name2,
    onChange,
    onChangeCommitted,
    orientation = "horizontal",
    rootRef: ref,
    scale = Identity$1,
    step = 1,
    shiftStep = 10,
    tabIndex,
    value: valueProp
  } = parameters;
  const touchId = React$u.useRef(void 0);
  const [active, setActive] = React$u.useState(-1);
  const [open, setOpen] = React$u.useState(-1);
  const [dragging, setDragging] = React$u.useState(false);
  const moveCount = React$u.useRef(0);
  const lastChangedValue = React$u.useRef(null);
  const [valueDerived, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue != null ? defaultValue : min2,
    name: "Slider"
  });
  const handleChange = onChange && ((event, value, thumbIndex) => {
    const nativeEvent = event.nativeEvent || event;
    const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
    Object.defineProperty(clonedEvent, "target", {
      writable: true,
      value: {
        value,
        name: name2
      }
    });
    lastChangedValue.current = value;
    onChange(clonedEvent, value, thumbIndex);
  });
  const range = Array.isArray(valueDerived);
  let values2 = range ? valueDerived.slice().sort(asc) : [valueDerived];
  values2 = values2.map((value) => value == null ? min2 : clamp(value, min2, max2));
  const marks = marksProp === true && step !== null ? [...Array(Math.floor((max2 - min2) / step) + 1)].map((_, index2) => ({
    value: min2 + step * index2
  })) : marksProp || [];
  const marksValues = marks.map((mark) => mark.value);
  const [focusedThumbIndex, setFocusedThumbIndex] = React$u.useState(-1);
  const sliderRef = React$u.useRef(null);
  const handleRef = useForkRef(ref, sliderRef);
  const createHandleHiddenInputFocus = (otherHandlers) => (event) => {
    var _a2;
    const index2 = Number(event.currentTarget.getAttribute("data-index"));
    if (isFocusVisible(event.target)) {
      setFocusedThumbIndex(index2);
    }
    setOpen(index2);
    (_a2 = otherHandlers == null ? void 0 : otherHandlers.onFocus) == null ? void 0 : _a2.call(otherHandlers, event);
  };
  const createHandleHiddenInputBlur = (otherHandlers) => (event) => {
    var _a2;
    if (!isFocusVisible(event.target)) {
      setFocusedThumbIndex(-1);
    }
    setOpen(-1);
    (_a2 = otherHandlers == null ? void 0 : otherHandlers.onBlur) == null ? void 0 : _a2.call(otherHandlers, event);
  };
  const changeValue = (event, valueInput) => {
    var _a2;
    const index2 = Number(event.currentTarget.getAttribute("data-index"));
    const value = values2[index2];
    const marksIndex = marksValues.indexOf(value);
    let newValue = valueInput;
    if (marks && step == null) {
      const maxMarksValue = marksValues[marksValues.length - 1];
      if (newValue >= maxMarksValue) {
        newValue = maxMarksValue;
      } else if (newValue <= marksValues[0]) {
        newValue = marksValues[0];
      } else {
        newValue = newValue < value ? marksValues[marksIndex - 1] : marksValues[marksIndex + 1];
      }
    }
    newValue = clamp(newValue, min2, max2);
    if (range) {
      if (disableSwap) {
        newValue = clamp(newValue, values2[index2 - 1] || -Infinity, values2[index2 + 1] || Infinity);
      }
      const previousValue = newValue;
      newValue = setValueIndex({
        values: values2,
        newValue,
        index: index2
      });
      let activeIndex = index2;
      if (!disableSwap) {
        activeIndex = newValue.indexOf(previousValue);
      }
      focusThumb({
        sliderRef,
        activeIndex
      });
    }
    setValueState(newValue);
    setFocusedThumbIndex(index2);
    if (handleChange && !areValuesEqual(newValue, valueDerived)) {
      handleChange(event, newValue, index2);
    }
    if (onChangeCommitted) {
      onChangeCommitted(event, (_a2 = lastChangedValue.current) != null ? _a2 : newValue);
    }
  };
  const createHandleHiddenInputKeyDown = (otherHandlers) => (event) => {
    var _a2;
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "PageUp", "PageDown", "Home", "End"].includes(event.key)) {
      event.preventDefault();
      const index2 = Number(event.currentTarget.getAttribute("data-index"));
      const value = values2[index2];
      let newValue = null;
      if (step != null) {
        const stepSize = event.shiftKey ? shiftStep : step;
        switch (event.key) {
          case "ArrowUp":
            newValue = getNewValue(value, stepSize, 1, min2, max2);
            break;
          case "ArrowRight":
            newValue = getNewValue(value, stepSize, isRtl ? -1 : 1, min2, max2);
            break;
          case "ArrowDown":
            newValue = getNewValue(value, stepSize, -1, min2, max2);
            break;
          case "ArrowLeft":
            newValue = getNewValue(value, stepSize, isRtl ? 1 : -1, min2, max2);
            break;
          case "PageUp":
            newValue = getNewValue(value, shiftStep, 1, min2, max2);
            break;
          case "PageDown":
            newValue = getNewValue(value, shiftStep, -1, min2, max2);
            break;
          case "Home":
            newValue = min2;
            break;
          case "End":
            newValue = max2;
            break;
        }
      } else if (marks) {
        const maxMarksValue = marksValues[marksValues.length - 1];
        const currentMarkIndex = marksValues.indexOf(value);
        const decrementKeys = [isRtl ? "ArrowRight" : "ArrowLeft", "ArrowDown", "PageDown", "Home"];
        const incrementKeys = [isRtl ? "ArrowLeft" : "ArrowRight", "ArrowUp", "PageUp", "End"];
        if (decrementKeys.includes(event.key)) {
          if (currentMarkIndex === 0) {
            newValue = marksValues[0];
          } else {
            newValue = marksValues[currentMarkIndex - 1];
          }
        } else if (incrementKeys.includes(event.key)) {
          if (currentMarkIndex === marksValues.length - 1) {
            newValue = maxMarksValue;
          } else {
            newValue = marksValues[currentMarkIndex + 1];
          }
        }
      }
      if (newValue != null) {
        changeValue(event, newValue);
      }
    }
    (_a2 = otherHandlers == null ? void 0 : otherHandlers.onKeyDown) == null ? void 0 : _a2.call(otherHandlers, event);
  };
  useEnhancedEffect(() => {
    var _a2;
    if (disabled && sliderRef.current.contains(document.activeElement)) {
      (_a2 = document.activeElement) == null ? void 0 : _a2.blur();
    }
  }, [disabled]);
  if (disabled && active !== -1) {
    setActive(-1);
  }
  if (disabled && focusedThumbIndex !== -1) {
    setFocusedThumbIndex(-1);
  }
  const createHandleHiddenInputChange = (otherHandlers) => (event) => {
    var _a2;
    (_a2 = otherHandlers.onChange) == null ? void 0 : _a2.call(otherHandlers, event);
    changeValue(event, event.target.valueAsNumber);
  };
  const previousIndex = React$u.useRef(void 0);
  let axis = orientation;
  if (isRtl && orientation === "horizontal") {
    axis += "-reverse";
  }
  const getFingerNewValue = ({
    finger,
    move = false
  }) => {
    const {
      current: slider
    } = sliderRef;
    const {
      width: width2,
      height: height2,
      bottom: bottom2,
      left: left2
    } = slider.getBoundingClientRect();
    let percent;
    if (axis.startsWith("vertical")) {
      percent = (bottom2 - finger.y) / height2;
    } else {
      percent = (finger.x - left2) / width2;
    }
    if (axis.includes("-reverse")) {
      percent = 1 - percent;
    }
    let newValue;
    newValue = percentToValue(percent, min2, max2);
    if (step) {
      newValue = roundValueToStep(newValue, step, min2);
    } else {
      const closestIndex = findClosest(marksValues, newValue);
      newValue = marksValues[closestIndex];
    }
    newValue = clamp(newValue, min2, max2);
    let activeIndex = 0;
    if (range) {
      if (!move) {
        activeIndex = findClosest(values2, newValue);
      } else {
        activeIndex = previousIndex.current;
      }
      if (disableSwap) {
        newValue = clamp(newValue, values2[activeIndex - 1] || -Infinity, values2[activeIndex + 1] || Infinity);
      }
      const previousValue = newValue;
      newValue = setValueIndex({
        values: values2,
        newValue,
        index: activeIndex
      });
      if (!(disableSwap && move)) {
        activeIndex = newValue.indexOf(previousValue);
        previousIndex.current = activeIndex;
      }
    }
    return {
      newValue,
      activeIndex
    };
  };
  const handleTouchMove = useEventCallback((nativeEvent) => {
    const finger = trackFinger(nativeEvent, touchId);
    if (!finger) {
      return;
    }
    moveCount.current += 1;
    if (nativeEvent.type === "mousemove" && nativeEvent.buttons === 0) {
      handleTouchEnd(nativeEvent);
      return;
    }
    const {
      newValue,
      activeIndex
    } = getFingerNewValue({
      finger,
      move: true
    });
    focusThumb({
      sliderRef,
      activeIndex,
      setActive
    });
    setValueState(newValue);
    if (!dragging && moveCount.current > INTENTIONAL_DRAG_COUNT_THRESHOLD) {
      setDragging(true);
    }
    if (handleChange && !areValuesEqual(newValue, valueDerived)) {
      handleChange(nativeEvent, newValue, activeIndex);
    }
  });
  const handleTouchEnd = useEventCallback((nativeEvent) => {
    var _a2;
    const finger = trackFinger(nativeEvent, touchId);
    setDragging(false);
    if (!finger) {
      return;
    }
    const {
      newValue
    } = getFingerNewValue({
      finger,
      move: true
    });
    setActive(-1);
    if (nativeEvent.type === "touchend") {
      setOpen(-1);
    }
    if (onChangeCommitted) {
      onChangeCommitted(nativeEvent, (_a2 = lastChangedValue.current) != null ? _a2 : newValue);
    }
    touchId.current = void 0;
    stopListening();
  });
  const handleTouchStart = useEventCallback((nativeEvent) => {
    if (disabled) {
      return;
    }
    if (!doesSupportTouchActionNone()) {
      nativeEvent.preventDefault();
    }
    const touch = nativeEvent.changedTouches[0];
    if (touch != null) {
      touchId.current = touch.identifier;
    }
    const finger = trackFinger(nativeEvent, touchId);
    if (finger !== false) {
      const {
        newValue,
        activeIndex
      } = getFingerNewValue({
        finger
      });
      focusThumb({
        sliderRef,
        activeIndex,
        setActive
      });
      setValueState(newValue);
      if (handleChange && !areValuesEqual(newValue, valueDerived)) {
        handleChange(nativeEvent, newValue, activeIndex);
      }
    }
    moveCount.current = 0;
    const doc = ownerDocument(sliderRef.current);
    doc.addEventListener("touchmove", handleTouchMove, {
      passive: true
    });
    doc.addEventListener("touchend", handleTouchEnd, {
      passive: true
    });
  });
  const stopListening = React$u.useCallback(() => {
    const doc = ownerDocument(sliderRef.current);
    doc.removeEventListener("mousemove", handleTouchMove);
    doc.removeEventListener("mouseup", handleTouchEnd);
    doc.removeEventListener("touchmove", handleTouchMove);
    doc.removeEventListener("touchend", handleTouchEnd);
  }, [handleTouchEnd, handleTouchMove]);
  React$u.useEffect(() => {
    const {
      current: slider
    } = sliderRef;
    slider.addEventListener("touchstart", handleTouchStart, {
      passive: doesSupportTouchActionNone()
    });
    return () => {
      slider.removeEventListener("touchstart", handleTouchStart);
      stopListening();
    };
  }, [stopListening, handleTouchStart]);
  React$u.useEffect(() => {
    if (disabled) {
      stopListening();
    }
  }, [disabled, stopListening]);
  const createHandleMouseDown = (otherHandlers) => (event) => {
    var _a2;
    (_a2 = otherHandlers.onMouseDown) == null ? void 0 : _a2.call(otherHandlers, event);
    if (disabled) {
      return;
    }
    if (event.defaultPrevented) {
      return;
    }
    if (event.button !== 0) {
      return;
    }
    event.preventDefault();
    const finger = trackFinger(event, touchId);
    if (finger !== false) {
      const {
        newValue,
        activeIndex
      } = getFingerNewValue({
        finger
      });
      focusThumb({
        sliderRef,
        activeIndex,
        setActive
      });
      setValueState(newValue);
      if (handleChange && !areValuesEqual(newValue, valueDerived)) {
        handleChange(event, newValue, activeIndex);
      }
    }
    moveCount.current = 0;
    const doc = ownerDocument(sliderRef.current);
    doc.addEventListener("mousemove", handleTouchMove, {
      passive: true
    });
    doc.addEventListener("mouseup", handleTouchEnd);
  };
  const trackOffset = valueToPercent(range ? values2[0] : min2, min2, max2);
  const trackLeap = valueToPercent(values2[values2.length - 1], min2, max2) - trackOffset;
  const getRootProps = (externalProps = {}) => {
    const externalHandlers = extractEventHandlers(externalProps);
    const ownEventHandlers = {
      onMouseDown: createHandleMouseDown(externalHandlers || {})
    };
    const mergedEventHandlers = __spreadValues(__spreadValues({}, externalHandlers), ownEventHandlers);
    return __spreadValues(__spreadProps(__spreadValues({}, externalProps), {
      ref: handleRef
    }), mergedEventHandlers);
  };
  const createHandleMouseOver = (otherHandlers) => (event) => {
    var _a2;
    (_a2 = otherHandlers.onMouseOver) == null ? void 0 : _a2.call(otherHandlers, event);
    const index2 = Number(event.currentTarget.getAttribute("data-index"));
    setOpen(index2);
  };
  const createHandleMouseLeave = (otherHandlers) => (event) => {
    var _a2;
    (_a2 = otherHandlers.onMouseLeave) == null ? void 0 : _a2.call(otherHandlers, event);
    setOpen(-1);
  };
  const getThumbProps = (externalProps = {}) => {
    const externalHandlers = extractEventHandlers(externalProps);
    const ownEventHandlers = {
      onMouseOver: createHandleMouseOver(externalHandlers || {}),
      onMouseLeave: createHandleMouseLeave(externalHandlers || {})
    };
    return __spreadValues(__spreadValues(__spreadValues({}, externalProps), externalHandlers), ownEventHandlers);
  };
  const getThumbStyle = (index2) => {
    return {
      // So the non active thumb doesn't show its label on hover.
      pointerEvents: active !== -1 && active !== index2 ? "none" : void 0
    };
  };
  let cssWritingMode;
  if (orientation === "vertical") {
    cssWritingMode = isRtl ? "vertical-rl" : "vertical-lr";
  }
  const getHiddenInputProps = (externalProps = {}) => {
    var _a2;
    const externalHandlers = extractEventHandlers(externalProps);
    const ownEventHandlers = {
      onChange: createHandleHiddenInputChange(externalHandlers || {}),
      onFocus: createHandleHiddenInputFocus(externalHandlers || {}),
      onBlur: createHandleHiddenInputBlur(externalHandlers || {}),
      onKeyDown: createHandleHiddenInputKeyDown(externalHandlers || {})
    };
    const mergedEventHandlers = __spreadValues(__spreadValues({}, externalHandlers), ownEventHandlers);
    return __spreadProps(__spreadValues(__spreadValues({
      tabIndex,
      "aria-labelledby": ariaLabelledby,
      "aria-orientation": orientation,
      "aria-valuemax": scale(max2),
      "aria-valuemin": scale(min2),
      name: name2,
      type: "range",
      min: parameters.min,
      max: parameters.max,
      step: parameters.step === null && parameters.marks ? "any" : (_a2 = parameters.step) != null ? _a2 : void 0,
      disabled
    }, externalProps), mergedEventHandlers), {
      style: __spreadProps(__spreadValues({}, visuallyHidden), {
        direction: isRtl ? "rtl" : "ltr",
        // So that VoiceOver's focus indicator matches the thumb's dimensions
        width: "100%",
        height: "100%",
        writingMode: cssWritingMode
      })
    });
  };
  return {
    active,
    axis,
    axisProps,
    dragging,
    focusedThumbIndex,
    getHiddenInputProps,
    getRootProps,
    getThumbProps,
    marks,
    open,
    range,
    rootRef: handleRef,
    trackLeap,
    trackOffset,
    values: values2,
    getThumbStyle
  };
}
const shouldSpreadAdditionalProps = (Slot) => {
  return !Slot || !isHostComponent(Slot);
};
function getSliderUtilityClass(slot) {
  return generateUtilityClass("MuiSlider", slot);
}
const sliderClasses = generateUtilityClasses("MuiSlider", ["root", "active", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "disabled", "dragging", "focusVisible", "mark", "markActive", "marked", "markLabel", "markLabelActive", "rail", "sizeSmall", "thumb", "thumbColorPrimary", "thumbColorSecondary", "thumbColorError", "thumbColorSuccess", "thumbColorInfo", "thumbColorWarning", "track", "trackInverted", "trackFalse", "thumbSizeSmall", "valueLabel", "valueLabelOpen", "valueLabelCircle", "valueLabelLabel", "vertical"]);
const React$t = window["React"];
const useValueLabelClasses = (props) => {
  const {
    open
  } = props;
  const utilityClasses = {
    offset: clsx(open && sliderClasses.valueLabelOpen),
    circle: sliderClasses.valueLabelCircle,
    label: sliderClasses.valueLabelLabel
  };
  return utilityClasses;
};
function SliderValueLabel$1(props) {
  const {
    children,
    className,
    value
  } = props;
  const classes = useValueLabelClasses(props);
  if (!children) {
    return null;
  }
  return /* @__PURE__ */ React$t.cloneElement(children, {
    className: children.props.className
  }, /* @__PURE__ */ jsxRuntimeExports.jsxs(React$t.Fragment, {
    children: [children.props.children, /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: clsx(classes.offset, className),
      "aria-hidden": true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: classes.circle,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: classes.label,
          children: value
        })
      })
    })]
  }));
}
const React$s = window["React"];
function Identity(x) {
  return x;
}
const SliderRoot = styled("span", {
  name: "MuiSlider",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`color${capitalize(ownerState.color)}`], ownerState.size !== "medium" && styles2[`size${capitalize(ownerState.size)}`], ownerState.marked && styles2.marked, ownerState.orientation === "vertical" && styles2.vertical, ownerState.track === "inverted" && styles2.trackInverted, ownerState.track === false && styles2.trackFalse];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  borderRadius: 12,
  boxSizing: "content-box",
  display: "inline-block",
  position: "relative",
  cursor: "pointer",
  touchAction: "none",
  WebkitTapHighlightColor: "transparent",
  "@media print": {
    colorAdjust: "exact"
  },
  [`&.${sliderClasses.disabled}`]: {
    pointerEvents: "none",
    cursor: "default",
    color: (theme2.vars || theme2).palette.grey[400]
  },
  [`&.${sliderClasses.dragging}`]: {
    [`& .${sliderClasses.thumb}, & .${sliderClasses.track}`]: {
      transition: "none"
    }
  },
  variants: [...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      color: (theme2.vars || theme2).palette[color2].main
    }
  })), {
    props: {
      orientation: "horizontal"
    },
    style: {
      height: 4,
      width: "100%",
      padding: "13px 0",
      // The primary input mechanism of the device includes a pointing device of limited accuracy.
      "@media (pointer: coarse)": {
        // Reach 42px touch target, about ~8mm on screen.
        padding: "20px 0"
      }
    }
  }, {
    props: {
      orientation: "horizontal",
      size: "small"
    },
    style: {
      height: 2
    }
  }, {
    props: {
      orientation: "horizontal",
      marked: true
    },
    style: {
      marginBottom: 20
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      width: 4,
      padding: "0 13px",
      // The primary input mechanism of the device includes a pointing device of limited accuracy.
      "@media (pointer: coarse)": {
        // Reach 42px touch target, about ~8mm on screen.
        padding: "0 20px"
      }
    }
  }, {
    props: {
      orientation: "vertical",
      size: "small"
    },
    style: {
      width: 2
    }
  }, {
    props: {
      orientation: "vertical",
      marked: true
    },
    style: {
      marginRight: 44
    }
  }]
})));
const SliderRail = styled("span", {
  name: "MuiSlider",
  slot: "Rail"
})({
  display: "block",
  position: "absolute",
  borderRadius: "inherit",
  backgroundColor: "currentColor",
  opacity: 0.38,
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      width: "100%",
      height: "inherit",
      top: "50%",
      transform: "translateY(-50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      width: "inherit",
      left: "50%",
      transform: "translateX(-50%)"
    }
  }, {
    props: {
      track: "inverted"
    },
    style: {
      opacity: 1
    }
  }]
});
const SliderTrack = styled("span", {
  name: "MuiSlider",
  slot: "Track"
})(memoTheme(({
  theme: theme2
}) => {
  return {
    display: "block",
    position: "absolute",
    borderRadius: "inherit",
    border: "1px solid currentColor",
    backgroundColor: "currentColor",
    transition: theme2.transitions.create(["left", "width", "bottom", "height"], {
      duration: theme2.transitions.duration.shortest
    }),
    variants: [{
      props: {
        size: "small"
      },
      style: {
        border: "none"
      }
    }, {
      props: {
        orientation: "horizontal"
      },
      style: {
        height: "inherit",
        top: "50%",
        transform: "translateY(-50%)"
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        width: "inherit",
        left: "50%",
        transform: "translateX(-50%)"
      }
    }, {
      props: {
        track: false
      },
      style: {
        display: "none"
      }
    }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
      props: {
        color: color2,
        track: "inverted"
      },
      style: __spreadValues({}, theme2.vars ? {
        backgroundColor: theme2.vars.palette.Slider[`${color2}Track`],
        borderColor: theme2.vars.palette.Slider[`${color2}Track`]
      } : __spreadValues(__spreadValues({
        backgroundColor: theme2.lighten(theme2.palette[color2].main, 0.62),
        borderColor: theme2.lighten(theme2.palette[color2].main, 0.62)
      }, theme2.applyStyles("dark", {
        backgroundColor: theme2.darken(theme2.palette[color2].main, 0.5)
      })), theme2.applyStyles("dark", {
        borderColor: theme2.darken(theme2.palette[color2].main, 0.5)
      })))
    }))]
  };
}));
const SliderThumb = styled("span", {
  name: "MuiSlider",
  slot: "Thumb",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.thumb, styles2[`thumbColor${capitalize(ownerState.color)}`], ownerState.size !== "medium" && styles2[`thumbSize${capitalize(ownerState.size)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  position: "absolute",
  width: 20,
  height: 20,
  boxSizing: "border-box",
  borderRadius: "50%",
  outline: 0,
  backgroundColor: "currentColor",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  transition: theme2.transitions.create(["box-shadow", "left", "bottom"], {
    duration: theme2.transitions.duration.shortest
  }),
  "&::before": {
    position: "absolute",
    content: '""',
    borderRadius: "inherit",
    width: "100%",
    height: "100%",
    boxShadow: (theme2.vars || theme2).shadows[2]
  },
  "&::after": {
    position: "absolute",
    content: '""',
    borderRadius: "50%",
    // 42px is the hit target
    width: 42,
    height: 42,
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)"
  },
  [`&.${sliderClasses.disabled}`]: {
    "&:hover": {
      boxShadow: "none"
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      width: 12,
      height: 12,
      "&::before": {
        boxShadow: "none"
      }
    }
  }, {
    props: {
      orientation: "horizontal"
    },
    style: {
      top: "50%",
      transform: "translate(-50%, -50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: "50%",
      transform: "translate(-50%, 50%)"
    }
  }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      [`&:hover, &.${sliderClasses.focusVisible}`]: {
        boxShadow: `0px 0px 0px 8px ${theme2.alpha((theme2.vars || theme2).palette[color2].main, 0.16)}`,
        "@media (hover: none)": {
          boxShadow: "none"
        }
      },
      [`&.${sliderClasses.active}`]: {
        boxShadow: `0px 0px 0px 14px ${theme2.alpha((theme2.vars || theme2).palette[color2].main, 0.16)}`
      }
    }
  }))]
})));
const SliderValueLabel = styled(SliderValueLabel$1, {
  name: "MuiSlider",
  slot: "ValueLabel"
})(memoTheme(({
  theme: theme2
}) => __spreadProps(__spreadValues({
  zIndex: 1,
  whiteSpace: "nowrap"
}, theme2.typography.body2), {
  fontWeight: 500,
  transition: theme2.transitions.create(["transform"], {
    duration: theme2.transitions.duration.shortest
  }),
  position: "absolute",
  backgroundColor: (theme2.vars || theme2).palette.grey[600],
  borderRadius: 2,
  color: (theme2.vars || theme2).palette.common.white,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  padding: "0.25rem 0.75rem",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      transform: "translateY(-100%) scale(0)",
      top: "-10px",
      transformOrigin: "bottom center",
      "&::before": {
        position: "absolute",
        content: '""',
        width: 8,
        height: 8,
        transform: "translate(-50%, 50%) rotate(45deg)",
        backgroundColor: "inherit",
        bottom: 0,
        left: "50%"
      },
      [`&.${sliderClasses.valueLabelOpen}`]: {
        transform: "translateY(-100%) scale(1)"
      }
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      transform: "translateY(-50%) scale(0)",
      right: "30px",
      top: "50%",
      transformOrigin: "right center",
      "&::before": {
        position: "absolute",
        content: '""',
        width: 8,
        height: 8,
        transform: "translate(-50%, -50%) rotate(45deg)",
        backgroundColor: "inherit",
        right: -8,
        top: "50%"
      },
      [`&.${sliderClasses.valueLabelOpen}`]: {
        transform: "translateY(-50%) scale(1)"
      }
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      fontSize: theme2.typography.pxToRem(12),
      padding: "0.25rem 0.5rem"
    }
  }, {
    props: {
      orientation: "vertical",
      size: "small"
    },
    style: {
      right: "20px"
    }
  }]
})));
const SliderMark = styled("span", {
  name: "MuiSlider",
  slot: "Mark",
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "markActive",
  overridesResolver: (props, styles2) => {
    const {
      markActive
    } = props;
    return [styles2.mark, markActive && styles2.markActive];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  position: "absolute",
  width: 2,
  height: 2,
  borderRadius: 1,
  backgroundColor: "currentColor",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      top: "50%",
      transform: "translate(-1px, -50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: "50%",
      transform: "translate(-50%, 1px)"
    }
  }, {
    props: {
      markActive: true
    },
    style: {
      backgroundColor: (theme2.vars || theme2).palette.background.paper,
      opacity: 0.8
    }
  }]
})));
const SliderMarkLabel = styled("span", {
  name: "MuiSlider",
  slot: "MarkLabel",
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "markLabelActive"
})(memoTheme(({
  theme: theme2
}) => __spreadProps(__spreadValues({}, theme2.typography.body2), {
  color: (theme2.vars || theme2).palette.text.secondary,
  position: "absolute",
  whiteSpace: "nowrap",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      top: 30,
      transform: "translateX(-50%)",
      "@media (pointer: coarse)": {
        top: 40
      }
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: 36,
      transform: "translateY(50%)",
      "@media (pointer: coarse)": {
        left: 44
      }
    }
  }, {
    props: {
      markLabelActive: true
    },
    style: {
      color: (theme2.vars || theme2).palette.text.primary
    }
  }]
})));
const useUtilityClasses$e = (ownerState) => {
  const {
    disabled,
    dragging,
    marked,
    orientation,
    track,
    classes,
    color: color2,
    size
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", dragging && "dragging", marked && "marked", orientation === "vertical" && "vertical", track === "inverted" && "trackInverted", track === false && "trackFalse", color2 && `color${capitalize(color2)}`, size && `size${capitalize(size)}`],
    rail: ["rail"],
    track: ["track"],
    mark: ["mark"],
    markActive: ["markActive"],
    markLabel: ["markLabel"],
    markLabelActive: ["markLabelActive"],
    valueLabel: ["valueLabel"],
    thumb: ["thumb", disabled && "disabled", size && `thumbSize${capitalize(size)}`, color2 && `thumbColor${capitalize(color2)}`],
    active: ["active"],
    disabled: ["disabled"],
    focusVisible: ["focusVisible"]
  };
  return composeClasses(slots, getSliderUtilityClass, classes);
};
const Forward = ({
  children
}) => children;
const Slider = /* @__PURE__ */ React$s.forwardRef(function Slider2(inputProps, ref) {
  var _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
  const props = useDefaultProps({
    props: inputProps,
    name: "MuiSlider"
  });
  const isRtl = useRtl();
  const _a2 = props, {
    "aria-label": ariaLabel,
    "aria-valuetext": ariaValuetext,
    "aria-labelledby": ariaLabelledby,
    component: component = "span",
    components = {},
    componentsProps = {},
    color: color2 = "primary",
    classes: classesProp,
    className,
    disableSwap = false,
    disabled = false,
    getAriaLabel,
    getAriaValueText,
    marks: marksProp = false,
    max: max2 = 100,
    min: min2 = 0,
    name: name2,
    onChange,
    onChangeCommitted,
    orientation = "horizontal",
    shiftStep = 10,
    size = "medium",
    step = 1,
    scale = Identity,
    slotProps,
    slots,
    tabIndex,
    track = "normal",
    value: valueProp,
    valueLabelDisplay = "off",
    valueLabelFormat = Identity
  } = _a2, other = __objRest(_a2, [
    "aria-label",
    "aria-valuetext",
    "aria-labelledby",
    // eslint-disable-next-line react/prop-types
    "component",
    "components",
    "componentsProps",
    "color",
    "classes",
    "className",
    "disableSwap",
    "disabled",
    "getAriaLabel",
    "getAriaValueText",
    "marks",
    "max",
    "min",
    "name",
    "onChange",
    "onChangeCommitted",
    "orientation",
    "shiftStep",
    "size",
    "step",
    "scale",
    "slotProps",
    "slots",
    "tabIndex",
    "track",
    "value",
    "valueLabelDisplay",
    "valueLabelFormat"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    isRtl,
    max: max2,
    min: min2,
    classes: classesProp,
    disabled,
    disableSwap,
    orientation,
    marks: marksProp,
    color: color2,
    size,
    step,
    shiftStep,
    scale,
    track,
    valueLabelDisplay,
    valueLabelFormat
  });
  const {
    axisProps: axisProps2,
    getRootProps,
    getHiddenInputProps,
    getThumbProps,
    open,
    active,
    axis,
    focusedThumbIndex,
    range,
    dragging,
    marks,
    values: values2,
    trackOffset,
    trackLeap,
    getThumbStyle
  } = useSlider(__spreadProps(__spreadValues({}, ownerState), {
    rootRef: ref
  }));
  ownerState.marked = marks.length > 0 && marks.some((mark) => mark.label);
  ownerState.dragging = dragging;
  ownerState.focusedThumbIndex = focusedThumbIndex;
  const classes = useUtilityClasses$e(ownerState);
  const RootSlot = (_c = (_b = slots == null ? void 0 : slots.root) != null ? _b : components.Root) != null ? _c : SliderRoot;
  const RailSlot = (_e = (_d = slots == null ? void 0 : slots.rail) != null ? _d : components.Rail) != null ? _e : SliderRail;
  const TrackSlot = (_g = (_f = slots == null ? void 0 : slots.track) != null ? _f : components.Track) != null ? _g : SliderTrack;
  const ThumbSlot = (_i = (_h = slots == null ? void 0 : slots.thumb) != null ? _h : components.Thumb) != null ? _i : SliderThumb;
  const ValueLabelSlot = (_k = (_j = slots == null ? void 0 : slots.valueLabel) != null ? _j : components.ValueLabel) != null ? _k : SliderValueLabel;
  const MarkSlot = (_m = (_l = slots == null ? void 0 : slots.mark) != null ? _l : components.Mark) != null ? _m : SliderMark;
  const MarkLabelSlot = (_o = (_n = slots == null ? void 0 : slots.markLabel) != null ? _n : components.MarkLabel) != null ? _o : SliderMarkLabel;
  const InputSlot = (_q = (_p = slots == null ? void 0 : slots.input) != null ? _p : components.Input) != null ? _q : "input";
  const rootSlotProps = (_r = slotProps == null ? void 0 : slotProps.root) != null ? _r : componentsProps.root;
  const railSlotProps = (_s = slotProps == null ? void 0 : slotProps.rail) != null ? _s : componentsProps.rail;
  const trackSlotProps = (_t = slotProps == null ? void 0 : slotProps.track) != null ? _t : componentsProps.track;
  const thumbSlotProps = (_u = slotProps == null ? void 0 : slotProps.thumb) != null ? _u : componentsProps.thumb;
  const valueLabelSlotProps = (_v = slotProps == null ? void 0 : slotProps.valueLabel) != null ? _v : componentsProps.valueLabel;
  const markSlotProps = (_w = slotProps == null ? void 0 : slotProps.mark) != null ? _w : componentsProps.mark;
  const markLabelSlotProps = (_x = slotProps == null ? void 0 : slotProps.markLabel) != null ? _x : componentsProps.markLabel;
  const inputSlotProps = (_y = slotProps == null ? void 0 : slotProps.input) != null ? _y : componentsProps.input;
  const rootProps = useSlotProps({
    elementType: RootSlot,
    getSlotProps: getRootProps,
    externalSlotProps: rootSlotProps,
    externalForwardedProps: other,
    additionalProps: __spreadValues({}, shouldSpreadAdditionalProps(RootSlot) && {
      as: component
    }),
    ownerState: __spreadValues(__spreadValues({}, ownerState), rootSlotProps == null ? void 0 : rootSlotProps.ownerState),
    className: [classes.root, className]
  });
  const railProps = useSlotProps({
    elementType: RailSlot,
    externalSlotProps: railSlotProps,
    ownerState,
    className: classes.rail
  });
  const trackProps = useSlotProps({
    elementType: TrackSlot,
    externalSlotProps: trackSlotProps,
    additionalProps: {
      style: __spreadValues(__spreadValues({}, axisProps2[axis].offset(trackOffset)), axisProps2[axis].leap(trackLeap))
    },
    ownerState: __spreadValues(__spreadValues({}, ownerState), trackSlotProps == null ? void 0 : trackSlotProps.ownerState),
    className: classes.track
  });
  const thumbProps = useSlotProps({
    elementType: ThumbSlot,
    getSlotProps: getThumbProps,
    externalSlotProps: thumbSlotProps,
    ownerState: __spreadValues(__spreadValues({}, ownerState), thumbSlotProps == null ? void 0 : thumbSlotProps.ownerState),
    className: classes.thumb
  });
  const valueLabelProps = useSlotProps({
    elementType: ValueLabelSlot,
    externalSlotProps: valueLabelSlotProps,
    ownerState: __spreadValues(__spreadValues({}, ownerState), valueLabelSlotProps == null ? void 0 : valueLabelSlotProps.ownerState),
    className: classes.valueLabel
  });
  const markProps = useSlotProps({
    elementType: MarkSlot,
    externalSlotProps: markSlotProps,
    ownerState,
    className: classes.mark
  });
  const markLabelProps = useSlotProps({
    elementType: MarkLabelSlot,
    externalSlotProps: markLabelSlotProps,
    ownerState,
    className: classes.markLabel
  });
  const inputSliderProps = useSlotProps({
    elementType: InputSlot,
    getSlotProps: getHiddenInputProps,
    externalSlotProps: inputSlotProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, __spreadProps(__spreadValues({}, rootProps), {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(RailSlot, __spreadValues({}, railProps)), /* @__PURE__ */ jsxRuntimeExports.jsx(TrackSlot, __spreadValues({}, trackProps)), marks.filter((mark) => mark.value >= min2 && mark.value <= max2).map((mark, index2) => {
      const percent = valueToPercent(mark.value, min2, max2);
      const style2 = axisProps2[axis].offset(percent);
      let markActive;
      if (track === false) {
        markActive = values2.includes(mark.value);
      } else {
        markActive = track === "normal" && (range ? mark.value >= values2[0] && mark.value <= values2[values2.length - 1] : mark.value <= values2[0]) || track === "inverted" && (range ? mark.value <= values2[0] || mark.value >= values2[values2.length - 1] : mark.value >= values2[0]);
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(React$s.Fragment, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(MarkSlot, __spreadProps(__spreadValues(__spreadValues({
          "data-index": index2
        }, markProps), !isHostComponent(MarkSlot) && {
          markActive
        }), {
          style: __spreadValues(__spreadValues({}, style2), markProps.style),
          className: clsx(markProps.className, markActive && classes.markActive)
        })), mark.label != null ? /* @__PURE__ */ jsxRuntimeExports.jsx(MarkLabelSlot, __spreadProps(__spreadValues(__spreadValues({
          "aria-hidden": true,
          "data-index": index2
        }, markLabelProps), !isHostComponent(MarkLabelSlot) && {
          markLabelActive: markActive
        }), {
          style: __spreadValues(__spreadValues({}, style2), markLabelProps.style),
          className: clsx(classes.markLabel, markLabelProps.className, markActive && classes.markLabelActive),
          children: mark.label
        })) : null]
      }, index2);
    }), values2.map((value, index2) => {
      const percent = valueToPercent(value, min2, max2);
      const style2 = axisProps2[axis].offset(percent);
      const ValueLabelComponent = valueLabelDisplay === "off" ? Forward : ValueLabelSlot;
      return (
        /* TODO v6: Change component structure. It will help in avoiding the complicated React.cloneElement API added in SliderValueLabel component. Should be: Thumb -> Input, ValueLabel. Follow Joy UI's Slider structure. */
        /* @__PURE__ */ jsxRuntimeExports.jsx(ValueLabelComponent, __spreadProps(__spreadValues(__spreadValues({}, !isHostComponent(ValueLabelComponent) && {
          valueLabelFormat,
          valueLabelDisplay,
          value: typeof valueLabelFormat === "function" ? valueLabelFormat(scale(value), index2) : valueLabelFormat,
          index: index2,
          open: open === index2 || active === index2 || valueLabelDisplay === "on",
          disabled
        }), valueLabelProps), {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThumbSlot, __spreadProps(__spreadValues({
            "data-index": index2
          }, thumbProps), {
            className: clsx(classes.thumb, thumbProps.className, active === index2 && classes.active, focusedThumbIndex === index2 && classes.focusVisible),
            style: __spreadValues(__spreadValues(__spreadValues({}, style2), getThumbStyle(index2)), thumbProps.style),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(InputSlot, __spreadValues({
              "data-index": index2,
              "aria-label": getAriaLabel ? getAriaLabel(index2) : ariaLabel,
              "aria-valuenow": scale(value),
              "aria-labelledby": ariaLabelledby,
              "aria-valuetext": getAriaValueText ? getAriaValueText(scale(value), index2) : ariaValuetext,
              value: values2[index2]
            }, inputSliderProps))
          }))
        }), index2)
      );
    })]
  }));
});
const React$r = window["React"];
function useSnackbar(parameters = {}) {
  const {
    autoHideDuration = null,
    disableWindowBlurListener = false,
    onClose,
    open,
    resumeHideDuration
  } = parameters;
  const timerAutoHide = useTimeout();
  React$r.useEffect(() => {
    if (!open) {
      return void 0;
    }
    function handleKeyDown(nativeEvent) {
      if (!nativeEvent.defaultPrevented) {
        if (nativeEvent.key === "Escape") {
          onClose == null ? void 0 : onClose(nativeEvent, "escapeKeyDown");
        }
      }
    }
    document.addEventListener("keydown", handleKeyDown);
    return () => {
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, [open, onClose]);
  const handleClose = useEventCallback((event, reason) => {
    onClose == null ? void 0 : onClose(event, reason);
  });
  const setAutoHideTimer = useEventCallback((autoHideDurationParam) => {
    if (!onClose || autoHideDurationParam == null) {
      return;
    }
    timerAutoHide.start(autoHideDurationParam, () => {
      handleClose(null, "timeout");
    });
  });
  React$r.useEffect(() => {
    if (open) {
      setAutoHideTimer(autoHideDuration);
    }
    return timerAutoHide.clear;
  }, [open, autoHideDuration, setAutoHideTimer, timerAutoHide]);
  const handleClickAway = (event) => {
    onClose == null ? void 0 : onClose(event, "clickaway");
  };
  const handlePause = timerAutoHide.clear;
  const handleResume = React$r.useCallback(() => {
    if (autoHideDuration != null) {
      setAutoHideTimer(resumeHideDuration != null ? resumeHideDuration : autoHideDuration * 0.5);
    }
  }, [autoHideDuration, resumeHideDuration, setAutoHideTimer]);
  const createHandleBlur = (otherHandlers) => (event) => {
    const onBlurCallback = otherHandlers.onBlur;
    onBlurCallback == null ? void 0 : onBlurCallback(event);
    handleResume();
  };
  const createHandleFocus = (otherHandlers) => (event) => {
    const onFocusCallback = otherHandlers.onFocus;
    onFocusCallback == null ? void 0 : onFocusCallback(event);
    handlePause();
  };
  const createMouseEnter = (otherHandlers) => (event) => {
    const onMouseEnterCallback = otherHandlers.onMouseEnter;
    onMouseEnterCallback == null ? void 0 : onMouseEnterCallback(event);
    handlePause();
  };
  const createMouseLeave = (otherHandlers) => (event) => {
    const onMouseLeaveCallback = otherHandlers.onMouseLeave;
    onMouseLeaveCallback == null ? void 0 : onMouseLeaveCallback(event);
    handleResume();
  };
  React$r.useEffect(() => {
    if (!disableWindowBlurListener && open) {
      window.addEventListener("focus", handleResume);
      window.addEventListener("blur", handlePause);
      return () => {
        window.removeEventListener("focus", handleResume);
        window.removeEventListener("blur", handlePause);
      };
    }
    return void 0;
  }, [disableWindowBlurListener, open, handleResume, handlePause]);
  const getRootProps = (externalProps = {}) => {
    const externalEventHandlers = __spreadValues(__spreadValues({}, extractEventHandlers(parameters)), extractEventHandlers(externalProps));
    return __spreadProps(__spreadValues(__spreadValues({
      // ClickAwayListener adds an `onClick` prop which results in the alert not being announced.
      // See https://github.com/mui/material-ui/issues/29080
      role: "presentation"
    }, externalProps), externalEventHandlers), {
      onBlur: createHandleBlur(externalEventHandlers),
      onFocus: createHandleFocus(externalEventHandlers),
      onMouseEnter: createMouseEnter(externalEventHandlers),
      onMouseLeave: createMouseLeave(externalEventHandlers)
    });
  };
  return {
    getRootProps,
    onClickAway: handleClickAway
  };
}
function getSnackbarContentUtilityClass(slot) {
  return generateUtilityClass("MuiSnackbarContent", slot);
}
generateUtilityClasses("MuiSnackbarContent", ["root", "message", "action"]);
const React$q = window["React"];
const useUtilityClasses$d = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    action: ["action"],
    message: ["message"]
  };
  return composeClasses(slots, getSnackbarContentUtilityClass, classes);
};
const SnackbarContentRoot = styled(Paper, {
  name: "MuiSnackbarContent",
  slot: "Root"
})(memoTheme(({
  theme: theme2
}) => {
  const emphasis = theme2.palette.mode === "light" ? 0.8 : 0.98;
  return __spreadProps(__spreadValues({}, theme2.typography.body2), {
    color: theme2.vars ? theme2.vars.palette.SnackbarContent.color : theme2.palette.getContrastText(emphasize(theme2.palette.background.default, emphasis)),
    backgroundColor: theme2.vars ? theme2.vars.palette.SnackbarContent.bg : emphasize(theme2.palette.background.default, emphasis),
    display: "flex",
    alignItems: "center",
    flexWrap: "wrap",
    padding: "6px 16px",
    flexGrow: 1,
    [theme2.breakpoints.up("sm")]: {
      flexGrow: "initial",
      minWidth: 288
    }
  });
}));
const SnackbarContentMessage = styled("div", {
  name: "MuiSnackbarContent",
  slot: "Message"
})({
  padding: "8px 0"
});
const SnackbarContentAction = styled("div", {
  name: "MuiSnackbarContent",
  slot: "Action"
})({
  display: "flex",
  alignItems: "center",
  marginLeft: "auto",
  paddingLeft: 16,
  marginRight: -8
});
const SnackbarContent = /* @__PURE__ */ React$q.forwardRef(function SnackbarContent2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSnackbarContent"
  });
  const _a2 = props, {
    action,
    className,
    message,
    role = "alert"
  } = _a2, other = __objRest(_a2, [
    "action",
    "className",
    "message",
    "role"
  ]);
  const ownerState = props;
  const classes = useUtilityClasses$d(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SnackbarContentRoot, __spreadProps(__spreadValues({
    role,
    elevation: 6,
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other), {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarContentMessage, {
      className: classes.message,
      ownerState,
      children: message
    }), action ? /* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarContentAction, {
      className: classes.action,
      ownerState,
      children: action
    }) : null]
  }));
});
function getSnackbarUtilityClass(slot) {
  return generateUtilityClass("MuiSnackbar", slot);
}
generateUtilityClasses("MuiSnackbar", ["root", "anchorOriginTopCenter", "anchorOriginBottomCenter", "anchorOriginTopRight", "anchorOriginBottomRight", "anchorOriginTopLeft", "anchorOriginBottomLeft"]);
const React$p = window["React"];
const useUtilityClasses$c = (ownerState) => {
  const {
    classes,
    anchorOrigin
  } = ownerState;
  const slots = {
    root: ["root", `anchorOrigin${capitalize(anchorOrigin.vertical)}${capitalize(anchorOrigin.horizontal)}`]
  };
  return composeClasses(slots, getSnackbarUtilityClass, classes);
};
const SnackbarRoot = styled("div", {
  name: "MuiSnackbar",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`anchorOrigin${capitalize(ownerState.anchorOrigin.vertical)}${capitalize(ownerState.anchorOrigin.horizontal)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  zIndex: (theme2.vars || theme2).zIndex.snackbar,
  position: "fixed",
  display: "flex",
  left: 8,
  right: 8,
  justifyContent: "center",
  alignItems: "center",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "top",
    style: {
      top: 8,
      [theme2.breakpoints.up("sm")]: {
        top: 24
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical !== "top",
    style: {
      bottom: 8,
      [theme2.breakpoints.up("sm")]: {
        bottom: 24
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.horizontal === "left",
    style: {
      justifyContent: "flex-start",
      [theme2.breakpoints.up("sm")]: {
        left: 24,
        right: "auto"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.horizontal === "right",
    style: {
      justifyContent: "flex-end",
      [theme2.breakpoints.up("sm")]: {
        right: 24,
        left: "auto"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.horizontal === "center",
    style: {
      [theme2.breakpoints.up("sm")]: {
        left: "50%",
        right: "auto",
        transform: "translateX(-50%)"
      }
    }
  }]
})));
const Snackbar = /* @__PURE__ */ React$p.forwardRef(function Snackbar2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSnackbar"
  });
  const theme2 = useTheme();
  const defaultTransitionDuration = {
    enter: theme2.transitions.duration.enteringScreen,
    exit: theme2.transitions.duration.leavingScreen
  };
  const _a2 = props, {
    action,
    anchorOrigin: {
      vertical,
      horizontal
    } = {
      vertical: "bottom",
      horizontal: "left"
    },
    autoHideDuration = null,
    children,
    className,
    ClickAwayListenerProps: ClickAwayListenerPropsProp,
    ContentProps: ContentPropsProp,
    disableWindowBlurListener = false,
    message,
    onBlur,
    onClose,
    onFocus,
    onMouseEnter,
    onMouseLeave,
    open,
    resumeHideDuration,
    slots = {},
    slotProps = {},
    TransitionComponent: TransitionComponentProp,
    transitionDuration = defaultTransitionDuration,
    TransitionProps: _b = {}
  } = _a2, _c = _b, {
    onEnter,
    onExited
  } = _c, TransitionPropsProp = __objRest(_c, [
    "onEnter",
    "onExited"
  ]), other = __objRest(_a2, [
    "action",
    "anchorOrigin",
    "autoHideDuration",
    "children",
    "className",
    "ClickAwayListenerProps",
    "ContentProps",
    "disableWindowBlurListener",
    "message",
    "onBlur",
    "onClose",
    "onFocus",
    "onMouseEnter",
    "onMouseLeave",
    "open",
    "resumeHideDuration",
    "slots",
    "slotProps",
    "TransitionComponent",
    "transitionDuration",
    "TransitionProps"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    anchorOrigin: {
      vertical,
      horizontal
    },
    autoHideDuration,
    disableWindowBlurListener,
    TransitionComponent: TransitionComponentProp,
    transitionDuration
  });
  const classes = useUtilityClasses$c(ownerState);
  const {
    getRootProps,
    onClickAway
  } = useSnackbar(__spreadValues({}, ownerState));
  const [exited, setExited] = React$p.useState(true);
  const handleExited = (node2) => {
    setExited(true);
    if (onExited) {
      onExited(node2);
    }
  };
  const handleEnter = (node2, isAppearing) => {
    setExited(false);
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  };
  const externalForwardedProps = {
    slots: __spreadValues({
      transition: TransitionComponentProp
    }, slots),
    slotProps: __spreadValues({
      content: ContentPropsProp,
      clickAwayListener: ClickAwayListenerPropsProp,
      transition: TransitionPropsProp
    }, slotProps)
  };
  const [Root, rootProps] = useSlot("root", {
    ref,
    className: [classes.root, className],
    elementType: SnackbarRoot,
    getSlotProps: getRootProps,
    externalForwardedProps: __spreadValues(__spreadValues({}, externalForwardedProps), other),
    ownerState
  });
  const [ClickAwaySlot, _d] = useSlot("clickAwayListener", {
    elementType: ClickAwayListener,
    externalForwardedProps,
    getSlotProps: (handlers) => ({
      onClickAway: (...params) => {
        var _a3;
        const event = params[0];
        (_a3 = handlers.onClickAway) == null ? void 0 : _a3.call(handlers, ...params);
        if (event == null ? void 0 : event.defaultMuiPrevented) {
          return;
        }
        onClickAway(...params);
      }
    }),
    ownerState
  }), _e = _d, {
    ownerState: clickAwayOwnerStateProp
  } = _e, clickAwayListenerProps = __objRest(_e, [
    "ownerState"
  ]);
  const [ContentSlot, contentSlotProps] = useSlot("content", {
    elementType: SnackbarContent,
    shouldForwardComponentProp: true,
    externalForwardedProps,
    additionalProps: {
      message,
      action
    },
    ownerState
  });
  const [TransitionSlot, transitionProps] = useSlot("transition", {
    elementType: Grow,
    externalForwardedProps,
    getSlotProps: (handlers) => ({
      onEnter: (...params) => {
        var _a3;
        (_a3 = handlers.onEnter) == null ? void 0 : _a3.call(handlers, ...params);
        handleEnter(...params);
      },
      onExited: (...params) => {
        var _a3;
        (_a3 = handlers.onExited) == null ? void 0 : _a3.call(handlers, ...params);
        handleExited(...params);
      }
    }),
    additionalProps: {
      appear: true,
      in: open,
      timeout: transitionDuration,
      direction: vertical === "top" ? "down" : "up"
    },
    ownerState
  });
  if (!open && exited) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ClickAwaySlot, __spreadProps(__spreadValues(__spreadValues({}, clickAwayListenerProps), slots.clickAwayListener && {
    ownerState: clickAwayOwnerStateProp
  }), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root, __spreadProps(__spreadValues({}, rootProps), {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionSlot, __spreadProps(__spreadValues({}, transitionProps), {
        children: children || /* @__PURE__ */ jsxRuntimeExports.jsx(ContentSlot, __spreadValues({}, contentSlotProps))
      }))
    }))
  }));
});
function getTooltipUtilityClass(slot) {
  return generateUtilityClass("MuiTooltip", slot);
}
const tooltipClasses = generateUtilityClasses("MuiTooltip", ["popper", "popperInteractive", "popperArrow", "popperClose", "tooltip", "tooltipArrow", "touch", "tooltipPlacementLeft", "tooltipPlacementRight", "tooltipPlacementTop", "tooltipPlacementBottom", "arrow"]);
const React$o = window["React"];
function round(value) {
  return Math.round(value * 1e5) / 1e5;
}
const useUtilityClasses$b = (ownerState) => {
  const {
    classes,
    disableInteractive,
    arrow: arrow2,
    touch,
    placement
  } = ownerState;
  const slots = {
    popper: ["popper", !disableInteractive && "popperInteractive", arrow2 && "popperArrow"],
    tooltip: ["tooltip", arrow2 && "tooltipArrow", touch && "touch", `tooltipPlacement${capitalize(placement.split("-")[0])}`],
    arrow: ["arrow"]
  };
  return composeClasses(slots, getTooltipUtilityClass, classes);
};
const TooltipPopper = styled(Popper, {
  name: "MuiTooltip",
  slot: "Popper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.popper, !ownerState.disableInteractive && styles2.popperInteractive, ownerState.arrow && styles2.popperArrow, !ownerState.open && styles2.popperClose];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  zIndex: (theme2.vars || theme2).zIndex.tooltip,
  pointerEvents: "none",
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.disableInteractive,
    style: {
      pointerEvents: "auto"
    }
  }, {
    props: ({
      open
    }) => !open,
    style: {
      pointerEvents: "none"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.arrow,
    style: {
      [`&[data-popper-placement*="bottom"] .${tooltipClasses.arrow}`]: {
        top: 0,
        marginTop: "-0.71em",
        "&::before": {
          transformOrigin: "0 100%"
        }
      },
      [`&[data-popper-placement*="top"] .${tooltipClasses.arrow}`]: {
        bottom: 0,
        marginBottom: "-0.71em",
        "&::before": {
          transformOrigin: "100% 0"
        }
      },
      [`&[data-popper-placement*="right"] .${tooltipClasses.arrow}`]: {
        height: "1em",
        width: "0.71em",
        "&::before": {
          transformOrigin: "100% 100%"
        }
      },
      [`&[data-popper-placement*="left"] .${tooltipClasses.arrow}`]: {
        height: "1em",
        width: "0.71em",
        "&::before": {
          transformOrigin: "0 0"
        }
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.arrow && !ownerState.isRtl,
    style: {
      [`&[data-popper-placement*="right"] .${tooltipClasses.arrow}`]: {
        left: 0,
        marginLeft: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.arrow && !!ownerState.isRtl,
    style: {
      [`&[data-popper-placement*="right"] .${tooltipClasses.arrow}`]: {
        right: 0,
        marginRight: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.arrow && !ownerState.isRtl,
    style: {
      [`&[data-popper-placement*="left"] .${tooltipClasses.arrow}`]: {
        right: 0,
        marginRight: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.arrow && !!ownerState.isRtl,
    style: {
      [`&[data-popper-placement*="left"] .${tooltipClasses.arrow}`]: {
        left: 0,
        marginLeft: "-0.71em"
      }
    }
  }]
})));
const TooltipTooltip = styled("div", {
  name: "MuiTooltip",
  slot: "Tooltip",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.tooltip, ownerState.touch && styles2.touch, ownerState.arrow && styles2.tooltipArrow, styles2[`tooltipPlacement${capitalize(ownerState.placement.split("-")[0])}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  backgroundColor: theme2.vars ? theme2.vars.palette.Tooltip.bg : theme2.alpha(theme2.palette.grey[700], 0.92),
  borderRadius: (theme2.vars || theme2).shape.borderRadius,
  color: (theme2.vars || theme2).palette.common.white,
  fontFamily: theme2.typography.fontFamily,
  padding: "4px 8px",
  fontSize: theme2.typography.pxToRem(11),
  maxWidth: 300,
  margin: 2,
  wordWrap: "break-word",
  fontWeight: theme2.typography.fontWeightMedium,
  [`.${tooltipClasses.popper}[data-popper-placement*="left"] &`]: {
    transformOrigin: "right center"
  },
  [`.${tooltipClasses.popper}[data-popper-placement*="right"] &`]: {
    transformOrigin: "left center"
  },
  [`.${tooltipClasses.popper}[data-popper-placement*="top"] &`]: {
    transformOrigin: "center bottom",
    marginBottom: "14px"
  },
  [`.${tooltipClasses.popper}[data-popper-placement*="bottom"] &`]: {
    transformOrigin: "center top",
    marginTop: "14px"
  },
  variants: [{
    props: ({
      ownerState
    }) => ownerState.arrow,
    style: {
      position: "relative",
      margin: 0
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.touch,
    style: {
      padding: "8px 16px",
      fontSize: theme2.typography.pxToRem(14),
      lineHeight: `${round(16 / 14)}em`,
      fontWeight: theme2.typography.fontWeightRegular
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.isRtl,
    style: {
      [`.${tooltipClasses.popper}[data-popper-placement*="left"] &`]: {
        marginRight: "14px"
      },
      [`.${tooltipClasses.popper}[data-popper-placement*="right"] &`]: {
        marginLeft: "14px"
      }
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.isRtl && ownerState.touch,
    style: {
      [`.${tooltipClasses.popper}[data-popper-placement*="left"] &`]: {
        marginRight: "24px"
      },
      [`.${tooltipClasses.popper}[data-popper-placement*="right"] &`]: {
        marginLeft: "24px"
      }
    }
  }, {
    props: ({
      ownerState
    }) => !!ownerState.isRtl,
    style: {
      [`.${tooltipClasses.popper}[data-popper-placement*="left"] &`]: {
        marginLeft: "14px"
      },
      [`.${tooltipClasses.popper}[data-popper-placement*="right"] &`]: {
        marginRight: "14px"
      }
    }
  }, {
    props: ({
      ownerState
    }) => !!ownerState.isRtl && ownerState.touch,
    style: {
      [`.${tooltipClasses.popper}[data-popper-placement*="left"] &`]: {
        marginLeft: "24px"
      },
      [`.${tooltipClasses.popper}[data-popper-placement*="right"] &`]: {
        marginRight: "24px"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.touch,
    style: {
      [`.${tooltipClasses.popper}[data-popper-placement*="top"] &`]: {
        marginBottom: "24px"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.touch,
    style: {
      [`.${tooltipClasses.popper}[data-popper-placement*="bottom"] &`]: {
        marginTop: "24px"
      }
    }
  }]
})));
const TooltipArrow = styled("span", {
  name: "MuiTooltip",
  slot: "Arrow"
})(memoTheme(({
  theme: theme2
}) => ({
  overflow: "hidden",
  position: "absolute",
  width: "1em",
  height: "0.71em",
  boxSizing: "border-box",
  color: theme2.vars ? theme2.vars.palette.Tooltip.bg : theme2.alpha(theme2.palette.grey[700], 0.9),
  "&::before": {
    content: '""',
    margin: "auto",
    display: "block",
    width: "100%",
    height: "100%",
    backgroundColor: "currentColor",
    transform: "rotate(45deg)"
  }
})));
let hystersisOpen = false;
const hystersisTimer = new Timeout();
let cursorPosition = {
  x: 0,
  y: 0
};
function composeEventHandler(handler, eventHandler) {
  return (event, ...params) => {
    if (eventHandler) {
      eventHandler(event, ...params);
    }
    handler(event, ...params);
  };
}
const Tooltip = /* @__PURE__ */ React$o.forwardRef(function Tooltip2(inProps, ref) {
  var _b, _c, _d;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTooltip"
  });
  const _a2 = props, {
    arrow: arrow2 = false,
    children: childrenProp,
    classes: classesProp,
    components = {},
    componentsProps = {},
    describeChild = false,
    disableFocusListener = false,
    disableHoverListener = false,
    disableInteractive: disableInteractiveProp = false,
    disableTouchListener = false,
    enterDelay = 100,
    enterNextDelay = 0,
    enterTouchDelay = 700,
    followCursor = false,
    id: idProp,
    leaveDelay = 0,
    leaveTouchDelay = 1500,
    onClose,
    onOpen,
    open: openProp,
    placement = "bottom",
    PopperComponent: PopperComponentProp,
    PopperProps = {},
    slotProps = {},
    slots = {},
    title,
    TransitionComponent: TransitionComponentProp,
    TransitionProps
  } = _a2, other = __objRest(_a2, [
    "arrow",
    "children",
    "classes",
    "components",
    "componentsProps",
    "describeChild",
    "disableFocusListener",
    "disableHoverListener",
    "disableInteractive",
    "disableTouchListener",
    "enterDelay",
    "enterNextDelay",
    "enterTouchDelay",
    "followCursor",
    "id",
    "leaveDelay",
    "leaveTouchDelay",
    "onClose",
    "onOpen",
    "open",
    "placement",
    "PopperComponent",
    "PopperProps",
    "slotProps",
    "slots",
    "title",
    "TransitionComponent",
    "TransitionProps"
  ]);
  const children = /* @__PURE__ */ React$o.isValidElement(childrenProp) ? childrenProp : /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
    children: childrenProp
  });
  const theme2 = useTheme();
  const isRtl = useRtl();
  const [childNode, setChildNode] = React$o.useState();
  const [arrowRef, setArrowRef] = React$o.useState(null);
  const ignoreNonTouchEvents = React$o.useRef(false);
  const disableInteractive = disableInteractiveProp || followCursor;
  const closeTimer = useTimeout();
  const enterTimer = useTimeout();
  const leaveTimer = useTimeout();
  const touchTimer = useTimeout();
  const [openState, setOpenState] = useControlled({
    controlled: openProp,
    default: false,
    name: "Tooltip",
    state: "open"
  });
  let open = openState;
  const id = useId(idProp);
  const prevUserSelect = React$o.useRef();
  const stopTouchInteraction = useEventCallback(() => {
    if (prevUserSelect.current !== void 0) {
      document.body.style.WebkitUserSelect = prevUserSelect.current;
      prevUserSelect.current = void 0;
    }
    touchTimer.clear();
  });
  React$o.useEffect(() => stopTouchInteraction, [stopTouchInteraction]);
  const handleOpen = (event) => {
    hystersisTimer.clear();
    hystersisOpen = true;
    setOpenState(true);
    if (onOpen && !open) {
      onOpen(event);
    }
  };
  const handleClose = useEventCallback(
    /**
     * @param {React.SyntheticEvent | Event} event
     */
    (event) => {
      hystersisTimer.start(800 + leaveDelay, () => {
        hystersisOpen = false;
      });
      setOpenState(false);
      if (onClose && open) {
        onClose(event);
      }
      closeTimer.start(theme2.transitions.duration.shortest, () => {
        ignoreNonTouchEvents.current = false;
      });
    }
  );
  const handleMouseOver = (event) => {
    if (ignoreNonTouchEvents.current && event.type !== "touchstart") {
      return;
    }
    if (childNode) {
      childNode.removeAttribute("title");
    }
    enterTimer.clear();
    leaveTimer.clear();
    if (enterDelay || hystersisOpen && enterNextDelay) {
      enterTimer.start(hystersisOpen ? enterNextDelay : enterDelay, () => {
        handleOpen(event);
      });
    } else {
      handleOpen(event);
    }
  };
  const handleMouseLeave = (event) => {
    enterTimer.clear();
    leaveTimer.start(leaveDelay, () => {
      handleClose(event);
    });
  };
  const [, setChildIsFocusVisible] = React$o.useState(false);
  const handleBlur = (event) => {
    if (!isFocusVisible(event.target)) {
      setChildIsFocusVisible(false);
      handleMouseLeave(event);
    }
  };
  const handleFocus = (event) => {
    if (!childNode) {
      setChildNode(event.currentTarget);
    }
    if (isFocusVisible(event.target)) {
      setChildIsFocusVisible(true);
      handleMouseOver(event);
    }
  };
  const detectTouchStart = (event) => {
    ignoreNonTouchEvents.current = true;
    const childrenProps2 = children.props;
    if (childrenProps2.onTouchStart) {
      childrenProps2.onTouchStart(event);
    }
  };
  const handleTouchStart = (event) => {
    detectTouchStart(event);
    leaveTimer.clear();
    closeTimer.clear();
    stopTouchInteraction();
    prevUserSelect.current = document.body.style.WebkitUserSelect;
    document.body.style.WebkitUserSelect = "none";
    touchTimer.start(enterTouchDelay, () => {
      document.body.style.WebkitUserSelect = prevUserSelect.current;
      handleMouseOver(event);
    });
  };
  const handleTouchEnd = (event) => {
    if (children.props.onTouchEnd) {
      children.props.onTouchEnd(event);
    }
    stopTouchInteraction();
    leaveTimer.start(leaveTouchDelay, () => {
      handleClose(event);
    });
  };
  React$o.useEffect(() => {
    if (!open) {
      return void 0;
    }
    function handleKeyDown(nativeEvent) {
      if (nativeEvent.key === "Escape") {
        handleClose(nativeEvent);
      }
    }
    document.addEventListener("keydown", handleKeyDown);
    return () => {
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, [handleClose, open]);
  const handleRef = useForkRef(getReactElementRef(children), setChildNode, ref);
  if (!title && title !== 0) {
    open = false;
  }
  const popperRef = React$o.useRef();
  const handleMouseMove = (event) => {
    const childrenProps2 = children.props;
    if (childrenProps2.onMouseMove) {
      childrenProps2.onMouseMove(event);
    }
    cursorPosition = {
      x: event.clientX,
      y: event.clientY
    };
    if (popperRef.current) {
      popperRef.current.update();
    }
  };
  const nameOrDescProps = {};
  const titleIsString = typeof title === "string";
  if (describeChild) {
    nameOrDescProps.title = !open && titleIsString && !disableHoverListener ? title : null;
    nameOrDescProps["aria-describedby"] = open ? id : null;
  } else {
    nameOrDescProps["aria-label"] = titleIsString ? title : null;
    nameOrDescProps["aria-labelledby"] = open && !titleIsString ? id : null;
  }
  const childrenProps = __spreadValues(__spreadProps(__spreadValues(__spreadValues(__spreadValues({}, nameOrDescProps), other), children.props), {
    className: clsx(other.className, children.props.className),
    onTouchStart: detectTouchStart,
    ref: handleRef
  }), followCursor ? {
    onMouseMove: handleMouseMove
  } : {});
  const interactiveWrapperListeners = {};
  if (!disableTouchListener) {
    childrenProps.onTouchStart = handleTouchStart;
    childrenProps.onTouchEnd = handleTouchEnd;
  }
  if (!disableHoverListener) {
    childrenProps.onMouseOver = composeEventHandler(handleMouseOver, childrenProps.onMouseOver);
    childrenProps.onMouseLeave = composeEventHandler(handleMouseLeave, childrenProps.onMouseLeave);
    if (!disableInteractive) {
      interactiveWrapperListeners.onMouseOver = handleMouseOver;
      interactiveWrapperListeners.onMouseLeave = handleMouseLeave;
    }
  }
  if (!disableFocusListener) {
    childrenProps.onFocus = composeEventHandler(handleFocus, childrenProps.onFocus);
    childrenProps.onBlur = composeEventHandler(handleBlur, childrenProps.onBlur);
    if (!disableInteractive) {
      interactiveWrapperListeners.onFocus = handleFocus;
      interactiveWrapperListeners.onBlur = handleBlur;
    }
  }
  const ownerState = __spreadProps(__spreadValues({}, props), {
    isRtl,
    arrow: arrow2,
    disableInteractive,
    placement,
    PopperComponentProp,
    touch: ignoreNonTouchEvents.current
  });
  const resolvedPopperProps = typeof slotProps.popper === "function" ? slotProps.popper(ownerState) : slotProps.popper;
  const popperOptions = React$o.useMemo(() => {
    var _a3, _b2;
    let tooltipModifiers = [{
      name: "arrow",
      enabled: Boolean(arrowRef),
      options: {
        element: arrowRef,
        padding: 4
      }
    }];
    if ((_a3 = PopperProps.popperOptions) == null ? void 0 : _a3.modifiers) {
      tooltipModifiers = tooltipModifiers.concat(PopperProps.popperOptions.modifiers);
    }
    if ((_b2 = resolvedPopperProps == null ? void 0 : resolvedPopperProps.popperOptions) == null ? void 0 : _b2.modifiers) {
      tooltipModifiers = tooltipModifiers.concat(resolvedPopperProps.popperOptions.modifiers);
    }
    return __spreadProps(__spreadValues(__spreadValues({}, PopperProps.popperOptions), resolvedPopperProps == null ? void 0 : resolvedPopperProps.popperOptions), {
      modifiers: tooltipModifiers
    });
  }, [arrowRef, PopperProps.popperOptions, resolvedPopperProps == null ? void 0 : resolvedPopperProps.popperOptions]);
  const classes = useUtilityClasses$b(ownerState);
  const resolvedTransitionProps = typeof slotProps.transition === "function" ? slotProps.transition(ownerState) : slotProps.transition;
  const externalForwardedProps = {
    slots: __spreadValues({
      popper: components.Popper,
      transition: (_b = components.Transition) != null ? _b : TransitionComponentProp,
      tooltip: components.Tooltip,
      arrow: components.Arrow
    }, slots),
    slotProps: {
      arrow: (_c = slotProps.arrow) != null ? _c : componentsProps.arrow,
      popper: __spreadValues(__spreadValues({}, PopperProps), resolvedPopperProps != null ? resolvedPopperProps : componentsProps.popper),
      // resolvedPopperProps can be spread because it's already an object
      tooltip: (_d = slotProps.tooltip) != null ? _d : componentsProps.tooltip,
      transition: __spreadValues(__spreadValues({}, TransitionProps), resolvedTransitionProps != null ? resolvedTransitionProps : componentsProps.transition)
    }
  };
  const [PopperSlot, popperSlotProps] = useSlot("popper", {
    elementType: TooltipPopper,
    externalForwardedProps,
    ownerState,
    className: clsx(classes.popper, PopperProps == null ? void 0 : PopperProps.className)
  });
  const [TransitionSlot, transitionSlotProps] = useSlot("transition", {
    elementType: Grow,
    externalForwardedProps,
    ownerState
  });
  const [TooltipSlot, tooltipSlotProps] = useSlot("tooltip", {
    elementType: TooltipTooltip,
    className: classes.tooltip,
    externalForwardedProps,
    ownerState
  });
  const [ArrowSlot, arrowSlotProps] = useSlot("arrow", {
    elementType: TooltipArrow,
    className: classes.arrow,
    externalForwardedProps,
    ownerState,
    ref: setArrowRef
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(React$o.Fragment, {
    children: [/* @__PURE__ */ React$o.cloneElement(children, childrenProps), /* @__PURE__ */ jsxRuntimeExports.jsx(PopperSlot, __spreadProps(__spreadValues(__spreadValues({
      as: PopperComponentProp != null ? PopperComponentProp : Popper,
      placement,
      anchorEl: followCursor ? {
        getBoundingClientRect: () => ({
          top: cursorPosition.y,
          left: cursorPosition.x,
          right: cursorPosition.x,
          bottom: cursorPosition.y,
          width: 0,
          height: 0
        })
      } : childNode,
      popperRef,
      open: childNode ? open : false,
      id,
      transition: true
    }, interactiveWrapperListeners), popperSlotProps), {
      popperOptions,
      children: ({
        TransitionProps: TransitionPropsInner
      }) => /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionSlot, __spreadProps(__spreadValues(__spreadValues({
        timeout: theme2.transitions.duration.shorter
      }, TransitionPropsInner), transitionSlotProps), {
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TooltipSlot, __spreadProps(__spreadValues({}, tooltipSlotProps), {
          children: [title, arrow2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowSlot, __spreadValues({}, arrowSlotProps)) : null]
        }))
      }))
    }))]
  });
});
const Stack = createStack({
  createStyledComponent: styled("div", {
    name: "MuiStack",
    slot: "Root"
  }),
  useThemeProps: (inProps) => useDefaultProps({
    props: inProps,
    name: "MuiStack"
  })
});
function getSwitchUtilityClass(slot) {
  return generateUtilityClass("MuiSwitch", slot);
}
const switchClasses = generateUtilityClasses("MuiSwitch", ["root", "edgeStart", "edgeEnd", "switchBase", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium", "checked", "disabled", "input", "thumb", "track"]);
const React$n = window["React"];
const useUtilityClasses$a = (ownerState) => {
  const {
    classes,
    edge,
    size,
    color: color2,
    checked,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", edge && `edge${capitalize(edge)}`, `size${capitalize(size)}`],
    switchBase: ["switchBase", `color${capitalize(color2)}`, checked && "checked", disabled && "disabled"],
    thumb: ["thumb"],
    track: ["track"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getSwitchUtilityClass, classes);
  return __spreadValues(__spreadValues({}, classes), composedClasses);
};
const SwitchRoot = styled("span", {
  name: "MuiSwitch",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.edge && styles2[`edge${capitalize(ownerState.edge)}`], styles2[`size${capitalize(ownerState.size)}`]];
  }
})({
  display: "inline-flex",
  width: 34 + 12 * 2,
  height: 14 + 12 * 2,
  overflow: "hidden",
  padding: 12,
  boxSizing: "border-box",
  position: "relative",
  flexShrink: 0,
  zIndex: 0,
  // Reset the stacking context.
  verticalAlign: "middle",
  // For correct alignment with the text.
  "@media print": {
    colorAdjust: "exact"
  },
  variants: [{
    props: {
      edge: "start"
    },
    style: {
      marginLeft: -8
    }
  }, {
    props: {
      edge: "end"
    },
    style: {
      marginRight: -8
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      width: 40,
      height: 24,
      padding: 7,
      [`& .${switchClasses.thumb}`]: {
        width: 16,
        height: 16
      },
      [`& .${switchClasses.switchBase}`]: {
        padding: 4,
        [`&.${switchClasses.checked}`]: {
          transform: "translateX(16px)"
        }
      }
    }
  }]
});
const SwitchSwitchBase = styled(SwitchBase, {
  name: "MuiSwitch",
  slot: "SwitchBase",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.switchBase, {
      [`& .${switchClasses.input}`]: styles2.input
    }, ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  position: "absolute",
  top: 0,
  left: 0,
  zIndex: 1,
  // Render above the focus ripple.
  color: theme2.vars ? theme2.vars.palette.Switch.defaultColor : `${theme2.palette.mode === "light" ? theme2.palette.common.white : theme2.palette.grey[300]}`,
  transition: theme2.transitions.create(["left", "transform"], {
    duration: theme2.transitions.duration.shortest
  }),
  [`&.${switchClasses.checked}`]: {
    transform: "translateX(20px)"
  },
  [`&.${switchClasses.disabled}`]: {
    color: theme2.vars ? theme2.vars.palette.Switch.defaultDisabledColor : `${theme2.palette.mode === "light" ? theme2.palette.grey[100] : theme2.palette.grey[600]}`
  },
  [`&.${switchClasses.checked} + .${switchClasses.track}`]: {
    opacity: 0.5
  },
  [`&.${switchClasses.disabled} + .${switchClasses.track}`]: {
    opacity: theme2.vars ? theme2.vars.opacity.switchTrackDisabled : `${theme2.palette.mode === "light" ? 0.12 : 0.2}`
  },
  [`& .${switchClasses.input}`]: {
    left: "-100%",
    width: "300%"
  }
})), memoTheme(({
  theme: theme2
}) => ({
  "&:hover": {
    backgroundColor: theme2.alpha((theme2.vars || theme2).palette.action.active, (theme2.vars || theme2).palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  variants: [...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["light"])).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      [`&.${switchClasses.checked}`]: {
        color: (theme2.vars || theme2).palette[color2].main,
        "&:hover": {
          backgroundColor: theme2.alpha((theme2.vars || theme2).palette[color2].main, (theme2.vars || theme2).palette.action.hoverOpacity),
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        },
        [`&.${switchClasses.disabled}`]: {
          color: theme2.vars ? theme2.vars.palette.Switch[`${color2}DisabledColor`] : `${theme2.palette.mode === "light" ? theme2.lighten(theme2.palette[color2].main, 0.62) : theme2.darken(theme2.palette[color2].main, 0.55)}`
        }
      },
      [`&.${switchClasses.checked} + .${switchClasses.track}`]: {
        backgroundColor: (theme2.vars || theme2).palette[color2].main
      }
    }
  }))]
})));
const SwitchTrack = styled("span", {
  name: "MuiSwitch",
  slot: "Track"
})(memoTheme(({
  theme: theme2
}) => ({
  height: "100%",
  width: "100%",
  borderRadius: 14 / 2,
  zIndex: -1,
  transition: theme2.transitions.create(["opacity", "background-color"], {
    duration: theme2.transitions.duration.shortest
  }),
  backgroundColor: theme2.vars ? theme2.vars.palette.common.onBackground : `${theme2.palette.mode === "light" ? theme2.palette.common.black : theme2.palette.common.white}`,
  opacity: theme2.vars ? theme2.vars.opacity.switchTrack : `${theme2.palette.mode === "light" ? 0.38 : 0.3}`
})));
const SwitchThumb = styled("span", {
  name: "MuiSwitch",
  slot: "Thumb"
})(memoTheme(({
  theme: theme2
}) => ({
  boxShadow: (theme2.vars || theme2).shadows[1],
  backgroundColor: "currentColor",
  width: 20,
  height: 20,
  borderRadius: "50%"
})));
const Switch = /* @__PURE__ */ React$n.forwardRef(function Switch2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSwitch"
  });
  const _a2 = props, {
    className,
    color: color2 = "primary",
    edge = false,
    size = "medium",
    sx,
    slots = {},
    slotProps = {}
  } = _a2, other = __objRest(_a2, [
    "className",
    "color",
    "edge",
    "size",
    "sx",
    "slots",
    "slotProps"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: color2,
    edge,
    size
  });
  const classes = useUtilityClasses$a(ownerState);
  const externalForwardedProps = {
    slots,
    slotProps
  };
  const [RootSlot, rootSlotProps] = useSlot("root", {
    className: clsx(classes.root, className),
    elementType: SwitchRoot,
    externalForwardedProps,
    ownerState,
    additionalProps: {
      sx
    }
  });
  const [ThumbSlot, thumbSlotProps] = useSlot("thumb", {
    className: classes.thumb,
    elementType: SwitchThumb,
    externalForwardedProps,
    ownerState
  });
  const icon = /* @__PURE__ */ jsxRuntimeExports.jsx(ThumbSlot, __spreadValues({}, thumbSlotProps));
  const [TrackSlot, trackSlotProps] = useSlot("track", {
    className: classes.track,
    elementType: SwitchTrack,
    externalForwardedProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, __spreadProps(__spreadValues({}, rootSlotProps), {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SwitchSwitchBase, __spreadProps(__spreadValues({
      type: "checkbox",
      icon,
      checkedIcon: icon,
      ref,
      ownerState
    }, other), {
      classes: __spreadProps(__spreadValues({}, classes), {
        root: classes.switchBase
      }),
      slots: __spreadValues(__spreadValues({}, slots.switchBase && {
        root: slots.switchBase
      }), slots.input && {
        input: slots.input
      }),
      slotProps: __spreadValues(__spreadProps(__spreadValues({}, slotProps.switchBase && {
        root: typeof slotProps.switchBase === "function" ? slotProps.switchBase(ownerState) : slotProps.switchBase
      }), {
        input: {
          role: "switch"
        }
      }), slotProps.input && {
        input: typeof slotProps.input === "function" ? slotProps.input(ownerState) : slotProps.input
      })
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(TrackSlot, __spreadValues({}, trackSlotProps))]
  }));
});
function getTabUtilityClass(slot) {
  return generateUtilityClass("MuiTab", slot);
}
const tabClasses = generateUtilityClasses("MuiTab", ["root", "labelIcon", "textColorInherit", "textColorPrimary", "textColorSecondary", "selected", "disabled", "fullWidth", "wrapped", "iconWrapper", "icon"]);
const React$m = window["React"];
const useUtilityClasses$9 = (ownerState) => {
  const {
    classes,
    textColor,
    fullWidth,
    wrapped,
    icon,
    label,
    selected,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", icon && label && "labelIcon", `textColor${capitalize(textColor)}`, fullWidth && "fullWidth", wrapped && "wrapped", selected && "selected", disabled && "disabled"],
    icon: ["iconWrapper", "icon"]
  };
  return composeClasses(slots, getTabUtilityClass, classes);
};
const TabRoot = styled(ButtonBase, {
  name: "MuiTab",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.label && ownerState.icon && styles2.labelIcon, styles2[`textColor${capitalize(ownerState.textColor)}`], ownerState.fullWidth && styles2.fullWidth, ownerState.wrapped && styles2.wrapped, {
      [`& .${tabClasses.iconWrapper}`]: styles2.iconWrapper
    }, {
      [`& .${tabClasses.icon}`]: styles2.icon
    }];
  }
})(memoTheme(({
  theme: theme2
}) => __spreadProps(__spreadValues({}, theme2.typography.button), {
  maxWidth: 360,
  minWidth: 90,
  position: "relative",
  minHeight: 48,
  flexShrink: 0,
  padding: "12px 16px",
  overflow: "hidden",
  whiteSpace: "normal",
  textAlign: "center",
  lineHeight: 1.25,
  variants: [{
    props: ({
      ownerState
    }) => ownerState.label && (ownerState.iconPosition === "top" || ownerState.iconPosition === "bottom"),
    style: {
      flexDirection: "column"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.label && ownerState.iconPosition !== "top" && ownerState.iconPosition !== "bottom",
    style: {
      flexDirection: "row"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.icon && ownerState.label,
    style: {
      minHeight: 72,
      paddingTop: 9,
      paddingBottom: 9
    }
  }, {
    props: ({
      ownerState,
      iconPosition
    }) => ownerState.icon && ownerState.label && iconPosition === "top",
    style: {
      [`& > .${tabClasses.icon}`]: {
        marginBottom: 6
      }
    }
  }, {
    props: ({
      ownerState,
      iconPosition
    }) => ownerState.icon && ownerState.label && iconPosition === "bottom",
    style: {
      [`& > .${tabClasses.icon}`]: {
        marginTop: 6
      }
    }
  }, {
    props: ({
      ownerState,
      iconPosition
    }) => ownerState.icon && ownerState.label && iconPosition === "start",
    style: {
      [`& > .${tabClasses.icon}`]: {
        marginRight: theme2.spacing(1)
      }
    }
  }, {
    props: ({
      ownerState,
      iconPosition
    }) => ownerState.icon && ownerState.label && iconPosition === "end",
    style: {
      [`& > .${tabClasses.icon}`]: {
        marginLeft: theme2.spacing(1)
      }
    }
  }, {
    props: {
      textColor: "inherit"
    },
    style: {
      color: "inherit",
      opacity: 0.6,
      // same opacity as theme.palette.text.secondary
      [`&.${tabClasses.selected}`]: {
        opacity: 1
      },
      [`&.${tabClasses.disabled}`]: {
        opacity: (theme2.vars || theme2).palette.action.disabledOpacity
      }
    }
  }, {
    props: {
      textColor: "primary"
    },
    style: {
      color: (theme2.vars || theme2).palette.text.secondary,
      [`&.${tabClasses.selected}`]: {
        color: (theme2.vars || theme2).palette.primary.main
      },
      [`&.${tabClasses.disabled}`]: {
        color: (theme2.vars || theme2).palette.text.disabled
      }
    }
  }, {
    props: {
      textColor: "secondary"
    },
    style: {
      color: (theme2.vars || theme2).palette.text.secondary,
      [`&.${tabClasses.selected}`]: {
        color: (theme2.vars || theme2).palette.secondary.main
      },
      [`&.${tabClasses.disabled}`]: {
        color: (theme2.vars || theme2).palette.text.disabled
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.fullWidth,
    style: {
      flexShrink: 1,
      flexGrow: 1,
      flexBasis: 0,
      maxWidth: "none"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.wrapped,
    style: {
      fontSize: theme2.typography.pxToRem(12)
    }
  }]
})));
const Tab = /* @__PURE__ */ React$m.forwardRef(function Tab2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTab"
  });
  const _a2 = props, {
    className,
    disabled = false,
    disableFocusRipple = false,
    fullWidth: fullWidth,
    icon: iconProp,
    iconPosition = "top",
    indicator: indicator,
    label,
    onChange,
    onClick,
    onFocus,
    selected: selected,
    selectionFollowsFocus: selectionFollowsFocus,
    textColor: textColor = "inherit",
    value,
    wrapped = false
  } = _a2, other = __objRest(_a2, [
    "className",
    "disabled",
    "disableFocusRipple",
    // eslint-disable-next-line react/prop-types
    "fullWidth",
    "icon",
    "iconPosition",
    // eslint-disable-next-line react/prop-types
    "indicator",
    "label",
    "onChange",
    "onClick",
    "onFocus",
    // eslint-disable-next-line react/prop-types
    "selected",
    // eslint-disable-next-line react/prop-types
    "selectionFollowsFocus",
    // eslint-disable-next-line react/prop-types
    "textColor",
    "value",
    "wrapped"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    disabled,
    disableFocusRipple,
    selected,
    icon: !!iconProp,
    iconPosition,
    label: !!label,
    fullWidth,
    textColor,
    wrapped
  });
  const classes = useUtilityClasses$9(ownerState);
  const icon = iconProp && label && /* @__PURE__ */ React$m.isValidElement(iconProp) ? /* @__PURE__ */ React$m.cloneElement(iconProp, {
    className: clsx(classes.icon, iconProp.props.className)
  }) : iconProp;
  const handleClick = (event) => {
    if (!selected && onChange) {
      onChange(event, value);
    }
    if (onClick) {
      onClick(event);
    }
  };
  const handleFocus = (event) => {
    if (selectionFollowsFocus && !selected && onChange) {
      onChange(event, value);
    }
    if (onFocus) {
      onFocus(event);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TabRoot, __spreadProps(__spreadValues({
    focusRipple: !disableFocusRipple,
    className: clsx(classes.root, className),
    ref,
    role: "tab",
    "aria-selected": selected,
    disabled,
    onClick: handleClick,
    onFocus: handleFocus,
    ownerState,
    tabIndex: selected ? 0 : -1
  }, other), {
    children: [iconPosition === "top" || iconPosition === "start" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(React$m.Fragment, {
      children: [icon, label]
    }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(React$m.Fragment, {
      children: [label, icon]
    }), indicator]
  }));
});
const React$l = window["React"];
const TableContext = /* @__PURE__ */ React$l.createContext();
function getTableUtilityClass(slot) {
  return generateUtilityClass("MuiTable", slot);
}
generateUtilityClasses("MuiTable", ["root", "stickyHeader"]);
const React$k = window["React"];
const useUtilityClasses$8 = (ownerState) => {
  const {
    classes,
    stickyHeader
  } = ownerState;
  const slots = {
    root: ["root", stickyHeader && "stickyHeader"]
  };
  return composeClasses(slots, getTableUtilityClass, classes);
};
const TableRoot = styled("table", {
  name: "MuiTable",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.stickyHeader && styles2.stickyHeader];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  display: "table",
  width: "100%",
  borderCollapse: "collapse",
  borderSpacing: 0,
  "& caption": __spreadProps(__spreadValues({}, theme2.typography.body2), {
    padding: theme2.spacing(2),
    color: (theme2.vars || theme2).palette.text.secondary,
    textAlign: "left",
    captionSide: "bottom"
  }),
  variants: [{
    props: ({
      ownerState
    }) => ownerState.stickyHeader,
    style: {
      borderCollapse: "separate"
    }
  }]
})));
const defaultComponent$3 = "table";
const Table = /* @__PURE__ */ React$k.forwardRef(function Table2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTable"
  });
  const _a2 = props, {
    className,
    component = defaultComponent$3,
    padding: padding2 = "normal",
    size = "medium",
    stickyHeader = false
  } = _a2, other = __objRest(_a2, [
    "className",
    "component",
    "padding",
    "size",
    "stickyHeader"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component,
    padding: padding2,
    size,
    stickyHeader
  });
  const classes = useUtilityClasses$8(ownerState);
  const table = React$k.useMemo(() => ({
    padding: padding2,
    size,
    stickyHeader
  }), [padding2, size, stickyHeader]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableContext.Provider, {
    value: table,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableRoot, __spreadValues({
      as: component,
      role: component === defaultComponent$3 ? null : "table",
      ref,
      className: clsx(classes.root, className),
      ownerState
    }, other))
  });
});
const React$j = window["React"];
const Tablelvl2Context = /* @__PURE__ */ React$j.createContext();
function getTableBodyUtilityClass(slot) {
  return generateUtilityClass("MuiTableBody", slot);
}
generateUtilityClasses("MuiTableBody", ["root"]);
const React$i = window["React"];
const useUtilityClasses$7 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTableBodyUtilityClass, classes);
};
const TableBodyRoot = styled("tbody", {
  name: "MuiTableBody",
  slot: "Root"
})({
  display: "table-row-group"
});
const tablelvl2$1 = {
  variant: "body"
};
const defaultComponent$2 = "tbody";
const TableBody = /* @__PURE__ */ React$i.forwardRef(function TableBody2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableBody"
  });
  const _a2 = props, {
    className,
    component = defaultComponent$2
  } = _a2, other = __objRest(_a2, [
    "className",
    "component"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component
  });
  const classes = useUtilityClasses$7(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Tablelvl2Context.Provider, {
    value: tablelvl2$1,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableBodyRoot, __spreadValues({
      className: clsx(classes.root, className),
      as: component,
      ref,
      role: component === defaultComponent$2 ? null : "rowgroup",
      ownerState
    }, other))
  });
});
function getTableCellUtilityClass(slot) {
  return generateUtilityClass("MuiTableCell", slot);
}
const tableCellClasses = generateUtilityClasses("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]);
const React$h = window["React"];
const useUtilityClasses$6 = (ownerState) => {
  const {
    classes,
    variant,
    align,
    padding: padding2,
    size,
    stickyHeader
  } = ownerState;
  const slots = {
    root: ["root", variant, stickyHeader && "stickyHeader", align !== "inherit" && `align${capitalize(align)}`, padding2 !== "normal" && `padding${capitalize(padding2)}`, `size${capitalize(size)}`]
  };
  return composeClasses(slots, getTableCellUtilityClass, classes);
};
const TableCellRoot = styled("td", {
  name: "MuiTableCell",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`size${capitalize(ownerState.size)}`], ownerState.padding !== "normal" && styles2[`padding${capitalize(ownerState.padding)}`], ownerState.align !== "inherit" && styles2[`align${capitalize(ownerState.align)}`], ownerState.stickyHeader && styles2.stickyHeader];
  }
})(memoTheme(({
  theme: theme2
}) => __spreadProps(__spreadValues({}, theme2.typography.body2), {
  display: "table-cell",
  verticalAlign: "inherit",
  // Workaround for a rendering bug with spanned columns in Chrome 62.0.
  // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
  borderBottom: theme2.vars ? `1px solid ${theme2.vars.palette.TableCell.border}` : `1px solid
    ${theme2.palette.mode === "light" ? theme2.lighten(theme2.alpha(theme2.palette.divider, 1), 0.88) : theme2.darken(theme2.alpha(theme2.palette.divider, 1), 0.68)}`,
  textAlign: "left",
  padding: 16,
  variants: [{
    props: {
      variant: "head"
    },
    style: {
      color: (theme2.vars || theme2).palette.text.primary,
      lineHeight: theme2.typography.pxToRem(24),
      fontWeight: theme2.typography.fontWeightMedium
    }
  }, {
    props: {
      variant: "body"
    },
    style: {
      color: (theme2.vars || theme2).palette.text.primary
    }
  }, {
    props: {
      variant: "footer"
    },
    style: {
      color: (theme2.vars || theme2).palette.text.secondary,
      lineHeight: theme2.typography.pxToRem(21),
      fontSize: theme2.typography.pxToRem(12)
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      padding: "6px 16px",
      [`&.${tableCellClasses.paddingCheckbox}`]: {
        width: 24,
        // prevent the checkbox column from growing
        padding: "0 12px 0 16px",
        "& > *": {
          padding: 0
        }
      }
    }
  }, {
    props: {
      padding: "checkbox"
    },
    style: {
      width: 48,
      // prevent the checkbox column from growing
      padding: "0 0 0 4px"
    }
  }, {
    props: {
      padding: "none"
    },
    style: {
      padding: 0
    }
  }, {
    props: {
      align: "left"
    },
    style: {
      textAlign: "left"
    }
  }, {
    props: {
      align: "center"
    },
    style: {
      textAlign: "center"
    }
  }, {
    props: {
      align: "right"
    },
    style: {
      textAlign: "right",
      flexDirection: "row-reverse"
    }
  }, {
    props: {
      align: "justify"
    },
    style: {
      textAlign: "justify"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.stickyHeader,
    style: {
      position: "sticky",
      top: 0,
      zIndex: 2,
      backgroundColor: (theme2.vars || theme2).palette.background.default
    }
  }]
})));
const TableCell = /* @__PURE__ */ React$h.forwardRef(function TableCell2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableCell"
  });
  const _a2 = props, {
    align = "inherit",
    className,
    component: componentProp,
    padding: paddingProp,
    scope: scopeProp,
    size: sizeProp,
    sortDirection,
    variant: variantProp
  } = _a2, other = __objRest(_a2, [
    "align",
    "className",
    "component",
    "padding",
    "scope",
    "size",
    "sortDirection",
    "variant"
  ]);
  const table = React$h.useContext(TableContext);
  const tablelvl22 = React$h.useContext(Tablelvl2Context);
  const isHeadCell = tablelvl22 && tablelvl22.variant === "head";
  let component;
  if (componentProp) {
    component = componentProp;
  } else {
    component = isHeadCell ? "th" : "td";
  }
  let scope = scopeProp;
  if (component === "td") {
    scope = void 0;
  } else if (!scope && isHeadCell) {
    scope = "col";
  }
  const variant = variantProp || tablelvl22 && tablelvl22.variant;
  const ownerState = __spreadProps(__spreadValues({}, props), {
    align,
    component,
    padding: paddingProp || (table && table.padding ? table.padding : "normal"),
    size: sizeProp || (table && table.size ? table.size : "medium"),
    sortDirection,
    stickyHeader: variant === "head" && table && table.stickyHeader,
    variant
  });
  const classes = useUtilityClasses$6(ownerState);
  let ariaSort = null;
  if (sortDirection) {
    ariaSort = sortDirection === "asc" ? "ascending" : "descending";
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableCellRoot, __spreadValues({
    as: component,
    ref,
    className: clsx(classes.root, className),
    "aria-sort": ariaSort,
    scope,
    ownerState
  }, other));
});
function getTableContainerUtilityClass(slot) {
  return generateUtilityClass("MuiTableContainer", slot);
}
generateUtilityClasses("MuiTableContainer", ["root"]);
const React$g = window["React"];
const useUtilityClasses$5 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTableContainerUtilityClass, classes);
};
const TableContainerRoot = styled("div", {
  name: "MuiTableContainer",
  slot: "Root"
})({
  width: "100%",
  overflowX: "auto"
});
const TableContainer = /* @__PURE__ */ React$g.forwardRef(function TableContainer2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableContainer"
  });
  const _a2 = props, {
    className,
    component = "div"
  } = _a2, other = __objRest(_a2, [
    "className",
    "component"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component
  });
  const classes = useUtilityClasses$5(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableContainerRoot, __spreadValues({
    ref,
    as: component,
    className: clsx(classes.root, className),
    ownerState
  }, other));
});
function getTableHeadUtilityClass(slot) {
  return generateUtilityClass("MuiTableHead", slot);
}
generateUtilityClasses("MuiTableHead", ["root"]);
const React$f = window["React"];
const useUtilityClasses$4 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTableHeadUtilityClass, classes);
};
const TableHeadRoot = styled("thead", {
  name: "MuiTableHead",
  slot: "Root"
})({
  display: "table-header-group"
});
const tablelvl2 = {
  variant: "head"
};
const defaultComponent$1 = "thead";
const TableHead = /* @__PURE__ */ React$f.forwardRef(function TableHead2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableHead"
  });
  const _a2 = props, {
    className,
    component = defaultComponent$1
  } = _a2, other = __objRest(_a2, [
    "className",
    "component"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component
  });
  const classes = useUtilityClasses$4(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Tablelvl2Context.Provider, {
    value: tablelvl2,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableHeadRoot, __spreadValues({
      as: component,
      className: clsx(classes.root, className),
      ref,
      role: component === defaultComponent$1 ? null : "rowgroup",
      ownerState
    }, other))
  });
});
const KeyboardArrowLeft = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
}));
const KeyboardArrowRight = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"
}));
function getTableRowUtilityClass(slot) {
  return generateUtilityClass("MuiTableRow", slot);
}
const tableRowClasses = generateUtilityClasses("MuiTableRow", ["root", "selected", "hover", "head", "footer"]);
const React$e = window["React"];
const useUtilityClasses$3 = (ownerState) => {
  const {
    classes,
    selected,
    hover,
    head: head2,
    footer
  } = ownerState;
  const slots = {
    root: ["root", selected && "selected", hover && "hover", head2 && "head", footer && "footer"]
  };
  return composeClasses(slots, getTableRowUtilityClass, classes);
};
const TableRowRoot = styled("tr", {
  name: "MuiTableRow",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.head && styles2.head, ownerState.footer && styles2.footer];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  color: "inherit",
  display: "table-row",
  verticalAlign: "middle",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  [`&.${tableRowClasses.hover}:hover`]: {
    backgroundColor: (theme2.vars || theme2).palette.action.hover
  },
  [`&.${tableRowClasses.selected}`]: {
    backgroundColor: theme2.alpha((theme2.vars || theme2).palette.primary.main, (theme2.vars || theme2).palette.action.selectedOpacity),
    "&:hover": {
      backgroundColor: theme2.alpha((theme2.vars || theme2).palette.primary.main, `${(theme2.vars || theme2).palette.action.selectedOpacity} + ${(theme2.vars || theme2).palette.action.hoverOpacity}`)
    }
  }
})));
const defaultComponent = "tr";
const TableRow = /* @__PURE__ */ React$e.forwardRef(function TableRow2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableRow"
  });
  const _a2 = props, {
    className,
    component = defaultComponent,
    hover = false,
    selected = false
  } = _a2, other = __objRest(_a2, [
    "className",
    "component",
    "hover",
    "selected"
  ]);
  const tablelvl22 = React$e.useContext(Tablelvl2Context);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component,
    hover,
    selected,
    head: tablelvl22 && tablelvl22.variant === "head",
    footer: tablelvl22 && tablelvl22.variant === "footer"
  });
  const classes = useUtilityClasses$3(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableRowRoot, __spreadValues({
    as: component,
    ref,
    className: clsx(classes.root, className),
    role: component === defaultComponent ? null : "row",
    ownerState
  }, other));
});
function easeInOutSin(time) {
  return (1 + Math.sin(Math.PI * time - Math.PI / 2)) / 2;
}
function animate(property, element, to, options = {}, cb = () => {
}) {
  const {
    ease = easeInOutSin,
    duration: duration2 = 300
    // standard
  } = options;
  let start2 = null;
  const from2 = element[property];
  let cancelled = false;
  const cancel = () => {
    cancelled = true;
  };
  const step = (timestamp) => {
    if (cancelled) {
      cb(new Error("Animation cancelled"));
      return;
    }
    if (start2 === null) {
      start2 = timestamp;
    }
    const time = Math.min(1, (timestamp - start2) / duration2);
    element[property] = ease(time) * (to - from2) + from2;
    if (time >= 1) {
      requestAnimationFrame(() => {
        cb(null);
      });
      return;
    }
    requestAnimationFrame(step);
  };
  if (from2 === to) {
    cb(new Error("Element already at target position"));
    return cancel;
  }
  requestAnimationFrame(step);
  return cancel;
}
const React$d = window["React"];
const styles = {
  width: 99,
  height: 99,
  position: "absolute",
  top: -9999,
  overflow: "scroll"
};
function ScrollbarSize(props) {
  const _a2 = props, {
    onChange
  } = _a2, other = __objRest(_a2, [
    "onChange"
  ]);
  const scrollbarHeight = React$d.useRef();
  const nodeRef = React$d.useRef(null);
  const setMeasurements = () => {
    scrollbarHeight.current = nodeRef.current.offsetHeight - nodeRef.current.clientHeight;
  };
  useEnhancedEffect(() => {
    const handleResize = debounce$1(() => {
      const prevHeight = scrollbarHeight.current;
      setMeasurements();
      if (prevHeight !== scrollbarHeight.current) {
        onChange(scrollbarHeight.current);
      }
    });
    const containerWindow = ownerWindow(nodeRef.current);
    containerWindow.addEventListener("resize", handleResize);
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
    };
  }, [onChange]);
  React$d.useEffect(() => {
    setMeasurements();
    onChange(scrollbarHeight.current);
  }, [onChange]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", __spreadProps(__spreadValues({
    style: styles
  }, other), {
    ref: nodeRef
  }));
}
function getTabScrollButtonUtilityClass(slot) {
  return generateUtilityClass("MuiTabScrollButton", slot);
}
const tabScrollButtonClasses = generateUtilityClasses("MuiTabScrollButton", ["root", "vertical", "horizontal", "disabled"]);
const React$c = window["React"];
const useUtilityClasses$2 = (ownerState) => {
  const {
    classes,
    orientation,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", orientation, disabled && "disabled"]
  };
  return composeClasses(slots, getTabScrollButtonUtilityClass, classes);
};
const TabScrollButtonRoot = styled(ButtonBase, {
  name: "MuiTabScrollButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.orientation && styles2[ownerState.orientation]];
  }
})({
  width: 40,
  flexShrink: 0,
  opacity: 0.8,
  [`&.${tabScrollButtonClasses.disabled}`]: {
    opacity: 0
  },
  variants: [{
    props: {
      orientation: "vertical"
    },
    style: {
      width: "100%",
      height: 40,
      "& svg": {
        transform: "var(--TabScrollButton-svgRotate)"
      }
    }
  }]
});
const TabScrollButton = /* @__PURE__ */ React$c.forwardRef(function TabScrollButton2(inProps, ref) {
  var _b, _c;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTabScrollButton"
  });
  const _a2 = props, {
    className,
    slots = {},
    slotProps = {},
    direction,
    orientation,
    disabled
  } = _a2, other = __objRest(_a2, [
    "className",
    "slots",
    "slotProps",
    "direction",
    "orientation",
    "disabled"
  ]);
  const isRtl = useRtl();
  const ownerState = __spreadValues({
    isRtl
  }, props);
  const classes = useUtilityClasses$2(ownerState);
  const StartButtonIcon = (_b = slots.StartScrollButtonIcon) != null ? _b : KeyboardArrowLeft;
  const EndButtonIcon = (_c = slots.EndScrollButtonIcon) != null ? _c : KeyboardArrowRight;
  const startButtonIconProps = useSlotProps({
    elementType: StartButtonIcon,
    externalSlotProps: slotProps.startScrollButtonIcon,
    additionalProps: {
      fontSize: "small"
    },
    ownerState
  });
  const endButtonIconProps = useSlotProps({
    elementType: EndButtonIcon,
    externalSlotProps: slotProps.endScrollButtonIcon,
    additionalProps: {
      fontSize: "small"
    },
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TabScrollButtonRoot, __spreadProps(__spreadValues({
    component: "div",
    className: clsx(classes.root, className),
    ref,
    role: null,
    ownerState,
    tabIndex: null
  }, other), {
    style: __spreadValues(__spreadValues({}, other.style), orientation === "vertical" && {
      "--TabScrollButton-svgRotate": `rotate(${isRtl ? -90 : 90}deg)`
    }),
    children: direction === "left" ? /* @__PURE__ */ jsxRuntimeExports.jsx(StartButtonIcon, __spreadValues({}, startButtonIconProps)) : /* @__PURE__ */ jsxRuntimeExports.jsx(EndButtonIcon, __spreadValues({}, endButtonIconProps))
  }));
});
function getTabsUtilityClass(slot) {
  return generateUtilityClass("MuiTabs", slot);
}
const tabsClasses = generateUtilityClasses("MuiTabs", ["root", "vertical", "list", "flexContainer", "flexContainerVertical", "centered", "scroller", "fixed", "scrollableX", "scrollableY", "hideScrollbar", "scrollButtons", "scrollButtonsHideMobile", "indicator"]);
const React$b = window["React"];
const nextItem = (list, item) => {
  if (list === item) {
    return list.firstChild;
  }
  if (item && item.nextElementSibling) {
    return item.nextElementSibling;
  }
  return list.firstChild;
};
const previousItem = (list, item) => {
  if (list === item) {
    return list.lastChild;
  }
  if (item && item.previousElementSibling) {
    return item.previousElementSibling;
  }
  return list.lastChild;
};
const moveFocus = (list, currentFocus, traversalFunction) => {
  let wrappedOnce = false;
  let nextFocus = traversalFunction(list, currentFocus);
  while (nextFocus) {
    if (nextFocus === list.firstChild) {
      if (wrappedOnce) {
        return;
      }
      wrappedOnce = true;
    }
    const nextFocusDisabled = nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
    if (!nextFocus.hasAttribute("tabindex") || nextFocusDisabled) {
      nextFocus = traversalFunction(list, nextFocus);
    } else {
      nextFocus.focus();
      return;
    }
  }
};
const useUtilityClasses$1 = (ownerState) => {
  const {
    vertical,
    fixed,
    hideScrollbar,
    scrollableX,
    scrollableY,
    centered,
    scrollButtonsHideMobile,
    classes
  } = ownerState;
  const slots = {
    root: ["root", vertical && "vertical"],
    scroller: ["scroller", fixed && "fixed", hideScrollbar && "hideScrollbar", scrollableX && "scrollableX", scrollableY && "scrollableY"],
    list: ["list", "flexContainer", vertical && "flexContainerVertical", vertical && "vertical", centered && "centered"],
    indicator: ["indicator"],
    scrollButtons: ["scrollButtons", scrollButtonsHideMobile && "scrollButtonsHideMobile"],
    scrollableX: [scrollableX && "scrollableX"],
    hideScrollbar: [hideScrollbar && "hideScrollbar"]
  };
  return composeClasses(slots, getTabsUtilityClass, classes);
};
const TabsRoot = styled("div", {
  name: "MuiTabs",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${tabsClasses.scrollButtons}`]: styles2.scrollButtons
    }, {
      [`& .${tabsClasses.scrollButtons}`]: ownerState.scrollButtonsHideMobile && styles2.scrollButtonsHideMobile
    }, styles2.root, ownerState.vertical && styles2.vertical];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  overflow: "hidden",
  minHeight: 48,
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch",
  display: "flex",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.vertical,
    style: {
      flexDirection: "column"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.scrollButtonsHideMobile,
    style: {
      [`& .${tabsClasses.scrollButtons}`]: {
        [theme2.breakpoints.down("sm")]: {
          display: "none"
        }
      }
    }
  }]
})));
const TabsScroller = styled("div", {
  name: "MuiTabs",
  slot: "Scroller",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.scroller, ownerState.fixed && styles2.fixed, ownerState.hideScrollbar && styles2.hideScrollbar, ownerState.scrollableX && styles2.scrollableX, ownerState.scrollableY && styles2.scrollableY];
  }
})({
  position: "relative",
  display: "inline-block",
  flex: "1 1 auto",
  whiteSpace: "nowrap",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.fixed,
    style: {
      overflowX: "hidden",
      width: "100%"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.hideScrollbar,
    style: {
      // Hide dimensionless scrollbar on macOS
      scrollbarWidth: "none",
      // Firefox
      "&::-webkit-scrollbar": {
        display: "none"
        // Safari + Chrome
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.scrollableX,
    style: {
      overflowX: "auto",
      overflowY: "hidden"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.scrollableY,
    style: {
      overflowY: "auto",
      overflowX: "hidden"
    }
  }]
});
const List = styled("div", {
  name: "MuiTabs",
  slot: "List",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.list, styles2.flexContainer, ownerState.vertical && styles2.flexContainerVertical, ownerState.centered && styles2.centered];
  }
})({
  display: "flex",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.vertical,
    style: {
      flexDirection: "column"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.centered,
    style: {
      justifyContent: "center"
    }
  }]
});
const TabsIndicator = styled("span", {
  name: "MuiTabs",
  slot: "Indicator"
})(memoTheme(({
  theme: theme2
}) => ({
  position: "absolute",
  height: 2,
  bottom: 0,
  width: "100%",
  transition: theme2.transitions.create(),
  variants: [{
    props: {
      indicatorColor: "primary"
    },
    style: {
      backgroundColor: (theme2.vars || theme2).palette.primary.main
    }
  }, {
    props: {
      indicatorColor: "secondary"
    },
    style: {
      backgroundColor: (theme2.vars || theme2).palette.secondary.main
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.vertical,
    style: {
      height: "100%",
      width: 2,
      right: 0
    }
  }]
})));
const TabsScrollbarSize = styled(ScrollbarSize)({
  overflowX: "auto",
  overflowY: "hidden",
  // Hide dimensionless scrollbar on macOS
  scrollbarWidth: "none",
  // Firefox
  "&::-webkit-scrollbar": {
    display: "none"
    // Safari + Chrome
  }
});
const defaultIndicatorStyle = {};
const Tabs = /* @__PURE__ */ React$b.forwardRef(function Tabs2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTabs"
  });
  const theme2 = useTheme();
  const isRtl = useRtl();
  const _a2 = props, {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    action,
    centered = false,
    children: childrenProp,
    className,
    component = "div",
    allowScrollButtonsMobile = false,
    indicatorColor = "primary",
    onChange,
    orientation = "horizontal",
    ScrollButtonComponent,
    scrollButtons: scrollButtons = "auto",
    selectionFollowsFocus,
    slots = {},
    slotProps = {},
    TabIndicatorProps = {},
    TabScrollButtonProps: TabScrollButtonProps = {},
    textColor: textColor = "primary",
    value,
    variant = "standard",
    visibleScrollbar = false
  } = _a2, other = __objRest(_a2, [
    "aria-label",
    "aria-labelledby",
    "action",
    "centered",
    "children",
    "className",
    "component",
    "allowScrollButtonsMobile",
    "indicatorColor",
    "onChange",
    "orientation",
    "ScrollButtonComponent",
    // TODO: remove in v7 (deprecated in v6)
    "scrollButtons",
    "selectionFollowsFocus",
    "slots",
    "slotProps",
    "TabIndicatorProps",
    // TODO: remove in v7 (deprecated in v6)
    "TabScrollButtonProps",
    // TODO: remove in v7 (deprecated in v6)
    "textColor",
    "value",
    "variant",
    "visibleScrollbar"
  ]);
  const scrollable = variant === "scrollable";
  const vertical = orientation === "vertical";
  const scrollStart = vertical ? "scrollTop" : "scrollLeft";
  const start2 = vertical ? "top" : "left";
  const end2 = vertical ? "bottom" : "right";
  const clientSize = vertical ? "clientHeight" : "clientWidth";
  const size = vertical ? "height" : "width";
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component,
    allowScrollButtonsMobile,
    indicatorColor,
    orientation,
    vertical,
    scrollButtons,
    textColor,
    variant,
    visibleScrollbar,
    fixed: !scrollable,
    hideScrollbar: scrollable && !visibleScrollbar,
    scrollableX: scrollable && !vertical,
    scrollableY: scrollable && vertical,
    centered: centered && !scrollable,
    scrollButtonsHideMobile: !allowScrollButtonsMobile
  });
  const classes = useUtilityClasses$1(ownerState);
  const startScrollButtonIconProps = useSlotProps({
    elementType: slots.StartScrollButtonIcon,
    externalSlotProps: slotProps.startScrollButtonIcon,
    ownerState
  });
  const endScrollButtonIconProps = useSlotProps({
    elementType: slots.EndScrollButtonIcon,
    externalSlotProps: slotProps.endScrollButtonIcon,
    ownerState
  });
  const [mounted, setMounted] = React$b.useState(false);
  const [indicatorStyle, setIndicatorStyle] = React$b.useState(defaultIndicatorStyle);
  const [displayStartScroll, setDisplayStartScroll] = React$b.useState(false);
  const [displayEndScroll, setDisplayEndScroll] = React$b.useState(false);
  const [updateScrollObserver, setUpdateScrollObserver] = React$b.useState(false);
  const [scrollerStyle, setScrollerStyle] = React$b.useState({
    overflow: "hidden",
    scrollbarWidth: 0
  });
  const valueToIndex = /* @__PURE__ */ new Map();
  const tabsRef = React$b.useRef(null);
  const tabListRef = React$b.useRef(null);
  const externalForwardedProps = {
    slots,
    slotProps: __spreadValues({
      indicator: TabIndicatorProps,
      scrollButton: TabScrollButtonProps
    }, slotProps)
  };
  const getTabsMeta = () => {
    const tabsNode = tabsRef.current;
    let tabsMeta;
    if (tabsNode) {
      const rect = tabsNode.getBoundingClientRect();
      tabsMeta = {
        clientWidth: tabsNode.clientWidth,
        scrollLeft: tabsNode.scrollLeft,
        scrollTop: tabsNode.scrollTop,
        scrollWidth: tabsNode.scrollWidth,
        top: rect.top,
        bottom: rect.bottom,
        left: rect.left,
        right: rect.right
      };
    }
    let tabMeta;
    if (tabsNode && value !== false) {
      const children2 = tabListRef.current.children;
      if (children2.length > 0) {
        const tab = children2[valueToIndex.get(value)];
        tabMeta = tab ? tab.getBoundingClientRect() : null;
      }
    }
    return {
      tabsMeta,
      tabMeta
    };
  };
  const updateIndicatorState = useEventCallback(() => {
    const {
      tabsMeta,
      tabMeta
    } = getTabsMeta();
    let startValue = 0;
    let startIndicator;
    if (vertical) {
      startIndicator = "top";
      if (tabMeta && tabsMeta) {
        startValue = tabMeta.top - tabsMeta.top + tabsMeta.scrollTop;
      }
    } else {
      startIndicator = isRtl ? "right" : "left";
      if (tabMeta && tabsMeta) {
        startValue = (isRtl ? -1 : 1) * (tabMeta[startIndicator] - tabsMeta[startIndicator] + tabsMeta.scrollLeft);
      }
    }
    const newIndicatorStyle = {
      [startIndicator]: startValue,
      // May be wrong until the font is loaded.
      [size]: tabMeta ? tabMeta[size] : 0
    };
    if (typeof indicatorStyle[startIndicator] !== "number" || typeof indicatorStyle[size] !== "number") {
      setIndicatorStyle(newIndicatorStyle);
    } else {
      const dStart = Math.abs(indicatorStyle[startIndicator] - newIndicatorStyle[startIndicator]);
      const dSize = Math.abs(indicatorStyle[size] - newIndicatorStyle[size]);
      if (dStart >= 1 || dSize >= 1) {
        setIndicatorStyle(newIndicatorStyle);
      }
    }
  });
  const scroll = (scrollValue, {
    animation = true
  } = {}) => {
    if (animation) {
      animate(scrollStart, tabsRef.current, scrollValue, {
        duration: theme2.transitions.duration.standard
      });
    } else {
      tabsRef.current[scrollStart] = scrollValue;
    }
  };
  const moveTabsScroll = (delta) => {
    let scrollValue = tabsRef.current[scrollStart];
    if (vertical) {
      scrollValue += delta;
    } else {
      scrollValue += delta * (isRtl ? -1 : 1);
    }
    scroll(scrollValue);
  };
  const getScrollSize = () => {
    const containerSize = tabsRef.current[clientSize];
    let totalSize = 0;
    const children2 = Array.from(tabListRef.current.children);
    for (let i = 0; i < children2.length; i += 1) {
      const tab = children2[i];
      if (totalSize + tab[clientSize] > containerSize) {
        if (i === 0) {
          totalSize = containerSize;
        }
        break;
      }
      totalSize += tab[clientSize];
    }
    return totalSize;
  };
  const handleStartScrollClick = () => {
    moveTabsScroll(-1 * getScrollSize());
  };
  const handleEndScrollClick = () => {
    moveTabsScroll(getScrollSize());
  };
  const [ScrollbarSlot, _b] = useSlot("scrollbar", {
    className: clsx(classes.scrollableX, classes.hideScrollbar),
    elementType: TabsScrollbarSize,
    shouldForwardComponentProp: true,
    externalForwardedProps,
    ownerState
  }), _c = _b, {
    onChange: scrollbarOnChange
  } = _c, scrollbarSlotProps = __objRest(_c, [
    "onChange"
  ]);
  const handleScrollbarSizeChange = React$b.useCallback((scrollbarWidth) => {
    scrollbarOnChange == null ? void 0 : scrollbarOnChange(scrollbarWidth);
    setScrollerStyle({
      overflow: null,
      scrollbarWidth
    });
  }, [scrollbarOnChange]);
  const [ScrollButtonsSlot, scrollButtonSlotProps] = useSlot("scrollButtons", {
    className: clsx(classes.scrollButtons, TabScrollButtonProps.className),
    elementType: TabScrollButton,
    externalForwardedProps,
    ownerState,
    additionalProps: {
      orientation,
      slots: {
        StartScrollButtonIcon: slots.startScrollButtonIcon || slots.StartScrollButtonIcon,
        EndScrollButtonIcon: slots.endScrollButtonIcon || slots.EndScrollButtonIcon
      },
      slotProps: {
        startScrollButtonIcon: startScrollButtonIconProps,
        endScrollButtonIcon: endScrollButtonIconProps
      }
    }
  });
  const getConditionalElements = () => {
    const conditionalElements2 = {};
    conditionalElements2.scrollbarSizeListener = scrollable ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollbarSlot, __spreadProps(__spreadValues({}, scrollbarSlotProps), {
      onChange: handleScrollbarSizeChange
    })) : null;
    const scrollButtonsActive = displayStartScroll || displayEndScroll;
    const showScrollButtons = scrollable && (scrollButtons === "auto" && scrollButtonsActive || scrollButtons === true);
    conditionalElements2.scrollButtonStart = showScrollButtons ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollButtonsSlot, __spreadValues({
      direction: isRtl ? "right" : "left",
      onClick: handleStartScrollClick,
      disabled: !displayStartScroll
    }, scrollButtonSlotProps)) : null;
    conditionalElements2.scrollButtonEnd = showScrollButtons ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollButtonsSlot, __spreadValues({
      direction: isRtl ? "left" : "right",
      onClick: handleEndScrollClick,
      disabled: !displayEndScroll
    }, scrollButtonSlotProps)) : null;
    return conditionalElements2;
  };
  const scrollSelectedIntoView = useEventCallback((animation) => {
    const {
      tabsMeta,
      tabMeta
    } = getTabsMeta();
    if (!tabMeta || !tabsMeta) {
      return;
    }
    if (tabMeta[start2] < tabsMeta[start2]) {
      const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[start2] - tabsMeta[start2]);
      scroll(nextScrollStart, {
        animation
      });
    } else if (tabMeta[end2] > tabsMeta[end2]) {
      const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[end2] - tabsMeta[end2]);
      scroll(nextScrollStart, {
        animation
      });
    }
  });
  const updateScrollButtonState = useEventCallback(() => {
    if (scrollable && scrollButtons !== false) {
      setUpdateScrollObserver(!updateScrollObserver);
    }
  });
  React$b.useEffect(() => {
    const handleResize = debounce$1(() => {
      if (tabsRef.current) {
        updateIndicatorState();
      }
    });
    let resizeObserver;
    const handleMutation = (records) => {
      records.forEach((record) => {
        record.removedNodes.forEach((item) => {
          resizeObserver == null ? void 0 : resizeObserver.unobserve(item);
        });
        record.addedNodes.forEach((item) => {
          resizeObserver == null ? void 0 : resizeObserver.observe(item);
        });
      });
      handleResize();
      updateScrollButtonState();
    };
    const win = ownerWindow(tabsRef.current);
    win.addEventListener("resize", handleResize);
    let mutationObserver;
    if (typeof ResizeObserver !== "undefined") {
      resizeObserver = new ResizeObserver(handleResize);
      Array.from(tabListRef.current.children).forEach((child) => {
        resizeObserver.observe(child);
      });
    }
    if (typeof MutationObserver !== "undefined") {
      mutationObserver = new MutationObserver(handleMutation);
      mutationObserver.observe(tabListRef.current, {
        childList: true
      });
    }
    return () => {
      handleResize.clear();
      win.removeEventListener("resize", handleResize);
      mutationObserver == null ? void 0 : mutationObserver.disconnect();
      resizeObserver == null ? void 0 : resizeObserver.disconnect();
    };
  }, [updateIndicatorState, updateScrollButtonState]);
  React$b.useEffect(() => {
    const tabListChildren = Array.from(tabListRef.current.children);
    const length2 = tabListChildren.length;
    if (typeof IntersectionObserver !== "undefined" && length2 > 0 && scrollable && scrollButtons !== false) {
      const firstTab = tabListChildren[0];
      const lastTab = tabListChildren[length2 - 1];
      const observerOptions = {
        root: tabsRef.current,
        threshold: 0.99
      };
      const handleScrollButtonStart = (entries) => {
        setDisplayStartScroll(!entries[0].isIntersecting);
      };
      const firstObserver = new IntersectionObserver(handleScrollButtonStart, observerOptions);
      firstObserver.observe(firstTab);
      const handleScrollButtonEnd = (entries) => {
        setDisplayEndScroll(!entries[0].isIntersecting);
      };
      const lastObserver = new IntersectionObserver(handleScrollButtonEnd, observerOptions);
      lastObserver.observe(lastTab);
      return () => {
        firstObserver.disconnect();
        lastObserver.disconnect();
      };
    }
    return void 0;
  }, [scrollable, scrollButtons, updateScrollObserver, childrenProp == null ? void 0 : childrenProp.length]);
  React$b.useEffect(() => {
    setMounted(true);
  }, []);
  React$b.useEffect(() => {
    updateIndicatorState();
  });
  React$b.useEffect(() => {
    scrollSelectedIntoView(defaultIndicatorStyle !== indicatorStyle);
  }, [scrollSelectedIntoView, indicatorStyle]);
  React$b.useImperativeHandle(action, () => ({
    updateIndicator: updateIndicatorState,
    updateScrollButtons: updateScrollButtonState
  }), [updateIndicatorState, updateScrollButtonState]);
  const [IndicatorSlot, indicatorSlotProps] = useSlot("indicator", {
    className: clsx(classes.indicator, TabIndicatorProps.className),
    elementType: TabsIndicator,
    externalForwardedProps,
    ownerState,
    additionalProps: {
      style: indicatorStyle
    }
  });
  const indicator = /* @__PURE__ */ jsxRuntimeExports.jsx(IndicatorSlot, __spreadValues({}, indicatorSlotProps));
  let childIndex = 0;
  const children = React$b.Children.map(childrenProp, (child) => {
    if (!/* @__PURE__ */ React$b.isValidElement(child)) {
      return null;
    }
    const childValue = child.props.value === void 0 ? childIndex : child.props.value;
    valueToIndex.set(childValue, childIndex);
    const selected = childValue === value;
    childIndex += 1;
    return /* @__PURE__ */ React$b.cloneElement(child, __spreadValues({
      fullWidth: variant === "fullWidth",
      indicator: selected && !mounted && indicator,
      selected,
      selectionFollowsFocus,
      onChange,
      textColor,
      value: childValue
    }, childIndex === 1 && value === false && !child.props.tabIndex ? {
      tabIndex: 0
    } : {}));
  });
  const handleKeyDown = (event) => {
    if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {
      return;
    }
    const list = tabListRef.current;
    const currentFocus = ownerDocument(list).activeElement;
    const role = currentFocus.getAttribute("role");
    if (role !== "tab") {
      return;
    }
    let previousItemKey = orientation === "horizontal" ? "ArrowLeft" : "ArrowUp";
    let nextItemKey = orientation === "horizontal" ? "ArrowRight" : "ArrowDown";
    if (orientation === "horizontal" && isRtl) {
      previousItemKey = "ArrowRight";
      nextItemKey = "ArrowLeft";
    }
    switch (event.key) {
      case previousItemKey:
        event.preventDefault();
        moveFocus(list, currentFocus, previousItem);
        break;
      case nextItemKey:
        event.preventDefault();
        moveFocus(list, currentFocus, nextItem);
        break;
      case "Home":
        event.preventDefault();
        moveFocus(list, null, nextItem);
        break;
      case "End":
        event.preventDefault();
        moveFocus(list, null, previousItem);
        break;
    }
  };
  const conditionalElements = getConditionalElements();
  const [RootSlot, rootSlotProps] = useSlot("root", {
    ref,
    className: clsx(classes.root, className),
    elementType: TabsRoot,
    externalForwardedProps: __spreadProps(__spreadValues(__spreadValues({}, externalForwardedProps), other), {
      component
    }),
    ownerState
  });
  const [ScrollerSlot, scrollerSlotProps] = useSlot("scroller", {
    ref: tabsRef,
    className: classes.scroller,
    elementType: TabsScroller,
    externalForwardedProps,
    ownerState,
    additionalProps: {
      style: {
        overflow: scrollerStyle.overflow,
        [vertical ? `margin${isRtl ? "Left" : "Right"}` : "marginBottom"]: visibleScrollbar ? void 0 : -scrollerStyle.scrollbarWidth
      }
    }
  });
  const [ListSlot, listSlotProps] = useSlot("list", {
    ref: tabListRef,
    className: clsx(classes.list, classes.flexContainer),
    elementType: List,
    externalForwardedProps,
    ownerState,
    getSlotProps: (handlers) => __spreadProps(__spreadValues({}, handlers), {
      onKeyDown: (event) => {
        var _a3;
        handleKeyDown(event);
        (_a3 = handlers.onKeyDown) == null ? void 0 : _a3.call(handlers, event);
      }
    })
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, __spreadProps(__spreadValues({}, rootSlotProps), {
    children: [conditionalElements.scrollButtonStart, conditionalElements.scrollbarSizeListener, /* @__PURE__ */ jsxRuntimeExports.jsxs(ScrollerSlot, __spreadProps(__spreadValues({}, scrollerSlotProps), {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ListSlot, __spreadProps(__spreadValues({
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-orientation": orientation === "vertical" ? "vertical" : null,
        role: "tablist"
      }, listSlotProps), {
        children
      })), mounted && indicator]
    })), conditionalElements.scrollButtonEnd]
  }));
});
function getTextFieldUtilityClass(slot) {
  return generateUtilityClass("MuiTextField", slot);
}
generateUtilityClasses("MuiTextField", ["root"]);
const React$a = window["React"];
const variantComponent = {
  standard: Input,
  filled: FilledInput,
  outlined: OutlinedInput
};
const useUtilityClasses = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTextFieldUtilityClass, classes);
};
const TextFieldRoot = styled(FormControl, {
  name: "MuiTextField",
  slot: "Root"
})({});
const TextField = /* @__PURE__ */ React$a.forwardRef(function TextField2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTextField"
  });
  const _a2 = props, {
    autoComplete,
    autoFocus = false,
    children,
    className,
    color: color2 = "primary",
    defaultValue,
    disabled = false,
    error = false,
    FormHelperTextProps: FormHelperTextPropsProp,
    fullWidth = false,
    helperText,
    id: idOverride,
    InputLabelProps: InputLabelPropsProp,
    inputProps: inputPropsProp,
    InputProps: InputPropsProp,
    inputRef,
    label,
    maxRows,
    minRows,
    multiline = false,
    name: name2,
    onBlur,
    onChange,
    onFocus,
    placeholder,
    required = false,
    rows,
    select = false,
    SelectProps: SelectPropsProp,
    slots = {},
    slotProps = {},
    type,
    value,
    variant = "outlined"
  } = _a2, other = __objRest(_a2, [
    "autoComplete",
    "autoFocus",
    "children",
    "className",
    "color",
    "defaultValue",
    "disabled",
    "error",
    "FormHelperTextProps",
    "fullWidth",
    "helperText",
    "id",
    "InputLabelProps",
    "inputProps",
    "InputProps",
    "inputRef",
    "label",
    "maxRows",
    "minRows",
    "multiline",
    "name",
    "onBlur",
    "onChange",
    "onFocus",
    "placeholder",
    "required",
    "rows",
    "select",
    "SelectProps",
    "slots",
    "slotProps",
    "type",
    "value",
    "variant"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    autoFocus,
    color: color2,
    disabled,
    error,
    fullWidth,
    multiline,
    required,
    select,
    variant
  });
  const classes = useUtilityClasses(ownerState);
  const id = useId(idOverride);
  const helperTextId = helperText && id ? `${id}-helper-text` : void 0;
  const inputLabelId = label && id ? `${id}-label` : void 0;
  const InputComponent = variantComponent[variant];
  const externalForwardedProps = {
    slots,
    slotProps: __spreadValues({
      input: InputPropsProp,
      inputLabel: InputLabelPropsProp,
      htmlInput: inputPropsProp,
      formHelperText: FormHelperTextPropsProp,
      select: SelectPropsProp
    }, slotProps)
  };
  const inputAdditionalProps = {};
  const inputLabelSlotProps = externalForwardedProps.slotProps.inputLabel;
  if (variant === "outlined") {
    if (inputLabelSlotProps && typeof inputLabelSlotProps.shrink !== "undefined") {
      inputAdditionalProps.notched = inputLabelSlotProps.shrink;
    }
    inputAdditionalProps.label = label;
  }
  if (select) {
    if (!SelectPropsProp || !SelectPropsProp.native) {
      inputAdditionalProps.id = void 0;
    }
    inputAdditionalProps["aria-describedby"] = void 0;
  }
  const [RootSlot, rootProps] = useSlot("root", {
    elementType: TextFieldRoot,
    shouldForwardComponentProp: true,
    externalForwardedProps: __spreadValues(__spreadValues({}, externalForwardedProps), other),
    ownerState,
    className: clsx(classes.root, className),
    ref,
    additionalProps: {
      disabled,
      error,
      fullWidth,
      required,
      color: color2,
      variant
    }
  });
  const [InputSlot, inputProps] = useSlot("input", {
    elementType: InputComponent,
    externalForwardedProps,
    additionalProps: inputAdditionalProps,
    ownerState
  });
  const [InputLabelSlot, inputLabelProps] = useSlot("inputLabel", {
    elementType: InputLabel,
    externalForwardedProps,
    ownerState
  });
  const [HtmlInputSlot, htmlInputProps] = useSlot("htmlInput", {
    elementType: "input",
    externalForwardedProps,
    ownerState
  });
  const [FormHelperTextSlot, formHelperTextProps] = useSlot("formHelperText", {
    elementType: FormHelperText,
    externalForwardedProps,
    ownerState
  });
  const [SelectSlot, selectProps] = useSlot("select", {
    elementType: Select,
    externalForwardedProps,
    ownerState
  });
  const InputElement = /* @__PURE__ */ jsxRuntimeExports.jsx(InputSlot, __spreadValues({
    "aria-describedby": helperTextId,
    autoComplete,
    autoFocus,
    defaultValue,
    fullWidth,
    multiline,
    name: name2,
    rows,
    maxRows,
    minRows,
    type,
    value,
    id,
    inputRef,
    onBlur,
    onChange,
    onFocus,
    placeholder,
    inputProps: htmlInputProps,
    slots: {
      input: slots.htmlInput ? HtmlInputSlot : void 0
    }
  }, inputProps));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, __spreadProps(__spreadValues({}, rootProps), {
    children: [label != null && label !== "" && /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabelSlot, __spreadProps(__spreadValues({
      htmlFor: id,
      id: inputLabelId
    }, inputLabelProps), {
      children: label
    })), select ? /* @__PURE__ */ jsxRuntimeExports.jsx(SelectSlot, __spreadProps(__spreadValues({
      "aria-describedby": helperTextId,
      id,
      labelId: inputLabelId,
      value,
      input: InputElement
    }, selectProps), {
      children
    })) : InputElement, helperText && /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperTextSlot, __spreadProps(__spreadValues({
      id: helperTextId
    }, formHelperTextProps), {
      children: helperText
    }))]
  }));
});
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;
  return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name2, prefix2) {
  if (typeof name2 === "symbol") name2 = name2.description ? "[".concat(name2.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix2 ? "".concat(prefix2, " ", name2) : name2 });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body2) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body2.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
});
function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r2, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done) ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r2 = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r2[k] = a[j];
  return r2;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++) {
    if (ar || !(i in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
      ar[i] = from2[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};
var ownKeys = function(o) {
  ownKeys = Object.getOwnPropertyNames || function(o2) {
    var ar = [];
    for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
    return ar;
  };
  return ownKeys(o);
};
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r2, s = 0;
  function next2() {
    while (r2 = env.stack.pop()) {
      try {
        if (!r2.async && s === 1) return s = 0, env.stack.push(r2), Promise.resolve().then(next2);
        if (r2.dispose) {
          var result = r2.dispose.call(r2.value);
          if (r2.async) return s |= 2, Promise.resolve(result).then(next2, function(e) {
            fail(e);
            return next2();
          });
        } else s |= 1;
      } catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next2();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
    return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
      return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
    });
  }
  return path;
}
const tslib_es6 = {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension
};
const tslib_es6$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  __addDisposableResource,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldIn,
  __classPrivateFieldSet,
  __createBinding,
  __decorate,
  __disposeResources,
  __esDecorate,
  __exportStar,
  __extends,
  __generator,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __propKey,
  __read,
  __rest,
  __rewriteRelativeImportExtension,
  __runInitializers,
  __setFunctionName,
  __spread,
  __spreadArray,
  __spreadArrays,
  __values,
  default: tslib_es6
}, Symbol.toStringTag, { value: "Module" }));
const scriptRel = "modulepreload";
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    let allSettled = function(promises$2) {
      return Promise.all(promises$2.map((p) => Promise.resolve(p).then((value$1) => ({
        status: "fulfilled",
        value: value$1
      }), (reason) => ({
        status: "rejected",
        reason
      }))));
    };
    const links = document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
    const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
    promise = allSettled(deps.map((dep) => {
      dep = assetsURL(dep, importerUrl);
      if (dep in seen) return;
      seen[dep] = true;
      const isCss = dep.endsWith(".css");
      const cssSelector = isCss ? '[rel="stylesheet"]' : "";
      if (!!importerUrl) for (let i$1 = links.length - 1; i$1 >= 0; i$1--) {
        const link$1 = links[i$1];
        if (link$1.href === dep && (!isCss || link$1.rel === "stylesheet")) return;
      }
      else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) return;
      const link = document.createElement("link");
      link.rel = isCss ? "stylesheet" : scriptRel;
      if (!isCss) link.as = "script";
      link.crossOrigin = "";
      link.href = dep;
      if (cspNonce) link.setAttribute("nonce", cspNonce);
      document.head.appendChild(link);
      if (isCss) return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(/* @__PURE__ */ new Error(`Unable to preload CSS for ${dep}`)));
      });
    }));
  }
  function handlePreloadError(err$2) {
    const e$1 = new Event("vite:preloadError", { cancelable: true });
    e$1.payload = err$2;
    window.dispatchEvent(e$1);
    if (!e$1.defaultPrevented) throw err$2;
  }
  return promise.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
const resolveFetch$4 = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = (...args) => __vitePreload(() => __async(null, null, function* () {
      const { default: fetch2 } = yield Promise.resolve().then(() => browser);
      return { default: fetch2 };
    }), true ? [] : void 0, import.meta.url).then(({ default: fetch2 }) => fetch2(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
class FunctionsError extends Error {
  constructor(message, name2 = "FunctionsError", context) {
    super(message);
    this.name = name2;
    this.context = context;
  }
}
class FunctionsFetchError extends FunctionsError {
  constructor(context) {
    super("Failed to send a request to the Edge Function", "FunctionsFetchError", context);
  }
}
class FunctionsRelayError extends FunctionsError {
  constructor(context) {
    super("Relay Error invoking the Edge Function", "FunctionsRelayError", context);
  }
}
class FunctionsHttpError extends FunctionsError {
  constructor(context) {
    super("Edge Function returned a non-2xx status code", "FunctionsHttpError", context);
  }
}
var FunctionRegion;
(function(FunctionRegion2) {
  FunctionRegion2["Any"] = "any";
  FunctionRegion2["ApNortheast1"] = "ap-northeast-1";
  FunctionRegion2["ApNortheast2"] = "ap-northeast-2";
  FunctionRegion2["ApSouth1"] = "ap-south-1";
  FunctionRegion2["ApSoutheast1"] = "ap-southeast-1";
  FunctionRegion2["ApSoutheast2"] = "ap-southeast-2";
  FunctionRegion2["CaCentral1"] = "ca-central-1";
  FunctionRegion2["EuCentral1"] = "eu-central-1";
  FunctionRegion2["EuWest1"] = "eu-west-1";
  FunctionRegion2["EuWest2"] = "eu-west-2";
  FunctionRegion2["EuWest3"] = "eu-west-3";
  FunctionRegion2["SaEast1"] = "sa-east-1";
  FunctionRegion2["UsEast1"] = "us-east-1";
  FunctionRegion2["UsWest1"] = "us-west-1";
  FunctionRegion2["UsWest2"] = "us-west-2";
})(FunctionRegion || (FunctionRegion = {}));
class FunctionsClient {
  constructor(url, { headers = {}, customFetch, region = FunctionRegion.Any } = {}) {
    this.url = url;
    this.headers = headers;
    this.region = region;
    this.fetch = resolveFetch$4(customFetch);
  }
  /**
   * Updates the authorization header
   * @param token - the new jwt token sent in the authorisation header
   */
  setAuth(token2) {
    this.headers.Authorization = `Bearer ${token2}`;
  }
  /**
   * Invokes a function
   * @param functionName - The name of the Function to invoke.
   * @param options - Options for invoking the Function.
   */
  invoke(functionName_1) {
    return __awaiter(this, arguments, void 0, function* (functionName, options = {}) {
      var _a2;
      try {
        const { headers, method, body: functionArgs, signal } = options;
        let _headers = {};
        let { region } = options;
        if (!region) {
          region = this.region;
        }
        const url = new URL(`${this.url}/${functionName}`);
        if (region && region !== "any") {
          _headers["x-region"] = region;
          url.searchParams.set("forceFunctionRegion", region);
        }
        let body2;
        if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, "Content-Type") || !headers)) {
          if (typeof Blob !== "undefined" && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {
            _headers["Content-Type"] = "application/octet-stream";
            body2 = functionArgs;
          } else if (typeof functionArgs === "string") {
            _headers["Content-Type"] = "text/plain";
            body2 = functionArgs;
          } else if (typeof FormData !== "undefined" && functionArgs instanceof FormData) {
            body2 = functionArgs;
          } else {
            _headers["Content-Type"] = "application/json";
            body2 = JSON.stringify(functionArgs);
          }
        } else {
          body2 = functionArgs;
        }
        const response = yield this.fetch(url.toString(), {
          method: method || "POST",
          // headers priority is (high to low):
          // 1. invoke-level headers
          // 2. client-level headers
          // 3. default Content-Type header
          headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),
          body: body2,
          signal
        }).catch((fetchError) => {
          if (fetchError.name === "AbortError") {
            throw fetchError;
          }
          throw new FunctionsFetchError(fetchError);
        });
        const isRelayError = response.headers.get("x-relay-error");
        if (isRelayError && isRelayError === "true") {
          throw new FunctionsRelayError(response);
        }
        if (!response.ok) {
          throw new FunctionsHttpError(response);
        }
        let responseType = ((_a2 = response.headers.get("Content-Type")) !== null && _a2 !== void 0 ? _a2 : "text/plain").split(";")[0].trim();
        let data;
        if (responseType === "application/json") {
          data = yield response.json();
        } else if (responseType === "application/octet-stream" || responseType === "application/pdf") {
          data = yield response.blob();
        } else if (responseType === "text/event-stream") {
          data = response;
        } else if (responseType === "multipart/form-data") {
          data = yield response.formData();
        } else {
          data = yield response.text();
        }
        return { data, error: null, response };
      } catch (error) {
        if (error instanceof Error && error.name === "AbortError") {
          return { data: null, error: new FunctionsFetchError(error) };
        }
        return {
          data: null,
          error,
          response: error instanceof FunctionsHttpError || error instanceof FunctionsRelayError ? error.context : void 0
        };
      }
    });
  }
}
var cjs = {};
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6$1);
var PostgrestClient$1 = {};
var PostgrestQueryBuilder$1 = {};
var PostgrestFilterBuilder$1 = {};
var PostgrestTransformBuilder$1 = {};
var PostgrestBuilder$1 = {};
var getGlobal = function() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
};
var globalObject = getGlobal();
const fetch$1 = globalObject.fetch;
const nodeFetch = globalObject.fetch.bind(globalObject);
const Headers$1 = globalObject.Headers;
const Request = globalObject.Request;
const Response$1 = globalObject.Response;
const browser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Headers: Headers$1,
  Request,
  Response: Response$1,
  default: nodeFetch,
  fetch: fetch$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(browser);
var PostgrestError$1 = {};
var hasRequiredPostgrestError;
function requirePostgrestError() {
  if (hasRequiredPostgrestError) return PostgrestError$1;
  hasRequiredPostgrestError = 1;
  Object.defineProperty(PostgrestError$1, "__esModule", { value: true });
  class PostgrestError2 extends Error {
    constructor(context) {
      super(context.message);
      this.name = "PostgrestError";
      this.details = context.details;
      this.hint = context.hint;
      this.code = context.code;
    }
  }
  PostgrestError$1.default = PostgrestError2;
  return PostgrestError$1;
}
var hasRequiredPostgrestBuilder;
function requirePostgrestBuilder() {
  if (hasRequiredPostgrestBuilder) return PostgrestBuilder$1;
  hasRequiredPostgrestBuilder = 1;
  Object.defineProperty(PostgrestBuilder$1, "__esModule", { value: true });
  const tslib_1 = require$$0;
  const node_fetch_1 = tslib_1.__importDefault(require$$1);
  const PostgrestError_1 = tslib_1.__importDefault(requirePostgrestError());
  class PostgrestBuilder2 {
    constructor(builder) {
      var _a2, _b;
      this.shouldThrowOnError = false;
      this.method = builder.method;
      this.url = builder.url;
      this.headers = new Headers(builder.headers);
      this.schema = builder.schema;
      this.body = builder.body;
      this.shouldThrowOnError = (_a2 = builder.shouldThrowOnError) !== null && _a2 !== void 0 ? _a2 : false;
      this.signal = builder.signal;
      this.isMaybeSingle = (_b = builder.isMaybeSingle) !== null && _b !== void 0 ? _b : false;
      if (builder.fetch) {
        this.fetch = builder.fetch;
      } else if (typeof fetch === "undefined") {
        this.fetch = node_fetch_1.default;
      } else {
        this.fetch = fetch;
      }
    }
    /**
     * If there's an error with the query, throwOnError will reject the promise by
     * throwing the error instead of returning it as part of a successful response.
     *
     * {@link https://github.com/supabase/supabase-js/issues/92}
     */
    throwOnError() {
      this.shouldThrowOnError = true;
      return this;
    }
    /**
     * Set an HTTP header for the request.
     */
    setHeader(name2, value) {
      this.headers = new Headers(this.headers);
      this.headers.set(name2, value);
      return this;
    }
    then(onfulfilled, onrejected) {
      if (this.schema === void 0) ;
      else if (["GET", "HEAD"].includes(this.method)) {
        this.headers.set("Accept-Profile", this.schema);
      } else {
        this.headers.set("Content-Profile", this.schema);
      }
      if (this.method !== "GET" && this.method !== "HEAD") {
        this.headers.set("Content-Type", "application/json");
      }
      const _fetch = this.fetch;
      let res = _fetch(this.url.toString(), {
        method: this.method,
        headers: this.headers,
        body: JSON.stringify(this.body),
        signal: this.signal
      }).then((res2) => __async(this, null, function* () {
        var _a2, _b, _c, _d;
        let error = null;
        let data = null;
        let count = null;
        let status = res2.status;
        let statusText = res2.statusText;
        if (res2.ok) {
          if (this.method !== "HEAD") {
            const body2 = yield res2.text();
            if (body2 === "") ;
            else if (this.headers.get("Accept") === "text/csv") {
              data = body2;
            } else if (this.headers.get("Accept") && ((_a2 = this.headers.get("Accept")) === null || _a2 === void 0 ? void 0 : _a2.includes("application/vnd.pgrst.plan+text"))) {
              data = body2;
            } else {
              data = JSON.parse(body2);
            }
          }
          const countHeader = (_b = this.headers.get("Prefer")) === null || _b === void 0 ? void 0 : _b.match(/count=(exact|planned|estimated)/);
          const contentRange = (_c = res2.headers.get("content-range")) === null || _c === void 0 ? void 0 : _c.split("/");
          if (countHeader && contentRange && contentRange.length > 1) {
            count = parseInt(contentRange[1]);
          }
          if (this.isMaybeSingle && this.method === "GET" && Array.isArray(data)) {
            if (data.length > 1) {
              error = {
                // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553
                code: "PGRST116",
                details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,
                hint: null,
                message: "JSON object requested, multiple (or no) rows returned"
              };
              data = null;
              count = null;
              status = 406;
              statusText = "Not Acceptable";
            } else if (data.length === 1) {
              data = data[0];
            } else {
              data = null;
            }
          }
        } else {
          const body2 = yield res2.text();
          try {
            error = JSON.parse(body2);
            if (Array.isArray(error) && res2.status === 404) {
              data = [];
              error = null;
              status = 200;
              statusText = "OK";
            }
          } catch (_e) {
            if (res2.status === 404 && body2 === "") {
              status = 204;
              statusText = "No Content";
            } else {
              error = {
                message: body2
              };
            }
          }
          if (error && this.isMaybeSingle && ((_d = error === null || error === void 0 ? void 0 : error.details) === null || _d === void 0 ? void 0 : _d.includes("0 rows"))) {
            error = null;
            status = 200;
            statusText = "OK";
          }
          if (error && this.shouldThrowOnError) {
            throw new PostgrestError_1.default(error);
          }
        }
        const postgrestResponse = {
          error,
          data,
          count,
          status,
          statusText
        };
        return postgrestResponse;
      }));
      if (!this.shouldThrowOnError) {
        res = res.catch((fetchError) => {
          var _a2, _b, _c;
          return {
            error: {
              message: `${(_a2 = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _a2 !== void 0 ? _a2 : "FetchError"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,
              details: `${(_b = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _b !== void 0 ? _b : ""}`,
              hint: "",
              code: `${(_c = fetchError === null || fetchError === void 0 ? void 0 : fetchError.code) !== null && _c !== void 0 ? _c : ""}`
            },
            data: null,
            count: null,
            status: 0,
            statusText: ""
          };
        });
      }
      return res.then(onfulfilled, onrejected);
    }
    /**
     * Override the type of the returned `data`.
     *
     * @typeParam NewResult - The new result type to override with
     * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead
     */
    returns() {
      return this;
    }
    /**
     * Override the type of the returned `data` field in the response.
     *
     * @typeParam NewResult - The new type to cast the response data to
     * @typeParam Options - Optional type configuration (defaults to { merge: true })
     * @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)
     * @example
     * ```typescript
     * // Merge with existing types (default behavior)
     * const query = supabase
     *   .from('users')
     *   .select()
     *   .overrideTypes<{ custom_field: string }>()
     *
     * // Replace existing types completely
     * const replaceQuery = supabase
     *   .from('users')
     *   .select()
     *   .overrideTypes<{ id: number; name: string }, { merge: false }>()
     * ```
     * @returns A PostgrestBuilder instance with the new type
     */
    overrideTypes() {
      return this;
    }
  }
  PostgrestBuilder$1.default = PostgrestBuilder2;
  return PostgrestBuilder$1;
}
var hasRequiredPostgrestTransformBuilder;
function requirePostgrestTransformBuilder() {
  if (hasRequiredPostgrestTransformBuilder) return PostgrestTransformBuilder$1;
  hasRequiredPostgrestTransformBuilder = 1;
  Object.defineProperty(PostgrestTransformBuilder$1, "__esModule", { value: true });
  const tslib_1 = require$$0;
  const PostgrestBuilder_1 = tslib_1.__importDefault(requirePostgrestBuilder());
  class PostgrestTransformBuilder2 extends PostgrestBuilder_1.default {
    /**
     * Perform a SELECT on the query result.
     *
     * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not
     * return modified rows. By calling this method, modified rows are returned in
     * `data`.
     *
     * @param columns - The columns to retrieve, separated by commas
     */
    select(columns) {
      let quoted = false;
      const cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map((c) => {
        if (/\s/.test(c) && !quoted) {
          return "";
        }
        if (c === '"') {
          quoted = !quoted;
        }
        return c;
      }).join("");
      this.url.searchParams.set("select", cleanedColumns);
      this.headers.append("Prefer", "return=representation");
      return this;
    }
    /**
     * Order the query result by `column`.
     *
     * You can call this method multiple times to order by multiple columns.
     *
     * You can order referenced tables, but it only affects the ordering of the
     * parent table if you use `!inner` in the query.
     *
     * @param column - The column to order by
     * @param options - Named parameters
     * @param options.ascending - If `true`, the result will be in ascending order
     * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,
     * `null`s appear last.
     * @param options.referencedTable - Set this to order a referenced table by
     * its columns
     * @param options.foreignTable - Deprecated, use `options.referencedTable`
     * instead
     */
    order(column2, { ascending = true, nullsFirst, foreignTable, referencedTable = foreignTable } = {}) {
      const key = referencedTable ? `${referencedTable}.order` : "order";
      const existingOrder = this.url.searchParams.get(key);
      this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : ""}${column2}.${ascending ? "asc" : "desc"}${nullsFirst === void 0 ? "" : nullsFirst ? ".nullsfirst" : ".nullslast"}`);
      return this;
    }
    /**
     * Limit the query result by `count`.
     *
     * @param count - The maximum number of rows to return
     * @param options - Named parameters
     * @param options.referencedTable - Set this to limit rows of referenced
     * tables instead of the parent table
     * @param options.foreignTable - Deprecated, use `options.referencedTable`
     * instead
     */
    limit(count, { foreignTable, referencedTable = foreignTable } = {}) {
      const key = typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`;
      this.url.searchParams.set(key, `${count}`);
      return this;
    }
    /**
     * Limit the query result by starting at an offset `from` and ending at the offset `to`.
     * Only records within this range are returned.
     * This respects the query order and if there is no order clause the range could behave unexpectedly.
     * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third
     * and fourth rows of the query.
     *
     * @param from - The starting index from which to limit the result
     * @param to - The last index to which to limit the result
     * @param options - Named parameters
     * @param options.referencedTable - Set this to limit rows of referenced
     * tables instead of the parent table
     * @param options.foreignTable - Deprecated, use `options.referencedTable`
     * instead
     */
    range(from2, to, { foreignTable, referencedTable = foreignTable } = {}) {
      const keyOffset = typeof referencedTable === "undefined" ? "offset" : `${referencedTable}.offset`;
      const keyLimit = typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`;
      this.url.searchParams.set(keyOffset, `${from2}`);
      this.url.searchParams.set(keyLimit, `${to - from2 + 1}`);
      return this;
    }
    /**
     * Set the AbortSignal for the fetch request.
     *
     * @param signal - The AbortSignal to use for the fetch request
     */
    abortSignal(signal) {
      this.signal = signal;
      return this;
    }
    /**
     * Return `data` as a single object instead of an array of objects.
     *
     * Query result must be one row (e.g. using `.limit(1)`), otherwise this
     * returns an error.
     */
    single() {
      this.headers.set("Accept", "application/vnd.pgrst.object+json");
      return this;
    }
    /**
     * Return `data` as a single object instead of an array of objects.
     *
     * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise
     * this returns an error.
     */
    maybeSingle() {
      if (this.method === "GET") {
        this.headers.set("Accept", "application/json");
      } else {
        this.headers.set("Accept", "application/vnd.pgrst.object+json");
      }
      this.isMaybeSingle = true;
      return this;
    }
    /**
     * Return `data` as a string in CSV format.
     */
    csv() {
      this.headers.set("Accept", "text/csv");
      return this;
    }
    /**
     * Return `data` as an object in [GeoJSON](https://geojson.org) format.
     */
    geojson() {
      this.headers.set("Accept", "application/geo+json");
      return this;
    }
    /**
     * Return `data` as the EXPLAIN plan for the query.
     *
     * You need to enable the
     * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)
     * setting before using this method.
     *
     * @param options - Named parameters
     *
     * @param options.analyze - If `true`, the query will be executed and the
     * actual run time will be returned
     *
     * @param options.verbose - If `true`, the query identifier will be returned
     * and `data` will include the output columns of the query
     *
     * @param options.settings - If `true`, include information on configuration
     * parameters that affect query planning
     *
     * @param options.buffers - If `true`, include information on buffer usage
     *
     * @param options.wal - If `true`, include information on WAL record generation
     *
     * @param options.format - The format of the output, can be `"text"` (default)
     * or `"json"`
     */
    explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = "text" } = {}) {
      var _a2;
      const options = [
        analyze ? "analyze" : null,
        verbose ? "verbose" : null,
        settings ? "settings" : null,
        buffers ? "buffers" : null,
        wal ? "wal" : null
      ].filter(Boolean).join("|");
      const forMediatype = (_a2 = this.headers.get("Accept")) !== null && _a2 !== void 0 ? _a2 : "application/json";
      this.headers.set("Accept", `application/vnd.pgrst.plan+${format}; for="${forMediatype}"; options=${options};`);
      if (format === "json") {
        return this;
      } else {
        return this;
      }
    }
    /**
     * Rollback the query.
     *
     * `data` will still be returned, but the query is not committed.
     */
    rollback() {
      this.headers.append("Prefer", "tx=rollback");
      return this;
    }
    /**
     * Override the type of the returned `data`.
     *
     * @typeParam NewResult - The new result type to override with
     * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead
     */
    returns() {
      return this;
    }
    /**
     * Set the maximum number of rows that can be affected by the query.
     * Only available in PostgREST v13+ and only works with PATCH and DELETE methods.
     *
     * @param value - The maximum number of rows that can be affected
     */
    maxAffected(value) {
      this.headers.append("Prefer", "handling=strict");
      this.headers.append("Prefer", `max-affected=${value}`);
      return this;
    }
  }
  PostgrestTransformBuilder$1.default = PostgrestTransformBuilder2;
  return PostgrestTransformBuilder$1;
}
var hasRequiredPostgrestFilterBuilder;
function requirePostgrestFilterBuilder() {
  if (hasRequiredPostgrestFilterBuilder) return PostgrestFilterBuilder$1;
  hasRequiredPostgrestFilterBuilder = 1;
  Object.defineProperty(PostgrestFilterBuilder$1, "__esModule", { value: true });
  const tslib_1 = require$$0;
  const PostgrestTransformBuilder_1 = tslib_1.__importDefault(requirePostgrestTransformBuilder());
  class PostgrestFilterBuilder2 extends PostgrestTransformBuilder_1.default {
    /**
     * Match only rows where `column` is equal to `value`.
     *
     * To check if the value of `column` is NULL, you should use `.is()` instead.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    eq(column2, value) {
      this.url.searchParams.append(column2, `eq.${value}`);
      return this;
    }
    /**
     * Match only rows where `column` is not equal to `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    neq(column2, value) {
      this.url.searchParams.append(column2, `neq.${value}`);
      return this;
    }
    /**
     * Match only rows where `column` is greater than `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    gt(column2, value) {
      this.url.searchParams.append(column2, `gt.${value}`);
      return this;
    }
    /**
     * Match only rows where `column` is greater than or equal to `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    gte(column2, value) {
      this.url.searchParams.append(column2, `gte.${value}`);
      return this;
    }
    /**
     * Match only rows where `column` is less than `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    lt(column2, value) {
      this.url.searchParams.append(column2, `lt.${value}`);
      return this;
    }
    /**
     * Match only rows where `column` is less than or equal to `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    lte(column2, value) {
      this.url.searchParams.append(column2, `lte.${value}`);
      return this;
    }
    /**
     * Match only rows where `column` matches `pattern` case-sensitively.
     *
     * @param column - The column to filter on
     * @param pattern - The pattern to match with
     */
    like(column2, pattern) {
      this.url.searchParams.append(column2, `like.${pattern}`);
      return this;
    }
    /**
     * Match only rows where `column` matches all of `patterns` case-sensitively.
     *
     * @param column - The column to filter on
     * @param patterns - The patterns to match with
     */
    likeAllOf(column2, patterns) {
      this.url.searchParams.append(column2, `like(all).{${patterns.join(",")}}`);
      return this;
    }
    /**
     * Match only rows where `column` matches any of `patterns` case-sensitively.
     *
     * @param column - The column to filter on
     * @param patterns - The patterns to match with
     */
    likeAnyOf(column2, patterns) {
      this.url.searchParams.append(column2, `like(any).{${patterns.join(",")}}`);
      return this;
    }
    /**
     * Match only rows where `column` matches `pattern` case-insensitively.
     *
     * @param column - The column to filter on
     * @param pattern - The pattern to match with
     */
    ilike(column2, pattern) {
      this.url.searchParams.append(column2, `ilike.${pattern}`);
      return this;
    }
    /**
     * Match only rows where `column` matches all of `patterns` case-insensitively.
     *
     * @param column - The column to filter on
     * @param patterns - The patterns to match with
     */
    ilikeAllOf(column2, patterns) {
      this.url.searchParams.append(column2, `ilike(all).{${patterns.join(",")}}`);
      return this;
    }
    /**
     * Match only rows where `column` matches any of `patterns` case-insensitively.
     *
     * @param column - The column to filter on
     * @param patterns - The patterns to match with
     */
    ilikeAnyOf(column2, patterns) {
      this.url.searchParams.append(column2, `ilike(any).{${patterns.join(",")}}`);
      return this;
    }
    /**
     * Match only rows where `column` IS `value`.
     *
     * For non-boolean columns, this is only relevant for checking if the value of
     * `column` is NULL by setting `value` to `null`.
     *
     * For boolean columns, you can also set `value` to `true` or `false` and it
     * will behave the same way as `.eq()`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    is(column2, value) {
      this.url.searchParams.append(column2, `is.${value}`);
      return this;
    }
    /**
     * Match only rows where `column` is included in the `values` array.
     *
     * @param column - The column to filter on
     * @param values - The values array to filter with
     */
    in(column2, values2) {
      const cleanedValues = Array.from(new Set(values2)).map((s) => {
        if (typeof s === "string" && new RegExp("[,()]").test(s))
          return `"${s}"`;
        else
          return `${s}`;
      }).join(",");
      this.url.searchParams.append(column2, `in.(${cleanedValues})`);
      return this;
    }
    /**
     * Only relevant for jsonb, array, and range columns. Match only rows where
     * `column` contains every element appearing in `value`.
     *
     * @param column - The jsonb, array, or range column to filter on
     * @param value - The jsonb, array, or range value to filter with
     */
    contains(column2, value) {
      if (typeof value === "string") {
        this.url.searchParams.append(column2, `cs.${value}`);
      } else if (Array.isArray(value)) {
        this.url.searchParams.append(column2, `cs.{${value.join(",")}}`);
      } else {
        this.url.searchParams.append(column2, `cs.${JSON.stringify(value)}`);
      }
      return this;
    }
    /**
     * Only relevant for jsonb, array, and range columns. Match only rows where
     * every element appearing in `column` is contained by `value`.
     *
     * @param column - The jsonb, array, or range column to filter on
     * @param value - The jsonb, array, or range value to filter with
     */
    containedBy(column2, value) {
      if (typeof value === "string") {
        this.url.searchParams.append(column2, `cd.${value}`);
      } else if (Array.isArray(value)) {
        this.url.searchParams.append(column2, `cd.{${value.join(",")}}`);
      } else {
        this.url.searchParams.append(column2, `cd.${JSON.stringify(value)}`);
      }
      return this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is greater than any element in `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */
    rangeGt(column2, range) {
      this.url.searchParams.append(column2, `sr.${range}`);
      return this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is either contained in `range` or greater than any element in
     * `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */
    rangeGte(column2, range) {
      this.url.searchParams.append(column2, `nxl.${range}`);
      return this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is less than any element in `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */
    rangeLt(column2, range) {
      this.url.searchParams.append(column2, `sl.${range}`);
      return this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is either contained in `range` or less than any element in
     * `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */
    rangeLte(column2, range) {
      this.url.searchParams.append(column2, `nxr.${range}`);
      return this;
    }
    /**
     * Only relevant for range columns. Match only rows where `column` is
     * mutually exclusive to `range` and there can be no element between the two
     * ranges.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */
    rangeAdjacent(column2, range) {
      this.url.searchParams.append(column2, `adj.${range}`);
      return this;
    }
    /**
     * Only relevant for array and range columns. Match only rows where
     * `column` and `value` have an element in common.
     *
     * @param column - The array or range column to filter on
     * @param value - The array or range value to filter with
     */
    overlaps(column2, value) {
      if (typeof value === "string") {
        this.url.searchParams.append(column2, `ov.${value}`);
      } else {
        this.url.searchParams.append(column2, `ov.{${value.join(",")}}`);
      }
      return this;
    }
    /**
     * Only relevant for text and tsvector columns. Match only rows where
     * `column` matches the query string in `query`.
     *
     * @param column - The text or tsvector column to filter on
     * @param query - The query text to match with
     * @param options - Named parameters
     * @param options.config - The text search configuration to use
     * @param options.type - Change how the `query` text is interpreted
     */
    textSearch(column2, query, { config: config2, type } = {}) {
      let typePart = "";
      if (type === "plain") {
        typePart = "pl";
      } else if (type === "phrase") {
        typePart = "ph";
      } else if (type === "websearch") {
        typePart = "w";
      }
      const configPart = config2 === void 0 ? "" : `(${config2})`;
      this.url.searchParams.append(column2, `${typePart}fts${configPart}.${query}`);
      return this;
    }
    /**
     * Match only rows where each column in `query` keys is equal to its
     * associated value. Shorthand for multiple `.eq()`s.
     *
     * @param query - The object to filter with, with column names as keys mapped
     * to their filter values
     */
    match(query) {
      Object.entries(query).forEach(([column2, value]) => {
        this.url.searchParams.append(column2, `eq.${value}`);
      });
      return this;
    }
    /**
     * Match only rows which doesn't satisfy the filter.
     *
     * Unlike most filters, `opearator` and `value` are used as-is and need to
     * follow [PostgREST
     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
     * to make sure they are properly sanitized.
     *
     * @param column - The column to filter on
     * @param operator - The operator to be negated to filter with, following
     * PostgREST syntax
     * @param value - The value to filter with, following PostgREST syntax
     */
    not(column2, operator, value) {
      this.url.searchParams.append(column2, `not.${operator}.${value}`);
      return this;
    }
    /**
     * Match only rows which satisfy at least one of the filters.
     *
     * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST
     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
     * to make sure it's properly sanitized.
     *
     * It's currently not possible to do an `.or()` filter across multiple tables.
     *
     * @param filters - The filters to use, following PostgREST syntax
     * @param options - Named parameters
     * @param options.referencedTable - Set this to filter on referenced tables
     * instead of the parent table
     * @param options.foreignTable - Deprecated, use `referencedTable` instead
     */
    or(filters, { foreignTable, referencedTable = foreignTable } = {}) {
      const key = referencedTable ? `${referencedTable}.or` : "or";
      this.url.searchParams.append(key, `(${filters})`);
      return this;
    }
    /**
     * Match only rows which satisfy the filter. This is an escape hatch - you
     * should use the specific filter methods wherever possible.
     *
     * Unlike most filters, `opearator` and `value` are used as-is and need to
     * follow [PostgREST
     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
     * to make sure they are properly sanitized.
     *
     * @param column - The column to filter on
     * @param operator - The operator to filter with, following PostgREST syntax
     * @param value - The value to filter with, following PostgREST syntax
     */
    filter(column2, operator, value) {
      this.url.searchParams.append(column2, `${operator}.${value}`);
      return this;
    }
  }
  PostgrestFilterBuilder$1.default = PostgrestFilterBuilder2;
  return PostgrestFilterBuilder$1;
}
var hasRequiredPostgrestQueryBuilder;
function requirePostgrestQueryBuilder() {
  if (hasRequiredPostgrestQueryBuilder) return PostgrestQueryBuilder$1;
  hasRequiredPostgrestQueryBuilder = 1;
  Object.defineProperty(PostgrestQueryBuilder$1, "__esModule", { value: true });
  const tslib_1 = require$$0;
  const PostgrestFilterBuilder_1 = tslib_1.__importDefault(requirePostgrestFilterBuilder());
  class PostgrestQueryBuilder2 {
    constructor(url, { headers = {}, schema, fetch: fetch2 }) {
      this.url = url;
      this.headers = new Headers(headers);
      this.schema = schema;
      this.fetch = fetch2;
    }
    /**
     * Perform a SELECT query on the table or view.
     *
     * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`
     *
     * @param options - Named parameters
     *
     * @param options.head - When set to `true`, `data` will not be returned.
     * Useful if you only need the count.
     *
     * @param options.count - Count algorithm to use to count rows in the table or view.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */
    select(columns, options) {
      const { head: head2 = false, count } = options !== null && options !== void 0 ? options : {};
      const method = head2 ? "HEAD" : "GET";
      let quoted = false;
      const cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map((c) => {
        if (/\s/.test(c) && !quoted) {
          return "";
        }
        if (c === '"') {
          quoted = !quoted;
        }
        return c;
      }).join("");
      this.url.searchParams.set("select", cleanedColumns);
      if (count) {
        this.headers.append("Prefer", `count=${count}`);
      }
      return new PostgrestFilterBuilder_1.default({
        method,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        fetch: this.fetch
      });
    }
    /**
     * Perform an INSERT into the table or view.
     *
     * By default, inserted rows are not returned. To return it, chain the call
     * with `.select()`.
     *
     * @param values - The values to insert. Pass an object to insert a single row
     * or an array to insert multiple rows.
     *
     * @param options - Named parameters
     *
     * @param options.count - Count algorithm to use to count inserted rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     *
     * @param options.defaultToNull - Make missing fields default to `null`.
     * Otherwise, use the default value for the column. Only applies for bulk
     * inserts.
     */
    insert(values2, { count, defaultToNull = true } = {}) {
      var _a2;
      const method = "POST";
      if (count) {
        this.headers.append("Prefer", `count=${count}`);
      }
      if (!defaultToNull) {
        this.headers.append("Prefer", `missing=default`);
      }
      if (Array.isArray(values2)) {
        const columns = values2.reduce((acc, x) => acc.concat(Object.keys(x)), []);
        if (columns.length > 0) {
          const uniqueColumns = [...new Set(columns)].map((column2) => `"${column2}"`);
          this.url.searchParams.set("columns", uniqueColumns.join(","));
        }
      }
      return new PostgrestFilterBuilder_1.default({
        method,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: values2,
        fetch: (_a2 = this.fetch) !== null && _a2 !== void 0 ? _a2 : fetch
      });
    }
    /**
     * Perform an UPSERT on the table or view. Depending on the column(s) passed
     * to `onConflict`, `.upsert()` allows you to perform the equivalent of
     * `.insert()` if a row with the corresponding `onConflict` columns doesn't
     * exist, or if it does exist, perform an alternative action depending on
     * `ignoreDuplicates`.
     *
     * By default, upserted rows are not returned. To return it, chain the call
     * with `.select()`.
     *
     * @param values - The values to upsert with. Pass an object to upsert a
     * single row or an array to upsert multiple rows.
     *
     * @param options - Named parameters
     *
     * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how
     * duplicate rows are determined. Two rows are duplicates if all the
     * `onConflict` columns are equal.
     *
     * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If
     * `false`, duplicate rows are merged with existing rows.
     *
     * @param options.count - Count algorithm to use to count upserted rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     *
     * @param options.defaultToNull - Make missing fields default to `null`.
     * Otherwise, use the default value for the column. This only applies when
     * inserting new rows, not when merging with existing rows under
     * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.
     */
    upsert(values2, { onConflict, ignoreDuplicates = false, count, defaultToNull = true } = {}) {
      var _a2;
      const method = "POST";
      this.headers.append("Prefer", `resolution=${ignoreDuplicates ? "ignore" : "merge"}-duplicates`);
      if (onConflict !== void 0)
        this.url.searchParams.set("on_conflict", onConflict);
      if (count) {
        this.headers.append("Prefer", `count=${count}`);
      }
      if (!defaultToNull) {
        this.headers.append("Prefer", "missing=default");
      }
      if (Array.isArray(values2)) {
        const columns = values2.reduce((acc, x) => acc.concat(Object.keys(x)), []);
        if (columns.length > 0) {
          const uniqueColumns = [...new Set(columns)].map((column2) => `"${column2}"`);
          this.url.searchParams.set("columns", uniqueColumns.join(","));
        }
      }
      return new PostgrestFilterBuilder_1.default({
        method,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: values2,
        fetch: (_a2 = this.fetch) !== null && _a2 !== void 0 ? _a2 : fetch
      });
    }
    /**
     * Perform an UPDATE on the table or view.
     *
     * By default, updated rows are not returned. To return it, chain the call
     * with `.select()` after filters.
     *
     * @param values - The values to update with
     *
     * @param options - Named parameters
     *
     * @param options.count - Count algorithm to use to count updated rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */
    update(values2, { count } = {}) {
      var _a2;
      const method = "PATCH";
      if (count) {
        this.headers.append("Prefer", `count=${count}`);
      }
      return new PostgrestFilterBuilder_1.default({
        method,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: values2,
        fetch: (_a2 = this.fetch) !== null && _a2 !== void 0 ? _a2 : fetch
      });
    }
    /**
     * Perform a DELETE on the table or view.
     *
     * By default, deleted rows are not returned. To return it, chain the call
     * with `.select()` after filters.
     *
     * @param options - Named parameters
     *
     * @param options.count - Count algorithm to use to count deleted rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */
    delete({ count } = {}) {
      var _a2;
      const method = "DELETE";
      if (count) {
        this.headers.append("Prefer", `count=${count}`);
      }
      return new PostgrestFilterBuilder_1.default({
        method,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        fetch: (_a2 = this.fetch) !== null && _a2 !== void 0 ? _a2 : fetch
      });
    }
  }
  PostgrestQueryBuilder$1.default = PostgrestQueryBuilder2;
  return PostgrestQueryBuilder$1;
}
var hasRequiredPostgrestClient;
function requirePostgrestClient() {
  if (hasRequiredPostgrestClient) return PostgrestClient$1;
  hasRequiredPostgrestClient = 1;
  Object.defineProperty(PostgrestClient$1, "__esModule", { value: true });
  const tslib_1 = require$$0;
  const PostgrestQueryBuilder_1 = tslib_1.__importDefault(requirePostgrestQueryBuilder());
  const PostgrestFilterBuilder_1 = tslib_1.__importDefault(requirePostgrestFilterBuilder());
  class PostgrestClient2 {
    // TODO: Add back shouldThrowOnError once we figure out the typings
    /**
     * Creates a PostgREST client.
     *
     * @param url - URL of the PostgREST endpoint
     * @param options - Named parameters
     * @param options.headers - Custom headers
     * @param options.schema - Postgres schema to switch to
     * @param options.fetch - Custom fetch
     */
    constructor(url, { headers = {}, schema, fetch: fetch2 } = {}) {
      this.url = url;
      this.headers = new Headers(headers);
      this.schemaName = schema;
      this.fetch = fetch2;
    }
    /**
     * Perform a query on a table or a view.
     *
     * @param relation - The table or view name to query
     */
    from(relation) {
      const url = new URL(`${this.url}/${relation}`);
      return new PostgrestQueryBuilder_1.default(url, {
        headers: new Headers(this.headers),
        schema: this.schemaName,
        fetch: this.fetch
      });
    }
    /**
     * Select a schema to query or perform an function (rpc) call.
     *
     * The schema needs to be on the list of exposed schemas inside Supabase.
     *
     * @param schema - The schema to query
     */
    schema(schema) {
      return new PostgrestClient2(this.url, {
        headers: this.headers,
        schema,
        fetch: this.fetch
      });
    }
    /**
     * Perform a function call.
     *
     * @param fn - The function name to call
     * @param args - The arguments to pass to the function call
     * @param options - Named parameters
     * @param options.head - When set to `true`, `data` will not be returned.
     * Useful if you only need the count.
     * @param options.get - When set to `true`, the function will be called with
     * read-only access mode.
     * @param options.count - Count algorithm to use to count rows returned by the
     * function. Only applicable for [set-returning
     * functions](https://www.postgresql.org/docs/current/functions-srf.html).
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */
    rpc(fn2, args = {}, { head: head2 = false, get: get2 = false, count } = {}) {
      var _a2;
      let method;
      const url = new URL(`${this.url}/rpc/${fn2}`);
      let body2;
      if (head2 || get2) {
        method = head2 ? "HEAD" : "GET";
        Object.entries(args).filter(([_, value]) => value !== void 0).map(([name2, value]) => [name2, Array.isArray(value) ? `{${value.join(",")}}` : `${value}`]).forEach(([name2, value]) => {
          url.searchParams.append(name2, value);
        });
      } else {
        method = "POST";
        body2 = args;
      }
      const headers = new Headers(this.headers);
      if (count) {
        headers.set("Prefer", `count=${count}`);
      }
      return new PostgrestFilterBuilder_1.default({
        method,
        url,
        headers,
        schema: this.schemaName,
        body: body2,
        fetch: (_a2 = this.fetch) !== null && _a2 !== void 0 ? _a2 : fetch
      });
    }
  }
  PostgrestClient$1.default = PostgrestClient2;
  return PostgrestClient$1;
}
var hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs) return cjs;
  hasRequiredCjs = 1;
  Object.defineProperty(cjs, "__esModule", { value: true });
  cjs.PostgrestError = cjs.PostgrestBuilder = cjs.PostgrestTransformBuilder = cjs.PostgrestFilterBuilder = cjs.PostgrestQueryBuilder = cjs.PostgrestClient = void 0;
  const tslib_1 = require$$0;
  const PostgrestClient_1 = tslib_1.__importDefault(requirePostgrestClient());
  cjs.PostgrestClient = PostgrestClient_1.default;
  const PostgrestQueryBuilder_1 = tslib_1.__importDefault(requirePostgrestQueryBuilder());
  cjs.PostgrestQueryBuilder = PostgrestQueryBuilder_1.default;
  const PostgrestFilterBuilder_1 = tslib_1.__importDefault(requirePostgrestFilterBuilder());
  cjs.PostgrestFilterBuilder = PostgrestFilterBuilder_1.default;
  const PostgrestTransformBuilder_1 = tslib_1.__importDefault(requirePostgrestTransformBuilder());
  cjs.PostgrestTransformBuilder = PostgrestTransformBuilder_1.default;
  const PostgrestBuilder_1 = tslib_1.__importDefault(requirePostgrestBuilder());
  cjs.PostgrestBuilder = PostgrestBuilder_1.default;
  const PostgrestError_1 = tslib_1.__importDefault(requirePostgrestError());
  cjs.PostgrestError = PostgrestError_1.default;
  cjs.default = {
    PostgrestClient: PostgrestClient_1.default,
    PostgrestQueryBuilder: PostgrestQueryBuilder_1.default,
    PostgrestFilterBuilder: PostgrestFilterBuilder_1.default,
    PostgrestTransformBuilder: PostgrestTransformBuilder_1.default,
    PostgrestBuilder: PostgrestBuilder_1.default,
    PostgrestError: PostgrestError_1.default
  };
  return cjs;
}
var cjsExports = requireCjs();
const index = /* @__PURE__ */ getDefaultExportFromCjs(cjsExports);
const {
  PostgrestClient,
  PostgrestQueryBuilder,
  PostgrestFilterBuilder,
  PostgrestTransformBuilder,
  PostgrestBuilder,
  PostgrestError
} = index;
class WebSocketFactory {
  static detectEnvironment() {
    var _a2;
    if (typeof WebSocket !== "undefined") {
      return { type: "native", constructor: WebSocket };
    }
    if (typeof globalThis !== "undefined" && typeof globalThis.WebSocket !== "undefined") {
      return { type: "native", constructor: globalThis.WebSocket };
    }
    if (typeof global !== "undefined" && typeof global.WebSocket !== "undefined") {
      return { type: "native", constructor: global.WebSocket };
    }
    if (typeof globalThis !== "undefined" && typeof globalThis.WebSocketPair !== "undefined" && typeof globalThis.WebSocket === "undefined") {
      return {
        type: "cloudflare",
        error: "Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",
        workaround: "Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."
      };
    }
    if (typeof globalThis !== "undefined" && globalThis.EdgeRuntime || typeof navigator !== "undefined" && ((_a2 = navigator.userAgent) === null || _a2 === void 0 ? void 0 : _a2.includes("Vercel-Edge"))) {
      return {
        type: "unsupported",
        error: "Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",
        workaround: "Use serverless functions or a different deployment target for WebSocket functionality."
      };
    }
    if (typeof process !== "undefined") {
      const processVersions = process["versions"];
      if (processVersions && processVersions["node"]) {
        const versionString = processVersions["node"];
        const nodeVersion = parseInt(versionString.replace(/^v/, "").split(".")[0]);
        if (nodeVersion >= 22) {
          if (typeof globalThis.WebSocket !== "undefined") {
            return { type: "native", constructor: globalThis.WebSocket };
          }
          return {
            type: "unsupported",
            error: `Node.js ${nodeVersion} detected but native WebSocket not found.`,
            workaround: "Provide a WebSocket implementation via the transport option."
          };
        }
        return {
          type: "unsupported",
          error: `Node.js ${nodeVersion} detected without native WebSocket support.`,
          workaround: 'For Node.js < 22, install "ws" package and provide it via the transport option:\nimport ws from "ws"\nnew RealtimeClient(url, { transport: ws })'
        };
      }
    }
    return {
      type: "unsupported",
      error: "Unknown JavaScript runtime without WebSocket support.",
      workaround: "Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."
    };
  }
  static getWebSocketConstructor() {
    const env = this.detectEnvironment();
    if (env.constructor) {
      return env.constructor;
    }
    let errorMessage = env.error || "WebSocket not supported in this environment.";
    if (env.workaround) {
      errorMessage += `

Suggested solution: ${env.workaround}`;
    }
    throw new Error(errorMessage);
  }
  static createWebSocket(url, protocols) {
    const WS = this.getWebSocketConstructor();
    return new WS(url, protocols);
  }
  static isWebSocketSupported() {
    try {
      const env = this.detectEnvironment();
      return env.type === "native" || env.type === "ws";
    } catch (_a2) {
      return false;
    }
  }
}
const version$5 = "2.76.1";
const DEFAULT_VERSION = `realtime-js/${version$5}`;
const VSN = "1.0.0";
const DEFAULT_TIMEOUT = 1e4;
const WS_CLOSE_NORMAL = 1e3;
const MAX_PUSH_BUFFER_SIZE = 100;
var SOCKET_STATES;
(function(SOCKET_STATES2) {
  SOCKET_STATES2[SOCKET_STATES2["connecting"] = 0] = "connecting";
  SOCKET_STATES2[SOCKET_STATES2["open"] = 1] = "open";
  SOCKET_STATES2[SOCKET_STATES2["closing"] = 2] = "closing";
  SOCKET_STATES2[SOCKET_STATES2["closed"] = 3] = "closed";
})(SOCKET_STATES || (SOCKET_STATES = {}));
var CHANNEL_STATES;
(function(CHANNEL_STATES2) {
  CHANNEL_STATES2["closed"] = "closed";
  CHANNEL_STATES2["errored"] = "errored";
  CHANNEL_STATES2["joined"] = "joined";
  CHANNEL_STATES2["joining"] = "joining";
  CHANNEL_STATES2["leaving"] = "leaving";
})(CHANNEL_STATES || (CHANNEL_STATES = {}));
var CHANNEL_EVENTS;
(function(CHANNEL_EVENTS2) {
  CHANNEL_EVENTS2["close"] = "phx_close";
  CHANNEL_EVENTS2["error"] = "phx_error";
  CHANNEL_EVENTS2["join"] = "phx_join";
  CHANNEL_EVENTS2["reply"] = "phx_reply";
  CHANNEL_EVENTS2["leave"] = "phx_leave";
  CHANNEL_EVENTS2["access_token"] = "access_token";
})(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));
var TRANSPORTS;
(function(TRANSPORTS2) {
  TRANSPORTS2["websocket"] = "websocket";
})(TRANSPORTS || (TRANSPORTS = {}));
var CONNECTION_STATE;
(function(CONNECTION_STATE2) {
  CONNECTION_STATE2["Connecting"] = "connecting";
  CONNECTION_STATE2["Open"] = "open";
  CONNECTION_STATE2["Closing"] = "closing";
  CONNECTION_STATE2["Closed"] = "closed";
})(CONNECTION_STATE || (CONNECTION_STATE = {}));
class Serializer {
  constructor() {
    this.HEADER_LENGTH = 1;
  }
  decode(rawPayload, callback) {
    if (rawPayload.constructor === ArrayBuffer) {
      return callback(this._binaryDecode(rawPayload));
    }
    if (typeof rawPayload === "string") {
      return callback(JSON.parse(rawPayload));
    }
    return callback({});
  }
  _binaryDecode(buffer) {
    const view = new DataView(buffer);
    const decoder = new TextDecoder();
    return this._decodeBroadcast(buffer, view, decoder);
  }
  _decodeBroadcast(buffer, view, decoder) {
    const topicSize = view.getUint8(1);
    const eventSize = view.getUint8(2);
    let offset2 = this.HEADER_LENGTH + 2;
    const topic = decoder.decode(buffer.slice(offset2, offset2 + topicSize));
    offset2 = offset2 + topicSize;
    const event = decoder.decode(buffer.slice(offset2, offset2 + eventSize));
    offset2 = offset2 + eventSize;
    const data = JSON.parse(decoder.decode(buffer.slice(offset2, buffer.byteLength)));
    return { ref: null, topic, event, payload: data };
  }
}
class Timer {
  constructor(callback, timerCalc) {
    this.callback = callback;
    this.timerCalc = timerCalc;
    this.timer = void 0;
    this.tries = 0;
    this.callback = callback;
    this.timerCalc = timerCalc;
  }
  reset() {
    this.tries = 0;
    clearTimeout(this.timer);
    this.timer = void 0;
  }
  // Cancels any previous scheduleTimeout and schedules callback
  scheduleTimeout() {
    clearTimeout(this.timer);
    this.timer = setTimeout(() => {
      this.tries = this.tries + 1;
      this.callback();
    }, this.timerCalc(this.tries + 1));
  }
}
var PostgresTypes;
(function(PostgresTypes2) {
  PostgresTypes2["abstime"] = "abstime";
  PostgresTypes2["bool"] = "bool";
  PostgresTypes2["date"] = "date";
  PostgresTypes2["daterange"] = "daterange";
  PostgresTypes2["float4"] = "float4";
  PostgresTypes2["float8"] = "float8";
  PostgresTypes2["int2"] = "int2";
  PostgresTypes2["int4"] = "int4";
  PostgresTypes2["int4range"] = "int4range";
  PostgresTypes2["int8"] = "int8";
  PostgresTypes2["int8range"] = "int8range";
  PostgresTypes2["json"] = "json";
  PostgresTypes2["jsonb"] = "jsonb";
  PostgresTypes2["money"] = "money";
  PostgresTypes2["numeric"] = "numeric";
  PostgresTypes2["oid"] = "oid";
  PostgresTypes2["reltime"] = "reltime";
  PostgresTypes2["text"] = "text";
  PostgresTypes2["time"] = "time";
  PostgresTypes2["timestamp"] = "timestamp";
  PostgresTypes2["timestamptz"] = "timestamptz";
  PostgresTypes2["timetz"] = "timetz";
  PostgresTypes2["tsrange"] = "tsrange";
  PostgresTypes2["tstzrange"] = "tstzrange";
})(PostgresTypes || (PostgresTypes = {}));
const convertChangeData = (columns, record, options = {}) => {
  var _a2;
  const skipTypes = (_a2 = options.skipTypes) !== null && _a2 !== void 0 ? _a2 : [];
  if (!record) {
    return {};
  }
  return Object.keys(record).reduce((acc, rec_key) => {
    acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);
    return acc;
  }, {});
};
const convertColumn = (columnName, columns, record, skipTypes) => {
  const column2 = columns.find((x) => x.name === columnName);
  const colType = column2 === null || column2 === void 0 ? void 0 : column2.type;
  const value = record[columnName];
  if (colType && !skipTypes.includes(colType)) {
    return convertCell(colType, value);
  }
  return noop$1(value);
};
const convertCell = (type, value) => {
  if (type.charAt(0) === "_") {
    const dataType = type.slice(1, type.length);
    return toArray(value, dataType);
  }
  switch (type) {
    case PostgresTypes.bool:
      return toBoolean(value);
    case PostgresTypes.float4:
    case PostgresTypes.float8:
    case PostgresTypes.int2:
    case PostgresTypes.int4:
    case PostgresTypes.int8:
    case PostgresTypes.numeric:
    case PostgresTypes.oid:
      return toNumber(value);
    case PostgresTypes.json:
    case PostgresTypes.jsonb:
      return toJson(value);
    case PostgresTypes.timestamp:
      return toTimestampString(value);
    // Format to be consistent with PostgREST
    case PostgresTypes.abstime:
    // To allow users to cast it based on Timezone
    case PostgresTypes.date:
    // To allow users to cast it based on Timezone
    case PostgresTypes.daterange:
    case PostgresTypes.int4range:
    case PostgresTypes.int8range:
    case PostgresTypes.money:
    case PostgresTypes.reltime:
    // To allow users to cast it based on Timezone
    case PostgresTypes.text:
    case PostgresTypes.time:
    // To allow users to cast it based on Timezone
    case PostgresTypes.timestamptz:
    // To allow users to cast it based on Timezone
    case PostgresTypes.timetz:
    // To allow users to cast it based on Timezone
    case PostgresTypes.tsrange:
    case PostgresTypes.tstzrange:
      return noop$1(value);
    default:
      return noop$1(value);
  }
};
const noop$1 = (value) => {
  return value;
};
const toBoolean = (value) => {
  switch (value) {
    case "t":
      return true;
    case "f":
      return false;
    default:
      return value;
  }
};
const toNumber = (value) => {
  if (typeof value === "string") {
    const parsedValue = parseFloat(value);
    if (!Number.isNaN(parsedValue)) {
      return parsedValue;
    }
  }
  return value;
};
const toJson = (value) => {
  if (typeof value === "string") {
    try {
      return JSON.parse(value);
    } catch (error) {
      console.log(`JSON parse error: ${error}`);
      return value;
    }
  }
  return value;
};
const toArray = (value, type) => {
  if (typeof value !== "string") {
    return value;
  }
  const lastIdx = value.length - 1;
  const closeBrace = value[lastIdx];
  const openBrace = value[0];
  if (openBrace === "{" && closeBrace === "}") {
    let arr;
    const valTrim = value.slice(1, lastIdx);
    try {
      arr = JSON.parse("[" + valTrim + "]");
    } catch (_) {
      arr = valTrim ? valTrim.split(",") : [];
    }
    return arr.map((val) => convertCell(type, val));
  }
  return value;
};
const toTimestampString = (value) => {
  if (typeof value === "string") {
    return value.replace(" ", "T");
  }
  return value;
};
const httpEndpointURL = (socketUrl) => {
  const wsUrl = new URL(socketUrl);
  wsUrl.protocol = wsUrl.protocol.replace(/^ws/i, "http");
  wsUrl.pathname = wsUrl.pathname.replace(/\/+$/, "").replace(/\/socket\/websocket$/i, "").replace(/\/socket$/i, "").replace(/\/websocket$/i, "");
  if (wsUrl.pathname === "" || wsUrl.pathname === "/") {
    wsUrl.pathname = "/api/broadcast";
  } else {
    wsUrl.pathname = wsUrl.pathname + "/api/broadcast";
  }
  return wsUrl.href;
};
class Push {
  /**
   * Initializes the Push
   *
   * @param channel The Channel
   * @param event The event, for example `"phx_join"`
   * @param payload The payload, for example `{user_id: 123}`
   * @param timeout The push timeout in milliseconds
   */
  constructor(channel, event, payload = {}, timeout = DEFAULT_TIMEOUT) {
    this.channel = channel;
    this.event = event;
    this.payload = payload;
    this.timeout = timeout;
    this.sent = false;
    this.timeoutTimer = void 0;
    this.ref = "";
    this.receivedResp = null;
    this.recHooks = [];
    this.refEvent = null;
  }
  resend(timeout) {
    this.timeout = timeout;
    this._cancelRefEvent();
    this.ref = "";
    this.refEvent = null;
    this.receivedResp = null;
    this.sent = false;
    this.send();
  }
  send() {
    if (this._hasReceived("timeout")) {
      return;
    }
    this.startTimeout();
    this.sent = true;
    this.channel.socket.push({
      topic: this.channel.topic,
      event: this.event,
      payload: this.payload,
      ref: this.ref,
      join_ref: this.channel._joinRef()
    });
  }
  updatePayload(payload) {
    this.payload = Object.assign(Object.assign({}, this.payload), payload);
  }
  receive(status, callback) {
    var _a2;
    if (this._hasReceived(status)) {
      callback((_a2 = this.receivedResp) === null || _a2 === void 0 ? void 0 : _a2.response);
    }
    this.recHooks.push({ status, callback });
    return this;
  }
  startTimeout() {
    if (this.timeoutTimer) {
      return;
    }
    this.ref = this.channel.socket._makeRef();
    this.refEvent = this.channel._replyEventName(this.ref);
    const callback = (payload) => {
      this._cancelRefEvent();
      this._cancelTimeout();
      this.receivedResp = payload;
      this._matchReceive(payload);
    };
    this.channel._on(this.refEvent, {}, callback);
    this.timeoutTimer = setTimeout(() => {
      this.trigger("timeout", {});
    }, this.timeout);
  }
  trigger(status, response) {
    if (this.refEvent)
      this.channel._trigger(this.refEvent, { status, response });
  }
  destroy() {
    this._cancelRefEvent();
    this._cancelTimeout();
  }
  _cancelRefEvent() {
    if (!this.refEvent) {
      return;
    }
    this.channel._off(this.refEvent, {});
  }
  _cancelTimeout() {
    clearTimeout(this.timeoutTimer);
    this.timeoutTimer = void 0;
  }
  _matchReceive({ status, response }) {
    this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));
  }
  _hasReceived(status) {
    return this.receivedResp && this.receivedResp.status === status;
  }
}
var REALTIME_PRESENCE_LISTEN_EVENTS;
(function(REALTIME_PRESENCE_LISTEN_EVENTS2) {
  REALTIME_PRESENCE_LISTEN_EVENTS2["SYNC"] = "sync";
  REALTIME_PRESENCE_LISTEN_EVENTS2["JOIN"] = "join";
  REALTIME_PRESENCE_LISTEN_EVENTS2["LEAVE"] = "leave";
})(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));
class RealtimePresence {
  /**
   * Initializes the Presence.
   *
   * @param channel - The RealtimeChannel
   * @param opts - The options,
   *        for example `{events: {state: 'state', diff: 'diff'}}`
   */
  constructor(channel, opts) {
    this.channel = channel;
    this.state = {};
    this.pendingDiffs = [];
    this.joinRef = null;
    this.enabled = false;
    this.caller = {
      onJoin: () => {
      },
      onLeave: () => {
      },
      onSync: () => {
      }
    };
    const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {
      state: "presence_state",
      diff: "presence_diff"
    };
    this.channel._on(events.state, {}, (newState) => {
      const { onJoin, onLeave, onSync } = this.caller;
      this.joinRef = this.channel._joinRef();
      this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);
      this.pendingDiffs.forEach((diff) => {
        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
      });
      this.pendingDiffs = [];
      onSync();
    });
    this.channel._on(events.diff, {}, (diff) => {
      const { onJoin, onLeave, onSync } = this.caller;
      if (this.inPendingSyncState()) {
        this.pendingDiffs.push(diff);
      } else {
        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
        onSync();
      }
    });
    this.onJoin((key, currentPresences, newPresences) => {
      this.channel._trigger("presence", {
        event: "join",
        key,
        currentPresences,
        newPresences
      });
    });
    this.onLeave((key, currentPresences, leftPresences) => {
      this.channel._trigger("presence", {
        event: "leave",
        key,
        currentPresences,
        leftPresences
      });
    });
    this.onSync(() => {
      this.channel._trigger("presence", { event: "sync" });
    });
  }
  /**
   * Used to sync the list of presences on the server with the
   * client's state.
   *
   * An optional `onJoin` and `onLeave` callback can be provided to
   * react to changes in the client's local presences across
   * disconnects and reconnects with the server.
   *
   * @internal
   */
  static syncState(currentState, newState, onJoin, onLeave) {
    const state = this.cloneDeep(currentState);
    const transformedState = this.transformState(newState);
    const joins = {};
    const leaves = {};
    this.map(state, (key, presences) => {
      if (!transformedState[key]) {
        leaves[key] = presences;
      }
    });
    this.map(transformedState, (key, newPresences) => {
      const currentPresences = state[key];
      if (currentPresences) {
        const newPresenceRefs = newPresences.map((m) => m.presence_ref);
        const curPresenceRefs = currentPresences.map((m) => m.presence_ref);
        const joinedPresences = newPresences.filter((m) => curPresenceRefs.indexOf(m.presence_ref) < 0);
        const leftPresences = currentPresences.filter((m) => newPresenceRefs.indexOf(m.presence_ref) < 0);
        if (joinedPresences.length > 0) {
          joins[key] = joinedPresences;
        }
        if (leftPresences.length > 0) {
          leaves[key] = leftPresences;
        }
      } else {
        joins[key] = newPresences;
      }
    });
    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);
  }
  /**
   * Used to sync a diff of presence join and leave events from the
   * server, as they happen.
   *
   * Like `syncState`, `syncDiff` accepts optional `onJoin` and
   * `onLeave` callbacks to react to a user joining or leaving from a
   * device.
   *
   * @internal
   */
  static syncDiff(state, diff, onJoin, onLeave) {
    const { joins, leaves } = {
      joins: this.transformState(diff.joins),
      leaves: this.transformState(diff.leaves)
    };
    if (!onJoin) {
      onJoin = () => {
      };
    }
    if (!onLeave) {
      onLeave = () => {
      };
    }
    this.map(joins, (key, newPresences) => {
      var _a2;
      const currentPresences = (_a2 = state[key]) !== null && _a2 !== void 0 ? _a2 : [];
      state[key] = this.cloneDeep(newPresences);
      if (currentPresences.length > 0) {
        const joinedPresenceRefs = state[key].map((m) => m.presence_ref);
        const curPresences = currentPresences.filter((m) => joinedPresenceRefs.indexOf(m.presence_ref) < 0);
        state[key].unshift(...curPresences);
      }
      onJoin(key, currentPresences, newPresences);
    });
    this.map(leaves, (key, leftPresences) => {
      let currentPresences = state[key];
      if (!currentPresences)
        return;
      const presenceRefsToRemove = leftPresences.map((m) => m.presence_ref);
      currentPresences = currentPresences.filter((m) => presenceRefsToRemove.indexOf(m.presence_ref) < 0);
      state[key] = currentPresences;
      onLeave(key, currentPresences, leftPresences);
      if (currentPresences.length === 0)
        delete state[key];
    });
    return state;
  }
  /** @internal */
  static map(obj, func) {
    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));
  }
  /**
   * Remove 'metas' key
   * Change 'phx_ref' to 'presence_ref'
   * Remove 'phx_ref' and 'phx_ref_prev'
   *
   * @example
   * // returns {
   *  abc123: [
   *    { presence_ref: '2', user_id: 1 },
   *    { presence_ref: '3', user_id: 2 }
   *  ]
   * }
   * RealtimePresence.transformState({
   *  abc123: {
   *    metas: [
   *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },
   *      { phx_ref: '3', user_id: 2 }
   *    ]
   *  }
   * })
   *
   * @internal
   */
  static transformState(state) {
    state = this.cloneDeep(state);
    return Object.getOwnPropertyNames(state).reduce((newState, key) => {
      const presences = state[key];
      if ("metas" in presences) {
        newState[key] = presences.metas.map((presence) => {
          presence["presence_ref"] = presence["phx_ref"];
          delete presence["phx_ref"];
          delete presence["phx_ref_prev"];
          return presence;
        });
      } else {
        newState[key] = presences;
      }
      return newState;
    }, {});
  }
  /** @internal */
  static cloneDeep(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  /** @internal */
  onJoin(callback) {
    this.caller.onJoin = callback;
  }
  /** @internal */
  onLeave(callback) {
    this.caller.onLeave = callback;
  }
  /** @internal */
  onSync(callback) {
    this.caller.onSync = callback;
  }
  /** @internal */
  inPendingSyncState() {
    return !this.joinRef || this.joinRef !== this.channel._joinRef();
  }
}
var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;
(function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2) {
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["ALL"] = "*";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["INSERT"] = "INSERT";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["UPDATE"] = "UPDATE";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["DELETE"] = "DELETE";
})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));
var REALTIME_LISTEN_TYPES;
(function(REALTIME_LISTEN_TYPES2) {
  REALTIME_LISTEN_TYPES2["BROADCAST"] = "broadcast";
  REALTIME_LISTEN_TYPES2["PRESENCE"] = "presence";
  REALTIME_LISTEN_TYPES2["POSTGRES_CHANGES"] = "postgres_changes";
  REALTIME_LISTEN_TYPES2["SYSTEM"] = "system";
})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));
var REALTIME_SUBSCRIBE_STATES;
(function(REALTIME_SUBSCRIBE_STATES2) {
  REALTIME_SUBSCRIBE_STATES2["SUBSCRIBED"] = "SUBSCRIBED";
  REALTIME_SUBSCRIBE_STATES2["TIMED_OUT"] = "TIMED_OUT";
  REALTIME_SUBSCRIBE_STATES2["CLOSED"] = "CLOSED";
  REALTIME_SUBSCRIBE_STATES2["CHANNEL_ERROR"] = "CHANNEL_ERROR";
})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));
class RealtimeChannel {
  constructor(topic, params = { config: {} }, socket) {
    var _a2, _b;
    this.topic = topic;
    this.params = params;
    this.socket = socket;
    this.bindings = {};
    this.state = CHANNEL_STATES.closed;
    this.joinedOnce = false;
    this.pushBuffer = [];
    this.subTopic = topic.replace(/^realtime:/i, "");
    this.params.config = Object.assign({
      broadcast: { ack: false, self: false },
      presence: { key: "", enabled: false },
      private: false
    }, params.config);
    this.timeout = this.socket.timeout;
    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
    this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);
    this.joinPush.receive("ok", () => {
      this.state = CHANNEL_STATES.joined;
      this.rejoinTimer.reset();
      this.pushBuffer.forEach((pushEvent) => pushEvent.send());
      this.pushBuffer = [];
    });
    this._onClose(() => {
      this.rejoinTimer.reset();
      this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`);
      this.state = CHANNEL_STATES.closed;
      this.socket._remove(this);
    });
    this._onError((reason) => {
      if (this._isLeaving() || this._isClosed()) {
        return;
      }
      this.socket.log("channel", `error ${this.topic}`, reason);
      this.state = CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this.joinPush.receive("timeout", () => {
      if (!this._isJoining()) {
        return;
      }
      this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout);
      this.state = CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this.joinPush.receive("error", (reason) => {
      if (this._isLeaving() || this._isClosed()) {
        return;
      }
      this.socket.log("channel", `error ${this.topic}`, reason);
      this.state = CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {
      this._trigger(this._replyEventName(ref), payload);
    });
    this.presence = new RealtimePresence(this);
    this.broadcastEndpointURL = httpEndpointURL(this.socket.endPoint);
    this.private = this.params.config.private || false;
    if (!this.private && ((_b = (_a2 = this.params.config) === null || _a2 === void 0 ? void 0 : _a2.broadcast) === null || _b === void 0 ? void 0 : _b.replay)) {
      throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`;
    }
  }
  /** Subscribe registers your client with the server */
  subscribe(callback, timeout = this.timeout) {
    var _a2, _b, _c;
    if (!this.socket.isConnected()) {
      this.socket.connect();
    }
    if (this.state == CHANNEL_STATES.closed) {
      const { config: { broadcast, presence, private: isPrivate } } = this.params;
      const postgres_changes = (_b = (_a2 = this.bindings.postgres_changes) === null || _a2 === void 0 ? void 0 : _a2.map((r2) => r2.filter)) !== null && _b !== void 0 ? _b : [];
      const presence_enabled = !!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] && this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0 || ((_c = this.params.config.presence) === null || _c === void 0 ? void 0 : _c.enabled) === true;
      const accessTokenPayload = {};
      const config2 = {
        broadcast,
        presence: Object.assign(Object.assign({}, presence), { enabled: presence_enabled }),
        postgres_changes,
        private: isPrivate
      };
      if (this.socket.accessTokenValue) {
        accessTokenPayload.access_token = this.socket.accessTokenValue;
      }
      this._onError((e) => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));
      this._onClose(() => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));
      this.updateJoinPayload(Object.assign({ config: config2 }, accessTokenPayload));
      this.joinedOnce = true;
      this._rejoin(timeout);
      this.joinPush.receive("ok", (_0) => __async(this, [_0], function* ({ postgres_changes: postgres_changes2 }) {
        var _a3;
        this.socket.setAuth();
        if (postgres_changes2 === void 0) {
          callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
          return;
        } else {
          const clientPostgresBindings = this.bindings.postgres_changes;
          const bindingsLen = (_a3 = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a3 !== void 0 ? _a3 : 0;
          const newPostgresBindings = [];
          for (let i = 0; i < bindingsLen; i++) {
            const clientPostgresBinding = clientPostgresBindings[i];
            const { filter: { event, schema, table, filter } } = clientPostgresBinding;
            const serverPostgresFilter = postgres_changes2 && postgres_changes2[i];
            if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {
              newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));
            } else {
              this.unsubscribe();
              this.state = CHANNEL_STATES.errored;
              callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error("mismatch between server and client bindings for postgres changes"));
              return;
            }
          }
          this.bindings.postgres_changes = newPostgresBindings;
          callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
          return;
        }
      })).receive("error", (error) => {
        this.state = CHANNEL_STATES.errored;
        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(", ") || "error")));
        return;
      }).receive("timeout", () => {
        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);
        return;
      });
    }
    return this;
  }
  presenceState() {
    return this.presence.state;
  }
  track(_0) {
    return __async(this, arguments, function* (payload, opts = {}) {
      return yield this.send({
        type: "presence",
        event: "track",
        payload
      }, opts.timeout || this.timeout);
    });
  }
  untrack() {
    return __async(this, arguments, function* (opts = {}) {
      return yield this.send({
        type: "presence",
        event: "untrack"
      }, opts);
    });
  }
  on(type, filter, callback) {
    if (this.state === CHANNEL_STATES.joined && type === REALTIME_LISTEN_TYPES.PRESENCE) {
      this.socket.log("channel", `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`);
      this.unsubscribe().then(() => this.subscribe());
    }
    return this._on(type, filter, callback);
  }
  /**
   * Sends a broadcast message explicitly via REST API.
   *
   * This method always uses the REST API endpoint regardless of WebSocket connection state.
   * Useful when you want to guarantee REST delivery or when gradually migrating from implicit REST fallback.
   *
   * @param event The name of the broadcast event
   * @param payload Payload to be sent (required)
   * @param opts Options including timeout
   * @returns Promise resolving to object with success status, and error details if failed
   */
  httpSend(_0, _1) {
    return __async(this, arguments, function* (event, payload, opts = {}) {
      var _a2;
      const authorization = this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "";
      if (payload === void 0 || payload === null) {
        return Promise.reject("Payload is required for httpSend()");
      }
      const options = {
        method: "POST",
        headers: {
          Authorization: authorization,
          apikey: this.socket.apiKey ? this.socket.apiKey : "",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          messages: [
            {
              topic: this.subTopic,
              event,
              payload,
              private: this.private
            }
          ]
        })
      };
      const response = yield this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a2 = opts.timeout) !== null && _a2 !== void 0 ? _a2 : this.timeout);
      if (response.status === 202) {
        return { success: true };
      }
      let errorMessage = response.statusText;
      try {
        const errorBody = yield response.json();
        errorMessage = errorBody.error || errorBody.message || errorMessage;
      } catch (_b) {
      }
      return Promise.reject(new Error(errorMessage));
    });
  }
  /**
   * Sends a message into the channel.
   *
   * @param args Arguments to send to channel
   * @param args.type The type of event to send
   * @param args.event The name of the event being sent
   * @param args.payload Payload to be sent
   * @param opts Options to be used during the send process
   */
  send(_0) {
    return __async(this, arguments, function* (args, opts = {}) {
      var _a2, _b;
      if (!this._canPush() && args.type === "broadcast") {
        console.warn("Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.");
        const { event, payload: endpoint_payload } = args;
        const authorization = this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "";
        const options = {
          method: "POST",
          headers: {
            Authorization: authorization,
            apikey: this.socket.apiKey ? this.socket.apiKey : "",
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            messages: [
              {
                topic: this.subTopic,
                event,
                payload: endpoint_payload,
                private: this.private
              }
            ]
          })
        };
        try {
          const response = yield this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a2 = opts.timeout) !== null && _a2 !== void 0 ? _a2 : this.timeout);
          yield (_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel();
          return response.ok ? "ok" : "error";
        } catch (error) {
          if (error.name === "AbortError") {
            return "timed out";
          } else {
            return "error";
          }
        }
      } else {
        return new Promise((resolve) => {
          var _a3, _b2, _c;
          const push = this._push(args.type, args, opts.timeout || this.timeout);
          if (args.type === "broadcast" && !((_c = (_b2 = (_a3 = this.params) === null || _a3 === void 0 ? void 0 : _a3.config) === null || _b2 === void 0 ? void 0 : _b2.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {
            resolve("ok");
          }
          push.receive("ok", () => resolve("ok"));
          push.receive("error", () => resolve("error"));
          push.receive("timeout", () => resolve("timed out"));
        });
      }
    });
  }
  updateJoinPayload(payload) {
    this.joinPush.updatePayload(payload);
  }
  /**
   * Leaves the channel.
   *
   * Unsubscribes from server events, and instructs channel to terminate on server.
   * Triggers onClose() hooks.
   *
   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:
   * channel.unsubscribe().receive("ok", () => alert("left!") )
   */
  unsubscribe(timeout = this.timeout) {
    this.state = CHANNEL_STATES.leaving;
    const onClose = () => {
      this.socket.log("channel", `leave ${this.topic}`);
      this._trigger(CHANNEL_EVENTS.close, "leave", this._joinRef());
    };
    this.joinPush.destroy();
    let leavePush = null;
    return new Promise((resolve) => {
      leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);
      leavePush.receive("ok", () => {
        onClose();
        resolve("ok");
      }).receive("timeout", () => {
        onClose();
        resolve("timed out");
      }).receive("error", () => {
        resolve("error");
      });
      leavePush.send();
      if (!this._canPush()) {
        leavePush.trigger("ok", {});
      }
    }).finally(() => {
      leavePush === null || leavePush === void 0 ? void 0 : leavePush.destroy();
    });
  }
  /**
   * Teardown the channel.
   *
   * Destroys and stops related timers.
   */
  teardown() {
    this.pushBuffer.forEach((push) => push.destroy());
    this.pushBuffer = [];
    this.rejoinTimer.reset();
    this.joinPush.destroy();
    this.state = CHANNEL_STATES.closed;
    this.bindings = {};
  }
  /** @internal */
  _fetchWithTimeout(url, options, timeout) {
    return __async(this, null, function* () {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeout);
      const response = yield this.socket.fetch(url, Object.assign(Object.assign({}, options), { signal: controller.signal }));
      clearTimeout(id);
      return response;
    });
  }
  /** @internal */
  _push(event, payload, timeout = this.timeout) {
    if (!this.joinedOnce) {
      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
    }
    let pushEvent = new Push(this, event, payload, timeout);
    if (this._canPush()) {
      pushEvent.send();
    } else {
      this._addToPushBuffer(pushEvent);
    }
    return pushEvent;
  }
  /** @internal */
  _addToPushBuffer(pushEvent) {
    pushEvent.startTimeout();
    this.pushBuffer.push(pushEvent);
    if (this.pushBuffer.length > MAX_PUSH_BUFFER_SIZE) {
      const removedPush = this.pushBuffer.shift();
      if (removedPush) {
        removedPush.destroy();
        this.socket.log("channel", `discarded push due to buffer overflow: ${removedPush.event}`, removedPush.payload);
      }
    }
  }
  /**
   * Overridable message hook
   *
   * Receives all events for specialized message handling before dispatching to the channel callbacks.
   * Must return the payload, modified or unmodified.
   *
   * @internal
   */
  _onMessage(_event, payload, _ref) {
    return payload;
  }
  /** @internal */
  _isMember(topic) {
    return this.topic === topic;
  }
  /** @internal */
  _joinRef() {
    return this.joinPush.ref;
  }
  /** @internal */
  _trigger(type, payload, ref) {
    var _a2, _b;
    const typeLower = type.toLocaleLowerCase();
    const { close, error, leave, join } = CHANNEL_EVENTS;
    const events = [close, error, leave, join];
    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {
      return;
    }
    let handledPayload = this._onMessage(typeLower, payload, ref);
    if (payload && !handledPayload) {
      throw "channel onMessage callbacks must return the payload, modified or unmodified";
    }
    if (["insert", "update", "delete"].includes(typeLower)) {
      (_a2 = this.bindings.postgres_changes) === null || _a2 === void 0 ? void 0 : _a2.filter((bind) => {
        var _a3, _b2, _c;
        return ((_a3 = bind.filter) === null || _a3 === void 0 ? void 0 : _a3.event) === "*" || ((_c = (_b2 = bind.filter) === null || _b2 === void 0 ? void 0 : _b2.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;
      }).map((bind) => bind.callback(handledPayload, ref));
    } else {
      (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind) => {
        var _a3, _b2, _c, _d, _e, _f;
        if (["broadcast", "presence", "postgres_changes"].includes(typeLower)) {
          if ("id" in bind) {
            const bindId = bind.id;
            const bindEvent = (_a3 = bind.filter) === null || _a3 === void 0 ? void 0 : _a3.event;
            return bindId && ((_b2 = payload.ids) === null || _b2 === void 0 ? void 0 : _b2.includes(bindId)) && (bindEvent === "*" || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));
          } else {
            const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();
            return bindEvent === "*" || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());
          }
        } else {
          return bind.type.toLocaleLowerCase() === typeLower;
        }
      }).map((bind) => {
        if (typeof handledPayload === "object" && "ids" in handledPayload) {
          const postgresChanges = handledPayload.data;
          const { schema, table, commit_timestamp, type: type2, errors } = postgresChanges;
          const enrichedPayload = {
            schema,
            table,
            commit_timestamp,
            eventType: type2,
            new: {},
            old: {},
            errors
          };
          handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));
        }
        bind.callback(handledPayload, ref);
      });
    }
  }
  /** @internal */
  _isClosed() {
    return this.state === CHANNEL_STATES.closed;
  }
  /** @internal */
  _isJoined() {
    return this.state === CHANNEL_STATES.joined;
  }
  /** @internal */
  _isJoining() {
    return this.state === CHANNEL_STATES.joining;
  }
  /** @internal */
  _isLeaving() {
    return this.state === CHANNEL_STATES.leaving;
  }
  /** @internal */
  _replyEventName(ref) {
    return `chan_reply_${ref}`;
  }
  /** @internal */
  _on(type, filter, callback) {
    const typeLower = type.toLocaleLowerCase();
    const binding = {
      type: typeLower,
      filter,
      callback
    };
    if (this.bindings[typeLower]) {
      this.bindings[typeLower].push(binding);
    } else {
      this.bindings[typeLower] = [binding];
    }
    return this;
  }
  /** @internal */
  _off(type, filter) {
    const typeLower = type.toLocaleLowerCase();
    if (this.bindings[typeLower]) {
      this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {
        var _a2;
        return !(((_a2 = bind.type) === null || _a2 === void 0 ? void 0 : _a2.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));
      });
    }
    return this;
  }
  /** @internal */
  static isEqual(obj1, obj2) {
    if (Object.keys(obj1).length !== Object.keys(obj2).length) {
      return false;
    }
    for (const k in obj1) {
      if (obj1[k] !== obj2[k]) {
        return false;
      }
    }
    return true;
  }
  /** @internal */
  _rejoinUntilConnected() {
    this.rejoinTimer.scheduleTimeout();
    if (this.socket.isConnected()) {
      this._rejoin();
    }
  }
  /**
   * Registers a callback that will be executed when the channel closes.
   *
   * @internal
   */
  _onClose(callback) {
    this._on(CHANNEL_EVENTS.close, {}, callback);
  }
  /**
   * Registers a callback that will be executed when the channel encounteres an error.
   *
   * @internal
   */
  _onError(callback) {
    this._on(CHANNEL_EVENTS.error, {}, (reason) => callback(reason));
  }
  /**
   * Returns `true` if the socket is connected and the channel has been joined.
   *
   * @internal
   */
  _canPush() {
    return this.socket.isConnected() && this._isJoined();
  }
  /** @internal */
  _rejoin(timeout = this.timeout) {
    if (this._isLeaving()) {
      return;
    }
    this.socket._leaveOpenTopic(this.topic);
    this.state = CHANNEL_STATES.joining;
    this.joinPush.resend(timeout);
  }
  /** @internal */
  _getPayloadRecords(payload) {
    const records = {
      new: {},
      old: {}
    };
    if (payload.type === "INSERT" || payload.type === "UPDATE") {
      records.new = convertChangeData(payload.columns, payload.record);
    }
    if (payload.type === "UPDATE" || payload.type === "DELETE") {
      records.old = convertChangeData(payload.columns, payload.old_record);
    }
    return records;
  }
}
const noop = () => {
};
const CONNECTION_TIMEOUTS = {
  HEARTBEAT_INTERVAL: 25e3,
  RECONNECT_DELAY: 10,
  HEARTBEAT_TIMEOUT_FALLBACK: 100
};
const RECONNECT_INTERVALS = [1e3, 2e3, 5e3, 1e4];
const DEFAULT_RECONNECT_FALLBACK = 1e4;
const WORKER_SCRIPT = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;
class RealtimeClient {
  /**
   * Initializes the Socket.
   *
   * @param endPoint The string WebSocket endpoint, ie, "ws://example.com/socket", "wss://example.com", "/socket" (inherited host & protocol)
   * @param httpEndpoint The string HTTP endpoint, ie, "https://example.com", "/" (inherited host & protocol)
   * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation
   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.
   * @param options.params The optional params to pass when connecting.
   * @param options.headers Deprecated: headers cannot be set on websocket connections and this option will be removed in the future.
   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.
   * @param options.heartbeatCallback The optional function to handle heartbeat status.
   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }
   * @param options.logLevel Sets the log level for Realtime
   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))
   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.
   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.
   * @param options.worker Use Web Worker to set a side flow. Defaults to false.
   * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.
   */
  constructor(endPoint, options) {
    var _a2;
    this.accessTokenValue = null;
    this.apiKey = null;
    this.channels = new Array();
    this.endPoint = "";
    this.httpEndpoint = "";
    this.headers = {};
    this.params = {};
    this.timeout = DEFAULT_TIMEOUT;
    this.transport = null;
    this.heartbeatIntervalMs = CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;
    this.heartbeatTimer = void 0;
    this.pendingHeartbeatRef = null;
    this.heartbeatCallback = noop;
    this.ref = 0;
    this.reconnectTimer = null;
    this.logger = noop;
    this.conn = null;
    this.sendBuffer = [];
    this.serializer = new Serializer();
    this.stateChangeCallbacks = {
      open: [],
      close: [],
      error: [],
      message: []
    };
    this.accessToken = null;
    this._connectionState = "disconnected";
    this._wasManualDisconnect = false;
    this._authPromise = null;
    this._resolveFetch = (customFetch) => {
      let _fetch;
      if (customFetch) {
        _fetch = customFetch;
      } else if (typeof fetch === "undefined") {
        _fetch = (...args) => __vitePreload(() => __async(this, null, function* () {
          const { default: fetch2 } = yield Promise.resolve().then(() => browser);
          return { default: fetch2 };
        }), true ? void 0 : void 0, import.meta.url).then(({ default: fetch2 }) => fetch2(...args)).catch((error) => {
          throw new Error(`Failed to load @supabase/node-fetch: ${error.message}. This is required for HTTP requests in Node.js environments without native fetch.`);
        });
      } else {
        _fetch = fetch;
      }
      return (...args) => _fetch(...args);
    };
    if (!((_a2 = options === null || options === void 0 ? void 0 : options.params) === null || _a2 === void 0 ? void 0 : _a2.apikey)) {
      throw new Error("API key is required to connect to Realtime");
    }
    this.apiKey = options.params.apikey;
    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
    this.httpEndpoint = httpEndpointURL(endPoint);
    this._initializeOptions(options);
    this._setupReconnectionTimer();
    this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);
  }
  /**
   * Connects the socket, unless already connected.
   */
  connect() {
    if (this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected()) {
      return;
    }
    this._setConnectionState("connecting");
    this._setAuthSafely("connect");
    if (this.transport) {
      this.conn = new this.transport(this.endpointURL());
    } else {
      try {
        this.conn = WebSocketFactory.createWebSocket(this.endpointURL());
      } catch (error) {
        this._setConnectionState("disconnected");
        const errorMessage = error.message;
        if (errorMessage.includes("Node.js")) {
          throw new Error(`${errorMessage}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`);
        }
        throw new Error(`WebSocket not available: ${errorMessage}`);
      }
    }
    this._setupConnectionHandlers();
  }
  /**
   * Returns the URL of the websocket.
   * @returns string The URL of the websocket.
   */
  endpointURL() {
    return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: VSN }));
  }
  /**
   * Disconnects the socket.
   *
   * @param code A numeric status code to send on disconnect.
   * @param reason A custom reason for the disconnect.
   */
  disconnect(code, reason) {
    if (this.isDisconnecting()) {
      return;
    }
    this._setConnectionState("disconnecting", true);
    if (this.conn) {
      const fallbackTimer = setTimeout(() => {
        this._setConnectionState("disconnected");
      }, 100);
      this.conn.onclose = () => {
        clearTimeout(fallbackTimer);
        this._setConnectionState("disconnected");
      };
      if (code) {
        this.conn.close(code, reason !== null && reason !== void 0 ? reason : "");
      } else {
        this.conn.close();
      }
      this._teardownConnection();
    } else {
      this._setConnectionState("disconnected");
    }
  }
  /**
   * Returns all created channels
   */
  getChannels() {
    return this.channels;
  }
  /**
   * Unsubscribes and removes a single channel
   * @param channel A RealtimeChannel instance
   */
  removeChannel(channel) {
    return __async(this, null, function* () {
      const status = yield channel.unsubscribe();
      if (this.channels.length === 0) {
        this.disconnect();
      }
      return status;
    });
  }
  /**
   * Unsubscribes and removes all channels
   */
  removeAllChannels() {
    return __async(this, null, function* () {
      const values_1 = yield Promise.all(this.channels.map((channel) => channel.unsubscribe()));
      this.channels = [];
      this.disconnect();
      return values_1;
    });
  }
  /**
   * Logs the message.
   *
   * For customized logging, `this.logger` can be overridden.
   */
  log(kind, msg, data) {
    this.logger(kind, msg, data);
  }
  /**
   * Returns the current state of the socket.
   */
  connectionState() {
    switch (this.conn && this.conn.readyState) {
      case SOCKET_STATES.connecting:
        return CONNECTION_STATE.Connecting;
      case SOCKET_STATES.open:
        return CONNECTION_STATE.Open;
      case SOCKET_STATES.closing:
        return CONNECTION_STATE.Closing;
      default:
        return CONNECTION_STATE.Closed;
    }
  }
  /**
   * Returns `true` is the connection is open.
   */
  isConnected() {
    return this.connectionState() === CONNECTION_STATE.Open;
  }
  /**
   * Returns `true` if the connection is currently connecting.
   */
  isConnecting() {
    return this._connectionState === "connecting";
  }
  /**
   * Returns `true` if the connection is currently disconnecting.
   */
  isDisconnecting() {
    return this._connectionState === "disconnecting";
  }
  channel(topic, params = { config: {} }) {
    const realtimeTopic = `realtime:${topic}`;
    const exists = this.getChannels().find((c) => c.topic === realtimeTopic);
    if (!exists) {
      const chan = new RealtimeChannel(`realtime:${topic}`, params, this);
      this.channels.push(chan);
      return chan;
    } else {
      return exists;
    }
  }
  /**
   * Push out a message if the socket is connected.
   *
   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.
   */
  push(data) {
    const { topic, event, payload, ref } = data;
    const callback = () => {
      this.encode(data, (result) => {
        var _a2;
        (_a2 = this.conn) === null || _a2 === void 0 ? void 0 : _a2.send(result);
      });
    };
    this.log("push", `${topic} ${event} (${ref})`, payload);
    if (this.isConnected()) {
      callback();
    } else {
      this.sendBuffer.push(callback);
    }
  }
  /**
   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.
   *
   * If param is null it will use the `accessToken` callback function or the token set on the client.
   *
   * On callback used, it will set the value of the token internal to the client.
   *
   * @param token A JWT string to override the token set on the client.
   */
  setAuth(token2 = null) {
    return __async(this, null, function* () {
      this._authPromise = this._performAuth(token2);
      try {
        yield this._authPromise;
      } finally {
        this._authPromise = null;
      }
    });
  }
  /**
   * Sends a heartbeat message if the socket is connected.
   */
  sendHeartbeat() {
    return __async(this, null, function* () {
      var _a2;
      if (!this.isConnected()) {
        try {
          this.heartbeatCallback("disconnected");
        } catch (e) {
          this.log("error", "error in heartbeat callback", e);
        }
        return;
      }
      if (this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null;
        this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
        try {
          this.heartbeatCallback("timeout");
        } catch (e) {
          this.log("error", "error in heartbeat callback", e);
        }
        this._wasManualDisconnect = false;
        (_a2 = this.conn) === null || _a2 === void 0 ? void 0 : _a2.close(WS_CLOSE_NORMAL, "heartbeat timeout");
        setTimeout(() => {
          var _a3;
          if (!this.isConnected()) {
            (_a3 = this.reconnectTimer) === null || _a3 === void 0 ? void 0 : _a3.scheduleTimeout();
          }
        }, CONNECTION_TIMEOUTS.HEARTBEAT_TIMEOUT_FALLBACK);
        return;
      }
      this.pendingHeartbeatRef = this._makeRef();
      this.push({
        topic: "phoenix",
        event: "heartbeat",
        payload: {},
        ref: this.pendingHeartbeatRef
      });
      try {
        this.heartbeatCallback("sent");
      } catch (e) {
        this.log("error", "error in heartbeat callback", e);
      }
      this._setAuthSafely("heartbeat");
    });
  }
  onHeartbeat(callback) {
    this.heartbeatCallback = callback;
  }
  /**
   * Flushes send buffer
   */
  flushSendBuffer() {
    if (this.isConnected() && this.sendBuffer.length > 0) {
      this.sendBuffer.forEach((callback) => callback());
      this.sendBuffer = [];
    }
  }
  /**
   * Return the next message ref, accounting for overflows
   *
   * @internal
   */
  _makeRef() {
    let newRef = this.ref + 1;
    if (newRef === this.ref) {
      this.ref = 0;
    } else {
      this.ref = newRef;
    }
    return this.ref.toString();
  }
  /**
   * Unsubscribe from channels with the specified topic.
   *
   * @internal
   */
  _leaveOpenTopic(topic) {
    let dupChannel = this.channels.find((c) => c.topic === topic && (c._isJoined() || c._isJoining()));
    if (dupChannel) {
      this.log("transport", `leaving duplicate topic "${topic}"`);
      dupChannel.unsubscribe();
    }
  }
  /**
   * Removes a subscription from the socket.
   *
   * @param channel An open subscription.
   *
   * @internal
   */
  _remove(channel) {
    this.channels = this.channels.filter((c) => c.topic !== channel.topic);
  }
  /** @internal */
  _onConnMessage(rawMessage) {
    this.decode(rawMessage.data, (msg) => {
      if (msg.topic === "phoenix" && msg.event === "phx_reply") {
        try {
          this.heartbeatCallback(msg.payload.status === "ok" ? "ok" : "error");
        } catch (e) {
          this.log("error", "error in heartbeat callback", e);
        }
      }
      if (msg.ref && msg.ref === this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null;
      }
      const { topic, event, payload, ref } = msg;
      const refString = ref ? `(${ref})` : "";
      const status = payload.status || "";
      this.log("receive", `${status} ${topic} ${event} ${refString}`.trim(), payload);
      this.channels.filter((channel) => channel._isMember(topic)).forEach((channel) => channel._trigger(event, payload, ref));
      this._triggerStateCallbacks("message", msg);
    });
  }
  /**
   * Clear specific timer
   * @internal
   */
  _clearTimer(timer) {
    var _a2;
    if (timer === "heartbeat" && this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = void 0;
    } else if (timer === "reconnect") {
      (_a2 = this.reconnectTimer) === null || _a2 === void 0 ? void 0 : _a2.reset();
    }
  }
  /**
   * Clear all timers
   * @internal
   */
  _clearAllTimers() {
    this._clearTimer("heartbeat");
    this._clearTimer("reconnect");
  }
  /**
   * Setup connection handlers for WebSocket events
   * @internal
   */
  _setupConnectionHandlers() {
    if (!this.conn)
      return;
    if ("binaryType" in this.conn) {
      this.conn.binaryType = "arraybuffer";
    }
    this.conn.onopen = () => this._onConnOpen();
    this.conn.onerror = (error) => this._onConnError(error);
    this.conn.onmessage = (event) => this._onConnMessage(event);
    this.conn.onclose = (event) => this._onConnClose(event);
  }
  /**
   * Teardown connection and cleanup resources
   * @internal
   */
  _teardownConnection() {
    if (this.conn) {
      this.conn.onopen = null;
      this.conn.onerror = null;
      this.conn.onmessage = null;
      this.conn.onclose = null;
      this.conn = null;
    }
    this._clearAllTimers();
    this.channels.forEach((channel) => channel.teardown());
  }
  /** @internal */
  _onConnOpen() {
    this._setConnectionState("connected");
    this.log("transport", `connected to ${this.endpointURL()}`);
    this.flushSendBuffer();
    this._clearTimer("reconnect");
    if (!this.worker) {
      this._startHeartbeat();
    } else {
      if (!this.workerRef) {
        this._startWorkerHeartbeat();
      }
    }
    this._triggerStateCallbacks("open");
  }
  /** @internal */
  _startHeartbeat() {
    this.heartbeatTimer && clearInterval(this.heartbeatTimer);
    this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
  }
  /** @internal */
  _startWorkerHeartbeat() {
    if (this.workerUrl) {
      this.log("worker", `starting worker for from ${this.workerUrl}`);
    } else {
      this.log("worker", `starting default worker`);
    }
    const objectUrl = this._workerObjectUrl(this.workerUrl);
    this.workerRef = new Worker(objectUrl);
    this.workerRef.onerror = (error) => {
      this.log("worker", "worker error", error.message);
      this.workerRef.terminate();
    };
    this.workerRef.onmessage = (event) => {
      if (event.data.event === "keepAlive") {
        this.sendHeartbeat();
      }
    };
    this.workerRef.postMessage({
      event: "start",
      interval: this.heartbeatIntervalMs
    });
  }
  /** @internal */
  _onConnClose(event) {
    var _a2;
    this._setConnectionState("disconnected");
    this.log("transport", "close", event);
    this._triggerChanError();
    this._clearTimer("heartbeat");
    if (!this._wasManualDisconnect) {
      (_a2 = this.reconnectTimer) === null || _a2 === void 0 ? void 0 : _a2.scheduleTimeout();
    }
    this._triggerStateCallbacks("close", event);
  }
  /** @internal */
  _onConnError(error) {
    this._setConnectionState("disconnected");
    this.log("transport", `${error}`);
    this._triggerChanError();
    this._triggerStateCallbacks("error", error);
  }
  /** @internal */
  _triggerChanError() {
    this.channels.forEach((channel) => channel._trigger(CHANNEL_EVENTS.error));
  }
  /** @internal */
  _appendParams(url, params) {
    if (Object.keys(params).length === 0) {
      return url;
    }
    const prefix2 = url.match(/\?/) ? "&" : "?";
    const query = new URLSearchParams(params);
    return `${url}${prefix2}${query}`;
  }
  _workerObjectUrl(url) {
    let result_url;
    if (url) {
      result_url = url;
    } else {
      const blob = new Blob([WORKER_SCRIPT], { type: "application/javascript" });
      result_url = URL.createObjectURL(blob);
    }
    return result_url;
  }
  /**
   * Set connection state with proper state management
   * @internal
   */
  _setConnectionState(state, manual = false) {
    this._connectionState = state;
    if (state === "connecting") {
      this._wasManualDisconnect = false;
    } else if (state === "disconnecting") {
      this._wasManualDisconnect = manual;
    }
  }
  /**
   * Perform the actual auth operation
   * @internal
   */
  _performAuth(token2 = null) {
    return __async(this, null, function* () {
      let tokenToSend;
      if (token2) {
        tokenToSend = token2;
      } else if (this.accessToken) {
        tokenToSend = yield this.accessToken();
      } else {
        tokenToSend = this.accessTokenValue;
      }
      if (this.accessTokenValue != tokenToSend) {
        this.accessTokenValue = tokenToSend;
        this.channels.forEach((channel) => {
          const payload = {
            access_token: tokenToSend,
            version: DEFAULT_VERSION
          };
          tokenToSend && channel.updateJoinPayload(payload);
          if (channel.joinedOnce && channel._isJoined()) {
            channel._push(CHANNEL_EVENTS.access_token, {
              access_token: tokenToSend
            });
          }
        });
      }
    });
  }
  /**
   * Wait for any in-flight auth operations to complete
   * @internal
   */
  _waitForAuthIfNeeded() {
    return __async(this, null, function* () {
      if (this._authPromise) {
        yield this._authPromise;
      }
    });
  }
  /**
   * Safely call setAuth with standardized error handling
   * @internal
   */
  _setAuthSafely(context = "general") {
    this.setAuth().catch((e) => {
      this.log("error", `error setting auth in ${context}`, e);
    });
  }
  /**
   * Trigger state change callbacks with proper error handling
   * @internal
   */
  _triggerStateCallbacks(event, data) {
    try {
      this.stateChangeCallbacks[event].forEach((callback) => {
        try {
          callback(data);
        } catch (e) {
          this.log("error", `error in ${event} callback`, e);
        }
      });
    } catch (e) {
      this.log("error", `error triggering ${event} callbacks`, e);
    }
  }
  /**
   * Setup reconnection timer with proper configuration
   * @internal
   */
  _setupReconnectionTimer() {
    this.reconnectTimer = new Timer(() => __async(this, null, function* () {
      setTimeout(() => __async(this, null, function* () {
        yield this._waitForAuthIfNeeded();
        if (!this.isConnected()) {
          this.connect();
        }
      }), CONNECTION_TIMEOUTS.RECONNECT_DELAY);
    }), this.reconnectAfterMs);
  }
  /**
   * Initialize client options with defaults
   * @internal
   */
  _initializeOptions(options) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j;
    this.transport = (_a2 = options === null || options === void 0 ? void 0 : options.transport) !== null && _a2 !== void 0 ? _a2 : null;
    this.timeout = (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : DEFAULT_TIMEOUT;
    this.heartbeatIntervalMs = (_c = options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) !== null && _c !== void 0 ? _c : CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;
    this.worker = (_d = options === null || options === void 0 ? void 0 : options.worker) !== null && _d !== void 0 ? _d : false;
    this.accessToken = (_e = options === null || options === void 0 ? void 0 : options.accessToken) !== null && _e !== void 0 ? _e : null;
    this.heartbeatCallback = (_f = options === null || options === void 0 ? void 0 : options.heartbeatCallback) !== null && _f !== void 0 ? _f : noop;
    if (options === null || options === void 0 ? void 0 : options.params)
      this.params = options.params;
    if (options === null || options === void 0 ? void 0 : options.logger)
      this.logger = options.logger;
    if ((options === null || options === void 0 ? void 0 : options.logLevel) || (options === null || options === void 0 ? void 0 : options.log_level)) {
      this.logLevel = options.logLevel || options.log_level;
      this.params = Object.assign(Object.assign({}, this.params), { log_level: this.logLevel });
    }
    this.reconnectAfterMs = (_g = options === null || options === void 0 ? void 0 : options.reconnectAfterMs) !== null && _g !== void 0 ? _g : ((tries) => {
      return RECONNECT_INTERVALS[tries - 1] || DEFAULT_RECONNECT_FALLBACK;
    });
    this.encode = (_h = options === null || options === void 0 ? void 0 : options.encode) !== null && _h !== void 0 ? _h : ((payload, callback) => {
      return callback(JSON.stringify(payload));
    });
    this.decode = (_j = options === null || options === void 0 ? void 0 : options.decode) !== null && _j !== void 0 ? _j : this.serializer.decode.bind(this.serializer);
    if (this.worker) {
      if (typeof window !== "undefined" && !window.Worker) {
        throw new Error("Web Worker is not supported");
      }
      this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;
    }
  }
}
class StorageError extends Error {
  constructor(message) {
    super(message);
    this.__isStorageError = true;
    this.name = "StorageError";
  }
}
function isStorageError(error) {
  return typeof error === "object" && error !== null && "__isStorageError" in error;
}
class StorageApiError extends StorageError {
  constructor(message, status, statusCode) {
    super(message);
    this.name = "StorageApiError";
    this.status = status;
    this.statusCode = statusCode;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      statusCode: this.statusCode
    };
  }
}
class StorageUnknownError extends StorageError {
  constructor(message, originalError) {
    super(message);
    this.name = "StorageUnknownError";
    this.originalError = originalError;
  }
}
const resolveFetch$3 = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = (...args) => __vitePreload(() => __async(null, null, function* () {
      const { default: fetch2 } = yield Promise.resolve().then(() => browser);
      return { default: fetch2 };
    }), true ? void 0 : void 0, import.meta.url).then(({ default: fetch2 }) => fetch2(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
const resolveResponse = () => __awaiter(void 0, void 0, void 0, function* () {
  if (typeof Response === "undefined") {
    return (yield __vitePreload(() => Promise.resolve().then(() => browser), true ? void 0 : void 0, import.meta.url)).Response;
  }
  return Response;
});
const recursiveToCamel = (item) => {
  if (Array.isArray(item)) {
    return item.map((el) => recursiveToCamel(el));
  } else if (typeof item === "function" || item !== Object(item)) {
    return item;
  }
  const result = {};
  Object.entries(item).forEach(([key, value]) => {
    const newKey = key.replace(/([-_][a-z])/gi, (c) => c.toUpperCase().replace(/[-_]/g, ""));
    result[newKey] = recursiveToCamel(value);
  });
  return result;
};
const isPlainObject$1 = (value) => {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
};
const _getErrorMessage$2 = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
const handleError$2 = (error, reject, options) => __awaiter(void 0, void 0, void 0, function* () {
  const Res = yield resolveResponse();
  if (error instanceof Res && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {
    error.json().then((err) => {
      const status = error.status || 500;
      const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || status + "";
      reject(new StorageApiError(_getErrorMessage$2(err), status, statusCode));
    }).catch((err) => {
      reject(new StorageUnknownError(_getErrorMessage$2(err), err));
    });
  } else {
    reject(new StorageUnknownError(_getErrorMessage$2(error), error));
  }
});
const _getRequestParams$2 = (method, options, parameters, body2) => {
  const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
  if (method === "GET" || !body2) {
    return params;
  }
  if (isPlainObject$1(body2)) {
    params.headers = Object.assign({ "Content-Type": "application/json" }, options === null || options === void 0 ? void 0 : options.headers);
    params.body = JSON.stringify(body2);
  } else {
    params.body = body2;
  }
  if (options === null || options === void 0 ? void 0 : options.duplex) {
    params.duplex = options.duplex;
  }
  return Object.assign(Object.assign({}, params), parameters);
};
function _handleRequest$2(fetcher, method, url, options, parameters, body2) {
  return __awaiter(this, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
      fetcher(url, _getRequestParams$2(method, options, parameters, body2)).then((result) => {
        if (!result.ok)
          throw result;
        if (options === null || options === void 0 ? void 0 : options.noResolveJson)
          return result;
        return result.json();
      }).then((data) => resolve(data)).catch((error) => handleError$2(error, reject, options));
    });
  });
}
function get(fetcher, url, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest$2(fetcher, "GET", url, options, parameters);
  });
}
function post$1(fetcher, url, body2, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest$2(fetcher, "POST", url, options, parameters, body2);
  });
}
function put(fetcher, url, body2, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest$2(fetcher, "PUT", url, options, parameters, body2);
  });
}
function head(fetcher, url, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest$2(fetcher, "HEAD", url, Object.assign(Object.assign({}, options), { noResolveJson: true }), parameters);
  });
}
function remove(fetcher, url, body2, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest$2(fetcher, "DELETE", url, options, parameters, body2);
  });
}
class StreamDownloadBuilder {
  constructor(downloadFn, shouldThrowOnError) {
    this.downloadFn = downloadFn;
    this.shouldThrowOnError = shouldThrowOnError;
  }
  then(onfulfilled, onrejected) {
    return this.execute().then(onfulfilled, onrejected);
  }
  execute() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const result = yield this.downloadFn();
        return {
          data: result.body,
          error: null
        };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
}
var _a;
class BlobDownloadBuilder {
  constructor(downloadFn, shouldThrowOnError) {
    this.downloadFn = downloadFn;
    this.shouldThrowOnError = shouldThrowOnError;
    this[_a] = "BlobDownloadBuilder";
    this.promise = null;
  }
  asStream() {
    return new StreamDownloadBuilder(this.downloadFn, this.shouldThrowOnError);
  }
  then(onfulfilled, onrejected) {
    return this.getPromise().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.getPromise().catch(onrejected);
  }
  finally(onfinally) {
    return this.getPromise().finally(onfinally);
  }
  getPromise() {
    if (!this.promise) {
      this.promise = this.execute();
    }
    return this.promise;
  }
  execute() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const result = yield this.downloadFn();
        return {
          data: yield result.blob(),
          error: null
        };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
}
_a = Symbol.toStringTag;
const DEFAULT_SEARCH_OPTIONS = {
  limit: 100,
  offset: 0,
  sortBy: {
    column: "name",
    order: "asc"
  }
};
const DEFAULT_FILE_OPTIONS = {
  cacheControl: "3600",
  contentType: "text/plain;charset=UTF-8",
  upsert: false
};
class StorageFileApi {
  constructor(url, headers = {}, bucketId, fetch2) {
    this.shouldThrowOnError = false;
    this.url = url;
    this.headers = headers;
    this.bucketId = bucketId;
    this.fetch = resolveFetch$3(fetch2);
  }
  /**
   * Enable throwing errors instead of returning them.
   */
  throwOnError() {
    this.shouldThrowOnError = true;
    return this;
  }
  /**
   * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.
   *
   * @param method HTTP method.
   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  uploadOrUpdate(method, path, fileBody, fileOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        let body2;
        const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);
        let headers = Object.assign(Object.assign({}, this.headers), method === "POST" && { "x-upsert": String(options.upsert) });
        const metadata = options.metadata;
        if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
          body2 = new FormData();
          body2.append("cacheControl", options.cacheControl);
          if (metadata) {
            body2.append("metadata", this.encodeMetadata(metadata));
          }
          body2.append("", fileBody);
        } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
          body2 = fileBody;
          body2.append("cacheControl", options.cacheControl);
          if (metadata) {
            body2.append("metadata", this.encodeMetadata(metadata));
          }
        } else {
          body2 = fileBody;
          headers["cache-control"] = `max-age=${options.cacheControl}`;
          headers["content-type"] = options.contentType;
          if (metadata) {
            headers["x-metadata"] = this.toBase64(this.encodeMetadata(metadata));
          }
        }
        if (fileOptions === null || fileOptions === void 0 ? void 0 : fileOptions.headers) {
          headers = Object.assign(Object.assign({}, headers), fileOptions.headers);
        }
        const cleanPath = this._removeEmptyFolders(path);
        const _path = this._getFinalPath(cleanPath);
        const data = yield (method == "PUT" ? put : post$1)(this.fetch, `${this.url}/object/${_path}`, body2, Object.assign({ headers }, (options === null || options === void 0 ? void 0 : options.duplex) ? { duplex: options.duplex } : {}));
        return {
          data: { path: cleanPath, id: data.Id, fullPath: data.Key },
          error: null
        };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Uploads a file to an existing bucket.
   *
   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  upload(path, fileBody, fileOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("POST", path, fileBody, fileOptions);
    });
  }
  /**
   * Upload a file with a token generated from `createSignedUploadUrl`.
   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param token The token generated from `createSignedUploadUrl`
   * @param fileBody The body of the file to be stored in the bucket.
   */
  uploadToSignedUrl(path, token2, fileBody, fileOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      const cleanPath = this._removeEmptyFolders(path);
      const _path = this._getFinalPath(cleanPath);
      const url = new URL(this.url + `/object/upload/sign/${_path}`);
      url.searchParams.set("token", token2);
      try {
        let body2;
        const options = Object.assign({ upsert: DEFAULT_FILE_OPTIONS.upsert }, fileOptions);
        const headers = Object.assign(Object.assign({}, this.headers), { "x-upsert": String(options.upsert) });
        if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
          body2 = new FormData();
          body2.append("cacheControl", options.cacheControl);
          body2.append("", fileBody);
        } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
          body2 = fileBody;
          body2.append("cacheControl", options.cacheControl);
        } else {
          body2 = fileBody;
          headers["cache-control"] = `max-age=${options.cacheControl}`;
          headers["content-type"] = options.contentType;
        }
        const data = yield put(this.fetch, url.toString(), body2, { headers });
        return {
          data: { path: cleanPath, fullPath: data.Key },
          error: null
        };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a signed upload URL.
   * Signed upload URLs can be used to upload files to the bucket without further authentication.
   * They are valid for 2 hours.
   * @param path The file path, including the current file name. For example `folder/image.png`.
   * @param options.upsert If set to true, allows the file to be overwritten if it already exists.
   */
  createSignedUploadUrl(path, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        let _path = this._getFinalPath(path);
        const headers = Object.assign({}, this.headers);
        if (options === null || options === void 0 ? void 0 : options.upsert) {
          headers["x-upsert"] = "true";
        }
        const data = yield post$1(this.fetch, `${this.url}/object/upload/sign/${_path}`, {}, { headers });
        const url = new URL(this.url + data.url);
        const token2 = url.searchParams.get("token");
        if (!token2) {
          throw new StorageError("No token returned by API");
        }
        return { data: { signedUrl: url.toString(), path, token: token2 }, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Replaces an existing file at the specified path with a new one.
   *
   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  update(path, fileBody, fileOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("PUT", path, fileBody, fileOptions);
    });
  }
  /**
   * Moves an existing file to a new path in the same bucket.
   *
   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
   * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.
   * @param options The destination options.
   */
  move(fromPath, toPath, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post$1(this.fetch, `${this.url}/object/move`, {
          bucketId: this.bucketId,
          sourceKey: fromPath,
          destinationKey: toPath,
          destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
        }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Copies an existing file to a new path in the same bucket.
   *
   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
   * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.
   * @param options The destination options.
   */
  copy(fromPath, toPath, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post$1(this.fetch, `${this.url}/object/copy`, {
          bucketId: this.bucketId,
          sourceKey: fromPath,
          destinationKey: toPath,
          destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
        }, { headers: this.headers });
        return { data: { path: data.Key }, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.
   *
   * @param path The file path, including the current file name. For example `folder/image.png`.
   * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.
   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   * @param options.transform Transform the asset before serving it to the client.
   */
  createSignedUrl(path, expiresIn, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        let _path = this._getFinalPath(path);
        let data = yield post$1(this.fetch, `${this.url}/object/sign/${_path}`, Object.assign({ expiresIn }, (options === null || options === void 0 ? void 0 : options.transform) ? { transform: options.transform } : {}), { headers: this.headers });
        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
        const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`);
        data = { signedUrl };
        return { data, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.
   *
   * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.
   * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.
   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   */
  createSignedUrls(paths, expiresIn, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post$1(this.fetch, `${this.url}/object/sign/${this.bucketId}`, { expiresIn, paths }, { headers: this.headers });
        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
        return {
          data: data.map((datum) => Object.assign(Object.assign({}, datum), { signedUrl: datum.signedURL ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`) : null })),
          error: null
        };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.
   *
   * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.
   * @param options.transform Transform the asset before serving it to the client.
   */
  download(path, options) {
    const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined";
    const renderPath = wantsTransformation ? "render/image/authenticated" : "object";
    const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
    const queryString = transformationQuery ? `?${transformationQuery}` : "";
    const _path = this._getFinalPath(path);
    const downloadFn = () => get(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {
      headers: this.headers,
      noResolveJson: true
    });
    return new BlobDownloadBuilder(downloadFn, this.shouldThrowOnError);
  }
  /**
   * Retrieves the details of an existing file.
   * @param path
   */
  info(path) {
    return __awaiter(this, void 0, void 0, function* () {
      const _path = this._getFinalPath(path);
      try {
        const data = yield get(this.fetch, `${this.url}/object/info/${_path}`, {
          headers: this.headers
        });
        return { data: recursiveToCamel(data), error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Checks the existence of a file.
   * @param path
   */
  exists(path) {
    return __awaiter(this, void 0, void 0, function* () {
      const _path = this._getFinalPath(path);
      try {
        yield head(this.fetch, `${this.url}/object/${_path}`, {
          headers: this.headers
        });
        return { data: true, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error) && error instanceof StorageUnknownError) {
          const originalError = error.originalError;
          if ([400, 404].includes(originalError === null || originalError === void 0 ? void 0 : originalError.status)) {
            return { data: false, error };
          }
        }
        throw error;
      }
    });
  }
  /**
   * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.
   * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.
   *
   * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.
   * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   * @param options.transform Transform the asset before serving it to the client.
   */
  getPublicUrl(path, options) {
    const _path = this._getFinalPath(path);
    const _queryString = [];
    const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `download=${options.download === true ? "" : options.download}` : "";
    if (downloadQueryParam !== "") {
      _queryString.push(downloadQueryParam);
    }
    const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined";
    const renderPath = wantsTransformation ? "render/image" : "object";
    const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
    if (transformationQuery !== "") {
      _queryString.push(transformationQuery);
    }
    let queryString = _queryString.join("&");
    if (queryString !== "") {
      queryString = `?${queryString}`;
    }
    return {
      data: { publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`) }
    };
  }
  /**
   * Deletes files within the same bucket
   *
   * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].
   */
  remove(paths) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield remove(this.fetch, `${this.url}/object/${this.bucketId}`, { prefixes: paths }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Get file metadata
   * @param id the file id to retrieve metadata
   */
  // async getMetadata(
  //   id: string
  // ): Promise<
  //   | {
  //       data: Metadata
  //       error: null
  //     }
  //   | {
  //       data: null
  //       error: StorageError
  //     }
  // > {
  //   try {
  //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })
  //     return { data, error: null }
  //   } catch (error) {
  //     if (isStorageError(error)) {
  //       return { data: null, error }
  //     }
  //     throw error
  //   }
  // }
  /**
   * Update file metadata
   * @param id the file id to update metadata
   * @param meta the new file metadata
   */
  // async updateMetadata(
  //   id: string,
  //   meta: Metadata
  // ): Promise<
  //   | {
  //       data: Metadata
  //       error: null
  //     }
  //   | {
  //       data: null
  //       error: StorageError
  //     }
  // > {
  //   try {
  //     const data = await post(
  //       this.fetch,
  //       `${this.url}/metadata/${id}`,
  //       { ...meta },
  //       { headers: this.headers }
  //     )
  //     return { data, error: null }
  //   } catch (error) {
  //     if (isStorageError(error)) {
  //       return { data: null, error }
  //     }
  //     throw error
  //   }
  // }
  /**
   * Lists all the files and folders within a path of the bucket.
   * @param path The folder path.
   * @param options Search options including limit (defaults to 100), offset, sortBy, and search
   */
  list(path, options, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const body2 = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), { prefix: path || "" });
        const data = yield post$1(this.fetch, `${this.url}/object/list/${this.bucketId}`, body2, { headers: this.headers }, parameters);
        return { data, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * @experimental this method signature might change in the future
   * @param options search options
   * @param parameters
   */
  listV2(options, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const body2 = Object.assign({}, options);
        const data = yield post$1(this.fetch, `${this.url}/object/list-v2/${this.bucketId}`, body2, { headers: this.headers }, parameters);
        return { data, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  encodeMetadata(metadata) {
    return JSON.stringify(metadata);
  }
  toBase64(data) {
    if (typeof Buffer !== "undefined") {
      return Buffer.from(data).toString("base64");
    }
    return btoa(data);
  }
  _getFinalPath(path) {
    return `${this.bucketId}/${path.replace(/^\/+/, "")}`;
  }
  _removeEmptyFolders(path) {
    return path.replace(/^\/|\/$/g, "").replace(/\/+/g, "/");
  }
  transformOptsToQueryString(transform) {
    const params = [];
    if (transform.width) {
      params.push(`width=${transform.width}`);
    }
    if (transform.height) {
      params.push(`height=${transform.height}`);
    }
    if (transform.resize) {
      params.push(`resize=${transform.resize}`);
    }
    if (transform.format) {
      params.push(`format=${transform.format}`);
    }
    if (transform.quality) {
      params.push(`quality=${transform.quality}`);
    }
    return params.join("&");
  }
}
const version$4 = "2.76.1";
const DEFAULT_HEADERS$3 = {
  "X-Client-Info": `storage-js/${version$4}`
};
class StorageBucketApi {
  constructor(url, headers = {}, fetch2, opts) {
    this.shouldThrowOnError = false;
    const baseUrl = new URL(url);
    if (opts === null || opts === void 0 ? void 0 : opts.useNewHostname) {
      const isSupabaseHost = /supabase\.(co|in|red)$/.test(baseUrl.hostname);
      if (isSupabaseHost && !baseUrl.hostname.includes("storage.supabase.")) {
        baseUrl.hostname = baseUrl.hostname.replace("supabase.", "storage.supabase.");
      }
    }
    this.url = baseUrl.href.replace(/\/$/, "");
    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS$3), headers);
    this.fetch = resolveFetch$3(fetch2);
  }
  /**
   * Enable throwing errors instead of returning them.
   */
  throwOnError() {
    this.shouldThrowOnError = true;
    return this;
  }
  /**
   * Retrieves the details of all Storage buckets within an existing project.
   */
  listBuckets() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield get(this.fetch, `${this.url}/bucket`, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves the details of an existing Storage bucket.
   *
   * @param id The unique identifier of the bucket you would like to retrieve.
   */
  getBucket(id) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield get(this.fetch, `${this.url}/bucket/${id}`, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a new Storage bucket
   *
   * @param id A unique identifier for the bucket you are creating.
   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.
   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
   * The global file size limit takes precedence over this value.
   * The default value is null, which doesn't set a per bucket file size limit.
   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
   * The default value is null, which allows files with all mime types to be uploaded.
   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
   * @returns newly created bucket id
   * @param options.type (private-beta) specifies the bucket type. see `BucketType` for more details.
   *   - default bucket type is `STANDARD`
   */
  createBucket(id_1) {
    return __awaiter(this, arguments, void 0, function* (id, options = {
      public: false
    }) {
      try {
        const data = yield post$1(this.fetch, `${this.url}/bucket`, {
          id,
          name: id,
          type: options.type,
          public: options.public,
          file_size_limit: options.fileSizeLimit,
          allowed_mime_types: options.allowedMimeTypes
        }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Updates a Storage bucket
   *
   * @param id A unique identifier for the bucket you are updating.
   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.
   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
   * The global file size limit takes precedence over this value.
   * The default value is null, which doesn't set a per bucket file size limit.
   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
   * The default value is null, which allows files with all mime types to be uploaded.
   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
   */
  updateBucket(id, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield put(this.fetch, `${this.url}/bucket/${id}`, {
          id,
          name: id,
          public: options.public,
          file_size_limit: options.fileSizeLimit,
          allowed_mime_types: options.allowedMimeTypes
        }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Removes all objects inside a single bucket.
   *
   * @param id The unique identifier of the bucket you would like to empty.
   */
  emptyBucket(id) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post$1(this.fetch, `${this.url}/bucket/${id}/empty`, {}, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.
   * You must first `empty()` the bucket.
   *
   * @param id The unique identifier of the bucket you would like to delete.
   */
  deleteBucket(id) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield remove(this.fetch, `${this.url}/bucket/${id}`, {}, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
}
class StorageAnalyticsApi {
  /**
   * Creates a new StorageAnalyticsApi instance
   * @param url - The base URL for the storage API
   * @param headers - HTTP headers to include in requests
   * @param fetch - Optional custom fetch implementation
   */
  constructor(url, headers = {}, fetch2) {
    this.shouldThrowOnError = false;
    this.url = url.replace(/\/$/, "");
    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS$3), headers);
    this.fetch = resolveFetch$3(fetch2);
  }
  /**
   * Enable throwing errors instead of returning them in the response
   * When enabled, failed operations will throw instead of returning { data: null, error }
   *
   * @returns This instance for method chaining
   */
  throwOnError() {
    this.shouldThrowOnError = true;
    return this;
  }
  /**
   * Creates a new analytics bucket using Iceberg tables
   * Analytics buckets are optimized for analytical queries and data processing
   *
   * @param name A unique name for the bucket you are creating
   * @returns Promise with newly created bucket name or error
   *
   * @example
   * ```typescript
   * const { data, error } = await storage.analytics.createBucket('analytics-data')
   * if (error) {
   *   console.error('Failed to create analytics bucket:', error.message)
   * } else {
   *   console.log('Created bucket:', data.name)
   * }
   * ```
   */
  createBucket(name2) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post$1(this.fetch, `${this.url}/bucket`, { name: name2 }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves the details of all Analytics Storage buckets within an existing project
   * Only returns buckets of type 'ANALYTICS'
   *
   * @param options Query parameters for listing buckets
   * @param options.limit Maximum number of buckets to return
   * @param options.offset Number of buckets to skip
   * @param options.sortColumn Column to sort by ('id', 'name', 'created_at', 'updated_at')
   * @param options.sortOrder Sort order ('asc' or 'desc')
   * @param options.search Search term to filter bucket names
   * @returns Promise with list of analytics buckets or error
   *
   * @example
   * ```typescript
   * const { data, error } = await storage.analytics.listBuckets({
   *   limit: 10,
   *   offset: 0,
   *   sortColumn: 'created_at',
   *   sortOrder: 'desc',
   *   search: 'analytics'
   * })
   * if (data) {
   *   console.log('Found analytics buckets:', data.length)
   *   data.forEach(bucket => console.log(`- ${bucket.name}`))
   * }
   * ```
   */
  listBuckets(options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const queryParams = new URLSearchParams();
        if ((options === null || options === void 0 ? void 0 : options.limit) !== void 0)
          queryParams.set("limit", options.limit.toString());
        if ((options === null || options === void 0 ? void 0 : options.offset) !== void 0)
          queryParams.set("offset", options.offset.toString());
        if (options === null || options === void 0 ? void 0 : options.sortColumn)
          queryParams.set("sortColumn", options.sortColumn);
        if (options === null || options === void 0 ? void 0 : options.sortOrder)
          queryParams.set("sortOrder", options.sortOrder);
        if (options === null || options === void 0 ? void 0 : options.search)
          queryParams.set("search", options.search);
        const queryString = queryParams.toString();
        const url = queryString ? `${this.url}/bucket?${queryString}` : `${this.url}/bucket`;
        const data = yield get(this.fetch, url, { headers: this.headers });
        const analyticsBuckets = Array.isArray(data) ? data.filter((bucket) => bucket.type === "ANALYTICS") : [];
        return { data: analyticsBuckets, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Deletes an existing analytics bucket
   * A bucket can't be deleted with existing objects inside it
   * You must first empty the bucket before deletion
   *
   * @param bucketId The unique identifier of the bucket you would like to delete
   * @returns Promise with success message or error
   *
   * @example
   * ```typescript
   * const { data, error } = await analyticsApi.deleteBucket('old-analytics-bucket')
   * if (error) {
   *   console.error('Failed to delete bucket:', error.message)
   * } else {
   *   console.log('Bucket deleted successfully:', data.message)
   * }
   * ```
   */
  deleteBucket(bucketId) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield remove(this.fetch, `${this.url}/bucket/${bucketId}`, {}, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
}
const DEFAULT_HEADERS$2 = {
  "X-Client-Info": `storage-js/${version$4}`,
  "Content-Type": "application/json"
};
class StorageVectorsError extends Error {
  constructor(message) {
    super(message);
    this.__isStorageVectorsError = true;
    this.name = "StorageVectorsError";
  }
}
function isStorageVectorsError(error) {
  return typeof error === "object" && error !== null && "__isStorageVectorsError" in error;
}
class StorageVectorsApiError extends StorageVectorsError {
  constructor(message, status, statusCode) {
    super(message);
    this.name = "StorageVectorsApiError";
    this.status = status;
    this.statusCode = statusCode;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      statusCode: this.statusCode
    };
  }
}
class StorageVectorsUnknownError extends StorageVectorsError {
  constructor(message, originalError) {
    super(message);
    this.name = "StorageVectorsUnknownError";
    this.originalError = originalError;
  }
}
var StorageVectorsErrorCode;
(function(StorageVectorsErrorCode2) {
  StorageVectorsErrorCode2["InternalError"] = "InternalError";
  StorageVectorsErrorCode2["S3VectorConflictException"] = "S3VectorConflictException";
  StorageVectorsErrorCode2["S3VectorNotFoundException"] = "S3VectorNotFoundException";
  StorageVectorsErrorCode2["S3VectorBucketNotEmpty"] = "S3VectorBucketNotEmpty";
  StorageVectorsErrorCode2["S3VectorMaxBucketsExceeded"] = "S3VectorMaxBucketsExceeded";
  StorageVectorsErrorCode2["S3VectorMaxIndexesExceeded"] = "S3VectorMaxIndexesExceeded";
})(StorageVectorsErrorCode || (StorageVectorsErrorCode = {}));
const resolveFetch$2 = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = (...args) => __vitePreload(() => __async(null, null, function* () {
      const { default: fetch2 } = yield Promise.resolve().then(() => browser);
      return { default: fetch2 };
    }), true ? void 0 : void 0, import.meta.url).then(({ default: fetch2 }) => fetch2(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
const isPlainObject = (value) => {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
};
const _getErrorMessage$1 = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
const handleError$1 = (error, reject, options) => __awaiter(void 0, void 0, void 0, function* () {
  const isResponseLike = error && typeof error === "object" && "status" in error && "ok" in error && typeof error.status === "number";
  if (isResponseLike && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {
    const status = error.status || 500;
    const responseError = error;
    if (typeof responseError.json === "function") {
      responseError.json().then((err) => {
        const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || (err === null || err === void 0 ? void 0 : err.code) || status + "";
        reject(new StorageVectorsApiError(_getErrorMessage$1(err), status, statusCode));
      }).catch(() => {
        const statusCode = status + "";
        const message = responseError.statusText || `HTTP ${status} error`;
        reject(new StorageVectorsApiError(message, status, statusCode));
      });
    } else {
      const statusCode = status + "";
      const message = responseError.statusText || `HTTP ${status} error`;
      reject(new StorageVectorsApiError(message, status, statusCode));
    }
  } else {
    reject(new StorageVectorsUnknownError(_getErrorMessage$1(error), error));
  }
});
const _getRequestParams$1 = (method, options, parameters, body2) => {
  const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
  if (!body2) {
    return params;
  }
  if (isPlainObject(body2)) {
    params.headers = Object.assign({ "Content-Type": "application/json" }, options === null || options === void 0 ? void 0 : options.headers);
    params.body = JSON.stringify(body2);
  } else {
    params.body = body2;
  }
  return Object.assign(Object.assign({}, params), parameters);
};
function _handleRequest$1(fetcher, method, url, options, parameters, body2) {
  return __awaiter(this, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
      fetcher(url, _getRequestParams$1(method, options, parameters, body2)).then((result) => {
        if (!result.ok)
          throw result;
        if (options === null || options === void 0 ? void 0 : options.noResolveJson)
          return result;
        const contentType = result.headers.get("content-type");
        if (!contentType || !contentType.includes("application/json")) {
          return {};
        }
        return result.json();
      }).then((data) => resolve(data)).catch((error) => handleError$1(error, reject, options));
    });
  });
}
function post(fetcher, url, body2, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest$1(fetcher, "POST", url, options, parameters, body2);
  });
}
class VectorIndexApi {
  constructor(url, headers = {}, fetch2) {
    this.shouldThrowOnError = false;
    this.url = url.replace(/\/$/, "");
    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS$2), headers);
    this.fetch = resolveFetch$2(fetch2);
  }
  /**
   * Enable throwing errors instead of returning them in the response
   * When enabled, failed operations will throw instead of returning { data: null, error }
   *
   * @returns This instance for method chaining
   * @example
   * ```typescript
   * const client = new VectorIndexApi(url, headers)
   * client.throwOnError()
   * const { data } = await client.createIndex(options) // throws on error
   * ```
   */
  throwOnError() {
    this.shouldThrowOnError = true;
    return this;
  }
  /**
   * Creates a new vector index within a bucket
   * Defines the schema for vectors including dimensionality, distance metric, and metadata config
   *
   * @param options - Index configuration
   * @param options.vectorBucketName - Name of the parent vector bucket
   * @param options.indexName - Unique name for the index within the bucket
   * @param options.dataType - Data type for vector components (currently only 'float32')
   * @param options.dimension - Dimensionality of vectors (e.g., 384, 768, 1536)
   * @param options.distanceMetric - Similarity metric ('cosine', 'euclidean', 'dotproduct')
   * @param options.metadataConfiguration - Optional config for non-filterable metadata keys
   * @returns Promise with empty response on success or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorConflictException` if index already exists (HTTP 409)
   * - `S3VectorMaxIndexesExceeded` if quota exceeded (HTTP 400)
   * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * const { data, error } = await client.createIndex({
   *   vectorBucketName: 'embeddings-prod',
   *   indexName: 'documents-openai-small',
   *   dataType: 'float32',
   *   dimension: 1536,
   *   distanceMetric: 'cosine',
   *   metadataConfiguration: {
   *     nonFilterableMetadataKeys: ['raw_text', 'internal_id']
   *   }
   * })
   * ```
   */
  createIndex(options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/CreateIndex`, options, {
          headers: this.headers
        });
        return { data: data || {}, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageVectorsError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves metadata for a specific vector index
   * Returns index configuration including dimension, distance metric, and metadata settings
   *
   * @param vectorBucketName - Name of the parent vector bucket
   * @param indexName - Name of the index to retrieve
   * @returns Promise with index metadata or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorNotFoundException` if index or bucket doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * const { data, error } = await client.getIndex('embeddings-prod', 'documents-openai-small')
   * if (data) {
   *   console.log('Index dimension:', data.index.dimension)
   *   console.log('Distance metric:', data.index.distanceMetric)
   * }
   * ```
   */
  getIndex(vectorBucketName, indexName) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/GetIndex`, { vectorBucketName, indexName }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageVectorsError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Lists vector indexes within a bucket with optional filtering and pagination
   * Supports prefix-based filtering and paginated results
   *
   * @param options - Listing options
   * @param options.vectorBucketName - Name of the parent vector bucket
   * @param options.prefix - Filter indexes by name prefix
   * @param options.maxResults - Maximum results per page (default: 100)
   * @param options.nextToken - Pagination token from previous response
   * @returns Promise with list of indexes and pagination token
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * // List all indexes in a bucket
   * const { data, error } = await client.listIndexes({
   *   vectorBucketName: 'embeddings-prod',
   *   prefix: 'documents-'
   * })
   * if (data) {
   *   console.log('Found indexes:', data.indexes.map(i => i.indexName))
   *   // Fetch next page if available
   *   if (data.nextToken) {
   *     const next = await client.listIndexes({
   *       vectorBucketName: 'embeddings-prod',
   *       nextToken: data.nextToken
   *     })
   *   }
   * }
   * ```
   */
  listIndexes(options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/ListIndexes`, options, {
          headers: this.headers
        });
        return { data, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageVectorsError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Deletes a vector index and all its data
   * This operation removes the index schema and all vectors stored in the index
   *
   * @param vectorBucketName - Name of the parent vector bucket
   * @param indexName - Name of the index to delete
   * @returns Promise with empty response on success or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorNotFoundException` if index or bucket doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * // Delete an index and all its vectors
   * const { error } = await client.deleteIndex('embeddings-prod', 'old-index')
   * if (!error) {
   *   console.log('Index deleted successfully')
   * }
   * ```
   */
  deleteIndex(vectorBucketName, indexName) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/DeleteIndex`, { vectorBucketName, indexName }, { headers: this.headers });
        return { data: data || {}, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageVectorsError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
}
class VectorDataApi {
  constructor(url, headers = {}, fetch2) {
    this.shouldThrowOnError = false;
    this.url = url.replace(/\/$/, "");
    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS$2), headers);
    this.fetch = resolveFetch$2(fetch2);
  }
  /**
   * Enable throwing errors instead of returning them in the response
   * When enabled, failed operations will throw instead of returning { data: null, error }
   *
   * @returns This instance for method chaining
   * @example
   * ```typescript
   * const client = new VectorDataApi(url, headers)
   * client.throwOnError()
   * const { data } = await client.putVectors(options) // throws on error
   * ```
   */
  throwOnError() {
    this.shouldThrowOnError = true;
    return this;
  }
  /**
   * Inserts or updates vectors in batch (upsert operation)
   * Accepts 1-500 vectors per request. Larger batches should be split
   *
   * @param options - Vector insertion options
   * @param options.vectorBucketName - Name of the parent vector bucket
   * @param options.indexName - Name of the target index
   * @param options.vectors - Array of vectors to insert/update (1-500 items)
   * @returns Promise with empty response on success or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorConflictException` if duplicate key conflict occurs (HTTP 409)
   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * const { data, error } = await client.putVectors({
   *   vectorBucketName: 'embeddings-prod',
   *   indexName: 'documents-openai-small',
   *   vectors: [
   *     {
   *       key: 'doc-1',
   *       data: { float32: [0.1, 0.2, 0.3, ...] }, // 1536 dimensions
   *       metadata: { title: 'Introduction', page: 1 }
   *     },
   *     {
   *       key: 'doc-2',
   *       data: { float32: [0.4, 0.5, 0.6, ...] },
   *       metadata: { title: 'Conclusion', page: 42 }
   *     }
   *   ]
   * })
   * ```
   */
  putVectors(options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        if (options.vectors.length < 1 || options.vectors.length > 500) {
          throw new Error("Vector batch size must be between 1 and 500 items");
        }
        const data = yield post(this.fetch, `${this.url}/PutVectors`, options, {
          headers: this.headers
        });
        return { data: data || {}, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageVectorsError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves vectors by their keys in batch
   * Optionally includes vector data and/or metadata in response
   * Additional permissions required when returning data or metadata
   *
   * @param options - Vector retrieval options
   * @param options.vectorBucketName - Name of the parent vector bucket
   * @param options.indexName - Name of the index
   * @param options.keys - Array of vector keys to retrieve
   * @param options.returnData - Whether to include vector embeddings (requires permission)
   * @param options.returnMetadata - Whether to include metadata (requires permission)
   * @returns Promise with array of vectors or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * const { data, error } = await client.getVectors({
   *   vectorBucketName: 'embeddings-prod',
   *   indexName: 'documents-openai-small',
   *   keys: ['doc-1', 'doc-2', 'doc-3'],
   *   returnData: false,     // Don't return embeddings
   *   returnMetadata: true   // Return metadata only
   * })
   * if (data) {
   *   data.vectors.forEach(v => console.log(v.key, v.metadata))
   * }
   * ```
   */
  getVectors(options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/GetVectors`, options, {
          headers: this.headers
        });
        return { data, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageVectorsError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Lists/scans vectors in an index with pagination
   * Supports parallel scanning via segment configuration for high-throughput scenarios
   * Additional permissions required when returning data or metadata
   *
   * @param options - Vector listing options
   * @param options.vectorBucketName - Name of the parent vector bucket
   * @param options.indexName - Name of the index
   * @param options.maxResults - Maximum results per page (default: 500, max: 1000)
   * @param options.nextToken - Pagination token from previous response
   * @param options.returnData - Whether to include vector embeddings (requires permission)
   * @param options.returnMetadata - Whether to include metadata (requires permission)
   * @param options.segmentCount - Total parallel segments (1-16) for distributed scanning
   * @param options.segmentIndex - Zero-based segment index (0 to segmentCount-1)
   * @returns Promise with array of vectors, pagination token, or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * // Simple pagination
   * let nextToken: string | undefined
   * do {
   *   const { data, error } = await client.listVectors({
   *     vectorBucketName: 'embeddings-prod',
   *     indexName: 'documents-openai-small',
   *     maxResults: 500,
   *     nextToken,
   *     returnMetadata: true
   *   })
   *   if (error) break
   *   console.log('Batch:', data.vectors.length)
   *   nextToken = data.nextToken
   * } while (nextToken)
   *
   * // Parallel scanning (4 concurrent workers)
   * const workers = [0, 1, 2, 3].map(async (segmentIndex) => {
   *   const { data } = await client.listVectors({
   *     vectorBucketName: 'embeddings-prod',
   *     indexName: 'documents-openai-small',
   *     segmentCount: 4,
   *     segmentIndex,
   *     returnMetadata: true
   *   })
   *   return data?.vectors || []
   * })
   * const results = await Promise.all(workers)
   * ```
   */
  listVectors(options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        if (options.segmentCount !== void 0) {
          if (options.segmentCount < 1 || options.segmentCount > 16) {
            throw new Error("segmentCount must be between 1 and 16");
          }
          if (options.segmentIndex !== void 0) {
            if (options.segmentIndex < 0 || options.segmentIndex >= options.segmentCount) {
              throw new Error(`segmentIndex must be between 0 and ${options.segmentCount - 1}`);
            }
          }
        }
        const data = yield post(this.fetch, `${this.url}/ListVectors`, options, {
          headers: this.headers
        });
        return { data, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageVectorsError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Queries for similar vectors using approximate nearest neighbor (ANN) search
   * Returns top-K most similar vectors based on the configured distance metric
   * Supports optional metadata filtering (requires GetVectors permission)
   *
   * @param options - Query options
   * @param options.vectorBucketName - Name of the parent vector bucket
   * @param options.indexName - Name of the index
   * @param options.queryVector - Query embedding to find similar vectors
   * @param options.topK - Number of nearest neighbors to return (default: 10)
   * @param options.filter - Optional JSON filter for metadata (requires GetVectors permission)
   * @param options.returnDistance - Whether to include similarity distances
   * @param options.returnMetadata - Whether to include metadata (requires GetVectors permission)
   * @returns Promise with array of similar vectors ordered by distance
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * // Semantic search with filtering
   * const { data, error } = await client.queryVectors({
   *   vectorBucketName: 'embeddings-prod',
   *   indexName: 'documents-openai-small',
   *   queryVector: { float32: [0.1, 0.2, 0.3, ...] }, // 1536 dimensions
   *   topK: 5,
   *   filter: {
   *     category: 'technical',
   *     published: true
   *   },
   *   returnDistance: true,
   *   returnMetadata: true
   * })
   * if (data) {
   *   data.matches.forEach(match => {
   *     console.log(`${match.key}: distance=${match.distance}`)
   *     console.log('Metadata:', match.metadata)
   *   })
   * }
   * ```
   */
  queryVectors(options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/QueryVectors`, options, {
          headers: this.headers
        });
        return { data, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageVectorsError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Deletes vectors by their keys in batch
   * Accepts 1-500 keys per request
   *
   * @param options - Vector deletion options
   * @param options.vectorBucketName - Name of the parent vector bucket
   * @param options.indexName - Name of the index
   * @param options.keys - Array of vector keys to delete (1-500 items)
   * @returns Promise with empty response on success or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * const { error } = await client.deleteVectors({
   *   vectorBucketName: 'embeddings-prod',
   *   indexName: 'documents-openai-small',
   *   keys: ['doc-1', 'doc-2', 'doc-3']
   * })
   * if (!error) {
   *   console.log('Vectors deleted successfully')
   * }
   * ```
   */
  deleteVectors(options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        if (options.keys.length < 1 || options.keys.length > 500) {
          throw new Error("Keys batch size must be between 1 and 500 items");
        }
        const data = yield post(this.fetch, `${this.url}/DeleteVectors`, options, {
          headers: this.headers
        });
        return { data: data || {}, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageVectorsError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
}
class VectorBucketApi {
  /**
   * Creates a new VectorBucketApi instance
   * @param url - The base URL for the storage vectors API
   * @param headers - HTTP headers to include in requests
   * @param fetch - Optional custom fetch implementation
   */
  constructor(url, headers = {}, fetch2) {
    this.shouldThrowOnError = false;
    this.url = url.replace(/\/$/, "");
    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS$2), headers);
    this.fetch = resolveFetch$2(fetch2);
  }
  /**
   * Enable throwing errors instead of returning them in the response
   * When enabled, failed operations will throw instead of returning { data: null, error }
   *
   * @returns This instance for method chaining
   * @example
   * ```typescript
   * const client = new VectorBucketApi(url, headers)
   * client.throwOnError()
   * const { data } = await client.createBucket('my-bucket') // throws on error
   * ```
   */
  throwOnError() {
    this.shouldThrowOnError = true;
    return this;
  }
  /**
   * Creates a new vector bucket
   * Vector buckets are containers for vector indexes and their data
   *
   * @param vectorBucketName - Unique name for the vector bucket
   * @returns Promise with empty response on success or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorConflictException` if bucket already exists (HTTP 409)
   * - `S3VectorMaxBucketsExceeded` if quota exceeded (HTTP 400)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * const { data, error } = await client.createBucket('embeddings-prod')
   * if (error) {
   *   console.error('Failed to create bucket:', error.message)
   * }
   * ```
   */
  createBucket(vectorBucketName) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/CreateVectorBucket`, { vectorBucketName }, { headers: this.headers });
        return { data: data || {}, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageVectorsError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves metadata for a specific vector bucket
   * Returns bucket configuration including encryption settings and creation time
   *
   * @param vectorBucketName - Name of the vector bucket to retrieve
   * @returns Promise with bucket metadata or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * const { data, error } = await client.getBucket('embeddings-prod')
   * if (data) {
   *   console.log('Bucket created at:', new Date(data.vectorBucket.creationTime! * 1000))
   * }
   * ```
   */
  getBucket(vectorBucketName) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/GetVectorBucket`, { vectorBucketName }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageVectorsError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Lists vector buckets with optional filtering and pagination
   * Supports prefix-based filtering and paginated results
   *
   * @param options - Listing options
   * @param options.prefix - Filter buckets by name prefix
   * @param options.maxResults - Maximum results per page (default: 100)
   * @param options.nextToken - Pagination token from previous response
   * @returns Promise with list of buckets and pagination token
   *
   * @throws {StorageVectorsApiError} With code:
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * // List all buckets with prefix 'prod-'
   * const { data, error } = await client.listBuckets({ prefix: 'prod-' })
   * if (data) {
   *   console.log('Found buckets:', data.buckets.length)
   *   // Fetch next page if available
   *   if (data.nextToken) {
   *     const next = await client.listBuckets({ nextToken: data.nextToken })
   *   }
   * }
   * ```
   */
  listBuckets() {
    return __awaiter(this, arguments, void 0, function* (options = {}) {
      try {
        const data = yield post(this.fetch, `${this.url}/ListVectorBuckets`, options, {
          headers: this.headers
        });
        return { data, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageVectorsError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Deletes a vector bucket
   * Bucket must be empty before deletion (all indexes must be removed first)
   *
   * @param vectorBucketName - Name of the vector bucket to delete
   * @returns Promise with empty response on success or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorBucketNotEmpty` if bucket contains indexes (HTTP 400)
   * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * // Delete all indexes first, then delete bucket
   * const { error } = await client.deleteBucket('old-bucket')
   * if (error?.statusCode === 'S3VectorBucketNotEmpty') {
   *   console.error('Must delete all indexes first')
   * }
   * ```
   */
  deleteBucket(vectorBucketName) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/DeleteVectorBucket`, { vectorBucketName }, { headers: this.headers });
        return { data: data || {}, error: null };
      } catch (error) {
        if (this.shouldThrowOnError) {
          throw error;
        }
        if (isStorageVectorsError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
}
class StorageVectorsClient extends VectorBucketApi {
  constructor(url, options = {}) {
    super(url, options.headers || {}, options.fetch);
  }
  /**
   * Access operations for a specific vector bucket
   * Returns a scoped client for index and vector operations within the bucket
   *
   * @param vectorBucketName - Name of the vector bucket
   * @returns Bucket-scoped client with index and vector operations
   *
   * @example
   * ```typescript
   * const bucket = client.bucket('embeddings-prod')
   *
   * // Create an index in this bucket
   * await bucket.createIndex({
   *   indexName: 'documents-openai',
   *   dataType: 'float32',
   *   dimension: 1536,
   *   distanceMetric: 'cosine'
   * })
   *
   * // List indexes in this bucket
   * const { data } = await bucket.listIndexes()
   * ```
   */
  from(vectorBucketName) {
    return new VectorBucketScope(this.url, this.headers, vectorBucketName, this.fetch);
  }
}
class VectorBucketScope extends VectorIndexApi {
  constructor(url, headers, vectorBucketName, fetch2) {
    super(url, headers, fetch2);
    this.vectorBucketName = vectorBucketName;
  }
  /**
   * Creates a new vector index in this bucket
   * Convenience method that automatically includes the bucket name
   *
   * @param options - Index configuration (vectorBucketName is automatically set)
   * @returns Promise with empty response on success or error
   *
   * @example
   * ```typescript
   * const bucket = client.bucket('embeddings-prod')
   * await bucket.createIndex({
   *   indexName: 'documents-openai',
   *   dataType: 'float32',
   *   dimension: 1536,
   *   distanceMetric: 'cosine',
   *   metadataConfiguration: {
   *     nonFilterableMetadataKeys: ['raw_text']
   *   }
   * })
   * ```
   */
  createIndex(options) {
    const _super = Object.create(null, {
      createIndex: { get: () => super.createIndex }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.createIndex.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName }));
    });
  }
  /**
   * Lists indexes in this bucket
   * Convenience method that automatically includes the bucket name
   *
   * @param options - Listing options (vectorBucketName is automatically set)
   * @returns Promise with list of indexes or error
   *
   * @example
   * ```typescript
   * const bucket = client.bucket('embeddings-prod')
   * const { data } = await bucket.listIndexes({ prefix: 'documents-' })
   * ```
   */
  listIndexes() {
    const _super = Object.create(null, {
      listIndexes: { get: () => super.listIndexes }
    });
    return __awaiter(this, arguments, void 0, function* (options = {}) {
      return _super.listIndexes.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName }));
    });
  }
  /**
   * Retrieves metadata for a specific index in this bucket
   * Convenience method that automatically includes the bucket name
   *
   * @param indexName - Name of the index to retrieve
   * @returns Promise with index metadata or error
   *
   * @example
   * ```typescript
   * const bucket = client.bucket('embeddings-prod')
   * const { data } = await bucket.getIndex('documents-openai')
   * console.log('Dimension:', data?.index.dimension)
   * ```
   */
  getIndex(indexName) {
    const _super = Object.create(null, {
      getIndex: { get: () => super.getIndex }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.getIndex.call(this, this.vectorBucketName, indexName);
    });
  }
  /**
   * Deletes an index from this bucket
   * Convenience method that automatically includes the bucket name
   *
   * @param indexName - Name of the index to delete
   * @returns Promise with empty response on success or error
   *
   * @example
   * ```typescript
   * const bucket = client.bucket('embeddings-prod')
   * await bucket.deleteIndex('old-index')
   * ```
   */
  deleteIndex(indexName) {
    const _super = Object.create(null, {
      deleteIndex: { get: () => super.deleteIndex }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.deleteIndex.call(this, this.vectorBucketName, indexName);
    });
  }
  /**
   * Access operations for a specific index within this bucket
   * Returns a scoped client for vector data operations
   *
   * @param indexName - Name of the index
   * @returns Index-scoped client with vector data operations
   *
   * @example
   * ```typescript
   * const index = client.bucket('embeddings-prod').index('documents-openai')
   *
   * // Insert vectors
   * await index.putVectors({
   *   vectors: [
   *     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }
   *   ]
   * })
   *
   * // Query similar vectors
   * const { data } = await index.queryVectors({
   *   queryVector: { float32: [...] },
   *   topK: 5
   * })
   * ```
   */
  index(indexName) {
    return new VectorIndexScope(this.url, this.headers, this.vectorBucketName, indexName, this.fetch);
  }
}
class VectorIndexScope extends VectorDataApi {
  constructor(url, headers, vectorBucketName, indexName, fetch2) {
    super(url, headers, fetch2);
    this.vectorBucketName = vectorBucketName;
    this.indexName = indexName;
  }
  /**
   * Inserts or updates vectors in this index
   * Convenience method that automatically includes bucket and index names
   *
   * @param options - Vector insertion options (bucket and index names automatically set)
   * @returns Promise with empty response on success or error
   *
   * @example
   * ```typescript
   * const index = client.bucket('embeddings-prod').index('documents-openai')
   * await index.putVectors({
   *   vectors: [
   *     {
   *       key: 'doc-1',
   *       data: { float32: [0.1, 0.2, ...] },
   *       metadata: { title: 'Introduction', page: 1 }
   *     }
   *   ]
   * })
   * ```
   */
  putVectors(options) {
    const _super = Object.create(null, {
      putVectors: { get: () => super.putVectors }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.putVectors.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
    });
  }
  /**
   * Retrieves vectors by keys from this index
   * Convenience method that automatically includes bucket and index names
   *
   * @param options - Vector retrieval options (bucket and index names automatically set)
   * @returns Promise with array of vectors or error
   *
   * @example
   * ```typescript
   * const index = client.bucket('embeddings-prod').index('documents-openai')
   * const { data } = await index.getVectors({
   *   keys: ['doc-1', 'doc-2'],
   *   returnMetadata: true
   * })
   * ```
   */
  getVectors(options) {
    const _super = Object.create(null, {
      getVectors: { get: () => super.getVectors }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.getVectors.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
    });
  }
  /**
   * Lists vectors in this index with pagination
   * Convenience method that automatically includes bucket and index names
   *
   * @param options - Listing options (bucket and index names automatically set)
   * @returns Promise with array of vectors and pagination token
   *
   * @example
   * ```typescript
   * const index = client.bucket('embeddings-prod').index('documents-openai')
   * const { data } = await index.listVectors({
   *   maxResults: 500,
   *   returnMetadata: true
   * })
   * ```
   */
  listVectors() {
    const _super = Object.create(null, {
      listVectors: { get: () => super.listVectors }
    });
    return __awaiter(this, arguments, void 0, function* (options = {}) {
      return _super.listVectors.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
    });
  }
  /**
   * Queries for similar vectors in this index
   * Convenience method that automatically includes bucket and index names
   *
   * @param options - Query options (bucket and index names automatically set)
   * @returns Promise with array of similar vectors ordered by distance
   *
   * @example
   * ```typescript
   * const index = client.bucket('embeddings-prod').index('documents-openai')
   * const { data } = await index.queryVectors({
   *   queryVector: { float32: [0.1, 0.2, ...] },
   *   topK: 5,
   *   filter: { category: 'technical' },
   *   returnDistance: true,
   *   returnMetadata: true
   * })
   * ```
   */
  queryVectors(options) {
    const _super = Object.create(null, {
      queryVectors: { get: () => super.queryVectors }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.queryVectors.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
    });
  }
  /**
   * Deletes vectors by keys from this index
   * Convenience method that automatically includes bucket and index names
   *
   * @param options - Deletion options (bucket and index names automatically set)
   * @returns Promise with empty response on success or error
   *
   * @example
   * ```typescript
   * const index = client.bucket('embeddings-prod').index('documents-openai')
   * await index.deleteVectors({
   *   keys: ['doc-1', 'doc-2', 'doc-3']
   * })
   * ```
   */
  deleteVectors(options) {
    const _super = Object.create(null, {
      deleteVectors: { get: () => super.deleteVectors }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.deleteVectors.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
    });
  }
}
class StorageClient extends StorageBucketApi {
  constructor(url, headers = {}, fetch2, opts) {
    super(url, headers, fetch2, opts);
  }
  /**
   * Perform file operation in a bucket.
   *
   * @param id The bucket id to operate on.
   */
  from(id) {
    return new StorageFileApi(this.url, this.headers, id, this.fetch);
  }
  /**
   * Access vector storage operations.
   *
   * @returns A StorageVectorsClient instance configured with the current storage settings.
   */
  get vectors() {
    return new StorageVectorsClient(this.url + "/vector", {
      headers: this.headers,
      fetch: this.fetch
    });
  }
  /**
   * Access analytics storage operations using Iceberg tables.
   *
   * @returns A StorageAnalyticsApi instance configured with the current storage settings.
   * @example
   * ```typescript
   * const client = createClient(url, key)
   * const analytics = client.storage.analytics
   *
   * // Create an analytics bucket
   * await analytics.createBucket('my-analytics-bucket')
   *
   * // List all analytics buckets
   * const { data: buckets } = await analytics.listBuckets()
   *
   * // Delete an analytics bucket
   * await analytics.deleteBucket('old-analytics-bucket')
   * ```
   */
  get analytics() {
    return new StorageAnalyticsApi(this.url + "/iceberg", this.headers, this.fetch);
  }
}
const version$3 = "2.76.1";
let JS_ENV = "";
if (typeof Deno !== "undefined") {
  JS_ENV = "deno";
} else if (typeof document !== "undefined") {
  JS_ENV = "web";
} else if (typeof navigator !== "undefined" && navigator.product === "ReactNative") {
  JS_ENV = "react-native";
} else {
  JS_ENV = "node";
}
const DEFAULT_HEADERS$1 = { "X-Client-Info": `supabase-js-${JS_ENV}/${version$3}` };
const DEFAULT_GLOBAL_OPTIONS = {
  headers: DEFAULT_HEADERS$1
};
const DEFAULT_DB_OPTIONS = {
  schema: "public"
};
const DEFAULT_AUTH_OPTIONS = {
  autoRefreshToken: true,
  persistSession: true,
  detectSessionInUrl: true,
  flowType: "implicit"
};
const DEFAULT_REALTIME_OPTIONS = {};
const resolveFetch$1 = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = nodeFetch;
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
const resolveHeadersConstructor = () => {
  if (typeof Headers === "undefined") {
    return Headers$1;
  }
  return Headers;
};
const fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {
  const fetch2 = resolveFetch$1(customFetch);
  const HeadersConstructor = resolveHeadersConstructor();
  return (input, init) => __async(null, null, function* () {
    var _a2;
    const accessToken = (_a2 = yield getAccessToken()) !== null && _a2 !== void 0 ? _a2 : supabaseKey;
    let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);
    if (!headers.has("apikey")) {
      headers.set("apikey", supabaseKey);
    }
    if (!headers.has("Authorization")) {
      headers.set("Authorization", `Bearer ${accessToken}`);
    }
    return fetch2(input, Object.assign(Object.assign({}, init), { headers }));
  });
};
function ensureTrailingSlash(url) {
  return url.endsWith("/") ? url : url + "/";
}
function applySettingDefaults(options, defaults) {
  var _a2, _b;
  const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions } = options;
  const { db: DEFAULT_DB_OPTIONS2, auth: DEFAULT_AUTH_OPTIONS2, realtime: DEFAULT_REALTIME_OPTIONS2, global: DEFAULT_GLOBAL_OPTIONS2 } = defaults;
  const result = {
    db: Object.assign(Object.assign({}, DEFAULT_DB_OPTIONS2), dbOptions),
    auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS2), authOptions),
    realtime: Object.assign(Object.assign({}, DEFAULT_REALTIME_OPTIONS2), realtimeOptions),
    storage: {},
    global: Object.assign(Object.assign(Object.assign({}, DEFAULT_GLOBAL_OPTIONS2), globalOptions), { headers: Object.assign(Object.assign({}, (_a2 = DEFAULT_GLOBAL_OPTIONS2 === null || DEFAULT_GLOBAL_OPTIONS2 === void 0 ? void 0 : DEFAULT_GLOBAL_OPTIONS2.headers) !== null && _a2 !== void 0 ? _a2 : {}), (_b = globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.headers) !== null && _b !== void 0 ? _b : {}) }),
    accessToken: () => __async(null, null, function* () {
      return "";
    })
  };
  if (options.accessToken) {
    result.accessToken = options.accessToken;
  } else {
    delete result.accessToken;
  }
  return result;
}
function validateSupabaseUrl(supabaseUrl) {
  const trimmedUrl = supabaseUrl === null || supabaseUrl === void 0 ? void 0 : supabaseUrl.trim();
  if (!trimmedUrl) {
    throw new Error("supabaseUrl is required.");
  }
  if (!trimmedUrl.match(/^https?:\/\//i)) {
    throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");
  }
  try {
    return new URL(ensureTrailingSlash(trimmedUrl));
  } catch (_a2) {
    throw Error("Invalid supabaseUrl: Provided URL is malformed.");
  }
}
const version$2 = "2.76.1";
const AUTO_REFRESH_TICK_DURATION_MS = 30 * 1e3;
const AUTO_REFRESH_TICK_THRESHOLD = 3;
const EXPIRY_MARGIN_MS = AUTO_REFRESH_TICK_THRESHOLD * AUTO_REFRESH_TICK_DURATION_MS;
const GOTRUE_URL = "http://localhost:9999";
const STORAGE_KEY = "supabase.auth.token";
const DEFAULT_HEADERS = { "X-Client-Info": `gotrue-js/${version$2}` };
const API_VERSION_HEADER_NAME = "X-Supabase-Api-Version";
const API_VERSIONS = {
  "2024-01-01": {
    timestamp: Date.parse("2024-01-01T00:00:00.0Z"),
    name: "2024-01-01"
  }
};
const BASE64URL_REGEX = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i;
const JWKS_TTL = 10 * 60 * 1e3;
class AuthError extends Error {
  constructor(message, status, code) {
    super(message);
    this.__isAuthError = true;
    this.name = "AuthError";
    this.status = status;
    this.code = code;
  }
}
function isAuthError(error) {
  return typeof error === "object" && error !== null && "__isAuthError" in error;
}
class AuthApiError extends AuthError {
  constructor(message, status, code) {
    super(message, status, code);
    this.name = "AuthApiError";
    this.status = status;
    this.code = code;
  }
}
function isAuthApiError(error) {
  return isAuthError(error) && error.name === "AuthApiError";
}
class AuthUnknownError extends AuthError {
  constructor(message, originalError) {
    super(message);
    this.name = "AuthUnknownError";
    this.originalError = originalError;
  }
}
class CustomAuthError extends AuthError {
  constructor(message, name2, status, code) {
    super(message, status, code);
    this.name = name2;
    this.status = status;
  }
}
class AuthSessionMissingError extends CustomAuthError {
  constructor() {
    super("Auth session missing!", "AuthSessionMissingError", 400, void 0);
  }
}
function isAuthSessionMissingError(error) {
  return isAuthError(error) && error.name === "AuthSessionMissingError";
}
class AuthInvalidTokenResponseError extends CustomAuthError {
  constructor() {
    super("Auth session or user missing", "AuthInvalidTokenResponseError", 500, void 0);
  }
}
class AuthInvalidCredentialsError extends CustomAuthError {
  constructor(message) {
    super(message, "AuthInvalidCredentialsError", 400, void 0);
  }
}
class AuthImplicitGrantRedirectError extends CustomAuthError {
  constructor(message, details = null) {
    super(message, "AuthImplicitGrantRedirectError", 500, void 0);
    this.details = null;
    this.details = details;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
}
function isAuthImplicitGrantRedirectError(error) {
  return isAuthError(error) && error.name === "AuthImplicitGrantRedirectError";
}
class AuthPKCEGrantCodeExchangeError extends CustomAuthError {
  constructor(message, details = null) {
    super(message, "AuthPKCEGrantCodeExchangeError", 500, void 0);
    this.details = null;
    this.details = details;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
}
class AuthRetryableFetchError extends CustomAuthError {
  constructor(message, status) {
    super(message, "AuthRetryableFetchError", status, void 0);
  }
}
function isAuthRetryableFetchError(error) {
  return isAuthError(error) && error.name === "AuthRetryableFetchError";
}
class AuthWeakPasswordError extends CustomAuthError {
  constructor(message, status, reasons) {
    super(message, "AuthWeakPasswordError", status, "weak_password");
    this.reasons = reasons;
  }
}
class AuthInvalidJwtError extends CustomAuthError {
  constructor(message) {
    super(message, "AuthInvalidJwtError", 400, "invalid_jwt");
  }
}
const TO_BASE64URL = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split("");
const IGNORE_BASE64URL = " 	\n\r=".split("");
const FROM_BASE64URL = (() => {
  const charMap = new Array(128);
  for (let i = 0; i < charMap.length; i += 1) {
    charMap[i] = -1;
  }
  for (let i = 0; i < IGNORE_BASE64URL.length; i += 1) {
    charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;
  }
  for (let i = 0; i < TO_BASE64URL.length; i += 1) {
    charMap[TO_BASE64URL[i].charCodeAt(0)] = i;
  }
  return charMap;
})();
function byteToBase64URL(byte, state, emit) {
  if (byte !== null) {
    state.queue = state.queue << 8 | byte;
    state.queuedBits += 8;
    while (state.queuedBits >= 6) {
      const pos = state.queue >> state.queuedBits - 6 & 63;
      emit(TO_BASE64URL[pos]);
      state.queuedBits -= 6;
    }
  } else if (state.queuedBits > 0) {
    state.queue = state.queue << 6 - state.queuedBits;
    state.queuedBits = 6;
    while (state.queuedBits >= 6) {
      const pos = state.queue >> state.queuedBits - 6 & 63;
      emit(TO_BASE64URL[pos]);
      state.queuedBits -= 6;
    }
  }
}
function byteFromBase64URL(charCode, state, emit) {
  const bits = FROM_BASE64URL[charCode];
  if (bits > -1) {
    state.queue = state.queue << 6 | bits;
    state.queuedBits += 6;
    while (state.queuedBits >= 8) {
      emit(state.queue >> state.queuedBits - 8 & 255);
      state.queuedBits -= 8;
    }
  } else if (bits === -2) {
    return;
  } else {
    throw new Error(`Invalid Base64-URL character "${String.fromCharCode(charCode)}"`);
  }
}
function stringFromBase64URL(str) {
  const conv = [];
  const utf8Emit = (codepoint) => {
    conv.push(String.fromCodePoint(codepoint));
  };
  const utf8State = {
    utf8seq: 0,
    codepoint: 0
  };
  const b64State = { queue: 0, queuedBits: 0 };
  const byteEmit = (byte) => {
    stringFromUTF8(byte, utf8State, utf8Emit);
  };
  for (let i = 0; i < str.length; i += 1) {
    byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);
  }
  return conv.join("");
}
function codepointToUTF8(codepoint, emit) {
  if (codepoint <= 127) {
    emit(codepoint);
    return;
  } else if (codepoint <= 2047) {
    emit(192 | codepoint >> 6);
    emit(128 | codepoint & 63);
    return;
  } else if (codepoint <= 65535) {
    emit(224 | codepoint >> 12);
    emit(128 | codepoint >> 6 & 63);
    emit(128 | codepoint & 63);
    return;
  } else if (codepoint <= 1114111) {
    emit(240 | codepoint >> 18);
    emit(128 | codepoint >> 12 & 63);
    emit(128 | codepoint >> 6 & 63);
    emit(128 | codepoint & 63);
    return;
  }
  throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);
}
function stringToUTF8(str, emit) {
  for (let i = 0; i < str.length; i += 1) {
    let codepoint = str.charCodeAt(i);
    if (codepoint > 55295 && codepoint <= 56319) {
      const highSurrogate = (codepoint - 55296) * 1024 & 65535;
      const lowSurrogate = str.charCodeAt(i + 1) - 56320 & 65535;
      codepoint = (lowSurrogate | highSurrogate) + 65536;
      i += 1;
    }
    codepointToUTF8(codepoint, emit);
  }
}
function stringFromUTF8(byte, state, emit) {
  if (state.utf8seq === 0) {
    if (byte <= 127) {
      emit(byte);
      return;
    }
    for (let leadingBit = 1; leadingBit < 6; leadingBit += 1) {
      if ((byte >> 7 - leadingBit & 1) === 0) {
        state.utf8seq = leadingBit;
        break;
      }
    }
    if (state.utf8seq === 2) {
      state.codepoint = byte & 31;
    } else if (state.utf8seq === 3) {
      state.codepoint = byte & 15;
    } else if (state.utf8seq === 4) {
      state.codepoint = byte & 7;
    } else {
      throw new Error("Invalid UTF-8 sequence");
    }
    state.utf8seq -= 1;
  } else if (state.utf8seq > 0) {
    if (byte <= 127) {
      throw new Error("Invalid UTF-8 sequence");
    }
    state.codepoint = state.codepoint << 6 | byte & 63;
    state.utf8seq -= 1;
    if (state.utf8seq === 0) {
      emit(state.codepoint);
    }
  }
}
function base64UrlToUint8Array(str) {
  const result = [];
  const state = { queue: 0, queuedBits: 0 };
  const onByte = (byte) => {
    result.push(byte);
  };
  for (let i = 0; i < str.length; i += 1) {
    byteFromBase64URL(str.charCodeAt(i), state, onByte);
  }
  return new Uint8Array(result);
}
function stringToUint8Array(str) {
  const result = [];
  stringToUTF8(str, (byte) => result.push(byte));
  return new Uint8Array(result);
}
function bytesToBase64URL(bytes) {
  const result = [];
  const state = { queue: 0, queuedBits: 0 };
  const onChar = (char2) => {
    result.push(char2);
  };
  bytes.forEach((byte) => byteToBase64URL(byte, state, onChar));
  byteToBase64URL(null, state, onChar);
  return result.join("");
}
function expiresAt(expiresIn) {
  const timeNow = Math.round(Date.now() / 1e3);
  return timeNow + expiresIn;
}
function uuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    const r2 = Math.random() * 16 | 0, v = c == "x" ? r2 : r2 & 3 | 8;
    return v.toString(16);
  });
}
const isBrowser$3 = () => typeof window !== "undefined" && typeof document !== "undefined";
const localStorageWriteTests = {
  tested: false,
  writable: false
};
const supportsLocalStorage = () => {
  if (!isBrowser$3()) {
    return false;
  }
  try {
    if (typeof globalThis.localStorage !== "object") {
      return false;
    }
  } catch (e) {
    return false;
  }
  if (localStorageWriteTests.tested) {
    return localStorageWriteTests.writable;
  }
  const randomKey = `lswt-${Math.random()}${Math.random()}`;
  try {
    globalThis.localStorage.setItem(randomKey, randomKey);
    globalThis.localStorage.removeItem(randomKey);
    localStorageWriteTests.tested = true;
    localStorageWriteTests.writable = true;
  } catch (e) {
    localStorageWriteTests.tested = true;
    localStorageWriteTests.writable = false;
  }
  return localStorageWriteTests.writable;
};
function parseParametersFromURL(href) {
  const result = {};
  const url = new URL(href);
  if (url.hash && url.hash[0] === "#") {
    try {
      const hashSearchParams = new URLSearchParams(url.hash.substring(1));
      hashSearchParams.forEach((value, key) => {
        result[key] = value;
      });
    } catch (e) {
    }
  }
  url.searchParams.forEach((value, key) => {
    result[key] = value;
  });
  return result;
}
const resolveFetch = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = (...args) => __vitePreload(() => __async(null, null, function* () {
      const { default: fetch2 } = yield Promise.resolve().then(() => browser);
      return { default: fetch2 };
    }), true ? void 0 : void 0, import.meta.url).then(({ default: fetch2 }) => fetch2(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
const looksLikeFetchResponse = (maybeResponse) => {
  return typeof maybeResponse === "object" && maybeResponse !== null && "status" in maybeResponse && "ok" in maybeResponse && "json" in maybeResponse && typeof maybeResponse.json === "function";
};
const setItemAsync = (storage, key, data) => __async(null, null, function* () {
  yield storage.setItem(key, JSON.stringify(data));
});
const getItemAsync = (storage, key) => __async(null, null, function* () {
  const value = yield storage.getItem(key);
  if (!value) {
    return null;
  }
  try {
    return JSON.parse(value);
  } catch (_a2) {
    return value;
  }
});
const removeItemAsync = (storage, key) => __async(null, null, function* () {
  yield storage.removeItem(key);
});
class Deferred {
  constructor() {
    this.promise = new Deferred.promiseConstructor((res, rej) => {
      this.resolve = res;
      this.reject = rej;
    });
  }
}
Deferred.promiseConstructor = Promise;
function decodeJWT(token2) {
  const parts = token2.split(".");
  if (parts.length !== 3) {
    throw new AuthInvalidJwtError("Invalid JWT structure");
  }
  for (let i = 0; i < parts.length; i++) {
    if (!BASE64URL_REGEX.test(parts[i])) {
      throw new AuthInvalidJwtError("JWT not in base64url format");
    }
  }
  const data = {
    // using base64url lib
    header: JSON.parse(stringFromBase64URL(parts[0])),
    payload: JSON.parse(stringFromBase64URL(parts[1])),
    signature: base64UrlToUint8Array(parts[2]),
    raw: {
      header: parts[0],
      payload: parts[1]
    }
  };
  return data;
}
function sleep(time) {
  return __async(this, null, function* () {
    return yield new Promise((accept) => {
      setTimeout(() => accept(null), time);
    });
  });
}
function retryable(fn2, isRetryable) {
  const promise = new Promise((accept, reject) => {
    (() => __async(null, null, function* () {
      for (let attempt = 0; attempt < Infinity; attempt++) {
        try {
          const result = yield fn2(attempt);
          if (!isRetryable(attempt, null, result)) {
            accept(result);
            return;
          }
        } catch (e) {
          if (!isRetryable(attempt, e)) {
            reject(e);
            return;
          }
        }
      }
    }))();
  });
  return promise;
}
function dec2hex(dec) {
  return ("0" + dec.toString(16)).substr(-2);
}
function generatePKCEVerifier() {
  const verifierLength = 56;
  const array = new Uint32Array(verifierLength);
  if (typeof crypto === "undefined") {
    const charSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
    const charSetLen = charSet.length;
    let verifier = "";
    for (let i = 0; i < verifierLength; i++) {
      verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));
    }
    return verifier;
  }
  crypto.getRandomValues(array);
  return Array.from(array, dec2hex).join("");
}
function sha256(randomString) {
  return __async(this, null, function* () {
    const encoder = new TextEncoder();
    const encodedData = encoder.encode(randomString);
    const hash2 = yield crypto.subtle.digest("SHA-256", encodedData);
    const bytes = new Uint8Array(hash2);
    return Array.from(bytes).map((c) => String.fromCharCode(c)).join("");
  });
}
function generatePKCEChallenge(verifier) {
  return __async(this, null, function* () {
    const hasCryptoSupport = typeof crypto !== "undefined" && typeof crypto.subtle !== "undefined" && typeof TextEncoder !== "undefined";
    if (!hasCryptoSupport) {
      console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.");
      return verifier;
    }
    const hashed = yield sha256(verifier);
    return btoa(hashed).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  });
}
function getCodeChallengeAndMethod(storage, storageKey, isPasswordRecovery = false) {
  return __async(this, null, function* () {
    const codeVerifier = generatePKCEVerifier();
    let storedCodeVerifier = codeVerifier;
    if (isPasswordRecovery) {
      storedCodeVerifier += "/PASSWORD_RECOVERY";
    }
    yield setItemAsync(storage, `${storageKey}-code-verifier`, storedCodeVerifier);
    const codeChallenge = yield generatePKCEChallenge(codeVerifier);
    const codeChallengeMethod = codeVerifier === codeChallenge ? "plain" : "s256";
    return [codeChallenge, codeChallengeMethod];
  });
}
const API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
function parseResponseAPIVersion(response) {
  const apiVersion = response.headers.get(API_VERSION_HEADER_NAME);
  if (!apiVersion) {
    return null;
  }
  if (!apiVersion.match(API_VERSION_REGEX)) {
    return null;
  }
  try {
    const date = /* @__PURE__ */ new Date(`${apiVersion}T00:00:00.0Z`);
    return date;
  } catch (e) {
    return null;
  }
}
function validateExp(exp) {
  if (!exp) {
    throw new Error("Missing exp claim");
  }
  const timeNow = Math.floor(Date.now() / 1e3);
  if (exp <= timeNow) {
    throw new Error("JWT has expired");
  }
}
function getAlgorithm(alg) {
  switch (alg) {
    case "RS256":
      return {
        name: "RSASSA-PKCS1-v1_5",
        hash: { name: "SHA-256" }
      };
    case "ES256":
      return {
        name: "ECDSA",
        namedCurve: "P-256",
        hash: { name: "SHA-256" }
      };
    default:
      throw new Error("Invalid alg claim");
  }
}
const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
function validateUUID(str) {
  if (!UUID_REGEX.test(str)) {
    throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not");
  }
}
function userNotAvailableProxy() {
  const proxyTarget = {};
  return new Proxy(proxyTarget, {
    get: (target, prop) => {
      if (prop === "__isUserNotAvailableProxy") {
        return true;
      }
      if (typeof prop === "symbol") {
        const sProp = prop.toString();
        if (sProp === "Symbol(Symbol.toPrimitive)" || sProp === "Symbol(Symbol.toStringTag)" || sProp === "Symbol(util.inspect.custom)") {
          return void 0;
        }
      }
      throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${prop}" property of the session object is not supported. Please use getUser() instead.`);
    },
    set: (_target, prop) => {
      throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${prop}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);
    },
    deleteProperty: (_target, prop) => {
      throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${prop}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);
    }
  });
}
function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}
const _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
const NETWORK_ERROR_CODES = [502, 503, 504];
function handleError(error) {
  return __async(this, null, function* () {
    var _a2;
    if (!looksLikeFetchResponse(error)) {
      throw new AuthRetryableFetchError(_getErrorMessage(error), 0);
    }
    if (NETWORK_ERROR_CODES.includes(error.status)) {
      throw new AuthRetryableFetchError(_getErrorMessage(error), error.status);
    }
    let data;
    try {
      data = yield error.json();
    } catch (e) {
      throw new AuthUnknownError(_getErrorMessage(e), e);
    }
    let errorCode = void 0;
    const responseAPIVersion = parseResponseAPIVersion(error);
    if (responseAPIVersion && responseAPIVersion.getTime() >= API_VERSIONS["2024-01-01"].timestamp && typeof data === "object" && data && typeof data.code === "string") {
      errorCode = data.code;
    } else if (typeof data === "object" && data && typeof data.error_code === "string") {
      errorCode = data.error_code;
    }
    if (!errorCode) {
      if (typeof data === "object" && data && typeof data.weak_password === "object" && data.weak_password && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.reasons.reduce((a, i) => a && typeof i === "string", true)) {
        throw new AuthWeakPasswordError(_getErrorMessage(data), error.status, data.weak_password.reasons);
      }
    } else if (errorCode === "weak_password") {
      throw new AuthWeakPasswordError(_getErrorMessage(data), error.status, ((_a2 = data.weak_password) === null || _a2 === void 0 ? void 0 : _a2.reasons) || []);
    } else if (errorCode === "session_not_found") {
      throw new AuthSessionMissingError();
    }
    throw new AuthApiError(_getErrorMessage(data), error.status || 500, errorCode);
  });
}
const _getRequestParams = (method, options, parameters, body2) => {
  const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
  if (method === "GET") {
    return params;
  }
  params.headers = Object.assign({ "Content-Type": "application/json;charset=UTF-8" }, options === null || options === void 0 ? void 0 : options.headers);
  params.body = JSON.stringify(body2);
  return Object.assign(Object.assign({}, params), parameters);
};
function _request(fetcher, method, url, options) {
  return __async(this, null, function* () {
    var _a2;
    const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);
    if (!headers[API_VERSION_HEADER_NAME]) {
      headers[API_VERSION_HEADER_NAME] = API_VERSIONS["2024-01-01"].name;
    }
    if (options === null || options === void 0 ? void 0 : options.jwt) {
      headers["Authorization"] = `Bearer ${options.jwt}`;
    }
    const qs = (_a2 = options === null || options === void 0 ? void 0 : options.query) !== null && _a2 !== void 0 ? _a2 : {};
    if (options === null || options === void 0 ? void 0 : options.redirectTo) {
      qs["redirect_to"] = options.redirectTo;
    }
    const queryString = Object.keys(qs).length ? "?" + new URLSearchParams(qs).toString() : "";
    const data = yield _handleRequest(fetcher, method, url + queryString, {
      headers,
      noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson
    }, {}, options === null || options === void 0 ? void 0 : options.body);
    return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : { data: Object.assign({}, data), error: null };
  });
}
function _handleRequest(fetcher, method, url, options, parameters, body2) {
  return __async(this, null, function* () {
    const requestParams = _getRequestParams(method, options, parameters, body2);
    let result;
    try {
      result = yield fetcher(url, Object.assign({}, requestParams));
    } catch (e) {
      console.error(e);
      throw new AuthRetryableFetchError(_getErrorMessage(e), 0);
    }
    if (!result.ok) {
      yield handleError(result);
    }
    if (options === null || options === void 0 ? void 0 : options.noResolveJson) {
      return result;
    }
    try {
      return yield result.json();
    } catch (e) {
      yield handleError(e);
    }
  });
}
function _sessionResponse(data) {
  var _a2;
  let session = null;
  if (hasSession(data)) {
    session = Object.assign({}, data);
    if (!data.expires_at) {
      session.expires_at = expiresAt(data.expires_in);
    }
  }
  const user = (_a2 = data.user) !== null && _a2 !== void 0 ? _a2 : data;
  return { data: { session, user }, error: null };
}
function _sessionResponsePassword(data) {
  const response = _sessionResponse(data);
  if (!response.error && data.weak_password && typeof data.weak_password === "object" && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.message && typeof data.weak_password.message === "string" && data.weak_password.reasons.reduce((a, i) => a && typeof i === "string", true)) {
    response.data.weak_password = data.weak_password;
  }
  return response;
}
function _userResponse(data) {
  var _a2;
  const user = (_a2 = data.user) !== null && _a2 !== void 0 ? _a2 : data;
  return { data: { user }, error: null };
}
function _ssoResponse(data) {
  return { data, error: null };
}
function _generateLinkResponse(data) {
  const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = __rest(data, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]);
  const properties2 = {
    action_link,
    email_otp,
    hashed_token,
    redirect_to,
    verification_type
  };
  const user = Object.assign({}, rest);
  return {
    data: {
      properties: properties2,
      user
    },
    error: null
  };
}
function _noResolveJsonResponse(data) {
  return data;
}
function hasSession(data) {
  return data.access_token && data.refresh_token && data.expires_in;
}
const SIGN_OUT_SCOPES = ["global", "local", "others"];
class GoTrueAdminApi {
  constructor({ url = "", headers = {}, fetch: fetch2 }) {
    this.url = url;
    this.headers = headers;
    this.fetch = resolveFetch(fetch2);
    this.mfa = {
      listFactors: this._listFactors.bind(this),
      deleteFactor: this._deleteFactor.bind(this)
    };
    this.oauth = {
      listClients: this._listOAuthClients.bind(this),
      createClient: this._createOAuthClient.bind(this),
      getClient: this._getOAuthClient.bind(this),
      deleteClient: this._deleteOAuthClient.bind(this),
      regenerateClientSecret: this._regenerateOAuthClientSecret.bind(this)
    };
  }
  /**
   * Removes a logged-in session.
   * @param jwt A valid, logged-in JWT.
   * @param scope The logout sope.
   */
  signOut(_0) {
    return __async(this, arguments, function* (jwt, scope = SIGN_OUT_SCOPES[0]) {
      if (SIGN_OUT_SCOPES.indexOf(scope) < 0) {
        throw new Error(`@supabase/auth-js: Parameter scope must be one of ${SIGN_OUT_SCOPES.join(", ")}`);
      }
      try {
        yield _request(this.fetch, "POST", `${this.url}/logout?scope=${scope}`, {
          headers: this.headers,
          jwt,
          noResolveJson: true
        });
        return { data: null, error: null };
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Sends an invite link to an email address.
   * @param email The email address of the user.
   * @param options Additional options to be included when inviting.
   */
  inviteUserByEmail(_0) {
    return __async(this, arguments, function* (email, options = {}) {
      try {
        return yield _request(this.fetch, "POST", `${this.url}/invite`, {
          body: { email, data: options.data },
          headers: this.headers,
          redirectTo: options.redirectTo,
          xform: _userResponse
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { user: null }, error };
        }
        throw error;
      }
    });
  }
  /**
   * Generates email links and OTPs to be sent via a custom email provider.
   * @param email The user's email.
   * @param options.password User password. For signup only.
   * @param options.data Optional user metadata. For signup only.
   * @param options.redirectTo The redirect url which should be appended to the generated link
   */
  generateLink(params) {
    return __async(this, null, function* () {
      try {
        const { options } = params, rest = __rest(params, ["options"]);
        const body2 = Object.assign(Object.assign({}, rest), options);
        if ("newEmail" in rest) {
          body2.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;
          delete body2["newEmail"];
        }
        return yield _request(this.fetch, "POST", `${this.url}/admin/generate_link`, {
          body: body2,
          headers: this.headers,
          xform: _generateLinkResponse,
          redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo
        });
      } catch (error) {
        if (isAuthError(error)) {
          return {
            data: {
              properties: null,
              user: null
            },
            error
          };
        }
        throw error;
      }
    });
  }
  // User Admin API
  /**
   * Creates a new user.
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  createUser(attributes) {
    return __async(this, null, function* () {
      try {
        return yield _request(this.fetch, "POST", `${this.url}/admin/users`, {
          body: attributes,
          headers: this.headers,
          xform: _userResponse
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { user: null }, error };
        }
        throw error;
      }
    });
  }
  /**
   * Get a list of users.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.
   */
  listUsers(params) {
    return __async(this, null, function* () {
      var _a2, _b, _c, _d, _e, _f, _g;
      try {
        const pagination = { nextPage: null, lastPage: 0, total: 0 };
        const response = yield _request(this.fetch, "GET", `${this.url}/admin/users`, {
          headers: this.headers,
          noResolveJson: true,
          query: {
            page: (_b = (_a2 = params === null || params === void 0 ? void 0 : params.page) === null || _a2 === void 0 ? void 0 : _a2.toString()) !== null && _b !== void 0 ? _b : "",
            per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""
          },
          xform: _noResolveJsonResponse
        });
        if (response.error)
          throw response.error;
        const users = yield response.json();
        const total = (_e = response.headers.get("x-total-count")) !== null && _e !== void 0 ? _e : 0;
        const links = (_g = (_f = response.headers.get("link")) === null || _f === void 0 ? void 0 : _f.split(",")) !== null && _g !== void 0 ? _g : [];
        if (links.length > 0) {
          links.forEach((link) => {
            const page = parseInt(link.split(";")[0].split("=")[1].substring(0, 1));
            const rel = JSON.parse(link.split(";")[1].split("=")[1]);
            pagination[`${rel}Page`] = page;
          });
          pagination.total = parseInt(total);
        }
        return { data: Object.assign(Object.assign({}, users), pagination), error: null };
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { users: [] }, error };
        }
        throw error;
      }
    });
  }
  /**
   * Get user by id.
   *
   * @param uid The user's unique identifier
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  getUserById(uid) {
    return __async(this, null, function* () {
      validateUUID(uid);
      try {
        return yield _request(this.fetch, "GET", `${this.url}/admin/users/${uid}`, {
          headers: this.headers,
          xform: _userResponse
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { user: null }, error };
        }
        throw error;
      }
    });
  }
  /**
   * Updates the user data.
   *
   * @param attributes The data you want to update.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  updateUserById(uid, attributes) {
    return __async(this, null, function* () {
      validateUUID(uid);
      try {
        return yield _request(this.fetch, "PUT", `${this.url}/admin/users/${uid}`, {
          body: attributes,
          headers: this.headers,
          xform: _userResponse
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { user: null }, error };
        }
        throw error;
      }
    });
  }
  /**
   * Delete a user. Requires a `service_role` key.
   *
   * @param id The user id you want to remove.
   * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema. Soft deletion allows user identification from the hashed user ID but is not reversible.
   * Defaults to false for backward compatibility.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  deleteUser(id, shouldSoftDelete = false) {
    return __async(this, null, function* () {
      validateUUID(id);
      try {
        return yield _request(this.fetch, "DELETE", `${this.url}/admin/users/${id}`, {
          headers: this.headers,
          body: {
            should_soft_delete: shouldSoftDelete
          },
          xform: _userResponse
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { user: null }, error };
        }
        throw error;
      }
    });
  }
  _listFactors(params) {
    return __async(this, null, function* () {
      validateUUID(params.userId);
      try {
        const { data, error } = yield _request(this.fetch, "GET", `${this.url}/admin/users/${params.userId}/factors`, {
          headers: this.headers,
          xform: (factors) => {
            return { data: { factors }, error: null };
          }
        });
        return { data, error };
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  _deleteFactor(params) {
    return __async(this, null, function* () {
      validateUUID(params.userId);
      validateUUID(params.id);
      try {
        const data = yield _request(this.fetch, "DELETE", `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {
          headers: this.headers
        });
        return { data, error: null };
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Lists all OAuth clients with optional pagination.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  _listOAuthClients(params) {
    return __async(this, null, function* () {
      var _a2, _b, _c, _d, _e, _f, _g;
      try {
        const pagination = { nextPage: null, lastPage: 0, total: 0 };
        const response = yield _request(this.fetch, "GET", `${this.url}/admin/oauth/clients`, {
          headers: this.headers,
          noResolveJson: true,
          query: {
            page: (_b = (_a2 = params === null || params === void 0 ? void 0 : params.page) === null || _a2 === void 0 ? void 0 : _a2.toString()) !== null && _b !== void 0 ? _b : "",
            per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""
          },
          xform: _noResolveJsonResponse
        });
        if (response.error)
          throw response.error;
        const clients = yield response.json();
        const total = (_e = response.headers.get("x-total-count")) !== null && _e !== void 0 ? _e : 0;
        const links = (_g = (_f = response.headers.get("link")) === null || _f === void 0 ? void 0 : _f.split(",")) !== null && _g !== void 0 ? _g : [];
        if (links.length > 0) {
          links.forEach((link) => {
            const page = parseInt(link.split(";")[0].split("=")[1].substring(0, 1));
            const rel = JSON.parse(link.split(";")[1].split("=")[1]);
            pagination[`${rel}Page`] = page;
          });
          pagination.total = parseInt(total);
        }
        return { data: Object.assign(Object.assign({}, clients), pagination), error: null };
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { clients: [] }, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a new OAuth client.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  _createOAuthClient(params) {
    return __async(this, null, function* () {
      try {
        return yield _request(this.fetch, "POST", `${this.url}/admin/oauth/clients`, {
          body: params,
          headers: this.headers,
          xform: (client) => {
            return { data: client, error: null };
          }
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Gets details of a specific OAuth client.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  _getOAuthClient(clientId) {
    return __async(this, null, function* () {
      try {
        return yield _request(this.fetch, "GET", `${this.url}/admin/oauth/clients/${clientId}`, {
          headers: this.headers,
          xform: (client) => {
            return { data: client, error: null };
          }
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Deletes an OAuth client.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  _deleteOAuthClient(clientId) {
    return __async(this, null, function* () {
      try {
        return yield _request(this.fetch, "DELETE", `${this.url}/admin/oauth/clients/${clientId}`, {
          headers: this.headers,
          xform: (client) => {
            return { data: client, error: null };
          }
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Regenerates the secret for an OAuth client.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  _regenerateOAuthClientSecret(clientId) {
    return __async(this, null, function* () {
      try {
        return yield _request(this.fetch, "POST", `${this.url}/admin/oauth/clients/${clientId}/regenerate_secret`, {
          headers: this.headers,
          xform: (client) => {
            return { data: client, error: null };
          }
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
}
function memoryLocalStorageAdapter(store = {}) {
  return {
    getItem: (key) => {
      return store[key] || null;
    },
    setItem: (key, value) => {
      store[key] = value;
    },
    removeItem: (key) => {
      delete store[key];
    }
  };
}
const internals = {
  /**
   * @experimental
   */
  debug: !!(globalThis && supportsLocalStorage() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true")
};
class LockAcquireTimeoutError extends Error {
  constructor(message) {
    super(message);
    this.isAcquireTimeout = true;
  }
}
class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {
}
function navigatorLock(name2, acquireTimeout, fn2) {
  return __async(this, null, function* () {
    if (internals.debug) {
      console.log("@supabase/gotrue-js: navigatorLock: acquire lock", name2, acquireTimeout);
    }
    const abortController = new globalThis.AbortController();
    if (acquireTimeout > 0) {
      setTimeout(() => {
        abortController.abort();
        if (internals.debug) {
          console.log("@supabase/gotrue-js: navigatorLock acquire timed out", name2);
        }
      }, acquireTimeout);
    }
    return yield Promise.resolve().then(() => globalThis.navigator.locks.request(name2, acquireTimeout === 0 ? {
      mode: "exclusive",
      ifAvailable: true
    } : {
      mode: "exclusive",
      signal: abortController.signal
    }, (lock) => __async(null, null, function* () {
      if (lock) {
        if (internals.debug) {
          console.log("@supabase/gotrue-js: navigatorLock: acquired", name2, lock.name);
        }
        try {
          return yield fn2();
        } finally {
          if (internals.debug) {
            console.log("@supabase/gotrue-js: navigatorLock: released", name2, lock.name);
          }
        }
      } else {
        if (acquireTimeout === 0) {
          if (internals.debug) {
            console.log("@supabase/gotrue-js: navigatorLock: not immediately available", name2);
          }
          throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock "${name2}" immediately failed`);
        } else {
          if (internals.debug) {
            try {
              const result = yield globalThis.navigator.locks.query();
              console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(result, null, "  "));
            } catch (e) {
              console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", e);
            }
          }
          console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request");
          return yield fn2();
        }
      }
    })));
  });
}
function polyfillGlobalThis() {
  if (typeof globalThis === "object")
    return;
  try {
    Object.defineProperty(Object.prototype, "__magic__", {
      get: function() {
        return this;
      },
      configurable: true
    });
    __magic__.globalThis = __magic__;
    delete Object.prototype.__magic__;
  } catch (e) {
    if (typeof self !== "undefined") {
      self.globalThis = self;
    }
  }
}
function getAddress(address) {
  if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
    throw new Error(`@supabase/auth-js: Address "${address}" is invalid.`);
  }
  return address.toLowerCase();
}
function fromHex(hex) {
  return parseInt(hex, 16);
}
function toHex(value) {
  const bytes = new TextEncoder().encode(value);
  const hex = Array.from(bytes, (byte) => byte.toString(16).padStart(2, "0")).join("");
  return "0x" + hex;
}
function createSiweMessage(parameters) {
  var _a2;
  const { chainId, domain, expirationTime, issuedAt = /* @__PURE__ */ new Date(), nonce, notBefore, requestId, resources, scheme, uri, version: version2 } = parameters;
  {
    if (!Number.isInteger(chainId))
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${chainId}`);
    if (!domain)
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.`);
    if (nonce && nonce.length < 8)
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${nonce}`);
    if (!uri)
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.`);
    if (version2 !== "1")
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${version2}`);
    if ((_a2 = parameters.statement) === null || _a2 === void 0 ? void 0 : _a2.includes("\n"))
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${parameters.statement}`);
  }
  const address = getAddress(parameters.address);
  const origin = scheme ? `${scheme}://${domain}` : domain;
  const statement = parameters.statement ? `${parameters.statement}
` : "";
  const prefix2 = `${origin} wants you to sign in with your Ethereum account:
${address}

${statement}`;
  let suffix = `URI: ${uri}
Version: ${version2}
Chain ID: ${chainId}${nonce ? `
Nonce: ${nonce}` : ""}
Issued At: ${issuedAt.toISOString()}`;
  if (expirationTime)
    suffix += `
Expiration Time: ${expirationTime.toISOString()}`;
  if (notBefore)
    suffix += `
Not Before: ${notBefore.toISOString()}`;
  if (requestId)
    suffix += `
Request ID: ${requestId}`;
  if (resources) {
    let content = "\nResources:";
    for (const resource of resources) {
      if (!resource || typeof resource !== "string")
        throw new Error(`@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${resource}`);
      content += `
- ${resource}`;
    }
    suffix += content;
  }
  return `${prefix2}
${suffix}`;
}
class WebAuthnError extends Error {
  constructor({ message, code, cause, name: name2 }) {
    var _a2;
    super(message, { cause });
    this.__isWebAuthnError = true;
    this.name = (_a2 = name2 !== null && name2 !== void 0 ? name2 : cause instanceof Error ? cause.name : void 0) !== null && _a2 !== void 0 ? _a2 : "Unknown Error";
    this.code = code;
  }
}
class WebAuthnUnknownError extends WebAuthnError {
  constructor(message, originalError) {
    super({
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: originalError,
      message
    });
    this.name = "WebAuthnUnknownError";
    this.originalError = originalError;
  }
}
function identifyRegistrationError({ error, options }) {
  var _a2, _b, _c;
  const { publicKey } = options;
  if (!publicKey) {
    throw Error("options was missing required publicKey property");
  }
  if (error.name === "AbortError") {
    if (options.signal instanceof AbortSignal) {
      return new WebAuthnError({
        message: "Registration ceremony was sent an abort signal",
        code: "ERROR_CEREMONY_ABORTED",
        cause: error
      });
    }
  } else if (error.name === "ConstraintError") {
    if (((_a2 = publicKey.authenticatorSelection) === null || _a2 === void 0 ? void 0 : _a2.requireResidentKey) === true) {
      return new WebAuthnError({
        message: "Discoverable credentials were required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",
        cause: error
      });
    } else if (
      // @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024
      options.mediation === "conditional" && ((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === "required"
    ) {
      return new WebAuthnError({
        message: "User verification was required during automatic registration but it could not be performed",
        code: "ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",
        cause: error
      });
    } else if (((_c = publicKey.authenticatorSelection) === null || _c === void 0 ? void 0 : _c.userVerification) === "required") {
      return new WebAuthnError({
        message: "User verification was required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",
        cause: error
      });
    }
  } else if (error.name === "InvalidStateError") {
    return new WebAuthnError({
      message: "The authenticator was previously registered",
      code: "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",
      cause: error
    });
  } else if (error.name === "NotAllowedError") {
    return new WebAuthnError({
      message: error.message,
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: error
    });
  } else if (error.name === "NotSupportedError") {
    const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param) => param.type === "public-key");
    if (validPubKeyCredParams.length === 0) {
      return new WebAuthnError({
        message: 'No entry in pubKeyCredParams was of type "public-key"',
        code: "ERROR_MALFORMED_PUBKEYCREDPARAMS",
        cause: error
      });
    }
    return new WebAuthnError({
      message: "No available authenticator supported any of the specified pubKeyCredParams algorithms",
      code: "ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",
      cause: error
    });
  } else if (error.name === "SecurityError") {
    const effectiveDomain = window.location.hostname;
    if (!isValidDomain(effectiveDomain)) {
      return new WebAuthnError({
        message: `${window.location.hostname} is an invalid domain`,
        code: "ERROR_INVALID_DOMAIN",
        cause: error
      });
    } else if (publicKey.rp.id !== effectiveDomain) {
      return new WebAuthnError({
        message: `The RP ID "${publicKey.rp.id}" is invalid for this domain`,
        code: "ERROR_INVALID_RP_ID",
        cause: error
      });
    }
  } else if (error.name === "TypeError") {
    if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {
      return new WebAuthnError({
        message: "User ID was not between 1 and 64 characters",
        code: "ERROR_INVALID_USER_ID_LENGTH",
        cause: error
      });
    }
  } else if (error.name === "UnknownError") {
    return new WebAuthnError({
      message: "The authenticator was unable to process the specified options, or could not create a new credential",
      code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
      cause: error
    });
  }
  return new WebAuthnError({
    message: "a Non-Webauthn related error has occurred",
    code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
    cause: error
  });
}
function identifyAuthenticationError({ error, options }) {
  const { publicKey } = options;
  if (!publicKey) {
    throw Error("options was missing required publicKey property");
  }
  if (error.name === "AbortError") {
    if (options.signal instanceof AbortSignal) {
      return new WebAuthnError({
        message: "Authentication ceremony was sent an abort signal",
        code: "ERROR_CEREMONY_ABORTED",
        cause: error
      });
    }
  } else if (error.name === "NotAllowedError") {
    return new WebAuthnError({
      message: error.message,
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: error
    });
  } else if (error.name === "SecurityError") {
    const effectiveDomain = window.location.hostname;
    if (!isValidDomain(effectiveDomain)) {
      return new WebAuthnError({
        message: `${window.location.hostname} is an invalid domain`,
        code: "ERROR_INVALID_DOMAIN",
        cause: error
      });
    } else if (publicKey.rpId !== effectiveDomain) {
      return new WebAuthnError({
        message: `The RP ID "${publicKey.rpId}" is invalid for this domain`,
        code: "ERROR_INVALID_RP_ID",
        cause: error
      });
    }
  } else if (error.name === "UnknownError") {
    return new WebAuthnError({
      message: "The authenticator was unable to process the specified options, or could not create a new assertion signature",
      code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
      cause: error
    });
  }
  return new WebAuthnError({
    message: "a Non-Webauthn related error has occurred",
    code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
    cause: error
  });
}
class WebAuthnAbortService {
  /**
   * Create an abort signal for a new WebAuthn operation.
   * Automatically cancels any existing operation.
   *
   * @returns {AbortSignal} Signal to pass to navigator.credentials.create() or .get()
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal MDN - AbortSignal}
   */
  createNewAbortSignal() {
    if (this.controller) {
      const abortError = new Error("Cancelling existing WebAuthn API call for new one");
      abortError.name = "AbortError";
      this.controller.abort(abortError);
    }
    const newController = new AbortController();
    this.controller = newController;
    return newController.signal;
  }
  /**
   * Manually cancel the current WebAuthn operation.
   * Useful for cleaning up when user cancels or navigates away.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort MDN - AbortController.abort}
   */
  cancelCeremony() {
    if (this.controller) {
      const abortError = new Error("Manually cancelling existing WebAuthn API call");
      abortError.name = "AbortError";
      this.controller.abort(abortError);
      this.controller = void 0;
    }
  }
}
const webAuthnAbortService = new WebAuthnAbortService();
function deserializeCredentialCreationOptions(options) {
  if (!options) {
    throw new Error("Credential creation options are required");
  }
  if (typeof PublicKeyCredential !== "undefined" && "parseCreationOptionsFromJSON" in PublicKeyCredential && typeof PublicKeyCredential.parseCreationOptionsFromJSON === "function") {
    return PublicKeyCredential.parseCreationOptionsFromJSON(
      /** we assert the options here as typescript still doesn't know about future webauthn types */
      options
    );
  }
  const { challenge: challengeStr, user: userOpts, excludeCredentials } = options, restOptions = __rest(
    options,
    ["challenge", "user", "excludeCredentials"]
  );
  const challenge = base64UrlToUint8Array(challengeStr).buffer;
  const user = Object.assign(Object.assign({}, userOpts), { id: base64UrlToUint8Array(userOpts.id).buffer });
  const result = Object.assign(Object.assign({}, restOptions), {
    challenge,
    user
  });
  if (excludeCredentials && excludeCredentials.length > 0) {
    result.excludeCredentials = new Array(excludeCredentials.length);
    for (let i = 0; i < excludeCredentials.length; i++) {
      const cred = excludeCredentials[i];
      result.excludeCredentials[i] = Object.assign(Object.assign({}, cred), {
        id: base64UrlToUint8Array(cred.id).buffer,
        type: cred.type || "public-key",
        // Cast transports to handle future transport types like "cable"
        transports: cred.transports
      });
    }
  }
  return result;
}
function deserializeCredentialRequestOptions(options) {
  if (!options) {
    throw new Error("Credential request options are required");
  }
  if (typeof PublicKeyCredential !== "undefined" && "parseRequestOptionsFromJSON" in PublicKeyCredential && typeof PublicKeyCredential.parseRequestOptionsFromJSON === "function") {
    return PublicKeyCredential.parseRequestOptionsFromJSON(options);
  }
  const { challenge: challengeStr, allowCredentials } = options, restOptions = __rest(
    options,
    ["challenge", "allowCredentials"]
  );
  const challenge = base64UrlToUint8Array(challengeStr).buffer;
  const result = Object.assign(Object.assign({}, restOptions), { challenge });
  if (allowCredentials && allowCredentials.length > 0) {
    result.allowCredentials = new Array(allowCredentials.length);
    for (let i = 0; i < allowCredentials.length; i++) {
      const cred = allowCredentials[i];
      result.allowCredentials[i] = Object.assign(Object.assign({}, cred), {
        id: base64UrlToUint8Array(cred.id).buffer,
        type: cred.type || "public-key",
        // Cast transports to handle future transport types like "cable"
        transports: cred.transports
      });
    }
  }
  return result;
}
function serializeCredentialCreationResponse(credential) {
  var _a2;
  if ("toJSON" in credential && typeof credential.toJSON === "function") {
    return credential.toJSON();
  }
  const credentialWithAttachment = credential;
  return {
    id: credential.id,
    rawId: credential.id,
    response: {
      attestationObject: bytesToBase64URL(new Uint8Array(credential.response.attestationObject)),
      clientDataJSON: bytesToBase64URL(new Uint8Array(credential.response.clientDataJSON))
    },
    type: "public-key",
    clientExtensionResults: credential.getClientExtensionResults(),
    // Convert null to undefined and cast to AuthenticatorAttachment type
    authenticatorAttachment: (_a2 = credentialWithAttachment.authenticatorAttachment) !== null && _a2 !== void 0 ? _a2 : void 0
  };
}
function serializeCredentialRequestResponse(credential) {
  var _a2;
  if ("toJSON" in credential && typeof credential.toJSON === "function") {
    return credential.toJSON();
  }
  const credentialWithAttachment = credential;
  const clientExtensionResults = credential.getClientExtensionResults();
  const assertionResponse = credential.response;
  return {
    id: credential.id,
    rawId: credential.id,
    // W3C spec expects rawId to match id for JSON format
    response: {
      authenticatorData: bytesToBase64URL(new Uint8Array(assertionResponse.authenticatorData)),
      clientDataJSON: bytesToBase64URL(new Uint8Array(assertionResponse.clientDataJSON)),
      signature: bytesToBase64URL(new Uint8Array(assertionResponse.signature)),
      userHandle: assertionResponse.userHandle ? bytesToBase64URL(new Uint8Array(assertionResponse.userHandle)) : void 0
    },
    type: "public-key",
    clientExtensionResults,
    // Convert null to undefined and cast to AuthenticatorAttachment type
    authenticatorAttachment: (_a2 = credentialWithAttachment.authenticatorAttachment) !== null && _a2 !== void 0 ? _a2 : void 0
  };
}
function isValidDomain(hostname) {
  return (
    // Consider localhost valid as well since it's okay wrt Secure Contexts
    hostname === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(hostname)
  );
}
function browserSupportsWebAuthn() {
  var _a2, _b;
  return !!(isBrowser$3() && "PublicKeyCredential" in window && window.PublicKeyCredential && "credentials" in navigator && typeof ((_a2 = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _a2 === void 0 ? void 0 : _a2.create) === "function" && typeof ((_b = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _b === void 0 ? void 0 : _b.get) === "function");
}
function createCredential(options) {
  return __async(this, null, function* () {
    try {
      const response = yield navigator.credentials.create(
        /** we assert the type here until typescript types are updated */
        options
      );
      if (!response) {
        return {
          data: null,
          error: new WebAuthnUnknownError("Empty credential response", response)
        };
      }
      if (!(response instanceof PublicKeyCredential)) {
        return {
          data: null,
          error: new WebAuthnUnknownError("Browser returned unexpected credential type", response)
        };
      }
      return { data: response, error: null };
    } catch (err) {
      return {
        data: null,
        error: identifyRegistrationError({
          error: err,
          options
        })
      };
    }
  });
}
function getCredential(options) {
  return __async(this, null, function* () {
    try {
      const response = yield navigator.credentials.get(
        /** we assert the type here until typescript types are updated */
        options
      );
      if (!response) {
        return {
          data: null,
          error: new WebAuthnUnknownError("Empty credential response", response)
        };
      }
      if (!(response instanceof PublicKeyCredential)) {
        return {
          data: null,
          error: new WebAuthnUnknownError("Browser returned unexpected credential type", response)
        };
      }
      return { data: response, error: null };
    } catch (err) {
      return {
        data: null,
        error: identifyAuthenticationError({
          error: err,
          options
        })
      };
    }
  });
}
const DEFAULT_CREATION_OPTIONS = {
  hints: ["security-key"],
  authenticatorSelection: {
    authenticatorAttachment: "cross-platform",
    requireResidentKey: false,
    /** set to preferred because older yubikeys don't have PIN/Biometric */
    userVerification: "preferred",
    residentKey: "discouraged"
  },
  attestation: "none"
};
const DEFAULT_REQUEST_OPTIONS = {
  /** set to preferred because older yubikeys don't have PIN/Biometric */
  userVerification: "preferred",
  hints: ["security-key"]
};
function deepMerge(...sources) {
  const isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  const isArrayBufferLike = (val) => val instanceof ArrayBuffer || ArrayBuffer.isView(val);
  const result = {};
  for (const source of sources) {
    if (!source)
      continue;
    for (const key in source) {
      const value = source[key];
      if (value === void 0)
        continue;
      if (Array.isArray(value)) {
        result[key] = value;
      } else if (isArrayBufferLike(value)) {
        result[key] = value;
      } else if (isObject(value)) {
        const existing = result[key];
        if (isObject(existing)) {
          result[key] = deepMerge(existing, value);
        } else {
          result[key] = deepMerge(value);
        }
      } else {
        result[key] = value;
      }
    }
  }
  return result;
}
function mergeCredentialCreationOptions(baseOptions, overrides) {
  return deepMerge(DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {});
}
function mergeCredentialRequestOptions(baseOptions, overrides) {
  return deepMerge(DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {});
}
class WebAuthnApi {
  constructor(client) {
    this.client = client;
    this.enroll = this._enroll.bind(this);
    this.challenge = this._challenge.bind(this);
    this.verify = this._verify.bind(this);
    this.authenticate = this._authenticate.bind(this);
    this.register = this._register.bind(this);
  }
  /**
   * Enroll a new WebAuthn factor.
   * Creates an unverified WebAuthn factor that must be verified with a credential.
   *
   * @experimental This method is experimental and may change in future releases
   * @param {Omit<MFAEnrollWebauthnParams, 'factorType'>} params - Enrollment parameters (friendlyName required)
   * @returns {Promise<AuthMFAEnrollWebauthnResponse>} Enrolled factor details or error
   * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}
   */
  _enroll(params) {
    return __async(this, null, function* () {
      return this.client.mfa.enroll(Object.assign(Object.assign({}, params), { factorType: "webauthn" }));
    });
  }
  /**
   * Challenge for WebAuthn credential creation or authentication.
   * Combines server challenge with browser credential operations.
   * Handles both registration (create) and authentication (request) flows.
   *
   * @experimental This method is experimental and may change in future releases
   * @param {MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal }} params - Challenge parameters including factorId
   * @param {Object} overrides - Allows you to override the parameters passed to navigator.credentials
   * @param {PublicKeyCredentialCreationOptionsFuture} overrides.create - Override options for credential creation
   * @param {PublicKeyCredentialRequestOptionsFuture} overrides.request - Override options for credential request
   * @returns {Promise<RequestResult>} Challenge response with credential or error
   * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}
   * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying Assertion}
   */
  _challenge(_0, _1) {
    return __async(this, arguments, function* ({ factorId, webauthn, friendlyName, signal }, overrides) {
      try {
        const { data: challengeResponse, error: challengeError } = yield this.client.mfa.challenge({
          factorId,
          webauthn
        });
        if (!challengeResponse) {
          return { data: null, error: challengeError };
        }
        const abortSignal = signal !== null && signal !== void 0 ? signal : webAuthnAbortService.createNewAbortSignal();
        if (challengeResponse.webauthn.type === "create") {
          const { user } = challengeResponse.webauthn.credential_options.publicKey;
          if (!user.name) {
            user.name = `${user.id}:${friendlyName}`;
          }
          if (!user.displayName) {
            user.displayName = user.name;
          }
        }
        switch (challengeResponse.webauthn.type) {
          case "create": {
            const options = mergeCredentialCreationOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.create);
            const { data, error } = yield createCredential({
              publicKey: options,
              signal: abortSignal
            });
            if (data) {
              return {
                data: {
                  factorId,
                  challengeId: challengeResponse.id,
                  webauthn: {
                    type: challengeResponse.webauthn.type,
                    credential_response: data
                  }
                },
                error: null
              };
            }
            return { data: null, error };
          }
          case "request": {
            const options = mergeCredentialRequestOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.request);
            const { data, error } = yield getCredential(Object.assign(Object.assign({}, challengeResponse.webauthn.credential_options), { publicKey: options, signal: abortSignal }));
            if (data) {
              return {
                data: {
                  factorId,
                  challengeId: challengeResponse.id,
                  webauthn: {
                    type: challengeResponse.webauthn.type,
                    credential_response: data
                  }
                },
                error: null
              };
            }
            return { data: null, error };
          }
        }
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        return {
          data: null,
          error: new AuthUnknownError("Unexpected error in challenge", error)
        };
      }
    });
  }
  /**
   * Verify a WebAuthn credential with the server.
   * Completes the WebAuthn ceremony by sending the credential to the server for verification.
   *
   * @experimental This method is experimental and may change in future releases
   * @param {Object} params - Verification parameters
   * @param {string} params.challengeId - ID of the challenge being verified
   * @param {string} params.factorId - ID of the WebAuthn factor
   * @param {MFAVerifyWebauthnParams<T>['webauthn']} params.webauthn - WebAuthn credential response
   * @returns {Promise<AuthMFAVerifyResponse>} Verification result with session or error
   * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}
   * */
  _verify(_0) {
    return __async(this, arguments, function* ({ challengeId, factorId, webauthn }) {
      return this.client.mfa.verify({
        factorId,
        challengeId,
        webauthn
      });
    });
  }
  /**
   * Complete WebAuthn authentication flow.
   * Performs challenge and verification in a single operation for existing credentials.
   *
   * @experimental This method is experimental and may change in future releases
   * @param {Object} params - Authentication parameters
   * @param {string} params.factorId - ID of the WebAuthn factor to authenticate with
   * @param {Object} params.webauthn - WebAuthn configuration
   * @param {string} params.webauthn.rpId - Relying Party ID (defaults to current hostname)
   * @param {string[]} params.webauthn.rpOrigins - Allowed origins (defaults to current origin)
   * @param {AbortSignal} params.webauthn.signal - Optional abort signal
   * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Override options for navigator.credentials.get
   * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Authentication result
   * @see {@link https://w3c.github.io/webauthn/#sctn-authentication W3C WebAuthn Spec - Authentication Ceremony}
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions MDN - PublicKeyCredentialRequestOptions}
   */
  _authenticate(_0, _1) {
    return __async(this, arguments, function* ({ factorId, webauthn: { rpId = typeof window !== "undefined" ? window.location.hostname : void 0, rpOrigins = typeof window !== "undefined" ? [window.location.origin] : void 0, signal } }, overrides) {
      if (!rpId) {
        return {
          data: null,
          error: new AuthError("rpId is required for WebAuthn authentication")
        };
      }
      try {
        if (!browserSupportsWebAuthn()) {
          return {
            data: null,
            error: new AuthUnknownError("Browser does not support WebAuthn", null)
          };
        }
        const { data: challengeResponse, error: challengeError } = yield this.challenge({
          factorId,
          webauthn: { rpId, rpOrigins },
          signal
        }, { request: overrides });
        if (!challengeResponse) {
          return { data: null, error: challengeError };
        }
        const { webauthn } = challengeResponse;
        return this._verify({
          factorId,
          challengeId: challengeResponse.challengeId,
          webauthn: {
            type: webauthn.type,
            rpId,
            rpOrigins,
            credential_response: webauthn.credential_response
          }
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        return {
          data: null,
          error: new AuthUnknownError("Unexpected error in authenticate", error)
        };
      }
    });
  }
  /**
   * Complete WebAuthn registration flow.
   * Performs enrollment, challenge, and verification in a single operation for new credentials.
   *
   * @experimental This method is experimental and may change in future releases
   * @param {Object} params - Registration parameters
   * @param {string} params.friendlyName - User-friendly name for the credential
   * @param {string} params.rpId - Relying Party ID (defaults to current hostname)
   * @param {string[]} params.rpOrigins - Allowed origins (defaults to current origin)
   * @param {AbortSignal} params.signal - Optional abort signal
   * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Override options for navigator.credentials.create
   * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Registration result
   * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registration Ceremony}
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions MDN - PublicKeyCredentialCreationOptions}
   */
  _register(_0, _1) {
    return __async(this, arguments, function* ({ friendlyName, rpId = typeof window !== "undefined" ? window.location.hostname : void 0, rpOrigins = typeof window !== "undefined" ? [window.location.origin] : void 0, signal }, overrides) {
      if (!rpId) {
        return {
          data: null,
          error: new AuthError("rpId is required for WebAuthn registration")
        };
      }
      try {
        if (!browserSupportsWebAuthn()) {
          return {
            data: null,
            error: new AuthUnknownError("Browser does not support WebAuthn", null)
          };
        }
        const { data: factor, error: enrollError } = yield this._enroll({
          friendlyName
        });
        if (!factor) {
          yield this.client.mfa.listFactors().then((factors) => {
            var _a2;
            return (_a2 = factors.data) === null || _a2 === void 0 ? void 0 : _a2.all.find((v) => v.factor_type === "webauthn" && v.friendly_name === friendlyName && v.status !== "unverified");
          }).then((factor2) => factor2 ? this.client.mfa.unenroll({ factorId: factor2 === null || factor2 === void 0 ? void 0 : factor2.id }) : void 0);
          return { data: null, error: enrollError };
        }
        const { data: challengeResponse, error: challengeError } = yield this._challenge({
          factorId: factor.id,
          friendlyName: factor.friendly_name,
          webauthn: { rpId, rpOrigins },
          signal
        }, {
          create: overrides
        });
        if (!challengeResponse) {
          return { data: null, error: challengeError };
        }
        return this._verify({
          factorId: factor.id,
          challengeId: challengeResponse.challengeId,
          webauthn: {
            rpId,
            rpOrigins,
            type: challengeResponse.webauthn.type,
            credential_response: challengeResponse.webauthn.credential_response
          }
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        return {
          data: null,
          error: new AuthUnknownError("Unexpected error in register", error)
        };
      }
    });
  }
}
polyfillGlobalThis();
const DEFAULT_OPTIONS = {
  url: GOTRUE_URL,
  storageKey: STORAGE_KEY,
  autoRefreshToken: true,
  persistSession: true,
  detectSessionInUrl: true,
  headers: DEFAULT_HEADERS,
  flowType: "implicit",
  debug: false,
  hasCustomAuthorizationHeader: false
};
function lockNoOp(name2, acquireTimeout, fn2) {
  return __async(this, null, function* () {
    return yield fn2();
  });
}
const GLOBAL_JWKS = {};
class GoTrueClient {
  /**
   * The JWKS used for verifying asymmetric JWTs
   */
  get jwks() {
    var _a2, _b;
    return (_b = (_a2 = GLOBAL_JWKS[this.storageKey]) === null || _a2 === void 0 ? void 0 : _a2.jwks) !== null && _b !== void 0 ? _b : { keys: [] };
  }
  set jwks(value) {
    GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), { jwks: value });
  }
  get jwks_cached_at() {
    var _a2, _b;
    return (_b = (_a2 = GLOBAL_JWKS[this.storageKey]) === null || _a2 === void 0 ? void 0 : _a2.cachedAt) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;
  }
  set jwks_cached_at(value) {
    GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), { cachedAt: value });
  }
  /**
   * Create a new client for use in the browser.
   */
  constructor(options) {
    var _a2, _b;
    this.userStorage = null;
    this.memoryStorage = null;
    this.stateChangeEmitters = /* @__PURE__ */ new Map();
    this.autoRefreshTicker = null;
    this.visibilityChangedCallback = null;
    this.refreshingDeferred = null;
    this.initializePromise = null;
    this.detectSessionInUrl = true;
    this.hasCustomAuthorizationHeader = false;
    this.suppressGetSessionWarning = false;
    this.lockAcquired = false;
    this.pendingInLock = [];
    this.broadcastChannel = null;
    this.logger = console.log;
    this.instanceID = GoTrueClient.nextInstanceID;
    GoTrueClient.nextInstanceID += 1;
    if (this.instanceID > 0 && isBrowser$3()) {
      console.warn("Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.");
    }
    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
    this.logDebugMessages = !!settings.debug;
    if (typeof settings.debug === "function") {
      this.logger = settings.debug;
    }
    this.persistSession = settings.persistSession;
    this.storageKey = settings.storageKey;
    this.autoRefreshToken = settings.autoRefreshToken;
    this.admin = new GoTrueAdminApi({
      url: settings.url,
      headers: settings.headers,
      fetch: settings.fetch
    });
    this.url = settings.url;
    this.headers = settings.headers;
    this.fetch = resolveFetch(settings.fetch);
    this.lock = settings.lock || lockNoOp;
    this.detectSessionInUrl = settings.detectSessionInUrl;
    this.flowType = settings.flowType;
    this.hasCustomAuthorizationHeader = settings.hasCustomAuthorizationHeader;
    if (settings.lock) {
      this.lock = settings.lock;
    } else if (isBrowser$3() && ((_a2 = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a2 === void 0 ? void 0 : _a2.locks)) {
      this.lock = navigatorLock;
    } else {
      this.lock = lockNoOp;
    }
    if (!this.jwks) {
      this.jwks = { keys: [] };
      this.jwks_cached_at = Number.MIN_SAFE_INTEGER;
    }
    this.mfa = {
      verify: this._verify.bind(this),
      enroll: this._enroll.bind(this),
      unenroll: this._unenroll.bind(this),
      challenge: this._challenge.bind(this),
      listFactors: this._listFactors.bind(this),
      challengeAndVerify: this._challengeAndVerify.bind(this),
      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),
      webauthn: new WebAuthnApi(this)
    };
    if (this.persistSession) {
      if (settings.storage) {
        this.storage = settings.storage;
      } else {
        if (supportsLocalStorage()) {
          this.storage = globalThis.localStorage;
        } else {
          this.memoryStorage = {};
          this.storage = memoryLocalStorageAdapter(this.memoryStorage);
        }
      }
      if (settings.userStorage) {
        this.userStorage = settings.userStorage;
      }
    } else {
      this.memoryStorage = {};
      this.storage = memoryLocalStorageAdapter(this.memoryStorage);
    }
    if (isBrowser$3() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
      try {
        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);
      } catch (e) {
        console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", e);
      }
      (_b = this.broadcastChannel) === null || _b === void 0 ? void 0 : _b.addEventListener("message", (event) => __async(this, null, function* () {
        this._debug("received broadcast notification from other tab or client", event);
        yield this._notifyAllSubscribers(event.data.event, event.data.session, false);
      }));
    }
    this.initialize();
  }
  _debug(...args) {
    if (this.logDebugMessages) {
      this.logger(`GoTrueClient@${this.instanceID} (${version$2}) ${(/* @__PURE__ */ new Date()).toISOString()}`, ...args);
    }
    return this;
  }
  /**
   * Initializes the client session either from the url or from storage.
   * This method is automatically called when instantiating the client, but should also be called
   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).
   */
  initialize() {
    return __async(this, null, function* () {
      if (this.initializePromise) {
        return yield this.initializePromise;
      }
      this.initializePromise = (() => __async(this, null, function* () {
        return yield this._acquireLock(-1, () => __async(this, null, function* () {
          return yield this._initialize();
        }));
      }))();
      return yield this.initializePromise;
    });
  }
  /**
   * IMPORTANT:
   * 1. Never throw in this method, as it is called from the constructor
   * 2. Never return a session from this method as it would be cached over
   *    the whole lifetime of the client
   */
  _initialize() {
    return __async(this, null, function* () {
      var _a2;
      try {
        const params = parseParametersFromURL(window.location.href);
        let callbackUrlType = "none";
        if (this._isImplicitGrantCallback(params)) {
          callbackUrlType = "implicit";
        } else if (yield this._isPKCECallback(params)) {
          callbackUrlType = "pkce";
        }
        if (isBrowser$3() && this.detectSessionInUrl && callbackUrlType !== "none") {
          const { data, error } = yield this._getSessionFromURL(params, callbackUrlType);
          if (error) {
            this._debug("#_initialize()", "error detecting session from URL", error);
            if (isAuthImplicitGrantRedirectError(error)) {
              const errorCode = (_a2 = error.details) === null || _a2 === void 0 ? void 0 : _a2.code;
              if (errorCode === "identity_already_exists" || errorCode === "identity_not_found" || errorCode === "single_identity_not_deletable") {
                return { error };
              }
            }
            yield this._removeSession();
            return { error };
          }
          const { session, redirectType } = data;
          this._debug("#_initialize()", "detected session in URL", session, "redirect type", redirectType);
          yield this._saveSession(session);
          setTimeout(() => __async(this, null, function* () {
            if (redirectType === "recovery") {
              yield this._notifyAllSubscribers("PASSWORD_RECOVERY", session);
            } else {
              yield this._notifyAllSubscribers("SIGNED_IN", session);
            }
          }), 0);
          return { error: null };
        }
        yield this._recoverAndRefresh();
        return { error: null };
      } catch (error) {
        if (isAuthError(error)) {
          return { error };
        }
        return {
          error: new AuthUnknownError("Unexpected error during initialization", error)
        };
      } finally {
        yield this._handleVisibilityChange();
        this._debug("#_initialize()", "end");
      }
    });
  }
  /**
   * Creates a new anonymous user.
   *
   * @returns A session where the is_anonymous claim in the access token JWT set to true
   */
  signInAnonymously(credentials) {
    return __async(this, null, function* () {
      var _a2, _b, _c;
      try {
        const res = yield _request(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          body: {
            data: (_b = (_a2 = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _a2 === void 0 ? void 0 : _a2.data) !== null && _b !== void 0 ? _b : {},
            gotrue_meta_security: { captcha_token: (_c = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _c === void 0 ? void 0 : _c.captchaToken }
          },
          xform: _sessionResponse
        });
        const { data, error } = res;
        if (error || !data) {
          return { data: { user: null, session: null }, error };
        }
        const session = data.session;
        const user = data.user;
        if (data.session) {
          yield this._saveSession(data.session);
          yield this._notifyAllSubscribers("SIGNED_IN", session);
        }
        return { data: { user, session }, error: null };
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { user: null, session: null }, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a new user.
   *
   * Be aware that if a user account exists in the system you may get back an
   * error message that attempts to hide this information from the user.
   * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.
   *
   * @returns A logged-in session if the server has "autoconfirm" ON
   * @returns A user if the server has "autoconfirm" OFF
   */
  signUp(credentials) {
    return __async(this, null, function* () {
      var _a2, _b, _c;
      try {
        let res;
        if ("email" in credentials) {
          const { email, password, options } = credentials;
          let codeChallenge = null;
          let codeChallengeMethod = null;
          if (this.flowType === "pkce") {
            ;
            [codeChallenge, codeChallengeMethod] = yield getCodeChallengeAndMethod(this.storage, this.storageKey);
          }
          res = yield _request(this.fetch, "POST", `${this.url}/signup`, {
            headers: this.headers,
            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
            body: {
              email,
              password,
              data: (_a2 = options === null || options === void 0 ? void 0 : options.data) !== null && _a2 !== void 0 ? _a2 : {},
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
              code_challenge: codeChallenge,
              code_challenge_method: codeChallengeMethod
            },
            xform: _sessionResponse
          });
        } else if ("phone" in credentials) {
          const { phone, password, options } = credentials;
          res = yield _request(this.fetch, "POST", `${this.url}/signup`, {
            headers: this.headers,
            body: {
              phone,
              password,
              data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},
              channel: (_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : "sms",
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
            },
            xform: _sessionResponse
          });
        } else {
          throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
        }
        const { data, error } = res;
        if (error || !data) {
          return { data: { user: null, session: null }, error };
        }
        const session = data.session;
        const user = data.user;
        if (data.session) {
          yield this._saveSession(data.session);
          yield this._notifyAllSubscribers("SIGNED_IN", session);
        }
        return { data: { user, session }, error: null };
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { user: null, session: null }, error };
        }
        throw error;
      }
    });
  }
  /**
   * Log in an existing user with an email and password or phone and password.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or that the
   * email/phone and password combination is wrong or that the account can only
   * be accessed via social login.
   */
  signInWithPassword(credentials) {
    return __async(this, null, function* () {
      try {
        let res;
        if ("email" in credentials) {
          const { email, password, options } = credentials;
          res = yield _request(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
            headers: this.headers,
            body: {
              email,
              password,
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
            },
            xform: _sessionResponsePassword
          });
        } else if ("phone" in credentials) {
          const { phone, password, options } = credentials;
          res = yield _request(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
            headers: this.headers,
            body: {
              phone,
              password,
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
            },
            xform: _sessionResponsePassword
          });
        } else {
          throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
        }
        const { data, error } = res;
        if (error) {
          return { data: { user: null, session: null }, error };
        } else if (!data || !data.session || !data.user) {
          return { data: { user: null, session: null }, error: new AuthInvalidTokenResponseError() };
        }
        if (data.session) {
          yield this._saveSession(data.session);
          yield this._notifyAllSubscribers("SIGNED_IN", data.session);
        }
        return {
          data: Object.assign({ user: data.user, session: data.session }, data.weak_password ? { weakPassword: data.weak_password } : null),
          error
        };
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { user: null, session: null }, error };
        }
        throw error;
      }
    });
  }
  /**
   * Log in an existing user via a third-party provider.
   * This method supports the PKCE flow.
   */
  signInWithOAuth(credentials) {
    return __async(this, null, function* () {
      var _a2, _b, _c, _d;
      return yield this._handleProviderSignIn(credentials.provider, {
        redirectTo: (_a2 = credentials.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo,
        scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
        queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
        skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect
      });
    });
  }
  /**
   * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.
   */
  exchangeCodeForSession(authCode) {
    return __async(this, null, function* () {
      yield this.initializePromise;
      return this._acquireLock(-1, () => __async(this, null, function* () {
        return this._exchangeCodeForSession(authCode);
      }));
    });
  }
  /**
   * Signs in a user by verifying a message signed by the user's private key.
   * Supports Ethereum (via Sign-In-With-Ethereum) & Solana (Sign-In-With-Solana) standards,
   * both of which derive from the EIP-4361 standard
   * With slight variation on Solana's side.
   * @reference https://eips.ethereum.org/EIPS/eip-4361
   */
  signInWithWeb3(credentials) {
    return __async(this, null, function* () {
      const { chain } = credentials;
      switch (chain) {
        case "ethereum":
          return yield this.signInWithEthereum(credentials);
        case "solana":
          return yield this.signInWithSolana(credentials);
        default:
          throw new Error(`@supabase/auth-js: Unsupported chain "${chain}"`);
      }
    });
  }
  signInWithEthereum(credentials) {
    return __async(this, null, function* () {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      let message;
      let signature;
      if ("message" in credentials) {
        message = credentials.message;
        signature = credentials.signature;
      } else {
        const { chain, wallet, statement, options } = credentials;
        let resolvedWallet;
        if (!isBrowser$3()) {
          if (typeof wallet !== "object" || !(options === null || options === void 0 ? void 0 : options.url)) {
            throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
          }
          resolvedWallet = wallet;
        } else if (typeof wallet === "object") {
          resolvedWallet = wallet;
        } else {
          const windowAny = window;
          if ("ethereum" in windowAny && typeof windowAny.ethereum === "object" && "request" in windowAny.ethereum && typeof windowAny.ethereum.request === "function") {
            resolvedWallet = windowAny.ethereum;
          } else {
            throw new Error(`@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.`);
          }
        }
        const url = new URL((_a2 = options === null || options === void 0 ? void 0 : options.url) !== null && _a2 !== void 0 ? _a2 : window.location.href);
        const accounts = yield resolvedWallet.request({
          method: "eth_requestAccounts"
        }).then((accs) => accs).catch(() => {
          throw new Error(`@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid`);
        });
        if (!accounts || accounts.length === 0) {
          throw new Error(`@supabase/auth-js: No accounts available. Please ensure the wallet is connected.`);
        }
        const address = getAddress(accounts[0]);
        let chainId = (_b = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _b === void 0 ? void 0 : _b.chainId;
        if (!chainId) {
          const chainIdHex = yield resolvedWallet.request({
            method: "eth_chainId"
          });
          chainId = fromHex(chainIdHex);
        }
        const siweMessage = {
          domain: url.host,
          address,
          statement,
          uri: url.href,
          version: "1",
          chainId,
          nonce: (_c = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _c === void 0 ? void 0 : _c.nonce,
          issuedAt: (_e = (_d = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _d === void 0 ? void 0 : _d.issuedAt) !== null && _e !== void 0 ? _e : /* @__PURE__ */ new Date(),
          expirationTime: (_f = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _f === void 0 ? void 0 : _f.expirationTime,
          notBefore: (_g = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _g === void 0 ? void 0 : _g.notBefore,
          requestId: (_h = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _h === void 0 ? void 0 : _h.requestId,
          resources: (_j = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _j === void 0 ? void 0 : _j.resources
        };
        message = createSiweMessage(siweMessage);
        signature = yield resolvedWallet.request({
          method: "personal_sign",
          params: [toHex(message), address]
        });
      }
      try {
        const { data, error } = yield _request(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
          headers: this.headers,
          body: Object.assign({
            chain: "ethereum",
            message,
            signature
          }, ((_k = credentials.options) === null || _k === void 0 ? void 0 : _k.captchaToken) ? { gotrue_meta_security: { captcha_token: (_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken } } : null),
          xform: _sessionResponse
        });
        if (error) {
          throw error;
        }
        if (!data || !data.session || !data.user) {
          return {
            data: { user: null, session: null },
            error: new AuthInvalidTokenResponseError()
          };
        }
        if (data.session) {
          yield this._saveSession(data.session);
          yield this._notifyAllSubscribers("SIGNED_IN", data.session);
        }
        return { data: Object.assign({}, data), error };
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { user: null, session: null }, error };
        }
        throw error;
      }
    });
  }
  signInWithSolana(credentials) {
    return __async(this, null, function* () {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      let message;
      let signature;
      if ("message" in credentials) {
        message = credentials.message;
        signature = credentials.signature;
      } else {
        const { chain, wallet, statement, options } = credentials;
        let resolvedWallet;
        if (!isBrowser$3()) {
          if (typeof wallet !== "object" || !(options === null || options === void 0 ? void 0 : options.url)) {
            throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
          }
          resolvedWallet = wallet;
        } else if (typeof wallet === "object") {
          resolvedWallet = wallet;
        } else {
          const windowAny = window;
          if ("solana" in windowAny && typeof windowAny.solana === "object" && ("signIn" in windowAny.solana && typeof windowAny.solana.signIn === "function" || "signMessage" in windowAny.solana && typeof windowAny.solana.signMessage === "function")) {
            resolvedWallet = windowAny.solana;
          } else {
            throw new Error(`@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.`);
          }
        }
        const url = new URL((_a2 = options === null || options === void 0 ? void 0 : options.url) !== null && _a2 !== void 0 ? _a2 : window.location.href);
        if ("signIn" in resolvedWallet && resolvedWallet.signIn) {
          const output = yield resolvedWallet.signIn(Object.assign(Object.assign(Object.assign({ issuedAt: (/* @__PURE__ */ new Date()).toISOString() }, options === null || options === void 0 ? void 0 : options.signInWithSolana), {
            // non-overridable properties
            version: "1",
            domain: url.host,
            uri: url.href
          }), statement ? { statement } : null));
          let outputToProcess;
          if (Array.isArray(output) && output[0] && typeof output[0] === "object") {
            outputToProcess = output[0];
          } else if (output && typeof output === "object" && "signedMessage" in output && "signature" in output) {
            outputToProcess = output;
          } else {
            throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");
          }
          if ("signedMessage" in outputToProcess && "signature" in outputToProcess && (typeof outputToProcess.signedMessage === "string" || outputToProcess.signedMessage instanceof Uint8Array) && outputToProcess.signature instanceof Uint8Array) {
            message = typeof outputToProcess.signedMessage === "string" ? outputToProcess.signedMessage : new TextDecoder().decode(outputToProcess.signedMessage);
            signature = outputToProcess.signature;
          } else {
            throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields");
          }
        } else {
          if (!("signMessage" in resolvedWallet) || typeof resolvedWallet.signMessage !== "function" || !("publicKey" in resolvedWallet) || typeof resolvedWallet !== "object" || !resolvedWallet.publicKey || !("toBase58" in resolvedWallet.publicKey) || typeof resolvedWallet.publicKey.toBase58 !== "function") {
            throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");
          }
          message = [
            `${url.host} wants you to sign in with your Solana account:`,
            resolvedWallet.publicKey.toBase58(),
            ...statement ? ["", statement, ""] : [""],
            "Version: 1",
            `URI: ${url.href}`,
            `Issued At: ${(_c = (_b = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _b === void 0 ? void 0 : _b.issuedAt) !== null && _c !== void 0 ? _c : (/* @__PURE__ */ new Date()).toISOString()}`,
            ...((_d = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _d === void 0 ? void 0 : _d.notBefore) ? [`Not Before: ${options.signInWithSolana.notBefore}`] : [],
            ...((_e = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _e === void 0 ? void 0 : _e.expirationTime) ? [`Expiration Time: ${options.signInWithSolana.expirationTime}`] : [],
            ...((_f = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _f === void 0 ? void 0 : _f.chainId) ? [`Chain ID: ${options.signInWithSolana.chainId}`] : [],
            ...((_g = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _g === void 0 ? void 0 : _g.nonce) ? [`Nonce: ${options.signInWithSolana.nonce}`] : [],
            ...((_h = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _h === void 0 ? void 0 : _h.requestId) ? [`Request ID: ${options.signInWithSolana.requestId}`] : [],
            ...((_k = (_j = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _j === void 0 ? void 0 : _j.resources) === null || _k === void 0 ? void 0 : _k.length) ? [
              "Resources",
              ...options.signInWithSolana.resources.map((resource) => `- ${resource}`)
            ] : []
          ].join("\n");
          const maybeSignature = yield resolvedWallet.signMessage(new TextEncoder().encode(message), "utf8");
          if (!maybeSignature || !(maybeSignature instanceof Uint8Array)) {
            throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");
          }
          signature = maybeSignature;
        }
      }
      try {
        const { data, error } = yield _request(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
          headers: this.headers,
          body: Object.assign({ chain: "solana", message, signature: bytesToBase64URL(signature) }, ((_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken) ? { gotrue_meta_security: { captcha_token: (_m = credentials.options) === null || _m === void 0 ? void 0 : _m.captchaToken } } : null),
          xform: _sessionResponse
        });
        if (error) {
          throw error;
        }
        if (!data || !data.session || !data.user) {
          return {
            data: { user: null, session: null },
            error: new AuthInvalidTokenResponseError()
          };
        }
        if (data.session) {
          yield this._saveSession(data.session);
          yield this._notifyAllSubscribers("SIGNED_IN", data.session);
        }
        return { data: Object.assign({}, data), error };
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { user: null, session: null }, error };
        }
        throw error;
      }
    });
  }
  _exchangeCodeForSession(authCode) {
    return __async(this, null, function* () {
      const storageItem = yield getItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      const [codeVerifier, redirectType] = (storageItem !== null && storageItem !== void 0 ? storageItem : "").split("/");
      try {
        const { data, error } = yield _request(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {
          headers: this.headers,
          body: {
            auth_code: authCode,
            code_verifier: codeVerifier
          },
          xform: _sessionResponse
        });
        yield removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
        if (error) {
          throw error;
        }
        if (!data || !data.session || !data.user) {
          return {
            data: { user: null, session: null, redirectType: null },
            error: new AuthInvalidTokenResponseError()
          };
        }
        if (data.session) {
          yield this._saveSession(data.session);
          yield this._notifyAllSubscribers("SIGNED_IN", data.session);
        }
        return { data: Object.assign(Object.assign({}, data), { redirectType: redirectType !== null && redirectType !== void 0 ? redirectType : null }), error };
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { user: null, session: null, redirectType: null }, error };
        }
        throw error;
      }
    });
  }
  /**
   * Allows signing in with an OIDC ID token. The authentication provider used
   * should be enabled and configured.
   */
  signInWithIdToken(credentials) {
    return __async(this, null, function* () {
      try {
        const { options, provider, token: token2, access_token, nonce } = credentials;
        const res = yield _request(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
          headers: this.headers,
          body: {
            provider,
            id_token: token2,
            access_token,
            nonce,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponse
        });
        const { data, error } = res;
        if (error) {
          return { data: { user: null, session: null }, error };
        } else if (!data || !data.session || !data.user) {
          return {
            data: { user: null, session: null },
            error: new AuthInvalidTokenResponseError()
          };
        }
        if (data.session) {
          yield this._saveSession(data.session);
          yield this._notifyAllSubscribers("SIGNED_IN", data.session);
        }
        return { data, error };
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { user: null, session: null }, error };
        }
        throw error;
      }
    });
  }
  /**
   * Log in a user using magiclink or a one-time password (OTP).
   *
   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.
   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.
   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or, that the account
   * can only be accessed via social login.
   *
   * Do note that you will need to configure a Whatsapp sender on Twilio
   * if you are using phone sign in with the 'whatsapp' channel. The whatsapp
   * channel is not supported on other providers
   * at this time.
   * This method supports PKCE when an email is passed.
   */
  signInWithOtp(credentials) {
    return __async(this, null, function* () {
      var _a2, _b, _c, _d, _e;
      try {
        if ("email" in credentials) {
          const { email, options } = credentials;
          let codeChallenge = null;
          let codeChallengeMethod = null;
          if (this.flowType === "pkce") {
            ;
            [codeChallenge, codeChallengeMethod] = yield getCodeChallengeAndMethod(this.storage, this.storageKey);
          }
          const { error } = yield _request(this.fetch, "POST", `${this.url}/otp`, {
            headers: this.headers,
            body: {
              email,
              data: (_a2 = options === null || options === void 0 ? void 0 : options.data) !== null && _a2 !== void 0 ? _a2 : {},
              create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
              code_challenge: codeChallenge,
              code_challenge_method: codeChallengeMethod
            },
            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
          });
          return { data: { user: null, session: null }, error };
        }
        if ("phone" in credentials) {
          const { phone, options } = credentials;
          const { data, error } = yield _request(this.fetch, "POST", `${this.url}/otp`, {
            headers: this.headers,
            body: {
              phone,
              data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},
              create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
              channel: (_e = options === null || options === void 0 ? void 0 : options.channel) !== null && _e !== void 0 ? _e : "sms"
            }
          });
          return { data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id }, error };
        }
        throw new AuthInvalidCredentialsError("You must provide either an email or phone number.");
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { user: null, session: null }, error };
        }
        throw error;
      }
    });
  }
  /**
   * Log in a user given a User supplied OTP or TokenHash received through mobile or email.
   */
  verifyOtp(params) {
    return __async(this, null, function* () {
      var _a2, _b;
      try {
        let redirectTo = void 0;
        let captchaToken = void 0;
        if ("options" in params) {
          redirectTo = (_a2 = params.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo;
          captchaToken = (_b = params.options) === null || _b === void 0 ? void 0 : _b.captchaToken;
        }
        const { data, error } = yield _request(this.fetch, "POST", `${this.url}/verify`, {
          headers: this.headers,
          body: Object.assign(Object.assign({}, params), { gotrue_meta_security: { captcha_token: captchaToken } }),
          redirectTo,
          xform: _sessionResponse
        });
        if (error) {
          throw error;
        }
        if (!data) {
          throw new Error("An error occurred on token verification.");
        }
        const session = data.session;
        const user = data.user;
        if (session === null || session === void 0 ? void 0 : session.access_token) {
          yield this._saveSession(session);
          yield this._notifyAllSubscribers(params.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", session);
        }
        return { data: { user, session }, error: null };
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { user: null, session: null }, error };
        }
        throw error;
      }
    });
  }
  /**
   * Attempts a single-sign on using an enterprise Identity Provider. A
   * successful SSO attempt will redirect the current page to the identity
   * provider authorization page. The redirect URL is implementation and SSO
   * protocol specific.
   *
   * You can use it by providing a SSO domain. Typically you can extract this
   * domain by asking users for their email address. If this domain is
   * registered on the Auth instance the redirect will use that organization's
   * currently active SSO Identity Provider for the login.
   *
   * If you have built an organization-specific login page, you can use the
   * organization's SSO Identity Provider UUID directly instead.
   */
  signInWithSSO(params) {
    return __async(this, null, function* () {
      var _a2, _b, _c;
      try {
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce") {
          ;
          [codeChallenge, codeChallengeMethod] = yield getCodeChallengeAndMethod(this.storage, this.storageKey);
        }
        return yield _request(this.fetch, "POST", `${this.url}/sso`, {
          body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId" in params ? { provider_id: params.providerId } : null), "domain" in params ? { domain: params.domain } : null), { redirect_to: (_b = (_a2 = params.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo) !== null && _b !== void 0 ? _b : void 0 }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } } : null), { skip_http_redirect: true, code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),
          headers: this.headers,
          xform: _ssoResponse
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Sends a reauthentication OTP to the user's email or phone number.
   * Requires the user to be signed-in.
   */
  reauthenticate() {
    return __async(this, null, function* () {
      yield this.initializePromise;
      return yield this._acquireLock(-1, () => __async(this, null, function* () {
        return yield this._reauthenticate();
      }));
    });
  }
  _reauthenticate() {
    return __async(this, null, function* () {
      try {
        return yield this._useSession((result) => __async(this, null, function* () {
          const { data: { session }, error: sessionError } = result;
          if (sessionError)
            throw sessionError;
          if (!session)
            throw new AuthSessionMissingError();
          const { error } = yield _request(this.fetch, "GET", `${this.url}/reauthenticate`, {
            headers: this.headers,
            jwt: session.access_token
          });
          return { data: { user: null, session: null }, error };
        }));
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { user: null, session: null }, error };
        }
        throw error;
      }
    });
  }
  /**
   * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.
   */
  resend(credentials) {
    return __async(this, null, function* () {
      try {
        const endpoint = `${this.url}/resend`;
        if ("email" in credentials) {
          const { email, type, options } = credentials;
          const { error } = yield _request(this.fetch, "POST", endpoint, {
            headers: this.headers,
            body: {
              email,
              type,
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
            },
            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
          });
          return { data: { user: null, session: null }, error };
        } else if ("phone" in credentials) {
          const { phone, type, options } = credentials;
          const { data, error } = yield _request(this.fetch, "POST", endpoint, {
            headers: this.headers,
            body: {
              phone,
              type,
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
            }
          });
          return { data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id }, error };
        }
        throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a type");
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { user: null, session: null }, error };
        }
        throw error;
      }
    });
  }
  /**
   * Returns the session, refreshing it if necessary.
   *
   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.
   *
   * **IMPORTANT:** This method loads values directly from the storage attached
   * to the client. If that storage is based on request cookies for example,
   * the values in it may not be authentic and therefore it's strongly advised
   * against using this method and its results in such circumstances. A warning
   * will be emitted if this is detected. Use {@link #getUser()} instead.
   */
  getSession() {
    return __async(this, null, function* () {
      yield this.initializePromise;
      const result = yield this._acquireLock(-1, () => __async(this, null, function* () {
        return this._useSession((result2) => __async(this, null, function* () {
          return result2;
        }));
      }));
      return result;
    });
  }
  /**
   * Acquires a global lock based on the storage key.
   */
  _acquireLock(acquireTimeout, fn2) {
    return __async(this, null, function* () {
      this._debug("#_acquireLock", "begin", acquireTimeout);
      try {
        if (this.lockAcquired) {
          const last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve();
          const result = (() => __async(this, null, function* () {
            yield last;
            return yield fn2();
          }))();
          this.pendingInLock.push((() => __async(this, null, function* () {
            try {
              yield result;
            } catch (e) {
            }
          }))());
          return result;
        }
        return yield this.lock(`lock:${this.storageKey}`, acquireTimeout, () => __async(this, null, function* () {
          this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
          try {
            this.lockAcquired = true;
            const result = fn2();
            this.pendingInLock.push((() => __async(this, null, function* () {
              try {
                yield result;
              } catch (e) {
              }
            }))());
            yield result;
            while (this.pendingInLock.length) {
              const waitOn = [...this.pendingInLock];
              yield Promise.all(waitOn);
              this.pendingInLock.splice(0, waitOn.length);
            }
            return yield result;
          } finally {
            this._debug("#_acquireLock", "lock released for storage key", this.storageKey);
            this.lockAcquired = false;
          }
        }));
      } finally {
        this._debug("#_acquireLock", "end");
      }
    });
  }
  /**
   * Use instead of {@link #getSession} inside the library. It is
   * semantically usually what you want, as getting a session involves some
   * processing afterwards that requires only one client operating on the
   * session at once across multiple tabs or processes.
   */
  _useSession(fn2) {
    return __async(this, null, function* () {
      this._debug("#_useSession", "begin");
      try {
        const result = yield this.__loadSession();
        return yield fn2(result);
      } finally {
        this._debug("#_useSession", "end");
      }
    });
  }
  /**
   * NEVER USE DIRECTLY!
   *
   * Always use {@link #_useSession}.
   */
  __loadSession() {
    return __async(this, null, function* () {
      this._debug("#__loadSession()", "begin");
      if (!this.lockAcquired) {
        this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack);
      }
      try {
        let currentSession = null;
        const maybeSession = yield getItemAsync(this.storage, this.storageKey);
        this._debug("#getSession()", "session from storage", maybeSession);
        if (maybeSession !== null) {
          if (this._isValidSession(maybeSession)) {
            currentSession = maybeSession;
          } else {
            this._debug("#getSession()", "session from storage is not valid");
            yield this._removeSession();
          }
        }
        if (!currentSession) {
          return { data: { session: null }, error: null };
        }
        const hasExpired = currentSession.expires_at ? currentSession.expires_at * 1e3 - Date.now() < EXPIRY_MARGIN_MS : false;
        this._debug("#__loadSession()", `session has${hasExpired ? "" : " not"} expired`, "expires_at", currentSession.expires_at);
        if (!hasExpired) {
          if (this.userStorage) {
            const maybeUser = yield getItemAsync(this.userStorage, this.storageKey + "-user");
            if (maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) {
              currentSession.user = maybeUser.user;
            } else {
              currentSession.user = userNotAvailableProxy();
            }
          }
          if (this.storage.isServer && currentSession.user) {
            let suppressWarning = this.suppressGetSessionWarning;
            const proxySession = new Proxy(currentSession, {
              get: (target, prop, receiver) => {
                if (!suppressWarning && prop === "user") {
                  console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.");
                  suppressWarning = true;
                  this.suppressGetSessionWarning = true;
                }
                return Reflect.get(target, prop, receiver);
              }
            });
            currentSession = proxySession;
          }
          return { data: { session: currentSession }, error: null };
        }
        const { data: session, error } = yield this._callRefreshToken(currentSession.refresh_token);
        if (error) {
          return { data: { session: null }, error };
        }
        return { data: { session }, error: null };
      } finally {
        this._debug("#__loadSession()", "end");
      }
    });
  }
  /**
   * Gets the current user details if there is an existing session. This method
   * performs a network request to the Supabase Auth server, so the returned
   * value is authentic and can be used to base authorization rules on.
   *
   * @param jwt Takes in an optional access token JWT. If no JWT is provided, the JWT from the current session is used.
   */
  getUser(jwt) {
    return __async(this, null, function* () {
      if (jwt) {
        return yield this._getUser(jwt);
      }
      yield this.initializePromise;
      const result = yield this._acquireLock(-1, () => __async(this, null, function* () {
        return yield this._getUser();
      }));
      return result;
    });
  }
  _getUser(jwt) {
    return __async(this, null, function* () {
      try {
        if (jwt) {
          return yield _request(this.fetch, "GET", `${this.url}/user`, {
            headers: this.headers,
            jwt,
            xform: _userResponse
          });
        }
        return yield this._useSession((result) => __async(this, null, function* () {
          var _a2, _b, _c;
          const { data, error } = result;
          if (error) {
            throw error;
          }
          if (!((_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) && !this.hasCustomAuthorizationHeader) {
            return { data: { user: null }, error: new AuthSessionMissingError() };
          }
          return yield _request(this.fetch, "GET", `${this.url}/user`, {
            headers: this.headers,
            jwt: (_c = (_b = data.session) === null || _b === void 0 ? void 0 : _b.access_token) !== null && _c !== void 0 ? _c : void 0,
            xform: _userResponse
          });
        }));
      } catch (error) {
        if (isAuthError(error)) {
          if (isAuthSessionMissingError(error)) {
            yield this._removeSession();
            yield removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
          }
          return { data: { user: null }, error };
        }
        throw error;
      }
    });
  }
  /**
   * Updates user data for a logged in user.
   */
  updateUser(_0) {
    return __async(this, arguments, function* (attributes, options = {}) {
      yield this.initializePromise;
      return yield this._acquireLock(-1, () => __async(this, null, function* () {
        return yield this._updateUser(attributes, options);
      }));
    });
  }
  _updateUser(_0) {
    return __async(this, arguments, function* (attributes, options = {}) {
      try {
        return yield this._useSession((result) => __async(this, null, function* () {
          const { data: sessionData, error: sessionError } = result;
          if (sessionError) {
            throw sessionError;
          }
          if (!sessionData.session) {
            throw new AuthSessionMissingError();
          }
          const session = sessionData.session;
          let codeChallenge = null;
          let codeChallengeMethod = null;
          if (this.flowType === "pkce" && attributes.email != null) {
            ;
            [codeChallenge, codeChallengeMethod] = yield getCodeChallengeAndMethod(this.storage, this.storageKey);
          }
          const { data, error: userError } = yield _request(this.fetch, "PUT", `${this.url}/user`, {
            headers: this.headers,
            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
            body: Object.assign(Object.assign({}, attributes), { code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),
            jwt: session.access_token,
            xform: _userResponse
          });
          if (userError)
            throw userError;
          session.user = data.user;
          yield this._saveSession(session);
          yield this._notifyAllSubscribers("USER_UPDATED", session);
          return { data: { user: session.user }, error: null };
        }));
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { user: null }, error };
        }
        throw error;
      }
    });
  }
  /**
   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.
   * If the refresh token or access token in the current session is invalid, an error will be thrown.
   * @param currentSession The current session that minimally contains an access token and refresh token.
   */
  setSession(currentSession) {
    return __async(this, null, function* () {
      yield this.initializePromise;
      return yield this._acquireLock(-1, () => __async(this, null, function* () {
        return yield this._setSession(currentSession);
      }));
    });
  }
  _setSession(currentSession) {
    return __async(this, null, function* () {
      try {
        if (!currentSession.access_token || !currentSession.refresh_token) {
          throw new AuthSessionMissingError();
        }
        const timeNow = Date.now() / 1e3;
        let expiresAt2 = timeNow;
        let hasExpired = true;
        let session = null;
        const { payload } = decodeJWT(currentSession.access_token);
        if (payload.exp) {
          expiresAt2 = payload.exp;
          hasExpired = expiresAt2 <= timeNow;
        }
        if (hasExpired) {
          const { data: refreshedSession, error } = yield this._callRefreshToken(currentSession.refresh_token);
          if (error) {
            return { data: { user: null, session: null }, error };
          }
          if (!refreshedSession) {
            return { data: { user: null, session: null }, error: null };
          }
          session = refreshedSession;
        } else {
          const { data, error } = yield this._getUser(currentSession.access_token);
          if (error) {
            throw error;
          }
          session = {
            access_token: currentSession.access_token,
            refresh_token: currentSession.refresh_token,
            user: data.user,
            token_type: "bearer",
            expires_in: expiresAt2 - timeNow,
            expires_at: expiresAt2
          };
          yield this._saveSession(session);
          yield this._notifyAllSubscribers("SIGNED_IN", session);
        }
        return { data: { user: session.user, session }, error: null };
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { session: null, user: null }, error };
        }
        throw error;
      }
    });
  }
  /**
   * Returns a new session, regardless of expiry status.
   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().
   * If the current session's refresh token is invalid, an error will be thrown.
   * @param currentSession The current session. If passed in, it must contain a refresh token.
   */
  refreshSession(currentSession) {
    return __async(this, null, function* () {
      yield this.initializePromise;
      return yield this._acquireLock(-1, () => __async(this, null, function* () {
        return yield this._refreshSession(currentSession);
      }));
    });
  }
  _refreshSession(currentSession) {
    return __async(this, null, function* () {
      try {
        return yield this._useSession((result) => __async(this, null, function* () {
          var _a2;
          if (!currentSession) {
            const { data, error: error2 } = result;
            if (error2) {
              throw error2;
            }
            currentSession = (_a2 = data.session) !== null && _a2 !== void 0 ? _a2 : void 0;
          }
          if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {
            throw new AuthSessionMissingError();
          }
          const { data: session, error } = yield this._callRefreshToken(currentSession.refresh_token);
          if (error) {
            return { data: { user: null, session: null }, error };
          }
          if (!session) {
            return { data: { user: null, session: null }, error: null };
          }
          return { data: { user: session.user, session }, error: null };
        }));
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { user: null, session: null }, error };
        }
        throw error;
      }
    });
  }
  /**
   * Gets the session data from a URL string
   */
  _getSessionFromURL(params, callbackUrlType) {
    return __async(this, null, function* () {
      try {
        if (!isBrowser$3())
          throw new AuthImplicitGrantRedirectError("No browser detected.");
        if (params.error || params.error_description || params.error_code) {
          throw new AuthImplicitGrantRedirectError(params.error_description || "Error in URL with unspecified error_description", {
            error: params.error || "unspecified_error",
            code: params.error_code || "unspecified_code"
          });
        }
        switch (callbackUrlType) {
          case "implicit":
            if (this.flowType === "pkce") {
              throw new AuthPKCEGrantCodeExchangeError("Not a valid PKCE flow url.");
            }
            break;
          case "pkce":
            if (this.flowType === "implicit") {
              throw new AuthImplicitGrantRedirectError("Not a valid implicit grant flow url.");
            }
            break;
          default:
        }
        if (callbackUrlType === "pkce") {
          this._debug("#_initialize()", "begin", "is PKCE flow", true);
          if (!params.code)
            throw new AuthPKCEGrantCodeExchangeError("No code detected.");
          const { data: data2, error: error2 } = yield this._exchangeCodeForSession(params.code);
          if (error2)
            throw error2;
          const url = new URL(window.location.href);
          url.searchParams.delete("code");
          window.history.replaceState(window.history.state, "", url.toString());
          return { data: { session: data2.session, redirectType: null }, error: null };
        }
        const { provider_token, provider_refresh_token, access_token, refresh_token, expires_in, expires_at, token_type } = params;
        if (!access_token || !expires_in || !refresh_token || !token_type) {
          throw new AuthImplicitGrantRedirectError("No session defined in URL");
        }
        const timeNow = Math.round(Date.now() / 1e3);
        const expiresIn = parseInt(expires_in);
        let expiresAt2 = timeNow + expiresIn;
        if (expires_at) {
          expiresAt2 = parseInt(expires_at);
        }
        const actuallyExpiresIn = expiresAt2 - timeNow;
        if (actuallyExpiresIn * 1e3 <= AUTO_REFRESH_TICK_DURATION_MS) {
          console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${actuallyExpiresIn}s, should have been closer to ${expiresIn}s`);
        }
        const issuedAt = expiresAt2 - expiresIn;
        if (timeNow - issuedAt >= 120) {
          console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", issuedAt, expiresAt2, timeNow);
        } else if (timeNow - issuedAt < 0) {
          console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew", issuedAt, expiresAt2, timeNow);
        }
        const { data, error } = yield this._getUser(access_token);
        if (error)
          throw error;
        const session = {
          provider_token,
          provider_refresh_token,
          access_token,
          expires_in: expiresIn,
          expires_at: expiresAt2,
          refresh_token,
          token_type,
          user: data.user
        };
        window.location.hash = "";
        this._debug("#_getSessionFromURL()", "clearing window.location.hash");
        return { data: { session, redirectType: params.type }, error: null };
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { session: null, redirectType: null }, error };
        }
        throw error;
      }
    });
  }
  /**
   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)
   */
  _isImplicitGrantCallback(params) {
    return Boolean(params.access_token || params.error_description);
  }
  /**
   * Checks if the current URL and backing storage contain parameters given by a PKCE flow
   */
  _isPKCECallback(params) {
    return __async(this, null, function* () {
      const currentStorageContent = yield getItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      return !!(params.code && currentStorageContent);
    });
  }
  /**
   * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `"SIGNED_OUT"` event.
   *
   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.
   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.
   *
   * If using `others` scope, no `SIGNED_OUT` event is fired!
   */
  signOut() {
    return __async(this, arguments, function* (options = { scope: "global" }) {
      yield this.initializePromise;
      return yield this._acquireLock(-1, () => __async(this, null, function* () {
        return yield this._signOut(options);
      }));
    });
  }
  _signOut() {
    return __async(this, arguments, function* ({ scope } = { scope: "global" }) {
      return yield this._useSession((result) => __async(this, null, function* () {
        var _a2;
        const { data, error: sessionError } = result;
        if (sessionError) {
          return { error: sessionError };
        }
        const accessToken = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token;
        if (accessToken) {
          const { error } = yield this.admin.signOut(accessToken, scope);
          if (error) {
            if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401 || error.status === 403))) {
              return { error };
            }
          }
        }
        if (scope !== "others") {
          yield this._removeSession();
          yield removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
        }
        return { error: null };
      }));
    });
  }
  onAuthStateChange(callback) {
    const id = uuid();
    const subscription = {
      id,
      callback,
      unsubscribe: () => {
        this._debug("#unsubscribe()", "state change callback with id removed", id);
        this.stateChangeEmitters.delete(id);
      }
    };
    this._debug("#onAuthStateChange()", "registered callback with id", id);
    this.stateChangeEmitters.set(id, subscription);
    (() => __async(this, null, function* () {
      yield this.initializePromise;
      yield this._acquireLock(-1, () => __async(this, null, function* () {
        this._emitInitialSession(id);
      }));
    }))();
    return { data: { subscription } };
  }
  _emitInitialSession(id) {
    return __async(this, null, function* () {
      return yield this._useSession((result) => __async(this, null, function* () {
        var _a2, _b;
        try {
          const { data: { session }, error } = result;
          if (error)
            throw error;
          yield (_a2 = this.stateChangeEmitters.get(id)) === null || _a2 === void 0 ? void 0 : _a2.callback("INITIAL_SESSION", session);
          this._debug("INITIAL_SESSION", "callback id", id, "session", session);
        } catch (err) {
          yield (_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback("INITIAL_SESSION", null);
          this._debug("INITIAL_SESSION", "callback id", id, "error", err);
          console.error(err);
        }
      }));
    });
  }
  /**
   * Sends a password reset request to an email address. This method supports the PKCE flow.
   *
   * @param email The email address of the user.
   * @param options.redirectTo The URL to send the user to after they click the password reset link.
   * @param options.captchaToken Verification token received when the user completes the captcha on the site.
   */
  resetPasswordForEmail(_0) {
    return __async(this, arguments, function* (email, options = {}) {
      let codeChallenge = null;
      let codeChallengeMethod = null;
      if (this.flowType === "pkce") {
        [codeChallenge, codeChallengeMethod] = yield getCodeChallengeAndMethod(
          this.storage,
          this.storageKey,
          true
          // isPasswordRecovery
        );
      }
      try {
        return yield _request(this.fetch, "POST", `${this.url}/recover`, {
          body: {
            email,
            code_challenge: codeChallenge,
            code_challenge_method: codeChallengeMethod,
            gotrue_meta_security: { captcha_token: options.captchaToken }
          },
          headers: this.headers,
          redirectTo: options.redirectTo
        });
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Gets all the identities linked to a user.
   */
  getUserIdentities() {
    return __async(this, null, function* () {
      var _a2;
      try {
        const { data, error } = yield this.getUser();
        if (error)
          throw error;
        return { data: { identities: (_a2 = data.user.identities) !== null && _a2 !== void 0 ? _a2 : [] }, error: null };
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  linkIdentity(credentials) {
    return __async(this, null, function* () {
      if ("token" in credentials) {
        return this.linkIdentityIdToken(credentials);
      }
      return this.linkIdentityOAuth(credentials);
    });
  }
  linkIdentityOAuth(credentials) {
    return __async(this, null, function* () {
      var _a2;
      try {
        const { data, error } = yield this._useSession((result) => __async(this, null, function* () {
          var _a3, _b, _c, _d, _e;
          const { data: data2, error: error2 } = result;
          if (error2)
            throw error2;
          const url = yield this._getUrlForProvider(`${this.url}/user/identities/authorize`, credentials.provider, {
            redirectTo: (_a3 = credentials.options) === null || _a3 === void 0 ? void 0 : _a3.redirectTo,
            scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
            queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
            skipBrowserRedirect: true
          });
          return yield _request(this.fetch, "GET", url, {
            headers: this.headers,
            jwt: (_e = (_d = data2.session) === null || _d === void 0 ? void 0 : _d.access_token) !== null && _e !== void 0 ? _e : void 0
          });
        }));
        if (error)
          throw error;
        if (isBrowser$3() && !((_a2 = credentials.options) === null || _a2 === void 0 ? void 0 : _a2.skipBrowserRedirect)) {
          window.location.assign(data === null || data === void 0 ? void 0 : data.url);
        }
        return { data: { provider: credentials.provider, url: data === null || data === void 0 ? void 0 : data.url }, error: null };
      } catch (error) {
        if (isAuthError(error)) {
          return { data: { provider: credentials.provider, url: null }, error };
        }
        throw error;
      }
    });
  }
  linkIdentityIdToken(credentials) {
    return __async(this, null, function* () {
      return yield this._useSession((result) => __async(this, null, function* () {
        var _a2;
        try {
          const { error: sessionError, data: { session } } = result;
          if (sessionError)
            throw sessionError;
          const { options, provider, token: token2, access_token, nonce } = credentials;
          const res = yield _request(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
            headers: this.headers,
            jwt: (_a2 = session === null || session === void 0 ? void 0 : session.access_token) !== null && _a2 !== void 0 ? _a2 : void 0,
            body: {
              provider,
              id_token: token2,
              access_token,
              nonce,
              link_identity: true,
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
            },
            xform: _sessionResponse
          });
          const { data, error } = res;
          if (error) {
            return { data: { user: null, session: null }, error };
          } else if (!data || !data.session || !data.user) {
            return {
              data: { user: null, session: null },
              error: new AuthInvalidTokenResponseError()
            };
          }
          if (data.session) {
            yield this._saveSession(data.session);
            yield this._notifyAllSubscribers("USER_UPDATED", data.session);
          }
          return { data, error };
        } catch (error) {
          if (isAuthError(error)) {
            return { data: { user: null, session: null }, error };
          }
          throw error;
        }
      }));
    });
  }
  /**
   * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.
   */
  unlinkIdentity(identity) {
    return __async(this, null, function* () {
      try {
        return yield this._useSession((result) => __async(this, null, function* () {
          var _a2, _b;
          const { data, error } = result;
          if (error) {
            throw error;
          }
          return yield _request(this.fetch, "DELETE", `${this.url}/user/identities/${identity.identity_id}`, {
            headers: this.headers,
            jwt: (_b = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) !== null && _b !== void 0 ? _b : void 0
          });
        }));
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Generates a new JWT.
   * @param refreshToken A valid refresh token that was returned on login.
   */
  _refreshAccessToken(refreshToken) {
    return __async(this, null, function* () {
      const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`;
      this._debug(debugName, "begin");
      try {
        const startedAt = Date.now();
        return yield retryable((attempt) => __async(this, null, function* () {
          if (attempt > 0) {
            yield sleep(200 * Math.pow(2, attempt - 1));
          }
          this._debug(debugName, "refreshing attempt", attempt);
          return yield _request(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {
            body: { refresh_token: refreshToken },
            headers: this.headers,
            xform: _sessionResponse
          });
        }), (attempt, error) => {
          const nextBackOffInterval = 200 * Math.pow(2, attempt);
          return error && isAuthRetryableFetchError(error) && // retryable only if the request can be sent before the backoff overflows the tick duration
          Date.now() + nextBackOffInterval - startedAt < AUTO_REFRESH_TICK_DURATION_MS;
        });
      } catch (error) {
        this._debug(debugName, "error", error);
        if (isAuthError(error)) {
          return { data: { session: null, user: null }, error };
        }
        throw error;
      } finally {
        this._debug(debugName, "end");
      }
    });
  }
  _isValidSession(maybeSession) {
    const isValidSession = typeof maybeSession === "object" && maybeSession !== null && "access_token" in maybeSession && "refresh_token" in maybeSession && "expires_at" in maybeSession;
    return isValidSession;
  }
  _handleProviderSignIn(provider, options) {
    return __async(this, null, function* () {
      const url = yield this._getUrlForProvider(`${this.url}/authorize`, provider, {
        redirectTo: options.redirectTo,
        scopes: options.scopes,
        queryParams: options.queryParams
      });
      this._debug("#_handleProviderSignIn()", "provider", provider, "options", options, "url", url);
      if (isBrowser$3() && !options.skipBrowserRedirect) {
        window.location.assign(url);
      }
      return { data: { provider, url }, error: null };
    });
  }
  /**
   * Recovers the session from LocalStorage and refreshes the token
   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.
   */
  _recoverAndRefresh() {
    return __async(this, null, function* () {
      var _a2, _b;
      const debugName = "#_recoverAndRefresh()";
      this._debug(debugName, "begin");
      try {
        const currentSession = yield getItemAsync(this.storage, this.storageKey);
        if (currentSession && this.userStorage) {
          let maybeUser = yield getItemAsync(this.userStorage, this.storageKey + "-user");
          if (!this.storage.isServer && Object.is(this.storage, this.userStorage) && !maybeUser) {
            maybeUser = { user: currentSession.user };
            yield setItemAsync(this.userStorage, this.storageKey + "-user", maybeUser);
          }
          currentSession.user = (_a2 = maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) !== null && _a2 !== void 0 ? _a2 : userNotAvailableProxy();
        } else if (currentSession && !currentSession.user) {
          if (!currentSession.user) {
            const separateUser = yield getItemAsync(this.storage, this.storageKey + "-user");
            if (separateUser && (separateUser === null || separateUser === void 0 ? void 0 : separateUser.user)) {
              currentSession.user = separateUser.user;
              yield removeItemAsync(this.storage, this.storageKey + "-user");
              yield setItemAsync(this.storage, this.storageKey, currentSession);
            } else {
              currentSession.user = userNotAvailableProxy();
            }
          }
        }
        this._debug(debugName, "session from storage", currentSession);
        if (!this._isValidSession(currentSession)) {
          this._debug(debugName, "session is not valid");
          if (currentSession !== null) {
            yield this._removeSession();
          }
          return;
        }
        const expiresWithMargin = ((_b = currentSession.expires_at) !== null && _b !== void 0 ? _b : Infinity) * 1e3 - Date.now() < EXPIRY_MARGIN_MS;
        this._debug(debugName, `session has${expiresWithMargin ? "" : " not"} expired with margin of ${EXPIRY_MARGIN_MS}s`);
        if (expiresWithMargin) {
          if (this.autoRefreshToken && currentSession.refresh_token) {
            const { error } = yield this._callRefreshToken(currentSession.refresh_token);
            if (error) {
              console.error(error);
              if (!isAuthRetryableFetchError(error)) {
                this._debug(debugName, "refresh failed with a non-retryable error, removing the session", error);
                yield this._removeSession();
              }
            }
          }
        } else if (currentSession.user && currentSession.user.__isUserNotAvailableProxy === true) {
          try {
            const { data, error: userError } = yield this._getUser(currentSession.access_token);
            if (!userError && (data === null || data === void 0 ? void 0 : data.user)) {
              currentSession.user = data.user;
              yield this._saveSession(currentSession);
              yield this._notifyAllSubscribers("SIGNED_IN", currentSession);
            } else {
              this._debug(debugName, "could not get user data, skipping SIGNED_IN notification");
            }
          } catch (getUserError) {
            console.error("Error getting user data:", getUserError);
            this._debug(debugName, "error getting user data, skipping SIGNED_IN notification", getUserError);
          }
        } else {
          yield this._notifyAllSubscribers("SIGNED_IN", currentSession);
        }
      } catch (err) {
        this._debug(debugName, "error", err);
        console.error(err);
        return;
      } finally {
        this._debug(debugName, "end");
      }
    });
  }
  _callRefreshToken(refreshToken) {
    return __async(this, null, function* () {
      var _a2, _b;
      if (!refreshToken) {
        throw new AuthSessionMissingError();
      }
      if (this.refreshingDeferred) {
        return this.refreshingDeferred.promise;
      }
      const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`;
      this._debug(debugName, "begin");
      try {
        this.refreshingDeferred = new Deferred();
        const { data, error } = yield this._refreshAccessToken(refreshToken);
        if (error)
          throw error;
        if (!data.session)
          throw new AuthSessionMissingError();
        yield this._saveSession(data.session);
        yield this._notifyAllSubscribers("TOKEN_REFRESHED", data.session);
        const result = { data: data.session, error: null };
        this.refreshingDeferred.resolve(result);
        return result;
      } catch (error) {
        this._debug(debugName, "error", error);
        if (isAuthError(error)) {
          const result = { data: null, error };
          if (!isAuthRetryableFetchError(error)) {
            yield this._removeSession();
          }
          (_a2 = this.refreshingDeferred) === null || _a2 === void 0 ? void 0 : _a2.resolve(result);
          return result;
        }
        (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);
        throw error;
      } finally {
        this.refreshingDeferred = null;
        this._debug(debugName, "end");
      }
    });
  }
  _notifyAllSubscribers(event, session, broadcast = true) {
    return __async(this, null, function* () {
      const debugName = `#_notifyAllSubscribers(${event})`;
      this._debug(debugName, "begin", session, `broadcast = ${broadcast}`);
      try {
        if (this.broadcastChannel && broadcast) {
          this.broadcastChannel.postMessage({ event, session });
        }
        const errors = [];
        const promises = Array.from(this.stateChangeEmitters.values()).map((x) => __async(this, null, function* () {
          try {
            yield x.callback(event, session);
          } catch (e) {
            errors.push(e);
          }
        }));
        yield Promise.all(promises);
        if (errors.length > 0) {
          for (let i = 0; i < errors.length; i += 1) {
            console.error(errors[i]);
          }
          throw errors[0];
        }
      } finally {
        this._debug(debugName, "end");
      }
    });
  }
  /**
   * set currentSession and currentUser
   * process to _startAutoRefreshToken if possible
   */
  _saveSession(session) {
    return __async(this, null, function* () {
      this._debug("#_saveSession()", session);
      this.suppressGetSessionWarning = true;
      const sessionToProcess = Object.assign({}, session);
      const userIsProxy = sessionToProcess.user && sessionToProcess.user.__isUserNotAvailableProxy === true;
      if (this.userStorage) {
        if (!userIsProxy && sessionToProcess.user) {
          yield setItemAsync(this.userStorage, this.storageKey + "-user", {
            user: sessionToProcess.user
          });
        }
        const mainSessionData = Object.assign({}, sessionToProcess);
        delete mainSessionData.user;
        const clonedMainSessionData = deepClone(mainSessionData);
        yield setItemAsync(this.storage, this.storageKey, clonedMainSessionData);
      } else {
        const clonedSession = deepClone(sessionToProcess);
        yield setItemAsync(this.storage, this.storageKey, clonedSession);
      }
    });
  }
  _removeSession() {
    return __async(this, null, function* () {
      this._debug("#_removeSession()");
      yield removeItemAsync(this.storage, this.storageKey);
      yield removeItemAsync(this.storage, this.storageKey + "-code-verifier");
      yield removeItemAsync(this.storage, this.storageKey + "-user");
      if (this.userStorage) {
        yield removeItemAsync(this.userStorage, this.storageKey + "-user");
      }
      yield this._notifyAllSubscribers("SIGNED_OUT", null);
    });
  }
  /**
   * Removes any registered visibilitychange callback.
   *
   * {@see #startAutoRefresh}
   * {@see #stopAutoRefresh}
   */
  _removeVisibilityChangedCallback() {
    this._debug("#_removeVisibilityChangedCallback()");
    const callback = this.visibilityChangedCallback;
    this.visibilityChangedCallback = null;
    try {
      if (callback && isBrowser$3() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {
        window.removeEventListener("visibilitychange", callback);
      }
    } catch (e) {
      console.error("removing visibilitychange callback failed", e);
    }
  }
  /**
   * This is the private implementation of {@link #startAutoRefresh}. Use this
   * within the library.
   */
  _startAutoRefresh() {
    return __async(this, null, function* () {
      yield this._stopAutoRefresh();
      this._debug("#_startAutoRefresh()");
      const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION_MS);
      this.autoRefreshTicker = ticker;
      if (ticker && typeof ticker === "object" && typeof ticker.unref === "function") {
        ticker.unref();
      } else if (typeof Deno !== "undefined" && typeof Deno.unrefTimer === "function") {
        Deno.unrefTimer(ticker);
      }
      setTimeout(() => __async(this, null, function* () {
        yield this.initializePromise;
        yield this._autoRefreshTokenTick();
      }), 0);
    });
  }
  /**
   * This is the private implementation of {@link #stopAutoRefresh}. Use this
   * within the library.
   */
  _stopAutoRefresh() {
    return __async(this, null, function* () {
      this._debug("#_stopAutoRefresh()");
      const ticker = this.autoRefreshTicker;
      this.autoRefreshTicker = null;
      if (ticker) {
        clearInterval(ticker);
      }
    });
  }
  /**
   * Starts an auto-refresh process in the background. The session is checked
   * every few seconds. Close to the time of expiration a process is started to
   * refresh the session. If refreshing fails it will be retried for as long as
   * necessary.
   *
   * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need
   * to call this function, it will be called for you.
   *
   * On browsers the refresh process works only when the tab/window is in the
   * foreground to conserve resources as well as prevent race conditions and
   * flooding auth with requests. If you call this method any managed
   * visibility change callback will be removed and you must manage visibility
   * changes on your own.
   *
   * On non-browser platforms the refresh process works *continuously* in the
   * background, which may not be desirable. You should hook into your
   * platform's foreground indication mechanism and call these methods
   * appropriately to conserve resources.
   *
   * {@see #stopAutoRefresh}
   */
  startAutoRefresh() {
    return __async(this, null, function* () {
      this._removeVisibilityChangedCallback();
      yield this._startAutoRefresh();
    });
  }
  /**
   * Stops an active auto refresh process running in the background (if any).
   *
   * If you call this method any managed visibility change callback will be
   * removed and you must manage visibility changes on your own.
   *
   * See {@link #startAutoRefresh} for more details.
   */
  stopAutoRefresh() {
    return __async(this, null, function* () {
      this._removeVisibilityChangedCallback();
      yield this._stopAutoRefresh();
    });
  }
  /**
   * Runs the auto refresh token tick.
   */
  _autoRefreshTokenTick() {
    return __async(this, null, function* () {
      this._debug("#_autoRefreshTokenTick()", "begin");
      try {
        yield this._acquireLock(0, () => __async(this, null, function* () {
          try {
            const now = Date.now();
            try {
              return yield this._useSession((result) => __async(this, null, function* () {
                const { data: { session } } = result;
                if (!session || !session.refresh_token || !session.expires_at) {
                  this._debug("#_autoRefreshTokenTick()", "no session");
                  return;
                }
                const expiresInTicks = Math.floor((session.expires_at * 1e3 - now) / AUTO_REFRESH_TICK_DURATION_MS);
                this._debug("#_autoRefreshTokenTick()", `access token expires in ${expiresInTicks} ticks, a tick lasts ${AUTO_REFRESH_TICK_DURATION_MS}ms, refresh threshold is ${AUTO_REFRESH_TICK_THRESHOLD} ticks`);
                if (expiresInTicks <= AUTO_REFRESH_TICK_THRESHOLD) {
                  yield this._callRefreshToken(session.refresh_token);
                }
              }));
            } catch (e) {
              console.error("Auto refresh tick failed with error. This is likely a transient error.", e);
            }
          } finally {
            this._debug("#_autoRefreshTokenTick()", "end");
          }
        }));
      } catch (e) {
        if (e.isAcquireTimeout || e instanceof LockAcquireTimeoutError) {
          this._debug("auto refresh token tick lock not available");
        } else {
          throw e;
        }
      }
    });
  }
  /**
   * Registers callbacks on the browser / platform, which in-turn run
   * algorithms when the browser window/tab are in foreground. On non-browser
   * platforms it assumes always foreground.
   */
  _handleVisibilityChange() {
    return __async(this, null, function* () {
      this._debug("#_handleVisibilityChange()");
      if (!isBrowser$3() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {
        if (this.autoRefreshToken) {
          this.startAutoRefresh();
        }
        return false;
      }
      try {
        this.visibilityChangedCallback = () => __async(this, null, function* () {
          return yield this._onVisibilityChanged(false);
        });
        window === null || window === void 0 ? void 0 : window.addEventListener("visibilitychange", this.visibilityChangedCallback);
        yield this._onVisibilityChanged(true);
      } catch (error) {
        console.error("_handleVisibilityChange", error);
      }
    });
  }
  /**
   * Callback registered with `window.addEventListener('visibilitychange')`.
   */
  _onVisibilityChanged(calledFromInitialize) {
    return __async(this, null, function* () {
      const methodName = `#_onVisibilityChanged(${calledFromInitialize})`;
      this._debug(methodName, "visibilityState", document.visibilityState);
      if (document.visibilityState === "visible") {
        if (this.autoRefreshToken) {
          this._startAutoRefresh();
        }
        if (!calledFromInitialize) {
          yield this.initializePromise;
          yield this._acquireLock(-1, () => __async(this, null, function* () {
            if (document.visibilityState !== "visible") {
              this._debug(methodName, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");
              return;
            }
            yield this._recoverAndRefresh();
          }));
        }
      } else if (document.visibilityState === "hidden") {
        if (this.autoRefreshToken) {
          this._stopAutoRefresh();
        }
      }
    });
  }
  /**
   * Generates the relevant login URL for a third-party provider.
   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.
   * @param options.scopes A space-separated list of scopes granted to the OAuth application.
   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.
   */
  _getUrlForProvider(url, provider, options) {
    return __async(this, null, function* () {
      const urlParams = [`provider=${encodeURIComponent(provider)}`];
      if (options === null || options === void 0 ? void 0 : options.redirectTo) {
        urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);
      }
      if (options === null || options === void 0 ? void 0 : options.scopes) {
        urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);
      }
      if (this.flowType === "pkce") {
        const [codeChallenge, codeChallengeMethod] = yield getCodeChallengeAndMethod(this.storage, this.storageKey);
        const flowParams = new URLSearchParams({
          code_challenge: `${encodeURIComponent(codeChallenge)}`,
          code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`
        });
        urlParams.push(flowParams.toString());
      }
      if (options === null || options === void 0 ? void 0 : options.queryParams) {
        const query = new URLSearchParams(options.queryParams);
        urlParams.push(query.toString());
      }
      if (options === null || options === void 0 ? void 0 : options.skipBrowserRedirect) {
        urlParams.push(`skip_http_redirect=${options.skipBrowserRedirect}`);
      }
      return `${url}?${urlParams.join("&")}`;
    });
  }
  _unenroll(params) {
    return __async(this, null, function* () {
      try {
        return yield this._useSession((result) => __async(this, null, function* () {
          var _a2;
          const { data: sessionData, error: sessionError } = result;
          if (sessionError) {
            return { data: null, error: sessionError };
          }
          return yield _request(this.fetch, "DELETE", `${this.url}/factors/${params.factorId}`, {
            headers: this.headers,
            jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
          });
        }));
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  _enroll(params) {
    return __async(this, null, function* () {
      try {
        return yield this._useSession((result) => __async(this, null, function* () {
          var _a2, _b;
          const { data: sessionData, error: sessionError } = result;
          if (sessionError) {
            return { data: null, error: sessionError };
          }
          const body2 = Object.assign({ friendly_name: params.friendlyName, factor_type: params.factorType }, params.factorType === "phone" ? { phone: params.phone } : params.factorType === "totp" ? { issuer: params.issuer } : {});
          const { data, error } = yield _request(this.fetch, "POST", `${this.url}/factors`, {
            body: body2,
            headers: this.headers,
            jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
          });
          if (error) {
            return { data: null, error };
          }
          if (params.factorType === "totp" && data.type === "totp" && ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code)) {
            data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;
          }
          return { data, error: null };
        }));
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  _verify(params) {
    return __async(this, null, function* () {
      return this._acquireLock(-1, () => __async(this, null, function* () {
        try {
          return yield this._useSession((result) => __async(this, null, function* () {
            var _a2;
            const { data: sessionData, error: sessionError } = result;
            if (sessionError) {
              return { data: null, error: sessionError };
            }
            const body2 = Object.assign({ challenge_id: params.challengeId }, "webauthn" in params ? {
              webauthn: Object.assign(Object.assign({}, params.webauthn), { credential_response: params.webauthn.type === "create" ? serializeCredentialCreationResponse(params.webauthn.credential_response) : serializeCredentialRequestResponse(params.webauthn.credential_response) })
            } : { code: params.code });
            const { data, error } = yield _request(this.fetch, "POST", `${this.url}/factors/${params.factorId}/verify`, {
              body: body2,
              headers: this.headers,
              jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
            });
            if (error) {
              return { data: null, error };
            }
            yield this._saveSession(Object.assign({ expires_at: Math.round(Date.now() / 1e3) + data.expires_in }, data));
            yield this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", data);
            return { data, error };
          }));
        } catch (error) {
          if (isAuthError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      }));
    });
  }
  _challenge(params) {
    return __async(this, null, function* () {
      return this._acquireLock(-1, () => __async(this, null, function* () {
        try {
          return yield this._useSession((result) => __async(this, null, function* () {
            var _a2;
            const { data: sessionData, error: sessionError } = result;
            if (sessionError) {
              return { data: null, error: sessionError };
            }
            const response = yield _request(this.fetch, "POST", `${this.url}/factors/${params.factorId}/challenge`, {
              body: params,
              headers: this.headers,
              jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
            });
            if (response.error) {
              return response;
            }
            const { data } = response;
            if (data.type !== "webauthn") {
              return { data, error: null };
            }
            switch (data.webauthn.type) {
              case "create":
                return {
                  data: Object.assign(Object.assign({}, data), { webauthn: Object.assign(Object.assign({}, data.webauthn), { credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), { publicKey: deserializeCredentialCreationOptions(data.webauthn.credential_options.publicKey) }) }) }),
                  error: null
                };
              case "request":
                return {
                  data: Object.assign(Object.assign({}, data), { webauthn: Object.assign(Object.assign({}, data.webauthn), { credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), { publicKey: deserializeCredentialRequestOptions(data.webauthn.credential_options.publicKey) }) }) }),
                  error: null
                };
            }
          }));
        } catch (error) {
          if (isAuthError(error)) {
            return { data: null, error };
          }
          throw error;
        }
      }));
    });
  }
  /**
   * {@see GoTrueMFAApi#challengeAndVerify}
   */
  _challengeAndVerify(params) {
    return __async(this, null, function* () {
      const { data: challengeData, error: challengeError } = yield this._challenge({
        factorId: params.factorId
      });
      if (challengeError) {
        return { data: null, error: challengeError };
      }
      return yield this._verify({
        factorId: params.factorId,
        challengeId: challengeData.id,
        code: params.code
      });
    });
  }
  /**
   * {@see GoTrueMFAApi#listFactors}
   */
  _listFactors() {
    return __async(this, null, function* () {
      var _a2;
      const { data: { user }, error: userError } = yield this.getUser();
      if (userError) {
        return { data: null, error: userError };
      }
      const data = {
        all: [],
        phone: [],
        totp: [],
        webauthn: []
      };
      for (const factor of (_a2 = user === null || user === void 0 ? void 0 : user.factors) !== null && _a2 !== void 0 ? _a2 : []) {
        data.all.push(factor);
        if (factor.status === "verified") {
          data[factor.factor_type].push(factor);
        }
      }
      return {
        data,
        error: null
      };
    });
  }
  /**
   * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}
   */
  _getAuthenticatorAssuranceLevel() {
    return __async(this, null, function* () {
      return this._acquireLock(-1, () => __async(this, null, function* () {
        return yield this._useSession((result) => __async(this, null, function* () {
          var _a2, _b;
          const { data: { session }, error: sessionError } = result;
          if (sessionError) {
            return { data: null, error: sessionError };
          }
          if (!session) {
            return {
              data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },
              error: null
            };
          }
          const { payload } = decodeJWT(session.access_token);
          let currentLevel = null;
          if (payload.aal) {
            currentLevel = payload.aal;
          }
          let nextLevel = currentLevel;
          const verifiedFactors = (_b = (_a2 = session.user.factors) === null || _a2 === void 0 ? void 0 : _a2.filter((factor) => factor.status === "verified")) !== null && _b !== void 0 ? _b : [];
          if (verifiedFactors.length > 0) {
            nextLevel = "aal2";
          }
          const currentAuthenticationMethods = payload.amr || [];
          return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null };
        }));
      }));
    });
  }
  fetchJwk(_0) {
    return __async(this, arguments, function* (kid, jwks = { keys: [] }) {
      let jwk = jwks.keys.find((key) => key.kid === kid);
      if (jwk) {
        return jwk;
      }
      const now = Date.now();
      jwk = this.jwks.keys.find((key) => key.kid === kid);
      if (jwk && this.jwks_cached_at + JWKS_TTL > now) {
        return jwk;
      }
      const { data, error } = yield _request(this.fetch, "GET", `${this.url}/.well-known/jwks.json`, {
        headers: this.headers
      });
      if (error) {
        throw error;
      }
      if (!data.keys || data.keys.length === 0) {
        return null;
      }
      this.jwks = data;
      this.jwks_cached_at = now;
      jwk = data.keys.find((key) => key.kid === kid);
      if (!jwk) {
        return null;
      }
      return jwk;
    });
  }
  /**
   * Extracts the JWT claims present in the access token by first verifying the
   * JWT against the server's JSON Web Key Set endpoint
   * `/.well-known/jwks.json` which is often cached, resulting in significantly
   * faster responses. Prefer this method over {@link #getUser} which always
   * sends a request to the Auth server for each JWT.
   *
   * If the project is not using an asymmetric JWT signing key (like ECC or
   * RSA) it always sends a request to the Auth server (similar to {@link
   * #getUser}) to verify the JWT.
   *
   * @param jwt An optional specific JWT you wish to verify, not the one you
   *            can obtain from {@link #getSession}.
   * @param options Various additional options that allow you to customize the
   *                behavior of this method.
   */
  getClaims(_0) {
    return __async(this, arguments, function* (jwt, options = {}) {
      try {
        let token2 = jwt;
        if (!token2) {
          const { data, error } = yield this.getSession();
          if (error || !data.session) {
            return { data: null, error };
          }
          token2 = data.session.access_token;
        }
        const { header, payload, signature, raw: { header: rawHeader, payload: rawPayload } } = decodeJWT(token2);
        if (!(options === null || options === void 0 ? void 0 : options.allowExpired)) {
          validateExp(payload.exp);
        }
        const signingKey = !header.alg || header.alg.startsWith("HS") || !header.kid || !("crypto" in globalThis && "subtle" in globalThis.crypto) ? null : yield this.fetchJwk(header.kid, (options === null || options === void 0 ? void 0 : options.keys) ? { keys: options.keys } : options === null || options === void 0 ? void 0 : options.jwks);
        if (!signingKey) {
          const { error } = yield this.getUser(token2);
          if (error) {
            throw error;
          }
          return {
            data: {
              claims: payload,
              header,
              signature
            },
            error: null
          };
        }
        const algorithm = getAlgorithm(header.alg);
        const publicKey = yield crypto.subtle.importKey("jwk", signingKey, algorithm, true, [
          "verify"
        ]);
        const isValid = yield crypto.subtle.verify(algorithm, publicKey, signature, stringToUint8Array(`${rawHeader}.${rawPayload}`));
        if (!isValid) {
          throw new AuthInvalidJwtError("Invalid JWT signature");
        }
        return {
          data: {
            claims: payload,
            header,
            signature
          },
          error: null
        };
      } catch (error) {
        if (isAuthError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
}
GoTrueClient.nextInstanceID = 0;
const AuthClient = GoTrueClient;
class SupabaseAuthClient extends AuthClient {
  constructor(options) {
    super(options);
  }
}
class SupabaseClient {
  /**
   * Create a new client for use in the browser.
   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.
   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.
   * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.
   * @param options.auth.autoRefreshToken Set to "true" if you want to automatically refresh the token before expiring.
   * @param options.auth.persistSession Set to "true" if you want to automatically save the user session into local storage.
   * @param options.auth.detectSessionInUrl Set to "true" if you want to automatically detects OAuth grants in the URL and signs in the user.
   * @param options.realtime Options passed along to realtime-js constructor.
   * @param options.storage Options passed along to the storage-js constructor.
   * @param options.global.fetch A custom fetch implementation.
   * @param options.global.headers Any additional headers to send with each network request.
   */
  constructor(supabaseUrl, supabaseKey, options) {
    var _a2, _b, _c;
    this.supabaseUrl = supabaseUrl;
    this.supabaseKey = supabaseKey;
    const baseUrl = validateSupabaseUrl(supabaseUrl);
    if (!supabaseKey)
      throw new Error("supabaseKey is required.");
    this.realtimeUrl = new URL("realtime/v1", baseUrl);
    this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace("http", "ws");
    this.authUrl = new URL("auth/v1", baseUrl);
    this.storageUrl = new URL("storage/v1", baseUrl);
    this.functionsUrl = new URL("functions/v1", baseUrl);
    const defaultStorageKey = `sb-${baseUrl.hostname.split(".")[0]}-auth-token`;
    const DEFAULTS = {
      db: DEFAULT_DB_OPTIONS,
      realtime: DEFAULT_REALTIME_OPTIONS,
      auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), { storageKey: defaultStorageKey }),
      global: DEFAULT_GLOBAL_OPTIONS
    };
    const settings = applySettingDefaults(options !== null && options !== void 0 ? options : {}, DEFAULTS);
    this.storageKey = (_a2 = settings.auth.storageKey) !== null && _a2 !== void 0 ? _a2 : "";
    this.headers = (_b = settings.global.headers) !== null && _b !== void 0 ? _b : {};
    if (!settings.accessToken) {
      this.auth = this._initSupabaseAuthClient((_c = settings.auth) !== null && _c !== void 0 ? _c : {}, this.headers, settings.global.fetch);
    } else {
      this.accessToken = settings.accessToken;
      this.auth = new Proxy({}, {
        get: (_, prop) => {
          throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);
        }
      });
    }
    this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);
    this.realtime = this._initRealtimeClient(Object.assign({ headers: this.headers, accessToken: this._getAccessToken.bind(this) }, settings.realtime));
    this.rest = new PostgrestClient(new URL("rest/v1", baseUrl).href, {
      headers: this.headers,
      schema: settings.db.schema,
      fetch: this.fetch
    });
    this.storage = new StorageClient(this.storageUrl.href, this.headers, this.fetch, options === null || options === void 0 ? void 0 : options.storage);
    if (!settings.accessToken) {
      this._listenForAuthEvents();
    }
  }
  /**
   * Supabase Functions allows you to deploy and invoke edge functions.
   */
  get functions() {
    return new FunctionsClient(this.functionsUrl.href, {
      headers: this.headers,
      customFetch: this.fetch
    });
  }
  /**
   * Perform a query on a table or a view.
   *
   * @param relation - The table or view name to query
   */
  from(relation) {
    return this.rest.from(relation);
  }
  // NOTE: signatures must be kept in sync with PostgrestClient.schema
  /**
   * Select a schema to query or perform an function (rpc) call.
   *
   * The schema needs to be on the list of exposed schemas inside Supabase.
   *
   * @param schema - The schema to query
   */
  schema(schema) {
    return this.rest.schema(schema);
  }
  // NOTE: signatures must be kept in sync with PostgrestClient.rpc
  /**
   * Perform a function call.
   *
   * @param fn - The function name to call
   * @param args - The arguments to pass to the function call
   * @param options - Named parameters
   * @param options.head - When set to `true`, `data` will not be returned.
   * Useful if you only need the count.
   * @param options.get - When set to `true`, the function will be called with
   * read-only access mode.
   * @param options.count - Count algorithm to use to count rows returned by the
   * function. Only applicable for [set-returning
   * functions](https://www.postgresql.org/docs/current/functions-srf.html).
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  rpc(fn2, args = {}, options = {
    head: false,
    get: false,
    count: void 0
  }) {
    return this.rest.rpc(fn2, args, options);
  }
  /**
   * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.
   *
   * @param {string} name - The name of the Realtime channel.
   * @param {Object} opts - The options to pass to the Realtime channel.
   *
   */
  channel(name2, opts = { config: {} }) {
    return this.realtime.channel(name2, opts);
  }
  /**
   * Returns all Realtime channels.
   */
  getChannels() {
    return this.realtime.getChannels();
  }
  /**
   * Unsubscribes and removes Realtime channel from Realtime client.
   *
   * @param {RealtimeChannel} channel - The name of the Realtime channel.
   *
   */
  removeChannel(channel) {
    return this.realtime.removeChannel(channel);
  }
  /**
   * Unsubscribes and removes all Realtime channels from Realtime client.
   */
  removeAllChannels() {
    return this.realtime.removeAllChannels();
  }
  _getAccessToken() {
    return __async(this, null, function* () {
      var _a2, _b;
      if (this.accessToken) {
        return yield this.accessToken();
      }
      const { data } = yield this.auth.getSession();
      return (_b = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) !== null && _b !== void 0 ? _b : this.supabaseKey;
    });
  }
  _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage, userStorage, storageKey, flowType, lock, debug }, headers, fetch2) {
    const authHeaders = {
      Authorization: `Bearer ${this.supabaseKey}`,
      apikey: `${this.supabaseKey}`
    };
    return new SupabaseAuthClient({
      url: this.authUrl.href,
      headers: Object.assign(Object.assign({}, authHeaders), headers),
      storageKey,
      autoRefreshToken,
      persistSession,
      detectSessionInUrl,
      storage,
      userStorage,
      flowType,
      lock,
      debug,
      fetch: fetch2,
      // auth checks if there is a custom authorizaiton header using this flag
      // so it knows whether to return an error when getUser is called with no session
      hasCustomAuthorizationHeader: Object.keys(this.headers).some((key) => key.toLowerCase() === "authorization")
    });
  }
  _initRealtimeClient(options) {
    return new RealtimeClient(this.realtimeUrl.href, Object.assign(Object.assign({}, options), { params: Object.assign({ apikey: this.supabaseKey }, options === null || options === void 0 ? void 0 : options.params) }));
  }
  _listenForAuthEvents() {
    const data = this.auth.onAuthStateChange((event, session) => {
      this._handleTokenChanged(event, "CLIENT", session === null || session === void 0 ? void 0 : session.access_token);
    });
    return data;
  }
  _handleTokenChanged(event, source, token2) {
    if ((event === "TOKEN_REFRESHED" || event === "SIGNED_IN") && this.changedAccessToken !== token2) {
      this.changedAccessToken = token2;
      this.realtime.setAuth(token2);
    } else if (event === "SIGNED_OUT") {
      this.realtime.setAuth();
      if (source == "STORAGE")
        this.auth.signOut();
      this.changedAccessToken = void 0;
    }
  }
}
const createClient = (supabaseUrl, supabaseKey, options) => {
  return new SupabaseClient(supabaseUrl, supabaseKey, options);
};
function shouldShowDeprecationWarning() {
  if (typeof window !== "undefined") {
    return false;
  }
  if (typeof process === "undefined") {
    return false;
  }
  const processVersion = process["version"];
  if (processVersion === void 0 || processVersion === null) {
    return false;
  }
  const versionMatch = processVersion.match(/^v(\d+)\./);
  if (!versionMatch) {
    return false;
  }
  const majorVersion = parseInt(versionMatch[1], 10);
  return majorVersion <= 18;
}
if (shouldShowDeprecationWarning()) {
  console.warn(`  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217`);
}
const SUPABASE_URL = "https://rdqpxixsbqcsyfewcmbz.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJkcXB4aXhzYnFjc3lmZXdjbWJ6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAxMjI3NTMsImV4cCI6MjA3NTY5ODc1M30.rTbYZNKNv1szvzjA2D828OVt7qUZVSXgi4G_tUqm3mA";
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
    // Explicitly use localStorage for web to keep users signed in across reloads
    storage: typeof window !== "undefined" ? window.localStorage : void 0
  }
});
function isAuthConfigured() {
  return Boolean(SUPABASE_ANON_KEY);
}
const createContext = window["React"].createContext;
const AuthContext = createContext({
  user: null,
  session: null,
  loading: true,
  signOut: () => {
  }
});
const envCandidates = [
  "https://strainspotter.onrender.com",
  void 0,
  void 0,
  void 0
].map((value) => typeof value === "string" ? value.trim() : "").filter(Boolean);
const fromEnv = envCandidates.length ? envCandidates[0] : "";
const isLocalhost = typeof window !== "undefined" && /localhost|127\.0\.0\.1/.test(window.location.host);
const isEnvLocal = fromEnv && /localhost|127\.0\.0\.1/.test(fromEnv);
const isCapacitor = typeof window !== "undefined" && window.location.protocol === "capacitor:";
const DEFAULT_REMOTE_API = "https://strainspotter.onrender.com";
const resolvedForLocal = isCapacitor ? fromEnv || DEFAULT_REMOTE_API : isLocalhost ? isEnvLocal ? fromEnv : "http://localhost:5181" : fromEnv || DEFAULT_REMOTE_API;
const API_BASE = resolvedForLocal.replace(/\/$/, "");
console.log("[Config] API_BASE:", API_BASE);
console.log("[Config] isCapacitor:", isCapacitor);
console.log("[Config] isLocalhost:", isLocalhost);
console.log("[Config] Window location:", typeof window !== "undefined" ? window.location.href : "N/A");
console.log("[Config] Window protocol:", typeof window !== "undefined" ? window.location.protocol : "N/A");
console.log("[Config] Environment variables:", {
  VITE_API_BASE: "https://strainspotter.onrender.com",
  VITE_API_BASE_URL: void 0,
  VITE_BACKEND_URL: void 0,
  VITE_API_URL: void 0
});
if (isCapacitor) {
  setTimeout(() => {
    alert(`StrainSpotter Config:
API_BASE: ${API_BASE}
Protocol: ${window.location.protocol}`);
  }, 2e3);
}
const functionsFallback = `${API_BASE}/api`;
const FUNCTIONS_BASE = functionsFallback.replace(/\/$/, "");
const React$9 = window["React"];
const useEffect$v = window["React"].useEffect;
const useState$A = window["React"].useState;
function AuthProvider({ children }) {
  const [user, setUser] = useState$A(null);
  const [session, setSession] = useState$A(null);
  const [loading, setLoading] = useState$A(true);
  useEffect$v(() => {
    if (!supabase) {
      setLoading(false);
      return;
    }
    supabase.auth.getSession().then(({ data: { session: session2 } }) => {
      var _a2, _b;
      console.log("[AuthContext] Initial session:", ((_a2 = session2 == null ? void 0 : session2.user) == null ? void 0 : _a2.email) || "none");
      setSession(session2);
      setUser((_b = session2 == null ? void 0 : session2.user) != null ? _b : null);
      setLoading(false);
    });
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (event, session2) => __async(null, null, function* () {
        var _a2, _b, _c, _d, _e;
        console.log("[AuthContext] Auth state change:", event, ((_a2 = session2 == null ? void 0 : session2.user) == null ? void 0 : _a2.email) || "none");
        setSession(session2);
        setUser((_b = session2 == null ? void 0 : session2.user) != null ? _b : null);
        setLoading(false);
        if (((_c = session2 == null ? void 0 : session2.user) == null ? void 0 : _c.id) && (event === "SIGNED_IN" || event === "USER_UPDATED")) {
          try {
            yield fetch(`${API_BASE}/api/users/ensure`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                user_id: session2.user.id,
                email: session2.user.email,
                username: ((_d = session2.user.user_metadata) == null ? void 0 : _d.username) || ((_e = session2.user.email) == null ? void 0 : _e.split("@")[0]) || `user_${session2.user.id.substring(0, 8)}`
              })
            });
            console.log("[AuthContext] User record ensured for:", session2.user.email);
          } catch (err) {
            console.error("[AuthContext] Failed to ensure user record:", err);
          }
        }
      })
    );
    return () => subscription.unsubscribe();
  }, []);
  const signOut = () => __async(null, null, function* () {
    if (supabase) {
      yield supabase.auth.signOut();
      console.log("[AuthContext] User signed out");
    }
  });
  const value = {
    user,
    session,
    loading,
    signOut
  };
  return /* @__PURE__ */ React$9.createElement(AuthContext.Provider, { value }, children);
}
const useState$z = window["React"].useState;
const useEffect$u = window["React"].useEffect;
function MobileOnlyGuard({ children }) {
  const [isMobile, setIsMobile] = useState$z(true);
  const [isProduction, setIsProduction] = useState$z(false);
  useEffect$u(() => {
    const isProd = true;
    setIsProduction(isProd);
    const checkDevice = () => {
      const userAgent = navigator.userAgent.toLowerCase();
      const isMobileDevice = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini|mobile|tablet/i.test(userAgent);
      const isSmallScreen = window.innerWidth <= 1024;
      setIsMobile(isMobileDevice || isSmallScreen);
    };
    checkDevice();
    window.addEventListener("resize", checkDevice);
    return () => window.removeEventListener("resize", checkDevice);
  }, []);
  if (!isProduction) {
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Box, { sx: {
      position: "fixed",
      top: 0,
      left: 0,
      right: 0,
      bgcolor: "rgba(255, 152, 0, 0.9)",
      color: "#fff",
      py: 0.5,
      px: 2,
      zIndex: 9999,
      textAlign: "center",
      fontSize: "0.75rem",
      fontWeight: 600
    } }, " DEV MODE - Desktop access enabled for development"), /* @__PURE__ */ React.createElement(Box, { sx: { pt: { xs: 0, sm: 4 } } }, children));
  }
  if (isProduction && !isMobile) {
    return /* @__PURE__ */ React.createElement(Container, { maxWidth: "sm" }, /* @__PURE__ */ React.createElement(Box, { sx: {
      minHeight: "100vh",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center",
      textAlign: "center",
      px: 3,
      background: "linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%)"
    } }, /* @__PURE__ */ React.createElement(Box, { sx: {
      bgcolor: "rgba(124, 179, 66, 0.1)",
      border: "2px solid rgba(124, 179, 66, 0.3)",
      borderRadius: 4,
      p: 4,
      maxWidth: 400
    } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h4", sx: {
      color: "#9CCC65",
      fontWeight: 700,
      mb: 2,
      fontSize: { xs: "1.5rem", sm: "2rem" }
    } }, " Mobile Only"), /* @__PURE__ */ React.createElement(Typography, { variant: "body1", sx: {
      color: "#fff",
      mb: 3,
      lineHeight: 1.6
    } }, "StrainSpotter is designed exclusively for mobile devices and tablets."), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: {
      color: "rgba(255, 255, 255, 0.7)",
      mb: 2
    } }, "Please access this app from:"), /* @__PURE__ */ React.createElement(Box, { sx: {
      bgcolor: "rgba(0, 0, 0, 0.3)",
      borderRadius: 2,
      p: 2,
      mb: 3
    } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#9CCC65", mb: 1 } }, " iPhone or Android phone"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#9CCC65" } }, " iPad or Android tablet")), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: {
      color: "rgba(255, 255, 255, 0.5)",
      display: "block",
      mt: 2
    } }, "Scan the QR code with your mobile device or visit this URL on your phone"))));
  }
  return children;
}
const AccessTimeIcon = createSvgIcon([/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2M12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8"
}, "0"), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
}, "1")]);
const ArrowBack = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20z"
}));
const AttachMoneyIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11.8 10.9c-2.27-.59-3-1.2-3-2.15 0-1.09 1.01-1.85 2.7-1.85 1.78 0 2.44.85 2.5 2.1h2.21c-.07-1.72-1.12-3.3-3.21-3.81V3h-3v2.16c-1.94.42-3.5 1.68-3.5 3.61 0 2.31 1.91 3.46 4.7 4.13 2.5.6 3 1.48 3 2.41 0 .69-.49 1.79-2.7 1.79-2.06 0-2.87-.92-2.98-2.1h-2.2c.12 2.19 1.76 3.42 3.68 3.83V21h3v-2.15c1.95-.37 3.5-1.5 3.5-3.55 0-2.84-2.43-3.81-4.7-4.4"
}));
const AutoAwesome = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "m19 9 1.25-2.75L23 5l-2.75-1.25L19 1l-1.25 2.75L15 5l2.75 1.25zm-7.5.5L9 4 6.5 9.5 1 12l5.5 2.5L9 20l2.5-5.5L17 12zM19 15l-1.25 2.75L15 19l2.75 1.25L19 23l1.25-2.75L23 19l-2.75-1.25z"
}));
const BoltIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11 21h-1l1-7H7.5c-.58 0-.57-.32-.38-.66s.05-.08.07-.12C8.48 10.94 10.42 7.54 13 3h1l-1 7h3.5c.49 0 .56.33.47.51l-.07.15C12.96 17.55 11 21 11 21"
}));
const BugReport = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20 8h-2.81c-.45-.78-1.07-1.45-1.82-1.96L17 4.41 15.59 3l-2.17 2.17C12.96 5.06 12.49 5 12 5s-.96.06-1.41.17L8.41 3 7 4.41l1.62 1.63C7.88 6.55 7.26 7.22 6.81 8H4v2h2.09c-.05.33-.09.66-.09 1v1H4v2h2v1c0 .34.04.67.09 1H4v2h2.81c1.04 1.79 2.97 3 5.19 3s4.15-1.21 5.19-3H20v-2h-2.09c.05-.33.09-.66.09-1v-1h2v-2h-2v-1c0-.34-.04-.67-.09-1H20zm-6 8h-4v-2h4zm0-4h-4v-2h4z"
}));
const CameraAltIcon = createSvgIcon([/* @__PURE__ */ jsxRuntimeExports.jsx("circle", {
  cx: "12",
  cy: "12",
  r: "3.2"
}, "0"), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M9 2 7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2h-3.17L15 2zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5"
}, "1")]);
const CheckCircleIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m-2 15-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8z"
}));
const Checklist = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M22 7h-9v2h9zm0 8h-9v2h9zM5.54 11 2 7.46l1.41-1.41 2.12 2.12 4.24-4.24 1.41 1.41zm0 8L2 15.46l1.41-1.41 2.12 2.12 4.24-4.24 1.41 1.41z"
}));
const CloseIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}));
const ContentCopy = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"
}));
const DeleteIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6zM19 4h-3.5l-1-1h-5l-1 1H5v2h14z"
}));
const DirectionsIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "m21.41 10.59-7.99-8c-.78-.78-2.05-.78-2.83 0l-8.01 8c-.78.78-.78 2.05 0 2.83l8.01 8c.78.78 2.05.78 2.83 0l7.99-8c.79-.79.79-2.05 0-2.83M13.5 14.5V12H10v3H8v-4c0-.55.45-1 1-1h4.5V7.5L17 11z"
}));
const EditIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.996.996 0 0 0-1.41 0l-1.83 1.83 3.75 3.75z"
}));
const EmojiEvents = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 5h-2V3H7v2H5c-1.1 0-2 .9-2 2v1c0 2.55 1.92 4.63 4.39 4.94.63 1.5 1.98 2.63 3.61 2.96V19H7v2h10v-2h-4v-3.1c1.63-.33 2.98-1.46 3.61-2.96C19.08 12.63 21 10.55 21 8V7c0-1.1-.9-2-2-2M5 8V7h2v3.82C5.84 10.4 5 9.3 5 8m14 0c0 1.3-.84 2.4-2 2.82V7h2z"
}));
const Engineering = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M9 15c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4m13.1-8.16c.01-.11.02-.22.02-.34s-.01-.23-.03-.34l.74-.58c.07-.05.08-.15.04-.22l-.7-1.21c-.04-.08-.14-.1-.21-.08l-.86.35c-.18-.14-.38-.25-.59-.34l-.13-.93c-.02-.09-.09-.15-.18-.15h-1.4c-.09 0-.16.06-.17.15l-.13.93c-.21.09-.41.21-.59.34l-.87-.35c-.08-.03-.17 0-.21.08l-.7 1.21c-.04.08-.03.17.04.22l.74.58c-.02.11-.03.23-.03.34s.01.23.03.34l-.74.58c-.07.05-.08.15-.04.22l.7 1.21c.04.08.14.1.21.08l.87-.35c.18.14.38.25.59.34l.13.93c.01.09.08.15.17.15h1.4c.09 0 .16-.06.17-.15l.13-.93c.21-.09.41-.21.59-.34l.87.35c.08.03.17 0 .21-.08l.7-1.21c.04-.08.03-.17-.04-.22zm-2.6.91c-.69 0-1.25-.56-1.25-1.25s.56-1.25 1.25-1.25 1.25.56 1.25 1.25-.56 1.25-1.25 1.25m.42 3.93-.5-.87c-.03-.06-.1-.08-.15-.06l-.62.25q-.195-.15-.42-.24l-.09-.66c-.02-.06-.08-.1-.14-.1h-1c-.06 0-.11.04-.12.11l-.09.66c-.15.06-.29.15-.42.24l-.62-.25c-.06-.02-.12 0-.15.06l-.5.87c-.03.06-.02.12.03.16l.53.41c-.01.08-.02.16-.02.24s.01.17.02.24l-.53.41c-.05.04-.06.11-.03.16l.5.87c.03.06.1.08.15.06l.62-.25q.195.15.42.24l.09.66c.01.07.06.11.12.11h1c.06 0 .12-.04.12-.11l.09-.66c.15-.06.29-.15.42-.24l.62.25c.06.02.12 0 .15-.06l.5-.87c.03-.06.02-.12-.03-.16l-.52-.41c.01-.08.02-.16.02-.24s-.01-.17-.02-.24l.53-.41c.05-.04.06-.11.04-.17m-2.42 1.65c-.46 0-.83-.38-.83-.83 0-.46.38-.83.83-.83s.83.38.83.83c0 .46-.37.83-.83.83M4.74 9h8.53c.27 0 .49-.22.49-.49v-.02c0-.27-.22-.49-.49-.49H13c0-1.48-.81-2.75-2-3.45v.95c0 .28-.22.5-.5.5s-.5-.22-.5-.5V4.14C9.68 4.06 9.35 4 9 4s-.68.06-1 .14V5.5c0 .28-.22.5-.5.5S7 5.78 7 5.5v-.95C5.81 5.25 5 6.52 5 8h-.26c-.27 0-.49.22-.49.49v.03c0 .26.22.48.49.48M9 13c1.86 0 3.41-1.28 3.86-3H5.14c.45 1.72 2 3 3.86 3"
}));
const FavoriteIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "m12 21.35-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54z"
}));
const FavoriteBorderIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M16.5 3c-1.74 0-3.41.81-4.5 2.09C10.91 3.81 9.24 3 7.5 3 4.42 3 2 5.42 2 8.5c0 3.78 3.4 6.86 8.55 11.54L12 21.35l1.45-1.32C18.6 15.36 22 12.28 22 8.5 22 5.42 19.58 3 16.5 3m-4.4 15.55-.1.1-.1-.1C7.14 14.24 4 11.39 4 8.5 4 6.5 5.5 5 7.5 5c1.54 0 3.04.99 3.57 2.36h1.87C13.46 5.99 14.96 5 16.5 5c2 0 3.5 1.5 3.5 3.5 0 2.89-3.14 5.74-7.9 10.05"
}));
const FeedbackIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2m-7 12h-2v-2h2zm0-4h-2V6h2z"
}));
const FilterListIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M10 18h4v-2h-4zM3 6v2h18V6zm3 7h12v-2H6z"
}));
const FlagIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M14.4 6 14 4H5v17h2v-7h5.6l.4 2h7V6z"
}));
const Grain = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M10 12c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2M6 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m0 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m12-8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2m-4 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m4-4c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m-4-4c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m-4-4c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2"
}));
const GroupsIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 12.75c1.63 0 3.07.39 4.24.9 1.08.48 1.76 1.56 1.76 2.73V18H6v-1.61c0-1.18.68-2.26 1.76-2.73 1.17-.52 2.61-.91 4.24-.91M4 13c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2m1.13 1.1c-.37-.06-.74-.1-1.13-.1-.99 0-1.93.21-2.78.58C.48 14.9 0 15.62 0 16.43V18h4.5v-1.61c0-.83.23-1.61.63-2.29M20 13c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2m4 3.43c0-.81-.48-1.53-1.22-1.85-.85-.37-1.79-.58-2.78-.58-.39 0-.76.04-1.13.1.4.68.63 1.46.63 2.29V18H24zM12 6c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3"
}));
const LanguageIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2m6.93 6h-2.95c-.32-1.25-.78-2.45-1.38-3.56 1.84.63 3.37 1.91 4.33 3.56M12 4.04c.83 1.2 1.48 2.53 1.91 3.96h-3.82c.43-1.43 1.08-2.76 1.91-3.96M4.26 14C4.1 13.36 4 12.69 4 12s.1-1.36.26-2h3.38c-.08.66-.14 1.32-.14 2s.06 1.34.14 2zm.82 2h2.95c.32 1.25.78 2.45 1.38 3.56-1.84-.63-3.37-1.9-4.33-3.56m2.95-8H5.08c.96-1.66 2.49-2.93 4.33-3.56C8.81 5.55 8.35 6.75 8.03 8M12 19.96c-.83-1.2-1.48-2.53-1.91-3.96h3.82c-.43 1.43-1.08 2.76-1.91 3.96M14.34 14H9.66c-.09-.66-.16-1.32-.16-2s.07-1.35.16-2h4.68c.09.65.16 1.32.16 2s-.07 1.34-.16 2m.25 5.56c.6-1.11 1.06-2.31 1.38-3.56h2.95c-.96 1.65-2.49 2.93-4.33 3.56M16.36 14c.08-.66.14-1.32.14-2s-.06-1.34-.14-2h3.38c.16.64.26 1.31.26 2s-.1 1.36-.26 2z"
}));
const LocalFloristIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 22c4.97 0 9-4.03 9-9-4.97 0-9 4.03-9 9M5.6 10.25c0 1.38 1.12 2.5 2.5 2.5.53 0 1.01-.16 1.42-.44l-.02.19c0 1.38 1.12 2.5 2.5 2.5s2.5-1.12 2.5-2.5l-.02-.19c.4.28.89.44 1.42.44 1.38 0 2.5-1.12 2.5-2.5 0-1-.59-1.85-1.43-2.25.84-.4 1.43-1.25 1.43-2.25 0-1.38-1.12-2.5-2.5-2.5-.53 0-1.01.16-1.42.44l.02-.19C14.5 2.12 13.38 1 12 1S9.5 2.12 9.5 3.5l.02.19c-.4-.28-.89-.44-1.42-.44-1.38 0-2.5 1.12-2.5 2.5 0 1 .59 1.85 1.43 2.25-.84.4-1.43 1.25-1.43 2.25M12 5.5c1.38 0 2.5 1.12 2.5 2.5s-1.12 2.5-2.5 2.5S9.5 9.38 9.5 8s1.12-2.5 2.5-2.5M3 13c0 4.97 4.03 9 9 9 0-4.97-4.03-9-9-9"
}));
const OfferIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "m21.41 11.58-9-9C12.05 2.22 11.55 2 11 2H4c-1.1 0-2 .9-2 2v7c0 .55.22 1.05.59 1.42l9 9c.36.36.86.58 1.41.58s1.05-.22 1.41-.59l7-7c.37-.36.59-.86.59-1.41s-.23-1.06-.59-1.42M5.5 7C4.67 7 4 6.33 4 5.5S4.67 4 5.5 4 7 4.67 7 5.5 6.33 7 5.5 7"
}));
const LocalShippingIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20 8h-3V4H3c-1.1 0-2 .9-2 2v11h2c0 1.66 1.34 3 3 3s3-1.34 3-3h6c0 1.66 1.34 3 3 3s3-1.34 3-3h2v-5zM6 18.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5m13.5-9 1.96 2.5H17V9.5zm-1.5 9c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5"
}));
const LocationOn = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7m0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5"
}));
const LogoutIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "m17 7-1.41 1.41L18.17 11H8v2h10.17l-2.58 2.58L17 17l5-5zM4 5h8V3H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h8v-2H4z"
}));
const MenuBookIcon = createSvgIcon([/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M21 5c-1.11-.35-2.33-.5-3.5-.5-1.95 0-4.05.4-5.5 1.5-1.45-1.1-3.55-1.5-5.5-1.5S2.45 4.9 1 6v14.65c0 .25.25.5.5.5.1 0 .15-.05.25-.05C3.1 20.45 5.05 20 6.5 20c1.95 0 4.05.4 5.5 1.5 1.35-.85 3.8-1.5 5.5-1.5 1.65 0 3.35.3 4.75 1.05.1.05.15.05.25.05.25 0 .5-.25.5-.5V6c-.6-.45-1.25-.75-2-1m0 13.5c-1.1-.35-2.3-.5-3.5-.5-1.7 0-4.15.65-5.5 1.5V8c1.35-.85 3.8-1.5 5.5-1.5 1.2 0 2.4.15 3.5.5z"
}, "0"), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M17.5 10.5c.88 0 1.73.09 2.5.26V9.24c-.79-.15-1.64-.24-2.5-.24-1.7 0-3.24.29-4.5.83v1.66c1.13-.64 2.7-.99 4.5-.99M13 12.49v1.66c1.13-.64 2.7-.99 4.5-.99.88 0 1.73.09 2.5.26V11.9c-.79-.15-1.64-.24-2.5-.24-1.7 0-3.24.3-4.5.83m4.5 1.84c-1.7 0-3.24.29-4.5.83v1.66c1.13-.64 2.7-.99 4.5-.99.88 0 1.73.09 2.5.26v-1.52c-.79-.16-1.64-.24-2.5-.24"
}, "1")]);
const MonitorHeart = createSvgIcon([/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M15.11 12.45 14 10.24l-3.11 6.21c-.16.34-.51.55-.89.55s-.73-.21-.89-.55L7.38 13H2v5c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-5h-6c-.38 0-.73-.21-.89-.55"
}, "0"), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20 4H4c-1.1 0-2 .9-2 2v5h6c.38 0 .73.21.89.55L10 13.76l3.11-6.21c.34-.68 1.45-.68 1.79 0L16.62 11H22V6c0-1.1-.9-2-2-2"
}, "1")]);
const MyLocationIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4m8.94 3c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7"
}));
const NoteAdd = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8zm2 14h-3v3h-2v-3H8v-2h3v-3h2v3h3zm-3-7V3.5L18.5 9z"
}));
const NoteAlt = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 3h-4.18C14.4 1.84 13.3 1 12 1s-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m-7-.25c.41 0 .75.34.75.75s-.34.75-.75.75-.75-.34-.75-.75.34-.75.75-.75M9.1 17H7v-2.14l5.96-5.96 2.12 2.12zm7.75-7.73-1.06 1.06-2.12-2.12 1.06-1.06c.2-.2.51-.2.71 0l1.41 1.41c.2.2.2.51 0 .71"
}));
const Opacity = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M17.66 8 12 2.35 6.34 8C4.78 9.56 4 11.64 4 13.64s.78 4.11 2.34 5.67 3.61 2.35 5.66 2.35 4.1-.79 5.66-2.35S20 15.64 20 13.64 19.22 9.56 17.66 8M6 14c.01-2 .62-3.27 1.76-4.4L12 5.27l4.24 4.38C17.38 10.77 17.99 12 18 14z"
}));
const OpenInNewIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3z"
}));
const PaymentIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2m0 14H4v-6h16zm0-10H4V6h16z"
}));
const PeopleIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5s-3 1.34-3 3 1.34 3 3 3m-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5 5 6.34 5 8s1.34 3 3 3m0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5m8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5"
}));
const PersonIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4m0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4"
}));
const PhoneIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M6.62 10.79c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.27-.27.67-.36 1.02-.24 1.12.37 2.33.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.03.74-.25 1.02z"
}));
const RateReviewIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2M6 14v-2.47l6.88-6.88c.2-.2.51-.2.71 0l1.77 1.77c.2.2.2.51 0 .71L8.47 14zm12 0h-7.5l2-2H18z"
}));
const RefreshIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4z"
}));
const Save = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3m3-10H5V5h10z"
}));
const Science = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19.8 18.4 14 10.67V6.5l1.35-1.69c.26-.33.03-.81-.39-.81H9.04c-.42 0-.65.48-.39.81L10 6.5v4.17L4.2 18.4c-.49.66-.02 1.6.8 1.6h14c.82 0 1.29-.94.8-1.6"
}));
const SearchIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"
}));
const Share = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92"
}));
const SpaIcon = createSvgIcon([/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M8.55 12c-1.07-.71-2.25-1.27-3.53-1.61 1.28.34 2.46.9 3.53 1.61m10.43-1.61c-1.29.34-2.49.91-3.57 1.64 1.08-.73 2.28-1.3 3.57-1.64"
}, "0"), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M15.49 9.63c-.18-2.79-1.31-5.51-3.43-7.63-2.14 2.14-3.32 4.86-3.55 7.63 1.28.68 2.46 1.56 3.49 2.63 1.03-1.06 2.21-1.94 3.49-2.63m-6.5 2.65c-.14-.1-.3-.19-.45-.29.15.11.31.19.45.29m6.42-.25c-.13.09-.27.16-.4.26.13-.1.27-.17.4-.26M12 15.45C9.85 12.17 6.18 10 2 10c0 5.32 3.36 9.82 8.03 11.49.63.23 1.29.4 1.97.51.68-.12 1.33-.29 1.97-.51C18.64 19.82 22 15.32 22 10c-4.18 0-7.85 2.17-10 5.45"
}, "1")]);
const StarIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 17.27 18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"
}));
const StoreIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20 4H4v2h16zm1 10v-2l-1-5H4l-1 5v2h1v6h10v-6h4v6h2v-6zm-9 4H6v-4h6z"
}));
const Timeline = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M23 8c0 1.1-.9 2-2 2-.18 0-.35-.02-.51-.07l-3.56 3.55c.05.16.07.34.07.52 0 1.1-.9 2-2 2s-2-.9-2-2c0-.18.02-.36.07-.52l-2.55-2.55c-.16.05-.34.07-.52.07s-.36-.02-.52-.07l-4.55 4.56c.05.16.07.33.07.51 0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2c.18 0 .35.02.51.07l4.56-4.55C8.02 9.36 8 9.18 8 9c0-1.1.9-2 2-2s2 .9 2 2c0 .18-.02.36-.07.52l2.55 2.55c.16-.05.34-.07.52-.07s.36.02.52.07l3.55-3.56C19.02 8.35 19 8.18 19 8c0-1.1.9-2 2-2s2 .9 2 2"
}));
const VerifiedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "m23 12-2.44-2.79.34-3.69-3.61-.82-1.89-3.2L12 2.96 8.6 1.5 6.71 4.69 3.1 5.5l.34 3.7L1 12l2.44 2.79-.34 3.7 3.61.82L8.6 22.5l3.4-1.47 3.4 1.46 1.89-3.19 3.61-.82-.34-3.69zm-12.91 4.72-3.8-3.81 1.48-1.48 2.32 2.33 5.85-5.87 1.48 1.48z"
}));
const WarningIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M1 21h22L12 2zm12-3h-2v-2h2zm0-4h-2v-4h2z"
}));
const WaterDrop = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 2c-5.33 4.55-8 8.48-8 11.8 0 4.98 3.8 8.2 8 8.2s8-3.22 8-8.2c0-3.32-2.67-7.25-8-11.8M7.83 14c.37 0 .67.26.74.62.41 2.22 2.28 2.98 3.64 2.87.43-.02.79.32.79.75 0 .4-.32.73-.72.75-2.13.13-4.62-1.09-5.19-4.12-.08-.45.28-.87.74-.87"
}));
const WbSunny = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "m6.76 4.84-1.8-1.79-1.41 1.41 1.79 1.79zM4 10.5H1v2h3zm9-9.95h-2V3.5h2zm7.45 3.91-1.41-1.41-1.79 1.79 1.41 1.41zm-3.21 13.7 1.79 1.8 1.41-1.41-1.8-1.79zM20 10.5v2h3v-2zm-8-5c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6m-1 16.95h2V19.5h-2zm-7.45-3.91 1.41 1.41 1.79-1.8-1.41-1.41z"
}));
function AgeGate({ onVerify }) {
  return /* @__PURE__ */ React.createElement(
    Box,
    {
      sx: {
        minHeight: "100vh",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        background: "linear-gradient(135deg, #1a3a1a 0%, #2d5a2d 50%, #1a3a1a 100%)",
        position: "relative",
        overflow: "hidden",
        "&::before": {
          content: '""',
          position: "absolute",
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          backgroundImage: `
            radial-gradient(circle at 20% 50%, rgba(76, 175, 80, 0.1) 0%, transparent 50%),
            radial-gradient(circle at 80% 80%, rgba(139, 195, 74, 0.1) 0%, transparent 50%)
          `
        }
      }
    },
    /* @__PURE__ */ React.createElement(Container, { maxWidth: "sm", sx: { position: "relative", zIndex: 1 } }, /* @__PURE__ */ React.createElement(
      Card,
      {
        elevation: 8,
        sx: {
          background: "linear-gradient(135deg, #2c2c2c 0%, #1f3a1f 100%)",
          border: "2px solid #4caf50"
        }
      },
      /* @__PURE__ */ React.createElement(CardContent, { sx: { p: 4, textAlign: "center" } }, /* @__PURE__ */ React.createElement(Box, { sx: { position: "relative", display: "inline-block" } }, /* @__PURE__ */ React.createElement(
        LocalFloristIcon,
        {
          sx: {
            fontSize: 100,
            color: "#4caf50",
            mb: 2,
            filter: "drop-shadow(0 0 20px rgba(76, 175, 80, 0.5))",
            animation: "pulse 2s ease-in-out infinite",
            "@keyframes pulse": {
              "0%, 100%": { transform: "scale(1)" },
              "50%": { transform: "scale(1.05)" }
            }
          }
        }
      )), /* @__PURE__ */ React.createElement(
        Typography,
        {
          variant: "h3",
          gutterBottom: true,
          fontWeight: "bold",
          sx: {
            background: "linear-gradient(45deg, #4caf50 30%, #8bc34a 90%)",
            WebkitBackgroundClip: "text",
            WebkitTextFillColor: "rgba(0,0,0,0)"
          }
        },
        "StrainSpotter"
      ), /* @__PURE__ */ React.createElement(Typography, { variant: "h6", color: "text.secondary", paragraph: true }, "AI-Powered Cannabis Strain Identification"), /* @__PURE__ */ React.createElement(Box, { sx: { my: 4, p: 3, bgcolor: "rgba(76, 175, 80, 0.1)", borderRadius: 2, border: "1px solid rgba(76, 175, 80, 0.3)" } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h5", gutterBottom: true, fontWeight: "bold", color: "primary.light" }, "Age Verification Required"), /* @__PURE__ */ React.createElement(Typography, { variant: "body1", paragraph: true, color: "text.primary" }, "You must be 21 years or older to use this application."), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, 'By clicking "I am 21+", you confirm that you meet the age requirement for cannabis-related content in your jurisdiction.')), /* @__PURE__ */ React.createElement(
        Button,
        {
          variant: "contained",
          size: "large",
          fullWidth: true,
          onClick: onVerify,
          sx: {
            py: 2.5,
            fontSize: "1.2rem",
            fontWeight: "bold",
            background: "linear-gradient(45deg, #4caf50 30%, #66bb6a 90%)",
            boxShadow: "0 3px 15px 2px rgba(76, 175, 80, .3)",
            "&:hover": {
              background: "linear-gradient(45deg, #388e3c 30%, #4caf50 90%)",
              boxShadow: "0 6px 20px 4px rgba(76, 175, 80, .4)"
            }
          }
        },
        /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 1 }, /* @__PURE__ */ React.createElement(Box, { component: "img", src: "/hero.png?v=13", alt: "", sx: { width: 20, height: 20, filter: "drop-shadow(0 0 4px rgba(124, 179, 66, 0.6))" } }), /* @__PURE__ */ React.createElement("span", null, "I am 21 or Older"), /* @__PURE__ */ React.createElement(Box, { component: "img", src: "/hero.png?v=13", alt: "", sx: { width: 20, height: 20, filter: "drop-shadow(0 0 4px rgba(124, 179, 66, 0.6))" } }))
      ), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", color: "text.secondary", display: "block", sx: { mt: 3 } }, "Cannabis is for medical and recreational use in accordance with state laws.", /* @__PURE__ */ React.createElement("br", null), "Please consume responsibly."))
    ))
  );
}
const React$8 = window["React"];
const useEffect$t = window["React"].useEffect;
const useState$y = window["React"].useState;
function Auth({ onBack }) {
  const [email, setEmail] = useState$y("");
  const [password, setPassword] = useState$y("");
  const [mode, setMode2] = useState$y("signin");
  const [loading, setLoading] = useState$y(false);
  const [error, setError] = useState$y(null);
  const [user, setUser] = useState$y(null);
  const [info, setInfo] = useState$y(null);
  useEffect$t(() => {
    if (!supabase) return;
    const { data: authListener } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser((session == null ? void 0 : session.user) || null);
    });
    supabase.auth.getSession().then(({ data }) => {
      var _a2;
      return setUser(((_a2 = data.session) == null ? void 0 : _a2.user) || null);
    });
    return () => {
      var _a2;
      return (_a2 = authListener == null ? void 0 : authListener.subscription) == null ? void 0 : _a2.unsubscribe();
    };
  }, []);
  function signIn() {
    return __async(this, null, function* () {
      var _a2;
      if (!isAuthConfigured()) {
        setError("Auth not configured. Set VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY.");
        return;
      }
      setLoading(true);
      setError(null);
      setInfo(null);
      const { error: error2 } = yield supabase.auth.signInWithPassword({ email, password });
      if (error2) {
        setError(error2.message);
      } else {
        try {
          const { data } = yield supabase.auth.getSession();
          const user2 = (_a2 = data == null ? void 0 : data.session) == null ? void 0 : _a2.user;
          if (user2 == null ? void 0 : user2.id) {
            const { data: profile } = yield supabase.from("profiles").select("username, avatar_url").eq("user_id", user2.id).single();
            if (!(profile == null ? void 0 : profile.username) || !(profile == null ? void 0 : profile.avatar_url)) {
              try {
                yield fetch(`${API_BASE}/api/profile-generator/generate`, {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    email: user2.email,
                    userId: user2.id
                  })
                });
              } catch (e) {
                console.warn("[auth] Failed to generate profile:", e);
              }
            } else {
              yield fetch(`${API_BASE}/api/users/ensure`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ user_id: user2.id, email: user2.email, username: profile.username })
              });
            }
          }
        } catch (e) {
          console.warn("[auth] ensure user after sign-in failed:", e);
        }
        if (onBack) {
          setTimeout(() => onBack(), 500);
        }
      }
      setLoading(false);
    });
  }
  function signUp() {
    return __async(this, null, function* () {
      var _a2, _b;
      if (!isAuthConfigured()) {
        setError("Auth not configured. Set VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY.");
        return;
      }
      setLoading(true);
      setError(null);
      setInfo(null);
      const redirectTo = typeof window !== "undefined" ? window.location.origin : void 0;
      const { data, error: error2 } = yield supabase.auth.signUp({
        email,
        password,
        options: {
          emailRedirectTo: redirectTo,
          data: { email_confirmed: true }
          // Auto-confirm for dev
        }
      });
      setLoading(false);
      if (error2) {
        setError(error2.message);
      } else if (((_b = (_a2 = data == null ? void 0 : data.user) == null ? void 0 : _a2.identities) == null ? void 0 : _b.length) === 0) {
        setError('This email is already registered. Please sign in, or use "Forgot password" to reset.');
      } else {
        try {
          yield fetch(`${API_BASE}/api/profile-generator/generate`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              email,
              userId: data.user.id
            })
          });
        } catch (e) {
          console.warn("[auth] Failed to generate profile:", e);
        }
        setError(null);
        setInfo("Account created with a cannabis-themed profile! You can now sign in.");
      }
    });
  }
  function signOut() {
    return __async(this, null, function* () {
      yield supabase == null ? void 0 : supabase.auth.signOut();
    });
  }
  function sendMagicLink() {
    return __async(this, null, function* () {
      if (!isAuthConfigured()) {
        setError("Auth not configured.");
        return;
      }
      setLoading(true);
      setError(null);
      setInfo(null);
      try {
        const redirectTo = typeof window !== "undefined" ? window.location.origin : void 0;
        const { error: error2 } = yield supabase.auth.signInWithOtp({ email, options: { emailRedirectTo: redirectTo } });
        if (error2) setError(error2.message);
        else setInfo("Magic link sent. Check your email and click the link to sign in.");
      } finally {
        setLoading(false);
      }
    });
  }
  function forgotPassword() {
    return __async(this, null, function* () {
      if (!isAuthConfigured()) {
        setError("Auth not configured.");
        return;
      }
      setLoading(true);
      setError(null);
      setInfo(null);
      try {
        const redirectTo = typeof window !== "undefined" ? `${window.location.origin}/` : void 0;
        const { error: error2 } = yield supabase.auth.resetPasswordForEmail(email, { redirectTo });
        if (error2) setError(error2.message);
        else setInfo("Password reset email sent. Check your email and click the link to reset your password. The link expires in 1 hour.");
      } finally {
        setLoading(false);
      }
    });
  }
  const ALLOWLIST = [
    "your@email.com",
    // <-- add your email(s) here
    "friend1@email.com",
    "friend2@email.com",
    "andrewbeck209@gmail.com"
    // Add more emails as needed
  ];
  if (!isAuthConfigured()) {
    return /* @__PURE__ */ React$8.createElement(Alert, { severity: "info" }, "Auth is not configured. You can still browse features.");
  }
  const isDev = typeof window !== "undefined" && (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1");
  if (user && !isDev && !ALLOWLIST.includes(user.email)) {
    return /* @__PURE__ */ React$8.createElement(Alert, { severity: "error" }, "This app is restricted. Only select users can access StrainSpotter web. Please use the mobile app.");
  }
  return /* @__PURE__ */ React$8.createElement(Box, { sx: { maxWidth: 420, mx: "auto", py: 4, background: "transparent" } }, onBack && /* @__PURE__ */ React$8.createElement(
    Button,
    {
      onClick: onBack,
      size: "small",
      variant: "contained",
      sx: {
        mb: 2,
        bgcolor: "#7CB342",
        color: "white",
        textTransform: "none",
        fontWeight: 700,
        borderRadius: 999,
        "&:hover": { bgcolor: "#689f38" }
      }
    },
    " Home"
  ), /* @__PURE__ */ React$8.createElement(Card, { sx: { background: "rgba(255,255,255,0.15)", backdropFilter: "blur(12px)", border: "2px solid rgba(0,0,0,0.12)", boxShadow: "none" } }, /* @__PURE__ */ React$8.createElement(CardContent, null, /* @__PURE__ */ React$8.createElement(Stack, { spacing: 2 }, /* @__PURE__ */ React$8.createElement(Box, { sx: { display: "flex", justifyContent: "center", mb: 2 } }, /* @__PURE__ */ React$8.createElement(
    Box,
    {
      sx: {
        width: 80,
        height: 80,
        borderRadius: "50%",
        background: "transparent",
        border: "2px solid rgba(124, 179, 66, 0.5)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        boxShadow: "0 0 30px rgba(124, 179, 66, 0.4)",
        overflow: "hidden"
      }
    },
    /* @__PURE__ */ React$8.createElement(
      "img",
      {
        src: "/hero.png?v=13",
        alt: "StrainSpotter",
        style: { width: "100%", height: "100%", objectFit: "cover" }
      }
    )
  )), /* @__PURE__ */ React$8.createElement(Typography, { variant: "h5", sx: { color: "black", fontSize: "2rem", fontWeight: 700, textAlign: "center" } }, "Account"), user ? /* @__PURE__ */ React$8.createElement(React$8.Fragment, null, /* @__PURE__ */ React$8.createElement(Typography, { variant: "body2" }, "Signed in as ", user.email), /* @__PURE__ */ React$8.createElement(Button, { variant: "outlined", onClick: signOut }, "Sign Out")) : /* @__PURE__ */ React$8.createElement(React$8.Fragment, null, /* @__PURE__ */ React$8.createElement(Tabs, { value: mode, onChange: (_e, v) => setMode2(v), "aria-label": "auth mode" }, /* @__PURE__ */ React$8.createElement(Tab, { label: "Sign In", value: "signin" }), /* @__PURE__ */ React$8.createElement(Tab, { label: "Sign Up", value: "signup" })), /* @__PURE__ */ React$8.createElement(TextField, { label: "Email", type: "email", value: email, onChange: (e) => setEmail(e.target.value), fullWidth: true, sx: { background: "rgba(255,255,255,0.10)", color: "black", fontSize: "1.15rem", borderRadius: 2, input: { color: "black" } }, InputLabelProps: { style: { color: "black", fontWeight: 600 } } }), mode === "signin" && /* @__PURE__ */ React$8.createElement(React$8.Fragment, null, /* @__PURE__ */ React$8.createElement(TextField, { label: "Password", type: "password", value: password, onChange: (e) => setPassword(e.target.value), fullWidth: true, sx: { background: "rgba(255,255,255,0.10)", color: "black", fontSize: "1.15rem", borderRadius: 2, input: { color: "black" } }, InputLabelProps: { style: { color: "black", fontWeight: 600 } } }), error && /* @__PURE__ */ React$8.createElement(Alert, { severity: "error", sx: { fontSize: "1.1rem", color: "black", background: "rgba(255,255,255,0.10)" } }, error), info && /* @__PURE__ */ React$8.createElement(Alert, { severity: "info", sx: { fontSize: "1.1rem", color: "black", background: "rgba(255,255,255,0.10)" } }, info), /* @__PURE__ */ React$8.createElement(Stack, { direction: { xs: "column", sm: "row" }, spacing: 1 }, /* @__PURE__ */ React$8.createElement(Button, { variant: "contained", onClick: signIn, disabled: loading, sx: { fontSize: "1.1rem", color: "black", background: "rgba(255,255,255,0.20)", border: "1.5px solid black", boxShadow: "none", fontWeight: 700 } }, loading ? /* @__PURE__ */ React$8.createElement(CircularProgress, { size: 20 }) : "Sign In"), /* @__PURE__ */ React$8.createElement(Button, { variant: "outlined", onClick: sendMagicLink, disabled: loading, sx: { fontSize: "1.1rem", color: "black", border: "1.5px solid black", fontWeight: 700 } }, "Send Magic Link"), /* @__PURE__ */ React$8.createElement(Button, { variant: "text", onClick: forgotPassword, disabled: loading, sx: { fontSize: "1.1rem", color: "black", fontWeight: 700 } }, "Forgot Password?"))), mode === "signup" && /* @__PURE__ */ React$8.createElement(React$8.Fragment, null, /* @__PURE__ */ React$8.createElement(TextField, { label: "Password", type: "password", value: password, onChange: (e) => setPassword(e.target.value), fullWidth: true, sx: { background: "rgba(255,255,255,0.10)", color: "black", fontSize: "1.15rem", borderRadius: 2, input: { color: "black" } }, InputLabelProps: { style: { color: "black", fontWeight: 600 } } }), error && /* @__PURE__ */ React$8.createElement(Alert, { severity: "error", sx: { fontSize: "1.1rem", color: "black", background: "rgba(255,255,255,0.10)" } }, error), info && /* @__PURE__ */ React$8.createElement(Alert, { severity: "info", sx: { fontSize: "1.1rem", color: "black", background: "rgba(255,255,255,0.10)" } }, info), /* @__PURE__ */ React$8.createElement(Stack, { direction: { xs: "column", sm: "row" }, spacing: 1 }, /* @__PURE__ */ React$8.createElement(Button, { variant: "contained", onClick: signUp, disabled: loading, sx: { fontSize: "1.1rem", color: "black", background: "rgba(255,255,255,0.20)", border: "1.5px solid black", boxShadow: "none", fontWeight: 700 } }, loading ? /* @__PURE__ */ React$8.createElement(CircularProgress, { size: 20 }) : "Create Account"), /* @__PURE__ */ React$8.createElement(Link$1, { component: "button", onClick: () => setMode2("signin"), sx: { alignSelf: "center", color: "black", fontWeight: 700 } }, "Already registered? Sign in"))))))));
}
const cannabisTheme = {
  colors: {
    // Primary greens (muted sage/olive green - less vivid)
    primary: {
      main: "#7CB342",
      // Muted olive green
      light: "#9CCC65",
      // Soft sage
      dark: "#558B2F"
    },
    // Secondary (earth tones)
    secondary: {
      main: "#9E9D24",
      // Muted earth yellow
      light: "#C5E1A5",
      dark: "#827717"
    },
    // Text
    text: {
      primary: "#9CCC65",
      // Soft sage green for main text
      secondary: "#7CB342"
    }
  },
  // Cannabis leaf icon SVG path
  leafIcon: {
    viewBox: "0 0 64 64",
    path: "M32 6c2.8 8.2 9.6 14 18 16-8.4 2-15.2 7.8-18 16-2.8-8.2-9.6-14-18-16 8.4-2 15.2-7.8 18-16ZM32 44c-3.5-6.5-9.9-10.7-18-12 4 5.3 7.1 11.1 8.5 17.3 3.1 1.5 6.2 2.7 9.5 3.7v-9ZM32 44c3.5-6.5 9.9-10.7 18-12-4 5.3-7.1 11.1-8.5 17.3-3.1 1.5-6.2 2.7-9.5 3.7v-9Z"
  },
  // Border styles
  borders: {
    primary: "2px solid #7CB342",
    subtle: "1px solid rgba(124, 179, 66, 0.3)"
  },
  // Shadows
  shadows: {
    card: "0 4px 20px rgba(0, 0, 0, 0.5)",
    elevated: "0 8px 30px rgba(0, 0, 0, 0.7)"
  }
};
const muiThemeOverrides = {
  palette: {
    mode: "dark",
    primary: {
      main: cannabisTheme.colors.primary.main,
      light: cannabisTheme.colors.primary.light,
      dark: cannabisTheme.colors.primary.dark
    },
    secondary: {
      main: cannabisTheme.colors.secondary.main,
      light: cannabisTheme.colors.secondary.light,
      dark: cannabisTheme.colors.secondary.dark
    },
    background: {
      default: "#1a1a1a",
      // Use a valid dark color for background
      paper: "#2c2c2c"
      // Use a valid card color for paper
    },
    text: {
      primary: cannabisTheme.colors.text.primary,
      secondary: cannabisTheme.colors.text.secondary
    }
  },
  components: {
    MuiCard: {
      styleOverrides: {
        root: {
          backgroundColor: "none",
          border: cannabisTheme.borders.subtle,
          boxShadow: cannabisTheme.shadows.card
        }
      }
    },
    MuiButton: {
      styleOverrides: {
        root: {
          borderRadius: 10,
          textTransform: "none",
          // Disable hover on touch devices to prevent double-tap issue
          "@media (hover: none)": {
            "&:hover": {
              backgroundColor: "inherit"
            }
          }
        },
        contained: {
          backgroundColor: "rgba(124, 179, 66, 0.3)",
          border: "2px solid rgba(124, 179, 66, 0.6)",
          backdropFilter: "blur(10px)",
          boxShadow: "0 6px 20px rgba(124, 179, 66, 0.2)",
          // Only apply hover on devices with hover capability (desktop)
          "@media (hover: hover)": {
            "&:hover": {
              backgroundColor: "rgba(124, 179, 66, 0.5)",
              border: "2px solid rgba(124, 179, 66, 0.8)"
            }
          },
          // Active state for touch devices
          "&:active": {
            backgroundColor: "rgba(124, 179, 66, 0.5)",
            transform: "scale(0.98)"
          }
        },
        outlined: {
          backgroundColor: "rgba(124, 179, 66, 0.2)",
          border: "2px solid rgba(124, 179, 66, 0.5)",
          backdropFilter: "blur(10px)",
          // Only apply hover on devices with hover capability (desktop)
          "@media (hover: hover)": {
            "&:hover": {
              backgroundColor: "rgba(124, 179, 66, 0.3)",
              border: "2px solid rgba(124, 179, 66, 0.7)"
            }
          },
          // Active state for touch devices
          "&:active": {
            backgroundColor: "rgba(124, 179, 66, 0.3)",
            transform: "scale(0.98)"
          }
        },
        text: {
          backgroundColor: "rgba(124, 179, 66, 0.15)",
          backdropFilter: "blur(10px)",
          // Only apply hover on devices with hover capability (desktop)
          "@media (hover: hover)": {
            "&:hover": {
              backgroundColor: "rgba(124, 179, 66, 0.25)"
            }
          },
          // Active state for touch devices
          "&:active": {
            backgroundColor: "rgba(124, 179, 66, 0.25)",
            transform: "scale(0.98)"
          }
        }
      }
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          backgroundColor: "#1a1a1a",
          borderBottom: cannabisTheme.borders.primary
        }
      }
    },
    MuiDrawer: {
      styleOverrides: {
        paper: {
          backgroundColor: "#2c2c2c",
          borderRight: cannabisTheme.borders.subtle
        }
      }
    },
    MuiDialog: {
      styleOverrides: {
        paper: {
          backgroundColor: "#2c2c2c",
          border: cannabisTheme.borders.subtle,
          boxShadow: cannabisTheme.shadows.elevated
        }
      }
    }
  },
  typography: {
    fontFamily: '"Inter", "Roboto", "Helvetica", "Arial", sans-serif',
    h1: { fontWeight: 700 },
    h2: { fontWeight: 700 },
    h3: { fontWeight: 600 },
    h4: { fontWeight: 600 },
    h5: { fontWeight: 600 },
    h6: { fontWeight: 600 }
  }
};
function CannabisLeafIcon(_g) {
  var _h = _g, { size = 28, color: color2, sx } = _h, props = __objRest(_h, ["size", "color", "sx"]);
  return /* @__PURE__ */ React.createElement(
    Box,
    __spreadValues({
      component: "svg",
      width: size,
      height: size,
      viewBox: cannabisTheme.leafIcon.viewBox,
      fill: "none",
      sx: __spreadValues({
        color: color2 || cannabisTheme.colors.primary.main
      }, sx)
    }, props),
    /* @__PURE__ */ React.createElement(
      "path",
      {
        d: cannabisTheme.leafIcon.path,
        fill: "currentColor"
      }
    )
  );
}
const useContext = window["React"].useContext;
function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
}
const useState$x = window["React"].useState;
const useRef$4 = window["React"].useRef;
const useEffect$s = window["React"].useEffect;
function Scanner({ onViewHistory, onBack }) {
  const [showGuide, setShowGuide] = useState$x(true);
  const [images, setImages] = useState$x([]);
  const [imagePreviews, setImagePreviews] = useState$x([]);
  const [loading, setLoading] = useState$x(false);
  const [loadingStatus, setLoadingStatus] = useState$x("");
  const [error, setError] = useState$x(null);
  const [matchedStrain, setMatchedStrain] = useState$x(null);
  const [suggestedStrains, setSuggestedStrains] = useState$x([]);
  const [detectedTextPreview, setDetectedTextPreview] = useState$x("");
  const [showResult, setShowResult] = useState$x(false);
  const [showTips, setShowTips] = useState$x(false);
  const [lastScanId, setLastScanId] = useState$x(null);
  const [reviews, setReviews] = useState$x([]);
  const [avgRating, setAvgRating] = useState$x(null);
  const [myRating, setMyRating] = useState$x(0);
  const [myComment, setMyComment] = useState$x("");
  const [submittingReview, setSubmittingReview] = useState$x(false);
  const [vendors, setVendors] = useState$x([]);
  const [dispensaries, setDispensaries] = useState$x([]);
  const [loadingVendors, setLoadingVendors] = useState$x(false);
  const [loadingDispensaries, setLoadingDispensaries] = useState$x(false);
  const [userLocation, setUserLocation] = useState$x(null);
  const fileInputRef = useRef$4(null);
  const { user: authUser } = useAuth();
  const currentUserId = (authUser == null ? void 0 : authUser.id) || null;
  const getSessionId = () => {
    let sid = localStorage.getItem("ss-session-id");
    if (!sid) {
      sid = `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      localStorage.setItem("ss-session-id", sid);
    }
    return sid;
  };
  useEffect$s(() => {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (position2) => {
          console.log("[Scanner] Location obtained successfully");
          setUserLocation({
            lat: position2.coords.latitude,
            lng: position2.coords.longitude
          });
        },
        (error2) => {
          console.log("[Scanner] Geolocation not available:", error2.message);
          setUserLocation({ lat: 37.7749, lng: -122.4194 });
        },
        {
          timeout: 5e3,
          maximumAge: 3e5,
          // 5 min cache
          enableHighAccuracy: false
        }
      );
    } else {
      console.log("[Scanner] Geolocation not supported");
      setUserLocation({ lat: 37.7749, lng: -122.4194 });
    }
  }, []);
  const fetchVendorsForStrain = (strainName) => __async(null, null, function* () {
    setLoadingVendors(true);
    try {
      const response = yield fetch(`${API_BASE}/api/seeds-live?strain=${encodeURIComponent(strainName)}&limit=20`);
      const data = yield response.json();
      const transformedVendors = (data.results || []).map((vendor) => ({
        name: vendor.name,
        website: vendor.website,
        country: vendor.country,
        rating: vendor.rating || 0,
        verified: vendor.verified || false,
        price: vendor.price || "N/A",
        seed_count: vendor.seed_count || 10,
        in_stock: vendor.in_stock !== false
      }));
      setVendors(transformedVendors);
    } catch (error2) {
      console.error("[Scanner] Error fetching vendors:", error2);
      setVendors([]);
    } finally {
      setLoadingVendors(false);
    }
  });
  const fetchDispensariesForStrain = () => __async(null, null, function* () {
    if (!userLocation) {
      setDispensaries([]);
      return;
    }
    setLoadingDispensaries(true);
    try {
      const response = yield fetch(
        `${API_BASE}/api/dispensaries-live?lat=${userLocation.lat}&lng=${userLocation.lng}&radius=100&limit=20`
      );
      const data = yield response.json();
      setDispensaries(data.results || []);
    } catch (error2) {
      console.error("[Scanner] Error fetching dispensaries:", error2);
      setDispensaries([]);
    } finally {
      setLoadingDispensaries(false);
    }
  });
  const handleImageCapture = (event) => __async(null, null, function* () {
    console.log("[Scanner] handleImageCapture called");
    const files = Array.from(event.target.files || []);
    console.log("[Scanner] Files selected:", files.length);
    if (!files.length) return;
    try {
      const nextImages = [...images, ...files].slice(0, 3);
      console.log("[Scanner] Processing images:", nextImages.length);
      const newPreviews = yield Promise.all(
        files.map((file, idx) => new Promise((resolve, reject) => {
          console.log(`[Scanner] Reading file ${idx + 1}:`, file.name, file.type, file.size);
          const reader = new FileReader();
          reader.onload = (e) => {
            console.log(`[Scanner] File ${idx + 1} loaded successfully`);
            resolve(e.target.result);
          };
          reader.onerror = (e) => {
            console.error(`[Scanner] Failed to read file ${idx + 1}:`, e);
            reject(new Error(`Failed to read image file ${idx + 1}`));
          };
          reader.readAsDataURL(file);
        }))
      );
      const nextPreviews = [...imagePreviews, ...newPreviews].slice(0, 3);
      console.log("[Scanner] All files converted to data URLs");
      setImages(nextImages);
      setImagePreviews(nextPreviews);
      setError(null);
      console.log("[Scanner] Image capture complete");
    } catch (err) {
      console.error("[Scanner] Error loading image:", err);
      console.error("[Scanner] Error stack:", err.stack);
      setError(`Failed to load image: ${err.message}. Please try again with a different photo.`);
      alert(`Image Load Error:
${err.message}`);
    }
  });
  const findMatchingStrain = (visionResult) => __async(null, null, function* () {
    if (!visionResult) return null;
    try {
      const matchResponse = yield fetch(`${API_BASE}/api/visual-match`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ visionResult })
      });
      if (!matchResponse.ok) {
        return null;
      }
      const matchData = yield matchResponse.json();
      if (matchData.matches && matchData.matches.length > 0) {
        const topMatch = matchData.matches[0];
        return __spreadProps(__spreadValues({}, topMatch.strain), {
          matchScore: topMatch.score,
          matchConfidence: topMatch.confidence,
          matchReasoning: topMatch.reasoning,
          allMatches: matchData.matches.slice(0, 5)
        });
      }
      return null;
    } catch (err) {
      console.error("[Scanner] Error in visual matching:", err);
      return null;
    }
  });
  const MAX_UPLOAD_BYTES = 3.3 * 1024 * 1024;
  const canUseEdgeUploads = typeof FUNCTIONS_BASE === "string" && FUNCTIONS_BASE.length > 0 && FUNCTIONS_BASE !== `${API_BASE}/api`;
  const uploadViaEdgeFunction = (_0) => __async(null, [_0], function* ({ base64, filename, contentType }) {
    if (!canUseEdgeUploads || !base64) return null;
    try {
      const headers = { "Content-Type": "application/json" };
      if (SUPABASE_ANON_KEY) {
        headers.Authorization = `Bearer ${SUPABASE_ANON_KEY}`;
        headers.apikey = SUPABASE_ANON_KEY;
      }
      const resp = yield fetch(`${FUNCTIONS_BASE}/uploads`, {
        method: "POST",
        headers,
        body: JSON.stringify({ filename, base64, contentType, user_id: currentUserId })
      });
      if (!resp.ok) {
        const text = yield resp.text().catch(() => "");
        console.warn("[Scanner] Edge upload failed:", resp.status, text);
        return null;
      }
      const data = yield resp.json();
      if (data == null ? void 0 : data.id) {
        return data;
      }
    } catch (err) {
      console.warn("[Scanner] Edge upload exception:", err);
    }
    return null;
  });
  const compressImageToBlob = (file, targetBytes = Infinity, initialMaxDim = 2048, initialQuality = 0.92) => __async(null, null, function* () {
    let workingFile = file;
    let maxDim = initialMaxDim;
    let quality = initialQuality;
    let lastBlob = null;
    for (let attempt = 0; attempt < 6; attempt++) {
      lastBlob = yield new Promise((resolve, reject) => {
        const img = new Image();
        const url = URL.createObjectURL(workingFile);
        img.onload = () => {
          const canvas = document.createElement("canvas");
          let { width: width2, height: height2 } = img;
          if (width2 > height2) {
            if (width2 > maxDim) {
              height2 = Math.round(height2 * maxDim / width2);
              width2 = maxDim;
            }
          } else if (height2 > maxDim) {
            width2 = Math.round(width2 * maxDim / height2);
            height2 = maxDim;
          }
          canvas.width = width2;
          canvas.height = height2;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0, width2, height2);
          canvas.toBlob(
            (blob) => {
              URL.revokeObjectURL(url);
              if (blob) {
                resolve(blob);
              } else {
                reject(new Error("Failed to compress image"));
              }
            },
            "image/jpeg",
            quality
          );
        };
        img.onerror = (e) => {
          URL.revokeObjectURL(url);
          reject(e);
        };
        img.src = url;
      });
      const sizeMb = (lastBlob.size / (1024 * 1024)).toFixed(2);
      console.log(
        `[Scanner] Compression attempt ${attempt + 1}: ${sizeMb} MB @ q=${quality.toFixed(2)} maxDim=${maxDim}`
      );
      if (lastBlob.size <= targetBytes) {
        break;
      }
      if (quality > 0.5) {
        quality = Math.max(0.5, quality - 0.1);
      } else {
        maxDim = Math.max(720, Math.floor(maxDim * 0.8));
      }
      workingFile = new File([lastBlob], workingFile.name || file.name || "upload.jpg", {
        type: "image/jpeg"
      });
    }
    return lastBlob != null ? lastBlob : file;
  });
  const blobToBase64 = (blob) => __async(null, null, function* () {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(String(reader.result).split(",")[1]);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  });
  const parseErrorResponse = (res) => __async(null, null, function* () {
    try {
      const data = yield res.json();
      const base = (data == null ? void 0 : data.error) || `HTTP ${res.status}`;
      const hint = (data == null ? void 0 : data.hint) ? ` Hint: ${data.hint}` : "";
      return `${base}${hint}`;
    } catch (e) {
      try {
        const text = yield res.text();
        return text || `HTTP ${res.status}`;
      } catch (e2) {
        return `HTTP ${res.status}`;
      }
    }
  });
  const handleScan = () => __async(null, null, function* () {
    var _a2, _b, _c, _d, _e;
    if (images.length === 0) {
      setError("Please select an image first");
      return;
    }
    if (!currentUserId) {
      setError("Sign in to use AI scans. Join or log in to continue.");
      setShowResult(false);
      return;
    }
    setLoading(true);
    setLoadingStatus("Preparing images...");
    setError(null);
    try {
      const processOne = (file, index2) => __async(null, null, function* () {
        var _a3, _b2, _c2;
        setLoadingStatus(`Preparing image ${index2 + 1} of ${images.length}...`);
        const compressedBlob = yield compressImageToBlob(file, 12 * 1024 * 1024);
        const sessionId = currentUserId || getSessionId();
        const safeFileName = String(file.name || "upload.jpg");
        let useLegacyUploader = false;
        let signedData = null;
        if (supabase && typeof ((_a3 = supabase.storage) == null ? void 0 : _a3.from) === "function") {
          const preflightUrl = `${API_BASE}/api/uploads/signed-url`;
          console.log("[Scanner] Requesting signed URL from:", preflightUrl);
          const preflight = yield fetch(preflightUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json", "x-session-id": sessionId },
            credentials: "include",
            body: JSON.stringify({
              filename: safeFileName,
              contentType: compressedBlob.type || "image/jpeg",
              user_id: currentUserId || null
            })
          });
          console.log("[Scanner] Preflight response:", preflight.status, preflight.statusText);
          if (preflight.status === 501) {
            useLegacyUploader = true;
          } else if (!preflight.ok) {
            const msg = yield parseErrorResponse(preflight);
            throw new Error(`Upload prep failed: ${msg}`);
          } else {
            signedData = yield preflight.json();
            if (!(signedData == null ? void 0 : signedData.bucket) || !(signedData == null ? void 0 : signedData.path) || !(signedData == null ? void 0 : signedData.token)) {
              console.warn("[Scanner] Signed upload data incomplete, falling back to legacy uploader");
              useLegacyUploader = true;
            }
          }
        } else {
          useLegacyUploader = true;
        }
        let scanId = null;
        if (!useLegacyUploader && signedData) {
          setLoadingStatus(`Uploading image ${index2 + 1} of ${images.length}...`);
          const uploadResult = yield supabase.storage.from(signedData.bucket).uploadToSignedUrl(signedData.path, signedData.token, compressedBlob, {
            contentType: compressedBlob.type || "image/jpeg"
          });
          if (uploadResult.error) {
            console.error("[Scanner] Signed upload failed:", uploadResult.error);
            throw new Error(`Cloud upload failed: ${uploadResult.error.message}`);
          }
          const finalizeResponse = yield fetch(`${API_BASE}/api/uploads/complete`, {
            method: "POST",
            headers: { "Content-Type": "application/json", "x-session-id": sessionId },
            credentials: "include",
            body: JSON.stringify({
              path: signedData.path,
              bucket: signedData.bucket,
              user_id: currentUserId || null
            })
          });
          if (!finalizeResponse.ok) {
            const msg = yield parseErrorResponse(finalizeResponse);
            throw new Error(`Upload finalize failed: ${msg}`);
          }
          const finalizeData = yield finalizeResponse.json();
          scanId = finalizeData.id;
          console.log("[Scanner] Signed upload complete, scan ID:", scanId);
        } else {
          let legacyBlob = compressedBlob;
          let approxBytes = legacyBlob.size * (4 / 3);
          let tightenAttempts = 0;
          while (approxBytes > MAX_UPLOAD_BYTES && tightenAttempts < 6) {
            legacyBlob = yield compressImageToBlob(
              new File([legacyBlob], safeFileName, { type: "image/jpeg" }),
              MAX_UPLOAD_BYTES * 0.55,
              Math.max(640, Math.floor(1600 / (tightenAttempts + 1))),
              Math.max(0.45, 0.85 - tightenAttempts * 0.1)
            );
            approxBytes = legacyBlob.size * (4 / 3);
            tightenAttempts += 1;
          }
          if (approxBytes > MAX_UPLOAD_BYTES) {
            throw new Error(
              "Image is still too large after automatic compression. Please retake the photo a little closer so we can process it."
            );
          }
          const legacyBase64 = yield blobToBase64(legacyBlob);
          let edgeResult = null;
          if (canUseEdgeUploads) {
            setLoadingStatus(`Uploading image ${index2 + 1} of ${images.length} to Supabase...`);
            edgeResult = yield uploadViaEdgeFunction({
              base64: legacyBase64,
              filename: safeFileName,
              contentType: legacyBlob.type || file.type || "image/jpeg"
            });
          }
          if (edgeResult == null ? void 0 : edgeResult.id) {
            scanId = edgeResult.id;
            console.log("[Scanner] Uploaded via Supabase Edge function, scan ID:", scanId);
          } else {
            setLoadingStatus(`Uploading image ${index2 + 1} of ${images.length}...`);
            const uploadResponse = yield fetch(`${API_BASE}/api/uploads`, {
              method: "POST",
              headers: { "Content-Type": "application/json", "x-session-id": sessionId },
              credentials: "include",
              body: JSON.stringify({
                filename: safeFileName,
                contentType: legacyBlob.type || file.type || "image/jpeg",
                base64: legacyBase64,
                user_id: currentUserId || null
              })
            });
            if (!uploadResponse.ok) {
              const msg = yield parseErrorResponse(uploadResponse);
              console.error("[Scanner] Upload failed:", msg);
              throw new Error(`Upload failed: ${msg}`);
            }
            const uploadData = yield uploadResponse.json();
            scanId = uploadData.id;
            console.log("[Scanner] Uploaded via legacy path (compressed), scan ID:", scanId);
          }
        }
        setLoadingStatus(`Analyzing image ${index2 + 1} with AI (this may take 30-60 seconds)...`);
        try {
          console.log("[Scanner] Processing via:", `${API_BASE}/api/scans/${scanId}/process`);
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 6e4);
          const processResponse = yield fetch(`${API_BASE}/api/scans/${scanId}/process`, {
            method: "POST",
            headers: { "Content-Type": "application/json", "x-session-id": getSessionId() },
            credentials: "include",
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          if (processResponse.ok) {
            const processData = yield processResponse.json();
            console.log("[Scanner] Process succeeded:", processData);
            const payload = (_c2 = (_b2 = processData == null ? void 0 : processData.result) != null ? _b2 : processData) != null ? _c2 : {};
            if (payload && !payload.id) {
              payload.id = scanId;
            }
            return payload;
          } else {
            const errText = yield processResponse.text();
            console.error("[Scanner] Process failed:", errText);
            throw new Error(`Processing failed: ${errText || processResponse.status}`);
          }
        } catch (e) {
          if (e.name === "AbortError") {
            console.error("[Scanner] Process timeout - AI analysis took too long");
            throw new Error("AI analysis timed out after 60 seconds. Please try again with a clearer image or check your connection.");
          }
          console.error("[Scanner] Process error:", e);
          throw new Error(`AI processing failed: ${e.message}`);
        }
      });
      const results = [];
      let lastId = null;
      for (let i = 0; i < images.length; i++) {
        const r2 = yield processOne(images[i], i);
        if (r2 == null ? void 0 : r2.id) lastId = r2.id;
        results.push((r2 == null ? void 0 : r2.result) || r2);
      }
      if (lastId) setLastScanId(lastId);
      setLoadingStatus("Matching results to strain database...");
      const firstText = ((_c = (_b = (_a2 = results[0]) == null ? void 0 : _a2.textAnnotations) == null ? void 0 : _b[0]) == null ? void 0 : _c.description) || "";
      setDetectedTextPreview(firstText.substring(0, 200));
      const merged = mergeVisionResults(results);
      const matchResult = yield findMatchingStrain(merged);
      if (matchResult) {
        setMatchedStrain(matchResult);
        if (matchResult.allMatches && matchResult.allMatches.length > 1) {
          setSuggestedStrains(matchResult.allMatches.slice(1).map((m) => m.strain));
        } else {
          setSuggestedStrains([]);
        }
        if (matchResult.name) {
          fetchVendorsForStrain(matchResult.name);
          fetchDispensariesForStrain();
        }
        if (lastId && matchResult.slug) {
          try {
            console.log("[Scanner] Saving match:", lastId, matchResult.slug);
            const saveResponse = yield fetch(`${API_BASE}/api/scans/${lastId}/save-match`, {
              method: "POST",
              headers: { "Content-Type": "application/json", "x-session-id": getSessionId() },
              credentials: "include",
              body: JSON.stringify({ matched_strain_slug: matchResult.slug, user_id: currentUserId || null })
            });
            if (saveResponse.ok) {
              console.log("[Scanner] Match saved successfully");
            } else {
              console.error("[Scanner] Failed to save match:", yield saveResponse.text());
            }
          } catch (e) {
            console.error("[Scanner] Failed to save match:", e);
          }
        } else {
          console.warn("[Scanner] Cannot save match - missing lastId or slug:", { lastId, slug: matchResult.slug });
        }
      } else {
        const detectedText = ((_e = (_d = merged == null ? void 0 : merged.textAnnotations) == null ? void 0 : _d[0]) == null ? void 0 : _e.description) || firstText || "";
        const cleanText = detectedText.replace(/\n/g, " ").replace(/[^\w\s'-]/g, " ").trim();
        const words = cleanText.split(/\s+/).filter((w) => w.length > 3);
        const topWord = words[0] || "";
        if (topWord) {
          try {
            const suggestResponse = yield fetch(`${API_BASE}/api/search?q=${encodeURIComponent(topWord)}&limit=5`, {
              headers: { "x-session-id": getSessionId() },
              credentials: "include"
            });
            const suggestions = yield suggestResponse.json();
            setSuggestedStrains(Array.isArray(suggestions) ? suggestions : []);
          } catch (e) {
            console.error("Failed to fetch suggestions:", e);
          }
        }
        const preview = detectedText ? detectedText.substring(0, 100) : "(no text detected)";
        setError(
          `No exact match found. Detected text: "${preview}${detectedText.length > 100 ? "..." : ""}". ${suggestedStrains.length > 0 ? "Check suggested strains below or " : ""}Try a clearer image with the strain name visible.`
        );
      }
      setShowResult(true);
    } catch (err) {
      console.error("[Scanner] Scan error:", err);
      console.error("[Scanner] Error stack:", err.stack);
      console.error("[Scanner] Error details:", JSON.stringify(err, Object.getOwnPropertyNames(err)));
      const errorMsg = err.message || "Scan failed. Please try again.";
      setError(`Scan failed: ${errorMsg}`);
      alert(`Scan Error:
${errorMsg}

Check console for details.`);
    } finally {
      setLoading(false);
    }
  });
  const handleReset = () => {
    imagePreviews.forEach((u) => URL.revokeObjectURL(u));
    setImages([]);
    setImagePreviews([]);
    setMatchedStrain(null);
    setSuggestedStrains([]);
    setDetectedTextPreview("");
    setShowResult(false);
    setError(null);
    setLastScanId(null);
    setVendors([]);
    setDispensaries([]);
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };
  function mergeVisionResults(results) {
    var _a2, _b, _c;
    if (!Array.isArray(results) || results.length === 0) return {};
    const out = { labelAnnotations: [], webDetection: { webEntities: [] }, textAnnotations: [] };
    const labelMap = /* @__PURE__ */ new Map();
    for (const r2 of results) {
      for (const l of (r2 == null ? void 0 : r2.labelAnnotations) || []) {
        const key = (l.description || "").toLowerCase();
        if (!key) continue;
        const prev2 = labelMap.get(key) || { description: l.description, scoreSum: 0, count: 0 };
        prev2.scoreSum += l.score || 0;
        prev2.count += 1;
        labelMap.set(key, prev2);
      }
    }
    out.labelAnnotations = Array.from(labelMap.values()).map((v) => ({ description: v.description, score: Math.min(1, v.scoreSum / v.count * (1 + 0.15 * (v.count - 1))) })).sort((a, b) => (b.score || 0) - (a.score || 0));
    const webMap = /* @__PURE__ */ new Map();
    for (const r2 of results) {
      for (const w of ((_a2 = r2 == null ? void 0 : r2.webDetection) == null ? void 0 : _a2.webEntities) || []) {
        const key = (w.description || "").toLowerCase();
        if (!key) continue;
        const prev2 = webMap.get(key) || { description: w.description, scoreSum: 0, count: 0 };
        prev2.scoreSum += w.score || 0;
        prev2.count += 1;
        webMap.set(key, prev2);
      }
    }
    out.webDetection.webEntities = Array.from(webMap.values()).map((v) => ({ description: v.description, score: Math.min(1, v.scoreSum / v.count * (1 + 0.15 * (v.count - 1))) })).sort((a, b) => (b.score || 0) - (a.score || 0));
    const textSet = /* @__PURE__ */ new Set();
    for (const r2 of results) {
      const t = (_c = (_b = r2 == null ? void 0 : r2.textAnnotations) == null ? void 0 : _b[0]) == null ? void 0 : _c.description;
      if (t) textSet.add(t);
    }
    if (textSet.size > 0) {
      const combined = Array.from(textSet).join("\n");
      out.textAnnotations = [{ description: combined }];
    }
    return __spreadValues(__spreadValues({}, results[0]), out);
  }
  const TipsContent = () => /* @__PURE__ */ React.createElement(Stack, { spacing: 1.2, sx: { mt: 1 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", color: "primary.light" }, "Pro tips for best results"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, " Frame the whole bud (cola), not extreme macro of sugar leaves."), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, " Use even, diffused lighting. Avoid harsh glare or deep shadows."), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, " Neutral, uncluttered background. Hold steady to avoid blur."), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, " Take 23 angles of the same bud (top and side) for richer features."), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, " If you have packaging, include the label or strain name when possible."), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, " Avoid filters/heavy compression; high-res, natural color is best."));
  const handleSelectSuggestion = (slug) => __async(null, null, function* () {
    try {
      const response = yield fetch(`${API_BASE}/api/strains/${slug}`);
      if (response.ok) {
        const strain = yield response.json();
        setMatchedStrain(strain);
        setSuggestedStrains([]);
        setError(null);
        if (strain.name) {
          fetchVendorsForStrain(strain.name);
          fetchDispensariesForStrain();
        }
        if (lastScanId && slug) {
          try {
            yield fetch(`${API_BASE}/api/scans/${lastScanId}/save-match`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ matched_strain_slug: slug, user_id: currentUserId })
            });
          } catch (e) {
            console.error("Failed to save suggestion selection:", e);
          }
        }
      }
    } catch (e) {
      console.error("Failed to load suggested strain:", e);
    }
  });
  useEffect$s(() => {
    const load = () => __async(null, null, function* () {
      if (!(matchedStrain == null ? void 0 : matchedStrain.slug)) {
        setReviews([]);
        setAvgRating(null);
        return;
      }
      try {
        const resp = yield fetch(`${API_BASE}/api/reviews?strain_slug=${encodeURIComponent(matchedStrain.slug)}`);
        if (!resp.ok) return;
        const data = yield resp.json();
        setReviews(Array.isArray(data) ? data : []);
        if (Array.isArray(data) && data.length) {
          const avg = data.reduce((s, r2) => s + (r2.rating || 0), 0) / data.length;
          setAvgRating(Math.round(avg * 10) / 10);
        } else {
          setAvgRating(null);
        }
      } catch (e) {
        console.debug("[Scanner] load reviews failed", e);
      }
    });
    load();
  }, [matchedStrain == null ? void 0 : matchedStrain.slug]);
  const submitReview = () => __async(null, null, function* () {
    if (!currentUserId) {
      alert("Please sign in to leave a review.");
      return;
    }
    if (!(matchedStrain == null ? void 0 : matchedStrain.slug)) return;
    if (!(myRating >= 1 && myRating <= 5)) {
      alert("Please select a rating from 1 to 5 stars.");
      return;
    }
    setSubmittingReview(true);
    try {
      const resp = yield fetch(`${API_BASE}/api/reviews`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          user_id: currentUserId,
          strain_slug: matchedStrain.slug,
          rating: myRating,
          comment: (myComment == null ? void 0 : myComment.trim()) || null
        })
      });
      if (!resp.ok) {
        const txt = yield resp.text();
        alert(`Failed to submit review: ${txt}`);
        return;
      }
      setMyComment("");
      const data = yield fetch(`${API_BASE}/api/reviews?strain_slug=${encodeURIComponent(matchedStrain.slug)}`).then((r2) => r2.json()).catch(() => []);
      setReviews(Array.isArray(data) ? data : []);
      if (Array.isArray(data) && data.length) {
        const avg = data.reduce((s, r2) => s + (r2.rating || 0), 0) / data.length;
        setAvgRating(Math.round(avg * 10) / 10);
      } else {
        setAvgRating(null);
      }
    } catch (e) {
      console.error("Submit review failed", e);
      alert("Submit failed. Please try again.");
    } finally {
      setSubmittingReview(false);
    }
  });
  return /* @__PURE__ */ React.createElement(Box, { sx: { minHeight: "100vh", paddingTop: "300px" } }, /* @__PURE__ */ React.createElement(Container, { maxWidth: "sm", sx: { pb: 2, px: 2 } }, onBack && /* @__PURE__ */ React.createElement(Box, { sx: { mb: 2 } }, /* @__PURE__ */ React.createElement(
    Button,
    {
      onClick: onBack,
      size: "large",
      variant: "contained",
      fullWidth: true,
      sx: {
        bgcolor: "#7cb342",
        color: "white",
        textTransform: "none",
        fontWeight: 700,
        borderRadius: 2,
        py: 1.5,
        fontSize: "1.1rem",
        boxShadow: "0 4px 12px rgba(124, 179, 66, 0.4)",
        "&:hover": { bgcolor: "#689f38" }
      }
    },
    " Back to Home"
  )), /* @__PURE__ */ React.createElement(
    Card,
    {
      sx: {
        mb: 2,
        overflow: "hidden",
        border: "1.5px solid #4caf50",
        bgcolor: "rgba(0,0,0,0.7)",
        backdropFilter: "blur(10px)"
      }
    },
    /* @__PURE__ */ React.createElement(CardContent, { sx: { p: 2, background: "linear-gradient(135deg, #2d5a2d 0%, #1f3a1f 100%)" } }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 1, sx: { mb: 1 } }, /* @__PURE__ */ React.createElement(CannabisLeafIcon, null), /* @__PURE__ */ React.createElement(Typography, { variant: "h6", fontWeight: "bold", color: "primary.light" }, "Identify Your Strain")), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", color: "text.secondary", sx: { display: "block", mb: 1 } }, "Snap a photo and let AI identify the strain."), /* @__PURE__ */ React.createElement(Alert, { severity: "info", icon: false, sx: { py: 0.5, px: 1, bgcolor: "rgba(76, 175, 80, 0.1)" } }, /* @__PURE__ */ React.createElement(Typography, { variant: "caption", fontWeight: "bold", color: "primary.light", sx: { fontSize: "0.7rem" } }, "How It Works:"), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", display: "block", color: "text.secondary", sx: { mt: 0.25, fontSize: "0.65rem" } }, "Our AI analyzes visual characteristics (colors, structure, labels, text) and matches them against 35,000+ strains. For best results, photograph buds in good lighting or include product labels with strain names."), /* @__PURE__ */ React.createElement(Button, { size: "small", variant: "outlined", sx: { mt: 1 }, onClick: () => setShowTips(true) }, "Photo Tips")))
  ), !currentUserId && /* @__PURE__ */ React.createElement(Alert, { severity: "warning", sx: { mb: 3 } }, "Sign in to use AI scans. Uploads require an account so we can track your starter credits."), error && /* @__PURE__ */ React.createElement(Alert, { severity: "error", sx: { mb: 3 }, onClose: () => setError(null) }, error), imagePreviews.length > 0 && /* @__PURE__ */ React.createElement(Card, { sx: { mb: 3, p: 1, position: "relative" } }, /* @__PURE__ */ React.createElement(Grid, { container: true, spacing: 1 }, imagePreviews.map((src, idx) => /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, sm: imagePreviews.length > 1 ? 6 : 12, key: idx, sx: { position: "relative" } }, /* @__PURE__ */ React.createElement(Box, { sx: { position: "relative" } }, /* @__PURE__ */ React.createElement(
    Box,
    {
      component: "img",
      src,
      alt: `Preview ${idx + 1}`,
      onError: (e) => {
        console.error("[Scanner] Image preview failed to load:", e);
        setError("Failed to display image preview. Please try a different photo.");
      },
      sx: { width: "100%", maxHeight: 320, objectFit: "cover", bgcolor: "rgba(0,0,0,0)", borderRadius: 1 }
    }
  ), showGuide && /* @__PURE__ */ React.createElement(
    Box,
    {
      sx: {
        position: "absolute",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        pointerEvents: "none",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      }
    },
    /* @__PURE__ */ React.createElement(
      Box,
      {
        sx: {
          border: "3px dashed #ffeb3b",
          borderRadius: "50%",
          width: "70%",
          height: "70%",
          opacity: 0.5,
          boxShadow: "0 0 0 2px #4caf50",
          background: "rgba(255,255,0,0.07)",
          zIndex: 2
        }
      }
    ),
    /* @__PURE__ */ React.createElement(
      Typography,
      {
        variant: "caption",
        sx: {
          position: "absolute",
          bottom: 8,
          left: "50%",
          transform: "translateX(-50%)",
          color: "#ffeb3b",
          bgcolor: "rgba(44,44,44,0.7)",
          px: 1.5,
          py: 0.5,
          borderRadius: 1,
          fontWeight: "bold",
          zIndex: 3
        }
      },
      "Frame the whole bud inside the circle"
    )
  ))))), /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "text",
      size: "small",
      sx: { mt: 1, color: showGuide ? "warning.main" : "primary.light" },
      onClick: () => setShowGuide((v) => !v)
    },
    showGuide ? "Hide Framing Guide" : "Show Framing Guide"
  )), /* @__PURE__ */ React.createElement(Stack, { spacing: 2, sx: { mt: imagePreviews.length === 0 ? "120px" : 0 } }, /* @__PURE__ */ React.createElement(
    "input",
    {
      ref: fileInputRef,
      type: "file",
      accept: "image/*",
      multiple: true,
      style: { display: "none" },
      onChange: handleImageCapture
    }
  ), imagePreviews.length === 0 ? /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "contained",
      size: "large",
      fullWidth: true,
      startIcon: /* @__PURE__ */ React.createElement(CameraAltIcon, null),
      onClick: () => {
        var _a2;
        return (_a2 = fileInputRef.current) == null ? void 0 : _a2.click();
      },
      sx: {
        py: 3,
        fontSize: "1.2rem",
        background: "linear-gradient(45deg, #4caf50 30%, #66bb6a 90%)",
        "&:hover": {
          background: "linear-gradient(45deg, #388e3c 30%, #4caf50 90%)"
        }
      }
    },
    " Take or Upload Photo"
  ) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "contained",
      size: "medium",
      fullWidth: true,
      onClick: handleScan,
      disabled: loading || !currentUserId,
      sx: {
        py: 1.5,
        fontSize: "0.9rem",
        background: "linear-gradient(45deg, #4caf50 30%, #66bb6a 90%)"
      }
    },
    loading ? /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1, alignItems: "center" }, /* @__PURE__ */ React.createElement(CircularProgress, { size: 20, color: "inherit" }), /* @__PURE__ */ React.createElement(Box, { component: "span", sx: { fontSize: "0.85rem" } }, loadingStatus || "Processing...")) : " Scan & Identify"
  ), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1 }, /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "text",
      size: "small",
      fullWidth: true,
      onClick: () => {
        var _a2;
        return (_a2 = fileInputRef.current) == null ? void 0 : _a2.click();
      },
      disabled: loading,
      sx: { color: "primary.light", fontSize: "0.8rem" }
    },
    "Add Photo"
  ), /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "outlined",
      size: "small",
      fullWidth: true,
      onClick: handleReset,
      disabled: loading,
      sx: { borderColor: "#4caf50", color: "#4caf50", fontSize: "0.8rem" }
    },
    "Reset"
  )))), imagePreviews.length === 0 && /* @__PURE__ */ React.createElement(Card, { sx: { mt: 2, bgcolor: "background.paper" } }, /* @__PURE__ */ React.createElement(CardContent, { sx: { p: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", gutterBottom: true, color: "primary.light", sx: { fontSize: "0.875rem" } }, " How It Works"), /* @__PURE__ */ React.createElement(Stack, { spacing: 1 }, /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "caption", fontWeight: "bold", color: "text.primary", sx: { fontSize: "0.75rem" } }, "1. Capture  2. AI Analysis  3. Match"), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", color: "text.secondary", sx: { display: "block", fontSize: "0.7rem", mt: 0.5 } }, "Photo  AI analyzes colors, structure, text  Matches against 35K+ strains"))), /* @__PURE__ */ React.createElement(Alert, { severity: "warning", sx: { mt: 1, py: 0.5, px: 1 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { fontSize: "0.65rem" } }, /* @__PURE__ */ React.createElement("strong", null, "Tip:"), " Images with visible strain names/labels produce best results."))))), /* @__PURE__ */ React.createElement(
    Dialog,
    {
      open: showResult,
      onClose: () => setShowResult(false),
      maxWidth: "sm",
      fullWidth: true,
      PaperProps: {
        sx: {
          background: "linear-gradient(135deg, #2c2c2c 0%, #1f3a1f 100%)",
          border: "2px solid #4caf50"
        }
      }
    },
    /* @__PURE__ */ React.createElement(DialogTitle, { sx: { borderBottom: "1px solid #4caf50" } }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", justifyContent: "space-between" }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1, alignItems: "center" }, /* @__PURE__ */ React.createElement(CannabisLeafIcon, null), /* @__PURE__ */ React.createElement(Typography, { variant: "h5", fontWeight: "bold", color: "primary.light" }, "Strain Identified")), /* @__PURE__ */ React.createElement(IconButton, { onClick: () => setShowResult(false), sx: { color: "#4caf50" } }, /* @__PURE__ */ React.createElement(CloseIcon, null)))),
    /* @__PURE__ */ React.createElement(DialogContent, { sx: { pt: 3 } }, detectedTextPreview && !matchedStrain && /* @__PURE__ */ React.createElement(Alert, { severity: "info", sx: { mb: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { fontWeight: "bold" } }, "Detected Text:"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { fontStyle: "italic", mt: 0.5 } }, '"', detectedTextPreview, detectedTextPreview.length >= 200 ? "..." : "", '"')), matchedStrain ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Alert, { severity: "success", icon: /* @__PURE__ */ React.createElement(CheckCircleIcon, null), sx: { mb: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", fontWeight: "bold" }, " Scan saved to your history!")), imagePreviews[0] && /* @__PURE__ */ React.createElement(Box, { sx: { mb: 2, textAlign: "center" } }, /* @__PURE__ */ React.createElement(
      "img",
      {
        src: imagePreviews[0],
        alt: "Scanned",
        style: {
          maxWidth: "100%",
          maxHeight: 200,
          borderRadius: 8,
          objectFit: "contain",
          border: "2px solid #4caf50"
        }
      }
    )), /* @__PURE__ */ React.createElement(Typography, { variant: "h4", gutterBottom: true, fontWeight: "bold", color: "primary.main" }, matchedStrain.name), matchedStrain.matchConfidence && /* @__PURE__ */ React.createElement(
      Alert,
      {
        severity: matchedStrain.matchConfidence >= 70 ? "success" : matchedStrain.matchConfidence >= 50 ? "info" : "warning",
        sx: { mb: 2 }
      },
      /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 1 }, /* @__PURE__ */ React.createElement(Typography, { variant: "body1", fontWeight: "bold" }, matchedStrain.matchConfidence, "% Confidence Match")),
      matchedStrain.matchReasoning && /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { display: "block", mt: 0.5 } }, matchedStrain.matchReasoning),
      matchedStrain.matchConfidence < 40 && /* @__PURE__ */ React.createElement(Stack, { spacing: 1, sx: { mt: 1 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "caption", color: "text.secondary" }, "Confidence is low. Try retaking the photo with these tips:"), /* @__PURE__ */ React.createElement(TipsContent, null), /* @__PURE__ */ React.createElement(Button, { size: "small", variant: "outlined", onClick: () => setShowTips(true) }, "Open Photo Tips"))
    ), matchedStrain.type && /* @__PURE__ */ React.createElement(
      Chip,
      {
        label: matchedStrain.type,
        size: "large",
        sx: {
          mb: 2,
          bgcolor: matchedStrain.type === "Indica" ? "#7b1fa2" : matchedStrain.type === "Sativa" ? "#f57c00" : "#00897b",
          color: "white",
          fontWeight: "bold",
          fontSize: "1rem"
        }
      }
    ), matchedStrain.description && /* @__PURE__ */ React.createElement(Typography, { variant: "body1", paragraph: true, color: "text.primary", sx: { my: 2 } }, matchedStrain.description), /* @__PURE__ */ React.createElement(Divider, { sx: { my: 2, bgcolor: "rgba(76, 175, 80, 0.3)" } }), /* @__PURE__ */ React.createElement(Grid, { container: true, spacing: 2, sx: { mb: 2 } }, matchedStrain.thc !== null && matchedStrain.thc > 0 && /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 6 }, /* @__PURE__ */ React.createElement(Card, { sx: { bgcolor: "rgba(76, 175, 80, 0.1)", border: "1px solid #4caf50" } }, /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Typography, { variant: "caption", color: "text.secondary" }, "THC Content"), /* @__PURE__ */ React.createElement(Typography, { variant: "h4", fontWeight: "bold", color: "primary.main" }, matchedStrain.thc, "%")))), matchedStrain.cbd !== null && matchedStrain.cbd > 0 && /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 6 }, /* @__PURE__ */ React.createElement(Card, { sx: { bgcolor: "rgba(76, 175, 80, 0.1)", border: "1px solid #4caf50" } }, /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Typography, { variant: "caption", color: "text.secondary" }, "CBD Content"), /* @__PURE__ */ React.createElement(Typography, { variant: "h4", fontWeight: "bold", color: "primary.main" }, matchedStrain.cbd, "%"))))), matchedStrain.effects && matchedStrain.effects.length > 0 && /* @__PURE__ */ React.createElement(Box, { sx: { mb: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", gutterBottom: true, color: "primary.light" }, "Effects"), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1, flexWrap: "wrap", useFlexGap: true }, matchedStrain.effects.map((effect2, idx) => /* @__PURE__ */ React.createElement(
      Chip,
      {
        key: idx,
        label: effect2,
        sx: {
          bgcolor: "rgba(139, 195, 74, 0.2)",
          color: "#8bc34a",
          border: "1px solid #8bc34a"
        }
      }
    )))), matchedStrain.flavors && matchedStrain.flavors.length > 0 && /* @__PURE__ */ React.createElement(Box, { sx: { mb: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", gutterBottom: true, color: "primary.light" }, "Flavors & Terpenes"), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1, flexWrap: "wrap", useFlexGap: true }, matchedStrain.flavors.map((flavor, idx) => /* @__PURE__ */ React.createElement(
      Chip,
      {
        key: idx,
        label: flavor,
        variant: "outlined",
        sx: { borderColor: "#66bb6a", color: "#66bb6a" }
      }
    )))), matchedStrain.lineage && matchedStrain.lineage.length > 0 && /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", gutterBottom: true, color: "primary.light" }, "Genetics"), /* @__PURE__ */ React.createElement(Typography, { variant: "body1", color: "text.secondary" }, matchedStrain.lineage.join("  "))), /* @__PURE__ */ React.createElement(Divider, { sx: { my: 2, bgcolor: "rgba(76, 175, 80, 0.3)" } }), /* @__PURE__ */ React.createElement(Box, { sx: { mb: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", gutterBottom: true, color: "primary.light" }, "Community Reviews"), avgRating !== null ? /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 1, sx: { mb: 1 } }, /* @__PURE__ */ React.createElement(Rating, { value: avgRating, readOnly: true, precision: 0.5 }), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, avgRating, " average  ", reviews.length, " ", reviews.length === 1 ? "review" : "reviews")) : /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary", sx: { mb: 1 } }, "No reviews yet. Be the first to rate this strain."), /* @__PURE__ */ React.createElement(Card, { sx: { mb: 2, bgcolor: "rgba(76, 175, 80, 0.06)", border: "1px solid rgba(76, 175, 80, 0.3)" } }, /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", color: "text.secondary", gutterBottom: true }, "Leave a review"), /* @__PURE__ */ React.createElement(Stack, { direction: { xs: "column", sm: "row" }, spacing: 2, alignItems: { xs: "flex-start", sm: "center" } }, /* @__PURE__ */ React.createElement(Rating, { value: myRating, onChange: (_e, v) => setMyRating(v || 0) }), /* @__PURE__ */ React.createElement(
      TextField,
      {
        placeholder: "Share your experience (optional)",
        fullWidth: true,
        size: "small",
        value: myComment,
        onChange: (e) => setMyComment(e.target.value),
        inputProps: { maxLength: 400 }
      }
    ), /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "contained",
        onClick: submitReview,
        disabled: submittingReview,
        sx: { whiteSpace: "nowrap" }
      },
      submittingReview ? "Submitting" : "Submit"
    )), !currentUserId && /* @__PURE__ */ React.createElement(Typography, { variant: "caption", color: "text.secondary", sx: { mt: 1, display: "block" } }, "Sign in to post a review."))), reviews.slice(0, 5).map((r2) => /* @__PURE__ */ React.createElement(Card, { key: r2.id, sx: { mb: 1.5, background: "rgba(255,255,255,0.15)", backdropFilter: "blur(8px)", border: "2px solid #4caf50", boxShadow: "0 2px 12px rgba(76,175,80,0.08)" } }, /* @__PURE__ */ React.createElement(CardContent, { sx: { py: 1.5 } }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 2 }, /* @__PURE__ */ React.createElement(Avatar, { sx: { bgcolor: "primary.main", width: 36, height: 36, fontWeight: 700 } }, r2.user_id ? r2.user_id.substring(0, 2).toUpperCase() : "??"), /* @__PURE__ */ React.createElement(Stack, null, /* @__PURE__ */ React.createElement(Rating, { value: r2.rating || 0, readOnly: true, size: "small" }), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", color: "text.secondary" }, new Date(r2.created_at).toLocaleDateString()))), r2.comment && /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.primary", sx: { mt: 1, fontSize: "1.08rem" } }, r2.comment))))), /* @__PURE__ */ React.createElement(Divider, { sx: { my: 2, bgcolor: "rgba(76, 175, 80, 0.3)" } }), /* @__PURE__ */ React.createElement(Box, { sx: { mb: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", gutterBottom: true, color: "primary.light" }, " Where to Buy Seeds"), loadingVendors ? /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, "Loading vendors...") : vendors.length > 0 ? /* @__PURE__ */ React.createElement(Stack, { spacing: 1 }, vendors.slice(0, 5).map((vendor, idx) => /* @__PURE__ */ React.createElement(Card, { key: idx, sx: { bgcolor: "rgba(76, 175, 80, 0.05)", border: "1px solid rgba(76, 175, 80, 0.3)" } }, /* @__PURE__ */ React.createElement(CardContent, { sx: { py: 1.5 } }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", justifyContent: "space-between", alignItems: "center" }, /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "body1", fontWeight: "bold", color: "primary.main" }, vendor.name, vendor.verified && /* @__PURE__ */ React.createElement(Chip, { label: " Verified", size: "small", sx: { ml: 1, height: 20, fontSize: "0.7rem", bgcolor: "#4caf50", color: "white" } })), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", color: "text.secondary" }, vendor.country, "  ", vendor.seed_count, " seeds  $", vendor.price)), vendor.website && /* @__PURE__ */ React.createElement(
      Button,
      {
        size: "small",
        variant: "outlined",
        href: vendor.website,
        target: "_blank",
        rel: "noopener noreferrer",
        sx: { borderColor: "#4caf50", color: "#4caf50" }
      },
      "Visit"
    )))))) : /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, "No seed vendors found for this strain.")), /* @__PURE__ */ React.createElement(Divider, { sx: { my: 2, bgcolor: "rgba(76, 175, 80, 0.3)" } }), /* @__PURE__ */ React.createElement(Box, { sx: { mb: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", gutterBottom: true, color: "primary.light" }, " Nearby Dispensaries"), !userLocation ? /* @__PURE__ */ React.createElement(Alert, { severity: "info", sx: { mb: 1 } }, "Enable location to find nearby dispensaries") : loadingDispensaries ? /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, "Loading dispensaries...") : dispensaries.length > 0 ? /* @__PURE__ */ React.createElement(Stack, { spacing: 1 }, dispensaries.slice(0, 5).map((dispensary, idx) => /* @__PURE__ */ React.createElement(Card, { key: idx, sx: { bgcolor: "rgba(76, 175, 80, 0.05)", border: "1px solid rgba(76, 175, 80, 0.3)" } }, /* @__PURE__ */ React.createElement(CardContent, { sx: { py: 1.5 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body1", fontWeight: "bold", color: "primary.main" }, dispensary.name), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", color: "text.secondary" }, dispensary.address && `${dispensary.address}, `, dispensary.city, ", ", dispensary.state, dispensary.distance && `  ${dispensary.distance.toFixed(1)} mi away`), dispensary.phone && /* @__PURE__ */ React.createElement(Typography, { variant: "caption", color: "text.secondary", sx: { display: "block" } }, " ", dispensary.phone))))) : /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, "No dispensaries found nearby.")), /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "contained",
        fullWidth: true,
        onClick: handleReset,
        sx: {
          mt: 3,
          py: 1.5,
          background: "linear-gradient(45deg, #4caf50 30%, #66bb6a 90%)"
        }
      },
      "Scan Another Strain"
    )) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Alert, { severity: "warning", sx: { mb: 2 } }, "No exact match found. The image may not contain a clear strain name."), /* @__PURE__ */ React.createElement(Alert, { severity: "info", sx: { mb: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, "Retake with better framing and lighting for stronger matches."), /* @__PURE__ */ React.createElement(TipsContent, null), /* @__PURE__ */ React.createElement(Button, { size: "small", variant: "outlined", sx: { mt: 1 }, onClick: () => setShowTips(true) }, "Open Photo Tips")), suggestedStrains.length > 0 && /* @__PURE__ */ React.createElement(Box, { sx: { mt: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", gutterBottom: true, color: "primary.light" }, " Possible Matches"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary", sx: { mb: 2 } }, "Tap a strain below if it matches what you're looking for:"), /* @__PURE__ */ React.createElement(Stack, { spacing: 1 }, suggestedStrains.map((strain) => /* @__PURE__ */ React.createElement(
      Card,
      {
        key: strain.slug,
        sx: {
          cursor: "pointer",
          bgcolor: "rgba(76, 175, 80, 0.05)",
          border: "1px solid rgba(76, 175, 80, 0.3)",
          transition: "all 0.2s",
          "&:hover": {
            bgcolor: "rgba(76, 175, 80, 0.15)",
            border: "1px solid #4caf50"
          }
        },
        onClick: () => handleSelectSuggestion(strain.slug)
      },
      /* @__PURE__ */ React.createElement(CardContent, { sx: { py: 1.5 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body1", fontWeight: "bold", color: "primary.main" }, strain.name), strain.type && /* @__PURE__ */ React.createElement(
        Chip,
        {
          label: strain.type,
          size: "small",
          sx: {
            mt: 0.5,
            height: 20,
            fontSize: "0.7rem",
            bgcolor: strain.type === "Indica" ? "#7b1fa2" : strain.type === "Sativa" ? "#f57c00" : "#00897b",
            color: "white"
          }
        }
      ))
    )))), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 2, sx: { mt: 3 } }, /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "contained",
        fullWidth: true,
        startIcon: /* @__PURE__ */ React.createElement(CheckCircleIcon, null),
        onClick: () => {
          setShowResult(false);
          onViewHistory == null ? void 0 : onViewHistory();
        },
        sx: {
          background: "linear-gradient(45deg, #4caf50 30%, #66bb6a 90%)"
        }
      },
      "View in History"
    ), /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "outlined",
        fullWidth: true,
        onClick: handleReset,
        sx: {
          borderColor: "#4caf50",
          color: "#4caf50"
        }
      },
      "Scan Again"
    ))))
  ), /* @__PURE__ */ React.createElement(Dialog, { open: showTips, onClose: () => setShowTips(false), maxWidth: "sm", fullWidth: true }, /* @__PURE__ */ React.createElement(DialogTitle, null, /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", justifyContent: "space-between" }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6" }, "Photo Tips for Best Results"), /* @__PURE__ */ React.createElement(IconButton, { onClick: () => setShowTips(false) }, /* @__PURE__ */ React.createElement(CloseIcon, null)))), /* @__PURE__ */ React.createElement(DialogContent, null, /* @__PURE__ */ React.createElement(TipsContent, null), /* @__PURE__ */ React.createElement(Alert, { severity: "info", sx: { mt: 2 } }, "Try 23 shots from different angles. Include a label if available."))));
}
/**
 * react-router v7.9.4
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined") console.warn(message);
    try {
      throw new Error(message);
    } catch (e) {
    }
  }
}
function createPath({
  pathname = "/",
  search = "",
  hash: hash2 = ""
}) {
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash2 && hash2 !== "#")
    pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substring(hashIndex);
      path = path.substring(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substring(searchIndex);
      path = path.substring(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function matchRoutes(routes, locationArg, basename = "/") {
  return matchRoutesImpl(routes, locationArg, basename, false);
}
function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    let decoded = decodePath(pathname);
    matches = matchRouteBranch(
      branches[i],
      decoded,
      allowPartial
    );
  }
  return matches;
}
function flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = "", _hasParentOptionalSegments = false) {
  let flattenRoute = (route, index2, hasParentOptionalSegments = _hasParentOptionalSegments, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index2,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      if (!meta.relativePath.startsWith(parentPath) && hasParentOptionalSegments) {
        return;
      }
      invariant(
        meta.relativePath.startsWith(parentPath),
        `Absolute route path "${meta.relativePath}" nested under path "${parentPath}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
      );
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        `Index routes must not have child routes. Please remove all child routes from route path "${path}".`
      );
      flattenRoutes(
        route.children,
        branches,
        routesMeta,
        path,
        hasParentOptionalSegments
      );
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index2) => {
    var _a2;
    if (route.path === "" || !((_a2 = route.path) == null ? void 0 : _a2.includes("?"))) {
      flattenRoute(route, index2);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index2, true, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0) return [];
  let [first, ...rest] = segments;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(
    ...restExploded.map(
      (subpath) => subpath === "" ? required : [required, subpath].join("/")
    )
  );
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map(
    (exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded
  );
}
function rankRouteBranches(branches) {
  branches.sort(
    (a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(
      a.routesMeta.map((meta) => meta.childrenIndex),
      b.routesMeta.map((meta) => meta.childrenIndex)
    )
  );
}
var paramRe = /^:[\w-]+$/;
var dynamicSegmentValue = 3;
var indexRouteValue = 2;
var emptySegmentValue = 1;
var staticSegmentValue = 10;
var splatPenalty = -2;
var isSplat = (s) => s === "*";
function computeScore(path, index2) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index2) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s) => !isSplat(s)).reduce(
    (score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue),
    initialScore
  );
}
function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a[a.length - 1] - b[b.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname, allowPartial = false) {
  let { routesMeta } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end2 = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match2 = matchPath(
      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end: end2 },
      remainingPathname
    );
    let route = meta.route;
    if (!match2 && end2 && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
      match2 = matchPath(
        {
          path: meta.relativePath,
          caseSensitive: meta.caseSensitive,
          end: false
        },
        remainingPathname
      );
    }
    if (!match2) {
      return null;
    }
    Object.assign(matchedParams, match2.params);
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match2.pathname]),
      pathnameBase: normalizePathname(
        joinPaths([matchedPathname, match2.pathnameBase])
      ),
      route
    });
    if (match2.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = { path: pattern, caseSensitive: false, end: true };
  }
  let [matcher, compiledParams] = compilePath(
    pattern.path,
    pattern.caseSensitive,
    pattern.end
  );
  let match2 = pathname.match(matcher);
  if (!match2) return null;
  let matchedPathname = match2[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match2.slice(1);
  let params = compiledParams.reduce(
    (memo2, { paramName, isOptional }, index2) => {
      if (paramName === "*") {
        let splatValue = captureGroups[index2] || "";
        pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
      }
      const value = captureGroups[index2];
      if (isOptional && !value) {
        memo2[paramName] = void 0;
      } else {
        memo2[paramName] = (value || "").replace(/%2F/g, "/");
      }
      return memo2;
    },
    {}
  );
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive = false, end2 = true) {
  warning(
    path === "*" || !path.endsWith("*") || path.endsWith("/*"),
    `Route path "${path}" will be treated as if it were "${path.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${path.replace(/\*$/, "/*")}".`
  );
  let params = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
    /\/:([\w-]+)(\?)?/g,
    (_, paramName, isOptional) => {
      params.push({ paramName, isOptional: isOptional != null });
      return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
    }
  ).replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2");
  if (path.endsWith("*")) {
    params.push({ paramName: "*" });
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end2) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, params];
}
function decodePath(value) {
  try {
    return value.split("/").map((v) => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
  } catch (error) {
    warning(
      false,
      `The URL path "${value}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`
    );
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function resolvePath(to, fromPathname = "/") {
  let {
    pathname: toPathname,
    search = "",
    hash: hash2 = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash2)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char2, field, dest, path) {
  return `Cannot include a '${char2}' character in a manually specified \`to.${field}\` field [${JSON.stringify(
    path
  )}].  Please separate it out to the \`to.${dest}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function getPathContributingMatches(matches) {
  return matches.filter(
    (match2, index2) => index2 === 0 || match2.route.path && match2.route.path.length > 0
  );
}
function getResolveToMatches(matches) {
  let pathMatches = getPathContributingMatches(matches);
  return pathMatches.map(
    (match2, idx) => idx === pathMatches.length - 1 ? match2.pathname : match2.pathnameBase
  );
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = __spreadValues({}, toArg);
    invariant(
      !to.pathname || !to.pathname.includes("?"),
      getInvalidPathError("?", "pathname", "search", to)
    );
    invariant(
      !to.pathname || !to.pathname.includes("#"),
      getInvalidPathError("#", "pathname", "hash", to)
    );
    invariant(
      !to.search || !to.search.includes("#"),
      getInvalidPathError("#", "search", "hash", to)
    );
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from2;
  if (toPathname == null) {
    from2 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from2);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
var normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
var normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}
var validMutationMethodsArr = [
  "POST",
  "PUT",
  "PATCH",
  "DELETE"
];
new Set(
  validMutationMethodsArr
);
var validRequestMethodsArr = [
  "GET",
  ...validMutationMethodsArr
];
new Set(validRequestMethodsArr);
const React$7 = window["React"];
var DataRouterContext = React$7.createContext(null);
DataRouterContext.displayName = "DataRouter";
var DataRouterStateContext = React$7.createContext(null);
DataRouterStateContext.displayName = "DataRouterState";
var RSCRouterContext = React$7.createContext(false);
function useIsRSCRouterContext() {
  return React$7.useContext(RSCRouterContext);
}
var ViewTransitionContext = React$7.createContext({
  isTransitioning: false
});
ViewTransitionContext.displayName = "ViewTransition";
var FetchersContext = React$7.createContext(
  /* @__PURE__ */ new Map()
);
FetchersContext.displayName = "Fetchers";
var AwaitContext = React$7.createContext(null);
AwaitContext.displayName = "Await";
var NavigationContext = React$7.createContext(
  null
);
NavigationContext.displayName = "Navigation";
var LocationContext = React$7.createContext(
  null
);
LocationContext.displayName = "Location";
var RouteContext = React$7.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
RouteContext.displayName = "Route";
var RouteErrorContext = React$7.createContext(null);
RouteErrorContext.displayName = "RouteError";
const React2 = window["React"];
function useHref(to, { relative } = {}) {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useHref() may be used only in the context of a <Router> component.`
  );
  let { basename, navigator: navigator2 } = React2.useContext(NavigationContext);
  let { hash: hash2, pathname, search } = useResolvedPath(to, { relative });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({ pathname: joinedPathname, search, hash: hash2 });
}
function useInRouterContext() {
  return React2.useContext(LocationContext) != null;
}
function useLocation() {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useLocation() may be used only in the context of a <Router> component.`
  );
  return React2.useContext(LocationContext).location;
}
var navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;
function useIsomorphicLayoutEffect(cb) {
  let isStatic = React2.useContext(NavigationContext).static;
  if (!isStatic) {
    React2.useLayoutEffect(cb);
  }
}
function useNavigate() {
  let { isDataRoute } = React2.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useNavigate() may be used only in the context of a <Router> component.`
  );
  let dataRouterContext = React2.useContext(DataRouterContext);
  let { basename, navigator: navigator2 } = React2.useContext(NavigationContext);
  let { matches } = React2.useContext(RouteContext);
  let { pathname: locationPathname } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
  let activeRef = React2.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = React2.useCallback(
    (to, options = {}) => {
      warning(activeRef.current, navigateEffectWarning);
      if (!activeRef.current) return;
      if (typeof to === "number") {
        navigator2.go(to);
        return;
      }
      let path = resolveTo(
        to,
        JSON.parse(routePathnamesJson),
        locationPathname,
        options.relative === "path"
      );
      if (dataRouterContext == null && basename !== "/") {
        path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
      }
      (!!options.replace ? navigator2.replace : navigator2.push)(
        path,
        options.state,
        options
      );
    },
    [
      basename,
      navigator2,
      routePathnamesJson,
      locationPathname,
      dataRouterContext
    ]
  );
  return navigate;
}
React2.createContext(null);
function useResolvedPath(to, { relative } = {}) {
  let { matches } = React2.useContext(RouteContext);
  let { pathname: locationPathname } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
  return React2.useMemo(
    () => resolveTo(
      to,
      JSON.parse(routePathnamesJson),
      locationPathname,
      relative === "path"
    ),
    [to, routePathnamesJson, locationPathname, relative]
  );
}
function useRoutesImpl(routes, locationArg, dataRouterState, unstable_onError, future) {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useRoutes() may be used only in the context of a <Router> component.`
  );
  let { navigator: navigator2 } = React2.useContext(NavigationContext);
  let { matches: parentMatches } = React2.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  {
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(
      parentPathname,
      !parentRoute || parentPath.endsWith("*") || parentPath.endsWith("*?"),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${parentPathname}" (under <Route path="${parentPath}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${parentPath}"> to <Route path="${parentPath === "/" ? "*" : `${parentPath}/*`}">.`
    );
  }
  let locationFromContext = useLocation();
  let location;
  {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = pathname;
  if (parentPathnameBase !== "/") {
    let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
    let segments = pathname.replace(/^\//, "").split("/");
    remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
  }
  let matches = matchRoutes(routes, { pathname: remainingPathname });
  {
    warning(
      parentRoute || matches != null,
      `No routes matched location "${location.pathname}${location.search}${location.hash}" `
    );
    warning(
      matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0,
      `Matched leaf route at location "${location.pathname}${location.search}${location.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
    );
  }
  let renderedMatches = _renderMatches(
    matches && matches.map(
      (match2) => Object.assign({}, match2, {
        params: Object.assign({}, parentParams, match2.params),
        pathname: joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes.
          // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
          // `new URL()` internally and we need to prevent it from treating
          // them as separators
          navigator2.encodeLocation ? navigator2.encodeLocation(
            match2.pathname.replace(/\?/g, "%3F").replace(/#/g, "%23")
          ).pathname : match2.pathname
        ]),
        pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
          // `new URL()` internally and we need to prevent it from treating
          // them as separators
          navigator2.encodeLocation ? navigator2.encodeLocation(
            match2.pathnameBase.replace(/\?/g, "%3F").replace(/#/g, "%23")
          ).pathname : match2.pathnameBase
        ])
      })
    ),
    parentMatches,
    dataRouterState,
    unstable_onError,
    future
  );
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? `${error.status} ${error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = { padding: "0.5rem", backgroundColor: lightgrey };
  let codeStyles = { padding: "2px 4px", backgroundColor: lightgrey };
  let devInfo = null;
  {
    console.error(
      "Error handled by React Router default ErrorBoundary:",
      error
    );
    devInfo = /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement("p", null, " Hey developer "), /* @__PURE__ */ React2.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ React2.createElement("code", { style: codeStyles }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ React2.createElement("code", { style: codeStyles }, "errorElement"), " prop on your route."));
  }
  return /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ React2.createElement("h3", { style: { fontStyle: "italic" } }, message), stack ? /* @__PURE__ */ React2.createElement("pre", { style: preStyles }, stack) : null, devInfo);
}
var defaultErrorElement = /* @__PURE__ */ React2.createElement(DefaultErrorComponent, null);
var RenderErrorBoundary = class extends React2.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error !== void 0 ? props.error : state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    if (this.props.unstable_onError) {
      this.props.unstable_onError(error, errorInfo);
    } else {
      console.error(
        "React Router caught the following error during render",
        error
      );
    }
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ React2.createElement(RouteContext.Provider, { value: this.props.routeContext }, /* @__PURE__ */ React2.createElement(
      RouteErrorContext.Provider,
      {
        value: this.state.error,
        children: this.props.component
      }
    )) : this.props.children;
  }
};
function RenderedRoute({ routeContext, match: match2, children }) {
  let dataRouterContext = React2.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match2.route.errorElement || match2.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match2.route.id;
  }
  return /* @__PURE__ */ React2.createElement(RouteContext.Provider, { value: routeContext }, children);
}
function _renderMatches(matches, parentMatches = [], dataRouterState = null, unstable_onError = null, future = null) {
  if (matches == null) {
    if (!dataRouterState) {
      return null;
    }
    if (dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = dataRouterState == null ? void 0 : dataRouterState.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex(
      (m) => m.route.id && (errors == null ? void 0 : errors[m.route.id]) !== void 0
    );
    invariant(
      errorIndex >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(
        errors
      ).join(",")}`
    );
    renderedMatches = renderedMatches.slice(
      0,
      Math.min(renderedMatches.length, errorIndex + 1)
    );
  }
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState) {
    for (let i = 0; i < renderedMatches.length; i++) {
      let match2 = renderedMatches[i];
      if (match2.route.HydrateFallback || match2.route.hydrateFallbackElement) {
        fallbackIndex = i;
      }
      if (match2.route.id) {
        let { loaderData, errors: errors2 } = dataRouterState;
        let needsToRunLoader = match2.route.loader && !loaderData.hasOwnProperty(match2.route.id) && (!errors2 || errors2[match2.route.id] === void 0);
        if (match2.route.lazy || needsToRunLoader) {
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  return renderedMatches.reduceRight(
    (outlet, match2, index2) => {
      let error;
      let shouldRenderHydrateFallback = false;
      let errorElement = null;
      let hydrateFallbackElement = null;
      if (dataRouterState) {
        error = errors && match2.route.id ? errors[match2.route.id] : void 0;
        errorElement = match2.route.errorElement || defaultErrorElement;
        if (renderFallback) {
          if (fallbackIndex < 0 && index2 === 0) {
            warningOnce(
              "route-fallback",
              false,
              "No `HydrateFallback` element provided to render during initial hydration"
            );
            shouldRenderHydrateFallback = true;
            hydrateFallbackElement = null;
          } else if (fallbackIndex === index2) {
            shouldRenderHydrateFallback = true;
            hydrateFallbackElement = match2.route.hydrateFallbackElement || null;
          }
        }
      }
      let matches2 = parentMatches.concat(renderedMatches.slice(0, index2 + 1));
      let getChildren = () => {
        let children;
        if (error) {
          children = errorElement;
        } else if (shouldRenderHydrateFallback) {
          children = hydrateFallbackElement;
        } else if (match2.route.Component) {
          children = /* @__PURE__ */ React2.createElement(match2.route.Component, null);
        } else if (match2.route.element) {
          children = match2.route.element;
        } else {
          children = outlet;
        }
        return /* @__PURE__ */ React2.createElement(
          RenderedRoute,
          {
            match: match2,
            routeContext: {
              outlet,
              matches: matches2,
              isDataRoute: dataRouterState != null
            },
            children
          }
        );
      };
      return dataRouterState && (match2.route.ErrorBoundary || match2.route.errorElement || index2 === 0) ? /* @__PURE__ */ React2.createElement(
        RenderErrorBoundary,
        {
          location: dataRouterState.location,
          revalidation: dataRouterState.revalidation,
          component: errorElement,
          error,
          children: getChildren(),
          routeContext: { outlet: null, matches: matches2, isDataRoute: true },
          unstable_onError
        }
      ) : getChildren();
    },
    null
  );
}
function getDataRouterConsoleError(hookName) {
  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function useDataRouterContext(hookName) {
  let ctx = React2.useContext(DataRouterContext);
  invariant(ctx, getDataRouterConsoleError(hookName));
  return ctx;
}
function useDataRouterState(hookName) {
  let state = React2.useContext(DataRouterStateContext);
  invariant(state, getDataRouterConsoleError(hookName));
  return state;
}
function useRouteContext(hookName) {
  let route = React2.useContext(RouteContext);
  invariant(route, getDataRouterConsoleError(hookName));
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext(hookName);
  let thisRoute = route.matches[route.matches.length - 1];
  invariant(
    thisRoute.route.id,
    `${hookName} can only be used on routes that contain a unique "id"`
  );
  return thisRoute.route.id;
}
function useRouteId() {
  return useCurrentRouteId(
    "useRouteId"
    /* UseRouteId */
  );
}
function useRouteError() {
  var _a2;
  let error = React2.useContext(RouteErrorContext);
  let state = useDataRouterState(
    "useRouteError"
    /* UseRouteError */
  );
  let routeId = useCurrentRouteId(
    "useRouteError"
    /* UseRouteError */
  );
  if (error !== void 0) {
    return error;
  }
  return (_a2 = state.errors) == null ? void 0 : _a2[routeId];
}
function useNavigateStable() {
  let { router } = useDataRouterContext(
    "useNavigate"
    /* UseNavigateStable */
  );
  let id = useCurrentRouteId(
    "useNavigate"
    /* UseNavigateStable */
  );
  let activeRef = React2.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = React2.useCallback(
    (_0, ..._1) => __async(null, [_0, ..._1], function* (to, options = {}) {
      warning(activeRef.current, navigateEffectWarning);
      if (!activeRef.current) return;
      if (typeof to === "number") {
        router.navigate(to);
      } else {
        yield router.navigate(to, __spreadValues({ fromRouteId: id }, options));
      }
    }),
    [router, id]
  );
  return navigate;
}
var alreadyWarned = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
    warning(false, message);
  }
}
const React3 = window["React"];
var alreadyWarned2 = {};
function warnOnce(condition, message) {
  if (!condition && !alreadyWarned2[message]) {
    alreadyWarned2[message] = true;
    console.warn(message);
  }
}
React3.memo(DataRoutes);
function DataRoutes({
  routes,
  future,
  state,
  unstable_onError
}) {
  return useRoutesImpl(routes, void 0, state, unstable_onError, future);
}
(class extends React3.Component {
  constructor(props) {
    super(props);
    this.state = { error: null };
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  componentDidCatch(error, errorInfo) {
    if (this.props.unstable_onError) {
      this.props.unstable_onError(error, errorInfo);
    } else {
      console.error(
        "<Await> caught the following error during render",
        error,
        errorInfo
      );
    }
  }
  render() {
    let { children, errorElement, resolve } = this.props;
    let promise = null;
    let status = 0;
    if (!(resolve instanceof Promise)) {
      status = 1;
      promise = Promise.resolve();
      Object.defineProperty(promise, "_tracked", { get: () => true });
      Object.defineProperty(promise, "_data", { get: () => resolve });
    } else if (this.state.error) {
      status = 2;
      let renderError = this.state.error;
      promise = Promise.reject().catch(() => {
      });
      Object.defineProperty(promise, "_tracked", { get: () => true });
      Object.defineProperty(promise, "_error", { get: () => renderError });
    } else if (resolve._tracked) {
      promise = resolve;
      status = "_error" in promise ? 2 : "_data" in promise ? 1 : 0;
    } else {
      status = 0;
      Object.defineProperty(resolve, "_tracked", { get: () => true });
      promise = resolve.then(
        (data2) => Object.defineProperty(resolve, "_data", { get: () => data2 }),
        (error) => {
          var _a2, _b;
          (_b = (_a2 = this.props).unstable_onError) == null ? void 0 : _b.call(_a2, error);
          Object.defineProperty(resolve, "_error", { get: () => error });
        }
      );
    }
    if (status === 2 && !errorElement) {
      throw promise._error;
    }
    if (status === 2) {
      return /* @__PURE__ */ React3.createElement(AwaitContext.Provider, { value: promise, children: errorElement });
    }
    if (status === 1) {
      return /* @__PURE__ */ React3.createElement(AwaitContext.Provider, { value: promise, children });
    }
    throw promise;
  }
});
var defaultMethod = "get";
var defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement(object) {
  return object != null && typeof object.tagName === "string";
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
var _formDataSupportsSubmitter = null;
function isFormDataSubmitterSupported() {
  if (_formDataSupportsSubmitter === null) {
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      );
      _formDataSupportsSubmitter = false;
    } catch (e) {
      _formDataSupportsSubmitter = true;
    }
  }
  return _formDataSupportsSubmitter;
}
var supportedFormEncTypes = /* @__PURE__ */ new Set([
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain"
]);
function getFormEncType(encType) {
  if (encType != null && !supportedFormEncTypes.has(encType)) {
    warning(
      false,
      `"${encType}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${defaultEncType}"`
    );
    return null;
  }
  return encType;
}
function getFormSubmissionInfo(target, basename) {
  let method;
  let action;
  let encType;
  let formData;
  let body2;
  if (isFormElement(target)) {
    let attr = target.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(target);
  } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
    let form = target.form;
    if (form == null) {
      throw new Error(
        `Cannot submit a <button> or <input type="submit"> without a <form>`
      );
    }
    let attr = target.getAttribute("formaction") || form.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(form, target);
    if (!isFormDataSubmitterSupported()) {
      let { name: name2, type, value } = target;
      if (type === "image") {
        let prefix2 = name2 ? `${name2}.` : "";
        formData.append(`${prefix2}x`, "0");
        formData.append(`${prefix2}y`, "0");
      } else if (name2) {
        formData.append(name2, value);
      }
    }
  } else if (isHtmlElement(target)) {
    throw new Error(
      `Cannot submit element that is not <form>, <button>, or <input type="submit|image">`
    );
  } else {
    method = defaultMethod;
    action = null;
    encType = defaultEncType;
    body2 = target;
  }
  if (formData && encType === "text/plain") {
    body2 = formData;
    formData = void 0;
  }
  return { action, method: method.toLowerCase(), encType, formData, body: body2 };
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function invariant2(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function singleFetchUrl(reqUrl, basename, extension) {
  let url = typeof reqUrl === "string" ? new URL(
    reqUrl,
    // This can be called during the SSR flow via PrefetchPageLinksImpl so
    // don't assume window is available
    typeof window === "undefined" ? "server://singlefetch/" : window.location.origin
  ) : reqUrl;
  if (url.pathname === "/") {
    url.pathname = `_root.${extension}`;
  } else if (basename && stripBasename(url.pathname, basename) === "/") {
    url.pathname = `${basename.replace(/\/$/, "")}/_root.${extension}`;
  } else {
    url.pathname = `${url.pathname.replace(/\/$/, "")}.${extension}`;
  }
  return url;
}
const React9 = window["React"];
const React8 = window["React"];
function loadRouteModule(route, routeModulesCache) {
  return __async(this, null, function* () {
    if (route.id in routeModulesCache) {
      return routeModulesCache[route.id];
    }
    try {
      let routeModule = yield import(
        /* @vite-ignore */
        /* webpackIgnore: true */
        route.module
      );
      routeModulesCache[route.id] = routeModule;
      return routeModule;
    } catch (error) {
      console.error(
        `Error loading route module \`${route.module}\`, reloading page...`
      );
      console.error(error);
      if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode && // @ts-expect-error
      void 0) ;
      window.location.reload();
      return new Promise(() => {
      });
    }
  });
}
function isHtmlLinkDescriptor(object) {
  if (object == null) {
    return false;
  }
  if (object.href == null) {
    return object.rel === "preload" && typeof object.imageSrcSet === "string" && typeof object.imageSizes === "string";
  }
  return typeof object.rel === "string" && typeof object.href === "string";
}
function getKeyedPrefetchLinks(matches, manifest, routeModules) {
  return __async(this, null, function* () {
    let links = yield Promise.all(
      matches.map((match2) => __async(null, null, function* () {
        let route = manifest.routes[match2.route.id];
        if (route) {
          let mod = yield loadRouteModule(route, routeModules);
          return mod.links ? mod.links() : [];
        }
        return [];
      }))
    );
    return dedupeLinkDescriptors(
      links.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map(
        (link) => link.rel === "stylesheet" ? __spreadProps(__spreadValues({}, link), { rel: "prefetch", as: "style" }) : __spreadProps(__spreadValues({}, link), { rel: "prefetch" })
      )
    );
  });
}
function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {
  let isNew = (match2, index2) => {
    if (!currentMatches[index2]) return true;
    return match2.route.id !== currentMatches[index2].route.id;
  };
  let matchPathChanged = (match2, index2) => {
    var _a2;
    return (
      // param change, /users/123 -> /users/456
      currentMatches[index2].pathname !== match2.pathname || // splat param changed, which is not present in match.path
      // e.g. /files/images/avatar.jpg -> files/finances.xls
      ((_a2 = currentMatches[index2].route.path) == null ? void 0 : _a2.endsWith("*")) && currentMatches[index2].params["*"] !== match2.params["*"]
    );
  };
  if (mode === "assets") {
    return nextMatches.filter(
      (match2, index2) => isNew(match2, index2) || matchPathChanged(match2, index2)
    );
  }
  if (mode === "data") {
    return nextMatches.filter((match2, index2) => {
      var _a2;
      let manifestRoute = manifest.routes[match2.route.id];
      if (!manifestRoute || !manifestRoute.hasLoader) {
        return false;
      }
      if (isNew(match2, index2) || matchPathChanged(match2, index2)) {
        return true;
      }
      if (match2.route.shouldRevalidate) {
        let routeChoice = match2.route.shouldRevalidate({
          currentUrl: new URL(
            location.pathname + location.search + location.hash,
            window.origin
          ),
          currentParams: ((_a2 = currentMatches[0]) == null ? void 0 : _a2.params) || {},
          nextUrl: new URL(page, window.origin),
          nextParams: match2.params,
          defaultShouldRevalidate: true
        });
        if (typeof routeChoice === "boolean") {
          return routeChoice;
        }
      }
      return true;
    });
  }
  return [];
}
function getModuleLinkHrefs(matches, manifest, { includeHydrateFallback } = {}) {
  return dedupeHrefs(
    matches.map((match2) => {
      let route = manifest.routes[match2.route.id];
      if (!route) return [];
      let hrefs = [route.module];
      if (route.clientActionModule) {
        hrefs = hrefs.concat(route.clientActionModule);
      }
      if (route.clientLoaderModule) {
        hrefs = hrefs.concat(route.clientLoaderModule);
      }
      if (includeHydrateFallback && route.hydrateFallbackModule) {
        hrefs = hrefs.concat(route.hydrateFallbackModule);
      }
      if (route.imports) {
        hrefs = hrefs.concat(route.imports);
      }
      return hrefs;
    }).flat(1)
  );
}
function dedupeHrefs(hrefs) {
  return [...new Set(hrefs)];
}
function sortKeys(obj) {
  let sorted = {};
  let keys = Object.keys(obj).sort();
  for (let key of keys) {
    sorted[key] = obj[key];
  }
  return sorted;
}
function dedupeLinkDescriptors(descriptors, preloads) {
  let set = /* @__PURE__ */ new Set();
  new Set(preloads);
  return descriptors.reduce((deduped, descriptor) => {
    let key = JSON.stringify(sortKeys(descriptor));
    if (!set.has(key)) {
      set.add(key);
      deduped.push({ key, link: descriptor });
    }
    return deduped;
  }, []);
}
function isFogOfWarEnabled(routeDiscovery, ssr) {
  return routeDiscovery.mode === "lazy" && ssr === true;
}
function getPartialManifest(_i, router) {
  var _j = _i, { sri } = _j, manifest = __objRest(_j, ["sri"]);
  let routeIds = new Set(router.state.matches.map((m) => m.route.id));
  let segments = router.state.location.pathname.split("/").filter(Boolean);
  let paths = ["/"];
  segments.pop();
  while (segments.length > 0) {
    paths.push(`/${segments.join("/")}`);
    segments.pop();
  }
  paths.forEach((path) => {
    let matches = matchRoutes(router.routes, path, router.basename);
    if (matches) {
      matches.forEach((m) => routeIds.add(m.route.id));
    }
  });
  let initialRoutes = [...routeIds].reduce(
    (acc, id) => Object.assign(acc, { [id]: manifest.routes[id] }),
    {}
  );
  return __spreadProps(__spreadValues({}, manifest), {
    routes: initialRoutes,
    sri: sri ? true : void 0
  });
}
function useDataRouterContext2() {
  let context = React8.useContext(DataRouterContext);
  invariant2(
    context,
    "You must render this element inside a <DataRouterContext.Provider> element"
  );
  return context;
}
function useDataRouterStateContext() {
  let context = React8.useContext(DataRouterStateContext);
  invariant2(
    context,
    "You must render this element inside a <DataRouterStateContext.Provider> element"
  );
  return context;
}
var FrameworkContext = React8.createContext(void 0);
FrameworkContext.displayName = "FrameworkContext";
function useFrameworkContext() {
  let context = React8.useContext(FrameworkContext);
  invariant2(
    context,
    "You must render this element inside a <HydratedRouter> element"
  );
  return context;
}
function usePrefetchBehavior(prefetch, theirElementProps) {
  let frameworkContext = React8.useContext(FrameworkContext);
  let [maybePrefetch, setMaybePrefetch] = React8.useState(false);
  let [shouldPrefetch, setShouldPrefetch] = React8.useState(false);
  let { onFocus, onBlur, onMouseEnter, onMouseLeave, onTouchStart } = theirElementProps;
  let ref = React8.useRef(null);
  React8.useEffect(() => {
    if (prefetch === "render") {
      setShouldPrefetch(true);
    }
    if (prefetch === "viewport") {
      let callback = (entries) => {
        entries.forEach((entry) => {
          setShouldPrefetch(entry.isIntersecting);
        });
      };
      let observer = new IntersectionObserver(callback, { threshold: 0.5 });
      if (ref.current) observer.observe(ref.current);
      return () => {
        observer.disconnect();
      };
    }
  }, [prefetch]);
  React8.useEffect(() => {
    if (maybePrefetch) {
      let id = setTimeout(() => {
        setShouldPrefetch(true);
      }, 100);
      return () => {
        clearTimeout(id);
      };
    }
  }, [maybePrefetch]);
  let setIntent = () => {
    setMaybePrefetch(true);
  };
  let cancelIntent = () => {
    setMaybePrefetch(false);
    setShouldPrefetch(false);
  };
  if (!frameworkContext) {
    return [false, ref, {}];
  }
  if (prefetch !== "intent") {
    return [shouldPrefetch, ref, {}];
  }
  return [
    shouldPrefetch,
    ref,
    {
      onFocus: composeEventHandlers(onFocus, setIntent),
      onBlur: composeEventHandlers(onBlur, cancelIntent),
      onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
      onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
      onTouchStart: composeEventHandlers(onTouchStart, setIntent)
    }
  ];
}
function composeEventHandlers(theirHandler, ourHandler) {
  return (event) => {
    theirHandler && theirHandler(event);
    if (!event.defaultPrevented) {
      ourHandler(event);
    }
  };
}
function getActiveMatches(matches, errors, isSpaMode) {
  if (isSpaMode && !isHydrated) {
    return [matches[0]];
  }
  return matches;
}
function PrefetchPageLinks(_k) {
  var _l = _k, { page } = _l, linkProps = __objRest(_l, ["page"]);
  let { router } = useDataRouterContext2();
  let matches = React8.useMemo(
    () => matchRoutes(router.routes, page, router.basename),
    [router.routes, page, router.basename]
  );
  if (!matches) {
    return null;
  }
  return /* @__PURE__ */ React8.createElement(PrefetchPageLinksImpl, __spreadValues({ page, matches }, linkProps));
}
function useKeyedPrefetchLinks(matches) {
  let { manifest, routeModules } = useFrameworkContext();
  let [keyedPrefetchLinks, setKeyedPrefetchLinks] = React8.useState([]);
  React8.useEffect(() => {
    let interrupted = false;
    void getKeyedPrefetchLinks(matches, manifest, routeModules).then(
      (links) => {
        if (!interrupted) {
          setKeyedPrefetchLinks(links);
        }
      }
    );
    return () => {
      interrupted = true;
    };
  }, [matches, manifest, routeModules]);
  return keyedPrefetchLinks;
}
function PrefetchPageLinksImpl(_m) {
  var _n = _m, {
    page,
    matches: nextMatches
  } = _n, linkProps = __objRest(_n, [
    "page",
    "matches"
  ]);
  let location = useLocation();
  let { manifest, routeModules } = useFrameworkContext();
  let { basename } = useDataRouterContext2();
  let { loaderData, matches } = useDataRouterStateContext();
  let newMatchesForData = React8.useMemo(
    () => getNewMatchesForLinks(
      page,
      nextMatches,
      matches,
      manifest,
      location,
      "data"
    ),
    [page, nextMatches, matches, manifest, location]
  );
  let newMatchesForAssets = React8.useMemo(
    () => getNewMatchesForLinks(
      page,
      nextMatches,
      matches,
      manifest,
      location,
      "assets"
    ),
    [page, nextMatches, matches, manifest, location]
  );
  let dataHrefs = React8.useMemo(() => {
    if (page === location.pathname + location.search + location.hash) {
      return [];
    }
    let routesParams = /* @__PURE__ */ new Set();
    let foundOptOutRoute = false;
    nextMatches.forEach((m) => {
      var _a2;
      let manifestRoute = manifest.routes[m.route.id];
      if (!manifestRoute || !manifestRoute.hasLoader) {
        return;
      }
      if (!newMatchesForData.some((m2) => m2.route.id === m.route.id) && m.route.id in loaderData && ((_a2 = routeModules[m.route.id]) == null ? void 0 : _a2.shouldRevalidate)) {
        foundOptOutRoute = true;
      } else if (manifestRoute.hasClientLoader) {
        foundOptOutRoute = true;
      } else {
        routesParams.add(m.route.id);
      }
    });
    if (routesParams.size === 0) {
      return [];
    }
    let url = singleFetchUrl(page, basename, "data");
    if (foundOptOutRoute && routesParams.size > 0) {
      url.searchParams.set(
        "_routes",
        nextMatches.filter((m) => routesParams.has(m.route.id)).map((m) => m.route.id).join(",")
      );
    }
    return [url.pathname + url.search];
  }, [
    basename,
    loaderData,
    location,
    manifest,
    newMatchesForData,
    nextMatches,
    page,
    routeModules
  ]);
  let moduleHrefs = React8.useMemo(
    () => getModuleLinkHrefs(newMatchesForAssets, manifest),
    [newMatchesForAssets, manifest]
  );
  let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);
  return /* @__PURE__ */ React8.createElement(React8.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ React8.createElement("link", __spreadValues({ key: href, rel: "prefetch", as: "fetch", href }, linkProps))), moduleHrefs.map((href) => /* @__PURE__ */ React8.createElement("link", __spreadValues({ key: href, rel: "modulepreload", href }, linkProps))), keyedPrefetchLinks.map(({ key, link }) => (
    // these don't spread `linkProps` because they are full link descriptors
    // already with their own props
    /* @__PURE__ */ React8.createElement("link", __spreadValues({ key, nonce: linkProps.nonce }, link))
  )));
}
var isHydrated = false;
function setIsHydrated() {
  isHydrated = true;
}
function Scripts(scriptProps) {
  let {
    manifest,
    serverHandoffString,
    isSpaMode,
    renderMeta,
    routeDiscovery,
    ssr
  } = useFrameworkContext();
  let { router, static: isStatic, staticContext } = useDataRouterContext2();
  let { matches: routerMatches } = useDataRouterStateContext();
  let isRSCRouterContext = useIsRSCRouterContext();
  let enableFogOfWar = isFogOfWarEnabled(routeDiscovery, ssr);
  if (renderMeta) {
    renderMeta.didRenderScripts = true;
  }
  let matches = getActiveMatches(routerMatches, null, isSpaMode);
  React8.useEffect(() => {
    setIsHydrated();
  }, []);
  let initialScripts = React8.useMemo(() => {
    var _a2;
    if (isRSCRouterContext) {
      return null;
    }
    let streamScript = "window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());";
    let contextScript = staticContext ? `window.__reactRouterContext = ${serverHandoffString};${streamScript}` : " ";
    let routeModulesScript = !isStatic ? " " : `${((_a2 = manifest.hmr) == null ? void 0 : _a2.runtime) ? `import ${JSON.stringify(manifest.hmr.runtime)};` : ""}${!enableFogOfWar ? `import ${JSON.stringify(manifest.url)}` : ""};
${matches.map((match2, routeIndex) => {
      let routeVarName = `route${routeIndex}`;
      let manifestEntry = manifest.routes[match2.route.id];
      invariant2(manifestEntry, `Route ${match2.route.id} not found in manifest`);
      let {
        clientActionModule,
        clientLoaderModule,
        clientMiddlewareModule,
        hydrateFallbackModule,
        module
      } = manifestEntry;
      let chunks = [
        ...clientActionModule ? [
          {
            module: clientActionModule,
            varName: `${routeVarName}_clientAction`
          }
        ] : [],
        ...clientLoaderModule ? [
          {
            module: clientLoaderModule,
            varName: `${routeVarName}_clientLoader`
          }
        ] : [],
        ...clientMiddlewareModule ? [
          {
            module: clientMiddlewareModule,
            varName: `${routeVarName}_clientMiddleware`
          }
        ] : [],
        ...hydrateFallbackModule ? [
          {
            module: hydrateFallbackModule,
            varName: `${routeVarName}_HydrateFallback`
          }
        ] : [],
        { module, varName: `${routeVarName}_main` }
      ];
      if (chunks.length === 1) {
        return `import * as ${routeVarName} from ${JSON.stringify(module)};`;
      }
      let chunkImportsSnippet = chunks.map((chunk) => `import * as ${chunk.varName} from "${chunk.module}";`).join("\n");
      let mergedChunksSnippet = `const ${routeVarName} = {${chunks.map((chunk) => `...${chunk.varName}`).join(",")}};`;
      return [chunkImportsSnippet, mergedChunksSnippet].join("\n");
    }).join("\n")}
  ${enableFogOfWar ? (
      // Inline a minimal manifest with the SSR matches
      `window.__reactRouterManifest = ${JSON.stringify(
        getPartialManifest(manifest, router),
        null,
        2
      )};`
    ) : ""}
  window.__reactRouterRouteModules = {${matches.map((match2, index2) => `${JSON.stringify(match2.route.id)}:route${index2}`).join(",")}};

import(${JSON.stringify(manifest.entry.module)});`;
    return /* @__PURE__ */ React8.createElement(React8.Fragment, null, /* @__PURE__ */ React8.createElement(
      "script",
      __spreadProps(__spreadValues({}, scriptProps), {
        suppressHydrationWarning: true,
        dangerouslySetInnerHTML: { __html: contextScript },
        type: void 0
      })
    ), /* @__PURE__ */ React8.createElement(
      "script",
      __spreadProps(__spreadValues({}, scriptProps), {
        suppressHydrationWarning: true,
        dangerouslySetInnerHTML: { __html: routeModulesScript },
        type: "module",
        async: true
      })
    ));
  }, []);
  let preloads = isHydrated || isRSCRouterContext ? [] : dedupe(
    manifest.entry.imports.concat(
      getModuleLinkHrefs(matches, manifest, {
        includeHydrateFallback: true
      })
    )
  );
  let sri = typeof manifest.sri === "object" ? manifest.sri : {};
  warnOnce(
    !isRSCRouterContext,
    "The <Scripts /> element is a no-op when using RSC and can be safely removed."
  );
  return isHydrated || isRSCRouterContext ? null : /* @__PURE__ */ React8.createElement(React8.Fragment, null, typeof manifest.sri === "object" ? /* @__PURE__ */ React8.createElement(
    "script",
    {
      "rr-importmap": "",
      type: "importmap",
      suppressHydrationWarning: true,
      dangerouslySetInnerHTML: {
        __html: JSON.stringify({
          integrity: sri
        })
      }
    }
  ) : null, !enableFogOfWar ? /* @__PURE__ */ React8.createElement(
    "link",
    {
      rel: "modulepreload",
      href: manifest.url,
      crossOrigin: scriptProps.crossOrigin,
      integrity: sri[manifest.url],
      suppressHydrationWarning: true
    }
  ) : null, /* @__PURE__ */ React8.createElement(
    "link",
    {
      rel: "modulepreload",
      href: manifest.entry.module,
      crossOrigin: scriptProps.crossOrigin,
      integrity: sri[manifest.entry.module],
      suppressHydrationWarning: true
    }
  ), preloads.map((path) => /* @__PURE__ */ React8.createElement(
    "link",
    {
      key: path,
      rel: "modulepreload",
      href: path,
      crossOrigin: scriptProps.crossOrigin,
      integrity: sri[path],
      suppressHydrationWarning: true
    }
  )), initialScripts);
}
function dedupe(array) {
  return [...new Set(array)];
}
function mergeRefs(...refs) {
  return (value) => {
    refs.forEach((ref) => {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
}
(class extends React9.Component {
  constructor(props) {
    super(props);
    this.state = { error: props.error || null, location: props.location };
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location) {
      return { error: props.error || null, location: props.location };
    }
    return { error: props.error || state.error, location: state.location };
  }
  render() {
    if (this.state.error) {
      return /* @__PURE__ */ React9.createElement(
        RemixRootDefaultErrorBoundary,
        {
          error: this.state.error,
          isOutsideRemixApp: true
        }
      );
    } else {
      return this.props.children;
    }
  }
});
function RemixRootDefaultErrorBoundary({
  error,
  isOutsideRemixApp
}) {
  console.error(error);
  let heyDeveloper = /* @__PURE__ */ React9.createElement(
    "script",
    {
      dangerouslySetInnerHTML: {
        __html: `
        console.log(
          " Hey developer . You can provide a way better UX than this when your app throws errors. Check out https://reactrouter.com/how-to/error-boundary for more information."
        );
      `
      }
    }
  );
  if (isRouteErrorResponse(error)) {
    return /* @__PURE__ */ React9.createElement(BoundaryShell, { title: "Unhandled Thrown Response!" }, /* @__PURE__ */ React9.createElement("h1", { style: { fontSize: "24px" } }, error.status, " ", error.statusText), heyDeveloper);
  }
  let errorInstance;
  if (error instanceof Error) {
    errorInstance = error;
  } else {
    let errorString = error == null ? "Unknown Error" : typeof error === "object" && "toString" in error ? error.toString() : JSON.stringify(error);
    errorInstance = new Error(errorString);
  }
  return /* @__PURE__ */ React9.createElement(
    BoundaryShell,
    {
      title: "Application Error!",
      isOutsideRemixApp
    },
    /* @__PURE__ */ React9.createElement("h1", { style: { fontSize: "24px" } }, "Application Error"),
    /* @__PURE__ */ React9.createElement(
      "pre",
      {
        style: {
          padding: "2rem",
          background: "hsla(10, 50%, 50%, 0.1)",
          color: "red",
          overflow: "auto"
        }
      },
      errorInstance.stack
    ),
    heyDeveloper
  );
}
function BoundaryShell({
  title,
  renderScripts,
  isOutsideRemixApp,
  children
}) {
  var _a2;
  let { routeModules } = useFrameworkContext();
  if (((_a2 = routeModules.root) == null ? void 0 : _a2.Layout) && !isOutsideRemixApp) {
    return children;
  }
  return /* @__PURE__ */ React9.createElement("html", { lang: "en" }, /* @__PURE__ */ React9.createElement("head", null, /* @__PURE__ */ React9.createElement("meta", { charSet: "utf-8" }), /* @__PURE__ */ React9.createElement(
    "meta",
    {
      name: "viewport",
      content: "width=device-width,initial-scale=1,viewport-fit=cover"
    }
  ), /* @__PURE__ */ React9.createElement("title", null, title)), /* @__PURE__ */ React9.createElement("body", null, /* @__PURE__ */ React9.createElement("main", { style: { fontFamily: "system-ui, sans-serif", padding: "2rem" } }, children, renderScripts ? /* @__PURE__ */ React9.createElement(Scripts, null) : null)));
}
const React10 = window["React"];
var isBrowser$2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
try {
  if (isBrowser$2) {
    window.__reactRouterVersion = // @ts-expect-error
    "7.9.4";
  }
} catch (e) {
}
var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var Link = React10.forwardRef(
  function LinkWithRef(_o, forwardedRef) {
    var _p = _o, {
      onClick,
      discover = "render",
      prefetch = "none",
      relative,
      reloadDocument,
      replace: replace2,
      state,
      target,
      to,
      preventScrollReset,
      viewTransition
    } = _p, rest = __objRest(_p, [
      "onClick",
      "discover",
      "prefetch",
      "relative",
      "reloadDocument",
      "replace",
      "state",
      "target",
      "to",
      "preventScrollReset",
      "viewTransition"
    ]);
    let { basename } = React10.useContext(NavigationContext);
    let isAbsolute = typeof to === "string" && ABSOLUTE_URL_REGEX2.test(to);
    let absoluteHref;
    let isExternal = false;
    if (typeof to === "string" && isAbsolute) {
      absoluteHref = to;
      if (isBrowser$2) {
        try {
          let currentUrl = new URL(window.location.href);
          let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
          let path = stripBasename(targetUrl.pathname, basename);
          if (targetUrl.origin === currentUrl.origin && path != null) {
            to = path + targetUrl.search + targetUrl.hash;
          } else {
            isExternal = true;
          }
        } catch (e) {
          warning(
            false,
            `<Link to="${to}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
          );
        }
      }
    }
    let href = useHref(to, { relative });
    let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(
      prefetch,
      rest
    );
    let internalOnClick = useLinkClickHandler(to, {
      replace: replace2,
      state,
      target,
      preventScrollReset,
      relative,
      viewTransition
    });
    function handleClick(event) {
      if (onClick) onClick(event);
      if (!event.defaultPrevented) {
        internalOnClick(event);
      }
    }
    let link = (
      // eslint-disable-next-line jsx-a11y/anchor-has-content
      /* @__PURE__ */ React10.createElement(
        "a",
        __spreadProps(__spreadValues(__spreadValues({}, rest), prefetchHandlers), {
          href: absoluteHref || href,
          onClick: isExternal || reloadDocument ? onClick : handleClick,
          ref: mergeRefs(forwardedRef, prefetchRef),
          target,
          "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
        })
      )
    );
    return shouldPrefetch && !isAbsolute ? /* @__PURE__ */ React10.createElement(React10.Fragment, null, link, /* @__PURE__ */ React10.createElement(PrefetchPageLinks, { page: href })) : link;
  }
);
Link.displayName = "Link";
var NavLink = React10.forwardRef(
  function NavLinkWithRef(_q, ref) {
    var _r = _q, {
      "aria-current": ariaCurrentProp = "page",
      caseSensitive = false,
      className: classNameProp = "",
      end: end2 = false,
      style: styleProp,
      to,
      viewTransition,
      children
    } = _r, rest = __objRest(_r, [
      "aria-current",
      "caseSensitive",
      "className",
      "end",
      "style",
      "to",
      "viewTransition",
      "children"
    ]);
    let path = useResolvedPath(to, { relative: rest.relative });
    let location = useLocation();
    let routerState = React10.useContext(DataRouterStateContext);
    let { navigator: navigator2, basename } = React10.useContext(NavigationContext);
    let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useViewTransitionState(path) && viewTransition === true;
    let toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path).pathname : path.pathname;
    let locationPathname = location.pathname;
    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
    if (!caseSensitive) {
      locationPathname = locationPathname.toLowerCase();
      nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
      toPathname = toPathname.toLowerCase();
    }
    if (nextLocationPathname && basename) {
      nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
    }
    const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
    let isActive = locationPathname === toPathname || !end2 && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end2 && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
    let renderProps = {
      isActive,
      isPending,
      isTransitioning
    };
    let ariaCurrent = isActive ? ariaCurrentProp : void 0;
    let className;
    if (typeof classNameProp === "function") {
      className = classNameProp(renderProps);
    } else {
      className = [
        classNameProp,
        isActive ? "active" : null,
        isPending ? "pending" : null,
        isTransitioning ? "transitioning" : null
      ].filter(Boolean).join(" ");
    }
    let style2 = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
    return /* @__PURE__ */ React10.createElement(
      Link,
      __spreadProps(__spreadValues({}, rest), {
        "aria-current": ariaCurrent,
        className,
        ref,
        style: style2,
        to,
        viewTransition
      }),
      typeof children === "function" ? children(renderProps) : children
    );
  }
);
NavLink.displayName = "NavLink";
var Form = React10.forwardRef(
  (_s, forwardedRef) => {
    var _t = _s, {
      discover = "render",
      fetcherKey,
      navigate,
      reloadDocument,
      replace: replace2,
      state,
      method = defaultMethod,
      action,
      onSubmit,
      relative,
      preventScrollReset,
      viewTransition
    } = _t, props = __objRest(_t, [
      "discover",
      "fetcherKey",
      "navigate",
      "reloadDocument",
      "replace",
      "state",
      "method",
      "action",
      "onSubmit",
      "relative",
      "preventScrollReset",
      "viewTransition"
    ]);
    let submit = useSubmit();
    let formAction = useFormAction(action, { relative });
    let formMethod = method.toLowerCase() === "get" ? "get" : "post";
    let isAbsolute = typeof action === "string" && ABSOLUTE_URL_REGEX2.test(action);
    let submitHandler = (event) => {
      onSubmit && onSubmit(event);
      if (event.defaultPrevented) return;
      event.preventDefault();
      let submitter = event.nativeEvent.submitter;
      let submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;
      submit(submitter || event.currentTarget, {
        fetcherKey,
        method: submitMethod,
        navigate,
        replace: replace2,
        state,
        relative,
        preventScrollReset,
        viewTransition
      });
    };
    return /* @__PURE__ */ React10.createElement(
      "form",
      __spreadProps(__spreadValues({
        ref: forwardedRef,
        method: formMethod,
        action: formAction,
        onSubmit: reloadDocument ? onSubmit : submitHandler
      }, props), {
        "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
      })
    );
  }
);
Form.displayName = "Form";
function getDataRouterConsoleError2(hookName) {
  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function useDataRouterContext3(hookName) {
  let ctx = React10.useContext(DataRouterContext);
  invariant(ctx, getDataRouterConsoleError2(hookName));
  return ctx;
}
function useLinkClickHandler(to, {
  target,
  replace: replaceProp,
  state,
  preventScrollReset,
  relative,
  viewTransition
} = {}) {
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to, { relative });
  return React10.useCallback(
    (event) => {
      if (shouldProcessLinkClick(event, target)) {
        event.preventDefault();
        let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
        navigate(to, {
          replace: replace2,
          state,
          preventScrollReset,
          relative,
          viewTransition
        });
      }
    },
    [
      location,
      navigate,
      path,
      replaceProp,
      state,
      target,
      to,
      preventScrollReset,
      relative,
      viewTransition
    ]
  );
}
var fetcherId = 0;
var getUniqueFetcherId = () => `__${String(++fetcherId)}__`;
function useSubmit() {
  let { router } = useDataRouterContext3(
    "useSubmit"
    /* UseSubmit */
  );
  let { basename } = React10.useContext(NavigationContext);
  let currentRouteId = useRouteId();
  return React10.useCallback(
    (_0, ..._1) => __async(null, [_0, ..._1], function* (target, options = {}) {
      let { action, method, encType, formData, body: body2 } = getFormSubmissionInfo(
        target,
        basename
      );
      if (options.navigate === false) {
        let key = options.fetcherKey || getUniqueFetcherId();
        yield router.fetch(key, currentRouteId, options.action || action, {
          preventScrollReset: options.preventScrollReset,
          formData,
          body: body2,
          formMethod: options.method || method,
          formEncType: options.encType || encType,
          flushSync: options.flushSync
        });
      } else {
        yield router.navigate(options.action || action, {
          preventScrollReset: options.preventScrollReset,
          formData,
          body: body2,
          formMethod: options.method || method,
          formEncType: options.encType || encType,
          replace: options.replace,
          state: options.state,
          fromRouteId: currentRouteId,
          flushSync: options.flushSync,
          viewTransition: options.viewTransition
        });
      }
    }),
    [router, basename, currentRouteId]
  );
}
function useFormAction(action, { relative } = {}) {
  let { basename } = React10.useContext(NavigationContext);
  let routeContext = React10.useContext(RouteContext);
  invariant(routeContext, "useFormAction must be used inside a RouteContext");
  let [match2] = routeContext.matches.slice(-1);
  let path = __spreadValues({}, useResolvedPath(action ? action : ".", { relative }));
  let location = useLocation();
  if (action == null) {
    path.search = location.search;
    let params = new URLSearchParams(path.search);
    let indexValues = params.getAll("index");
    let hasNakedIndexParam = indexValues.some((v) => v === "");
    if (hasNakedIndexParam) {
      params.delete("index");
      indexValues.filter((v) => v).forEach((v) => params.append("index", v));
      let qs = params.toString();
      path.search = qs ? `?${qs}` : "";
    }
  }
  if ((!action || action === ".") && match2.route.index) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  }
  if (basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
function useViewTransitionState(to, { relative } = {}) {
  let vtContext = React10.useContext(ViewTransitionContext);
  invariant(
    vtContext != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
  );
  let { basename } = useDataRouterContext3(
    "useViewTransitionState"
    /* useViewTransitionState */
  );
  let path = useResolvedPath(to, { relative });
  if (!vtContext.isTransitioning) {
    return false;
  }
  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
}
const useState$w = window["React"].useState;
const useEffect$r = window["React"].useEffect;
const useCallback$a = window["React"].useCallback;
function ScanHistory({ onBack }) {
  const navigate = useNavigate();
  const [scans, setScans] = useState$w([]);
  const [loading, setLoading] = useState$w(true);
  const [error, setError] = useState$w(null);
  const [selectedScan, setSelectedScan] = useState$w(null);
  const [strainDetails, setStrainDetails] = useState$w(null);
  const [loadingDetails, setLoadingDetails] = useState$w(false);
  const fetchScans = useCallback$a(() => __async(null, null, function* () {
    var _a2, _b, _c;
    try {
      setLoading(true);
      let userId = null;
      try {
        const session = yield supabase == null ? void 0 : supabase.auth.getSession();
        userId = ((_c = (_b = (_a2 = session == null ? void 0 : session.data) == null ? void 0 : _a2.session) == null ? void 0 : _b.user) == null ? void 0 : _c.id) || null;
      } catch (sessionError) {
        console.debug("[ScanHistory] getSession failed", sessionError);
      }
      const url = userId ? `${API_BASE}/api/scans?user_id=${encodeURIComponent(userId)}` : `${API_BASE}/api/scans`;
      const response = yield fetch(url);
      if (!response.ok) throw new Error("Failed to fetch scans");
      const data = yield response.json();
      setScans(data.scans || []);
      setError(null);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }), []);
  useEffect$r(() => {
    fetchScans();
  }, [fetchScans]);
  const handleViewStrain = (scan) => __async(null, null, function* () {
    if (!scan.matched_strain_slug) return;
    setSelectedScan(scan);
    setLoadingDetails(true);
    try {
      const response = yield fetch(`${API_BASE}/api/strains/${scan.matched_strain_slug}`);
      if (response.ok) {
        const data = yield response.json();
        setStrainDetails(data);
      } else {
        setStrainDetails(null);
      }
    } catch (err) {
      console.error("Failed to load strain details:", err);
      setStrainDetails(null);
    } finally {
      setLoadingDetails(false);
    }
  });
  const handleCloseDialog = () => {
    setSelectedScan(null);
    setStrainDetails(null);
  };
  return /* @__PURE__ */ React.createElement(Box, { sx: { minHeight: "100vh", py: 4 } }, /* @__PURE__ */ React.createElement(Container, { maxWidth: "md" }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", justifyContent: "space-between", alignItems: "center", sx: { mb: 3 } }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1, alignItems: "center" }, /* @__PURE__ */ React.createElement(CannabisLeafIcon, { style: { height: 28 } }), /* @__PURE__ */ React.createElement(Typography, { variant: "h5", fontWeight: 700 }, "Scan History")), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1 }, onBack && /* @__PURE__ */ React.createElement(Button, { variant: "outlined", onClick: onBack }, "Back"), /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "contained",
      color: "success",
      startIcon: /* @__PURE__ */ React.createElement(CannabisLeafIcon, { style: { height: 20 } }),
      onClick: () => navigate("/"),
      sx: { textTransform: "none" }
    },
    "Home"
  ))), loading && /* @__PURE__ */ React.createElement(Box, { sx: { display: "flex", justifyContent: "center", py: 6 } }, /* @__PURE__ */ React.createElement(CircularProgress, null)), !loading && error && /* @__PURE__ */ React.createElement(Alert, { severity: "error", sx: { mb: 3 } }, error), !loading && !error && scans.length === 0 && /* @__PURE__ */ React.createElement(Alert, { severity: "info" }, "No scans found yet. Run a scan to see it appear here."), !loading && !error && scans.length > 0 && /* @__PURE__ */ React.createElement(Stack, { spacing: 2 }, scans.map((scan) => /* @__PURE__ */ React.createElement(
    Card,
    {
      key: scan.id,
      variant: "outlined",
      sx: { borderRadius: 3, background: "rgba(255,255,255,0.08)" }
    },
    /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Stack, { direction: "row", justifyContent: "space-between", alignItems: "center" }, /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", fontWeight: 600 }, scan.matched_strain_name || "Unknown Strain"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, "Scanned on ", new Date(scan.created_at).toLocaleString())), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1 }, /* @__PURE__ */ React.createElement(
      Button,
      {
        size: "small",
        variant: "contained",
        color: "success",
        onClick: () => handleViewStrain(scan),
        disabled: !scan.matched_strain_slug
      },
      "View Details"
    ))), scan.notes && /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { mt: 1 } }, scan.notes))
  )))), /* @__PURE__ */ React.createElement(
    Dialog,
    {
      open: Boolean(selectedScan),
      onClose: handleCloseDialog,
      maxWidth: "sm",
      fullWidth: true
    },
    /* @__PURE__ */ React.createElement(DialogTitle, null, /* @__PURE__ */ React.createElement(Stack, { direction: "row", justifyContent: "space-between", alignItems: "center" }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 1 }, /* @__PURE__ */ React.createElement(LocalFloristIcon, { color: "success" }), /* @__PURE__ */ React.createElement(Typography, { variant: "h6", fontWeight: 600 }, "Strain Details")), /* @__PURE__ */ React.createElement(
      Button,
      {
        onClick: handleCloseDialog,
        size: "small",
        color: "inherit",
        startIcon: /* @__PURE__ */ React.createElement(CloseIcon, { fontSize: "small" })
      },
      "Close"
    ))),
    /* @__PURE__ */ React.createElement(DialogContent, { dividers: true }, loadingDetails && /* @__PURE__ */ React.createElement(Box, { sx: { display: "flex", justifyContent: "center", py: 4 } }, /* @__PURE__ */ React.createElement(CircularProgress, null)), !loadingDetails && strainDetails && /* @__PURE__ */ React.createElement(Stack, { spacing: 2 }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6" }, strainDetails.name), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, strainDetails.description || "No description available."), Array.isArray(strainDetails.effects) && strainDetails.effects.length > 0 && /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", gutterBottom: true }, "Effects"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, strainDetails.effects.join(", "))), Array.isArray(strainDetails.flavors) && strainDetails.flavors.length > 0 && /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", gutterBottom: true }, "Flavors"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, strainDetails.flavors.join(", ")))), !loadingDetails && !strainDetails && /* @__PURE__ */ React.createElement(Alert, { severity: "info" }, "Strain details not available.")),
    selectedScan && /* @__PURE__ */ React.createElement(DialogActions, null, /* @__PURE__ */ React.createElement(Typography, { variant: "caption", color: "text.secondary", sx: { px: 2, pb: 1 } }, "Scan ID: ", selectedScan.id))
  ));
}
const useState$v = window["React"].useState;
function MembershipLogin({ onSuccess }) {
  const [email, setEmail] = useState$v("");
  const [name2, setName] = useState$v("");
  const [loading, setLoading] = useState$v(false);
  const [error, setError] = useState$v("");
  const [applied, setApplied] = useState$v(false);
  const handleApply = () => __async(null, null, function* () {
    setLoading(true);
    setError("");
    try {
      const resp = yield fetch(`${API_BASE}/api/membership/apply`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email, full_name: name2 })
      });
      const data = yield resp.json();
      if (!resp.ok || !data.success) throw new Error(data.error || "Application failed");
      setApplied(true);
    } catch (e) {
      setError(e.message);
    }
    setLoading(false);
  });
  return /* @__PURE__ */ React.createElement(Box, { sx: { minHeight: "100vh", display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", background: "none" } }, /* @__PURE__ */ React.createElement(Paper, { sx: { p: 4, borderRadius: 6, minWidth: 340, maxWidth: 400, textAlign: "center", background: "rgba(255,255,255,0.15)", backdropFilter: "blur(20px)", border: "2px solid rgba(124, 179, 66, 0.3)" } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h4", sx: { mb: 2, color: "#fff", fontWeight: 900 } }, "Enter the Garden"), /* @__PURE__ */ React.createElement(Typography, { variant: "body1", sx: { mb: 3, color: "#e0e0e0" } }, "Welcome! Please apply for membership to access the full app."), /* @__PURE__ */ React.createElement(
    TextField,
    {
      label: "Full Name",
      value: name2,
      onChange: (e) => setName(e.target.value),
      fullWidth: true,
      sx: { mb: 2 }
    }
  ), /* @__PURE__ */ React.createElement(
    TextField,
    {
      label: "Email Address",
      value: email,
      onChange: (e) => setEmail(e.target.value),
      fullWidth: true,
      sx: { mb: 2 }
    }
  ), error && /* @__PURE__ */ React.createElement(Typography, { color: "error", sx: { mb: 2 } }, error), !applied ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "contained",
      color: "success",
      sx: {
        fontWeight: 700,
        borderRadius: 999,
        px: 4,
        py: 1,
        fontSize: 18,
        boxShadow: "none",
        bgcolor: "rgba(124, 179, 66, 0.3)",
        border: "2px solid rgba(124, 179, 66, 0.6)",
        backdropFilter: "blur(10px)",
        color: "#fff",
        textTransform: "none",
        mb: 2,
        "&:hover": {
          bgcolor: "rgba(124, 179, 66, 0.5)",
          border: "2px solid rgba(124, 179, 66, 0.8)"
        }
      },
      onClick: handleApply,
      disabled: loading || !email || !name2
    },
    loading ? /* @__PURE__ */ React.createElement(CircularProgress, { size: 24, color: "inherit" }) : "Apply for Membership"
  ), /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "text",
      sx: {
        fontWeight: 600,
        color: "#fff",
        textTransform: "none",
        bgcolor: "rgba(124, 179, 66, 0.15)",
        backdropFilter: "blur(10px)",
        "&:hover": {
          bgcolor: "rgba(124, 179, 66, 0.25)"
        }
      },
      onClick: () => onSuccess && onSuccess()
    },
    "Skip for now (Browse only)"
  )) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { mt: 3, color: "#fff", mb: 2 } }, "Membership application complete! You may now enter the garden."), /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "contained",
      color: "success",
      sx: {
        fontWeight: 700,
        borderRadius: 999,
        px: 4,
        py: 1,
        fontSize: 18,
        boxShadow: "none",
        bgcolor: "rgba(124, 179, 66, 0.3)",
        border: "2px solid rgba(124, 179, 66, 0.6)",
        backdropFilter: "blur(10px)",
        color: "#fff",
        textTransform: "none",
        "&:hover": {
          bgcolor: "rgba(124, 179, 66, 0.5)",
          border: "2px solid rgba(124, 179, 66, 0.8)"
        }
      },
      onClick: () => onSuccess && onSuccess()
    },
    "Continue"
  ))));
}
const React$6 = window["React"];
let ErrorBoundary$1 = class ErrorBoundary extends React$6.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }
  static getDerivedStateFromError() {
    return { hasError: true };
  }
  componentDidCatch(error, errorInfo) {
    this.setState({ error, errorInfo });
    console.error("\n FRONTEND ERROR CAUGHT BY BOUNDARY ");
    console.error("");
    console.error("Time:", (/* @__PURE__ */ new Date()).toISOString());
    console.error("Error:", error.toString());
    console.error("Component Stack:", errorInfo.componentStack);
    console.error("\n");
  }
  render() {
    if (this.state.hasError) {
      return /* @__PURE__ */ React$6.createElement(Container, { maxWidth: "md", sx: { py: 8 } }, /* @__PURE__ */ React$6.createElement(Card, { sx: { bgcolor: "rgba(211, 47, 47, 0.05)", border: "2px solid #d32f2f44" } }, /* @__PURE__ */ React$6.createElement(CardContent, null, /* @__PURE__ */ React$6.createElement(Typography, { variant: "h4", gutterBottom: true, color: "error" }, " Something went wrong"), /* @__PURE__ */ React$6.createElement(Alert, { severity: "error", sx: { mb: 3 } }, /* @__PURE__ */ React$6.createElement(Typography, { variant: "body1", fontWeight: "bold" }, this.state.error && this.state.error.toString())), /* @__PURE__ */ React$6.createElement(Typography, { variant: "body2", color: "text.secondary", sx: { mb: 2 } }, "The application encountered an error. This has been logged to the console."), /* @__PURE__ */ React$6.createElement(Box, { sx: { mb: 3 } }, /* @__PURE__ */ React$6.createElement(Typography, { variant: "caption", color: "text.secondary", sx: { display: "block", mb: 1 } }, "Component Stack:"), /* @__PURE__ */ React$6.createElement(
        Box,
        {
          component: "pre",
          sx: {
            bgcolor: "rgba(0,0,0,0.05)",
            p: 2,
            borderRadius: 1,
            fontSize: "0.75rem",
            overflow: "auto",
            maxHeight: 300
          }
        },
        this.state.errorInfo && this.state.errorInfo.componentStack
      )), /* @__PURE__ */ React$6.createElement(
        Button,
        {
          variant: "contained",
          onClick: () => window.location.reload(),
          sx: { mr: 2 }
        },
        "Reload Page"
      ), /* @__PURE__ */ React$6.createElement(
        Button,
        {
          variant: "outlined",
          onClick: () => {
            this.setState({ hasError: false, error: null, errorInfo: null });
            window.history.back();
          }
        },
        "Go Back"
      ), /* @__PURE__ */ React$6.createElement(Alert, { severity: "info", sx: { mt: 3 } }, /* @__PURE__ */ React$6.createElement(Typography, { variant: "caption", fontWeight: "bold" }, " For developers:"), /* @__PURE__ */ React$6.createElement(Typography, { variant: "caption", display: "block" }, " Open browser DevTools (F12)  Console tab for full error details"), /* @__PURE__ */ React$6.createElement(Typography, { variant: "caption", display: "block" }, " Check backend errors at: ", /* @__PURE__ */ React$6.createElement("code", null, "http://localhost:5173/errors")), /* @__PURE__ */ React$6.createElement(Typography, { variant: "caption", display: "block" }, " PM2 logs: ", /* @__PURE__ */ React$6.createElement("code", null, "pm2 logs strainspotter-backend"))))));
    }
    return this.props.children;
  }
};
const useState$u = window["React"].useState;
const useEffect$q = window["React"].useEffect;
const useCallback$9 = window["React"].useCallback;
function SeedVendorFinder({ onBack, strainName, strainSlug }) {
  const [vendors, setVendors] = useState$u([]);
  const [loading, setLoading] = useState$u(false);
  const [error, setError] = useState$u(null);
  const [searchStrain, setSearchStrain] = useState$u(strainName || "");
  const [country, setCountry] = useState$u("all");
  const [showPopular, setShowPopular] = useState$u(false);
  const searchVendors = useCallback$9((strain) => __async(null, null, function* () {
    setLoading(true);
    setError(null);
    setShowPopular(false);
    try {
      let url = `${API_BASE}/api/seeds-live?`;
      if (strain) url += `strain=${encodeURIComponent(strain)}&`;
      if (country !== "all") url += `country=${country}&`;
      url += `include_google=true`;
      const response = yield fetch(url);
      if (!response.ok) throw new Error("Search failed");
      const data = yield response.json();
      setVendors(data.results || []);
    } catch (err) {
      console.error("Seed vendor search failed:", err);
      setError("Failed to find seed vendors. Please try again.");
    } finally {
      setLoading(false);
    }
  }), [country]);
  const loadPopularVendors = useCallback$9(() => __async(null, null, function* () {
    var _a2;
    setLoading(true);
    setError(null);
    setShowPopular(true);
    try {
      const url = `${API_BASE}/api/seeds-live/popular`;
      console.log("[SeedVendorFinder] Fetching from:", url);
      const response = yield fetch(url);
      console.log("[SeedVendorFinder] Response status:", response.status, response.statusText);
      if (!response.ok) throw new Error("Failed to load popular vendors");
      const data = yield response.json();
      console.log("[SeedVendorFinder] Received vendors:", ((_a2 = data == null ? void 0 : data.results) == null ? void 0 : _a2.length) || 0);
      setVendors(data.results || []);
    } catch (err) {
      console.error("[SeedVendorFinder] Failed to load popular vendors:", err);
      setError("Failed to load seed vendors. Please try again.");
    } finally {
      setLoading(false);
    }
  }), []);
  useEffect$q(() => {
    if (strainName || strainSlug) {
      searchVendors(strainSlug || strainName);
    } else {
      loadPopularVendors();
    }
  }, [strainName, strainSlug, searchVendors, loadPopularVendors]);
  const handleSearch = () => {
    if (searchStrain.trim()) {
      searchVendors(searchStrain.trim());
    } else {
      loadPopularVendors();
    }
  };
  return /* @__PURE__ */ React.createElement(Box, { sx: {
    minHeight: "100vh",
    pt: "calc(env(safe-area-inset-top) + 32px)",
    px: 2,
    pb: 2,
    background: "none"
  } }, onBack && /* @__PURE__ */ React.createElement(
    Button,
    {
      size: "small",
      variant: "outlined",
      onClick: onBack,
      startIcon: /* @__PURE__ */ React.createElement(ArrowBack, null),
      sx: {
        color: "#fff",
        borderColor: "rgba(124, 179, 66, 0.6)",
        fontSize: "0.875rem",
        mb: 2,
        "&:hover": {
          borderColor: "rgba(124, 179, 66, 1)",
          bgcolor: "rgba(124, 179, 66, 0.1)"
        }
      }
    },
    "Back"
  ), /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 2, mb: 2 }, /* @__PURE__ */ React.createElement(StoreIcon, { sx: { fontSize: 32, color: "#7cb342" } }), /* @__PURE__ */ React.createElement(Typography, { variant: "h5", sx: { color: "#fff", fontWeight: 700 } }, "Seed Vendor Finder")), /* @__PURE__ */ React.createElement(Paper, { sx: {
    p: 2,
    mb: 2,
    background: "rgba(255,255,255,0.1)",
    backdropFilter: "blur(20px)",
    border: "1px solid rgba(124, 179, 66, 0.3)",
    borderRadius: 2
  } }, /* @__PURE__ */ React.createElement(Grid, { container: true, spacing: 2 }, /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, md: 6 }, /* @__PURE__ */ React.createElement(
    TextField,
    {
      fullWidth: true,
      size: "small",
      label: "Strain Name",
      value: searchStrain,
      onChange: (e) => setSearchStrain(e.target.value),
      placeholder: "e.g., Blue Dream, OG Kush",
      onKeyPress: (e) => e.key === "Enter" && handleSearch(),
      sx: {
        "& .MuiOutlinedInput-root": {
          color: "#fff",
          "& fieldset": { borderColor: "rgba(124, 179, 66, 0.5)" },
          "&:hover fieldset": { borderColor: "rgba(124, 179, 66, 0.7)" },
          "&.Mui-focused fieldset": { borderColor: "#7cb342" }
        },
        "& .MuiInputLabel-root": { color: "#fff" }
      }
    }
  )), /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, md: 3 }, /* @__PURE__ */ React.createElement(FormControl, { fullWidth: true, size: "small" }, /* @__PURE__ */ React.createElement(InputLabel, { sx: { color: "#fff" } }, "Country"), /* @__PURE__ */ React.createElement(
    Select,
    {
      value: country,
      onChange: (e) => setCountry(e.target.value),
      label: "Country",
      sx: {
        color: "#fff",
        "& .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.5)" },
        "&:hover .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.7)" },
        "&.Mui-focused .MuiOutlinedInput-notchedOutline": { borderColor: "#7cb342" }
      }
    },
    /* @__PURE__ */ React.createElement(MenuItem, { value: "all" }, "All Countries"),
    /* @__PURE__ */ React.createElement(MenuItem, { value: "USA" }, "USA"),
    /* @__PURE__ */ React.createElement(MenuItem, { value: "Canada" }, "Canada"),
    /* @__PURE__ */ React.createElement(MenuItem, { value: "Netherlands" }, "Netherlands"),
    /* @__PURE__ */ React.createElement(MenuItem, { value: "Spain" }, "Spain"),
    /* @__PURE__ */ React.createElement(MenuItem, { value: "UK" }, "UK")
  ))), /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, md: 3 }, /* @__PURE__ */ React.createElement(
    Button,
    {
      fullWidth: true,
      variant: "contained",
      onClick: handleSearch,
      disabled: loading,
      sx: {
        bgcolor: "#7cb342",
        "&:hover": { bgcolor: "#689f38" },
        height: "40px"
      }
    },
    loading ? "Searching..." : "Search"
  )))), error && /* @__PURE__ */ React.createElement(Alert, { severity: "error", sx: { mb: 2 } }, error), loading && /* @__PURE__ */ React.createElement(Box, { sx: { display: "flex", justifyContent: "center", py: 8 } }, /* @__PURE__ */ React.createElement(CircularProgress, { sx: { color: "#7cb342" } })), !loading && vendors.length === 0 && /* @__PURE__ */ React.createElement(Paper, { sx: {
    p: 4,
    textAlign: "center",
    background: "rgba(255,255,255,0.1)",
    backdropFilter: "blur(20px)",
    border: "1px solid rgba(124, 179, 66, 0.3)",
    borderRadius: 2
  } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { color: "#fff", mb: 2 } }, "No seed vendors found"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#e0e0e0", mb: 2 } }, "Try a different strain or view popular seed banks."), /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "outlined",
      onClick: loadPopularVendors,
      sx: {
        color: "#fff",
        borderColor: "rgba(124, 179, 66, 0.6)",
        "&:hover": { borderColor: "#7cb342", bgcolor: "rgba(124, 179, 66, 0.1)" }
      }
    },
    "View Popular Seed Banks"
  )), !loading && vendors.length > 0 && /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#e0e0e0", mb: 2 } }, showPopular ? "Popular Seed Banks" : `Found ${vendors.length} seed vendors`), /* @__PURE__ */ React.createElement(Grid, { container: true, spacing: 2 }, vendors.map((vendor) => /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, md: 6, key: vendor.id }, /* @__PURE__ */ React.createElement(Card, { sx: {
    background: "rgba(255,255,255,0.1)",
    backdropFilter: "blur(20px)",
    border: "1px solid rgba(124, 179, 66, 0.3)",
    borderRadius: 2,
    height: "100%"
  } }, /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Stack, { spacing: 2 }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", justifyContent: "space-between", alignItems: "flex-start" }, /* @__PURE__ */ React.createElement(Box, { flex: 1 }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 1, mb: 1 }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { color: "#fff", fontWeight: 600 } }, vendor.name), vendor.verified && /* @__PURE__ */ React.createElement(VerifiedIcon, { sx: { fontSize: 20, color: "#7cb342" } })), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1, flexWrap: "wrap" }, /* @__PURE__ */ React.createElement(
    Chip,
    {
      label: vendor.source,
      size: "small",
      sx: { bgcolor: "rgba(255,255,255,0.2)", color: "#fff", fontSize: "0.65rem", height: 18 }
    }
  ), vendor.country && /* @__PURE__ */ React.createElement(
    Chip,
    {
      label: vendor.country,
      size: "small",
      sx: { bgcolor: "rgba(124, 179, 66, 0.3)", color: "#fff", fontSize: "0.65rem", height: 18 }
    }
  ))), (vendor.website || vendor.product_url) && /* @__PURE__ */ React.createElement(
    IconButton,
    {
      size: "small",
      component: "a",
      href: vendor.website || vendor.product_url,
      target: "_blank",
      sx: { color: "#7cb342" },
      title: "Visit Website"
    },
    /* @__PURE__ */ React.createElement(LanguageIcon, null)
  )), vendor.description && /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#e0e0e0" } }, vendor.description), vendor.price && /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { color: "#7cb342", fontWeight: 600 } }, "$", vendor.price, " ", vendor.currency || "USD"), vendor.seed_count && /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "#e0e0e0" } }, vendor.seed_count, " seeds")), vendor.rating > 0 && /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 0.5 }, /* @__PURE__ */ React.createElement(StarIcon, { sx: { fontSize: 16, color: "#ffd600" } }), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#fff" } }, vendor.rating, " ", vendor.review_count > 0 && `(${vendor.review_count} reviews)`)), vendor.shipping_regions && vendor.shipping_regions.length > 0 && /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 1 }, /* @__PURE__ */ React.createElement(LocalShippingIcon, { sx: { fontSize: 16, color: "#7cb342" } }), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "#e0e0e0" } }, "Ships to: ", vendor.shipping_regions.join(", "))), vendor.payment_methods && vendor.payment_methods.length > 0 && /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 1 }, /* @__PURE__ */ React.createElement(PaymentIcon, { sx: { fontSize: 16, color: "#7cb342" } }), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "#e0e0e0" } }, vendor.payment_methods.join(", "))), vendor.in_stock !== void 0 && /* @__PURE__ */ React.createElement(
    Chip,
    {
      label: vendor.in_stock ? "In Stock" : "Out of Stock",
      size: "small",
      sx: {
        bgcolor: vendor.in_stock ? "rgba(76, 175, 80, 0.3)" : "rgba(244, 67, 54, 0.3)",
        color: "#fff",
        fontSize: "0.75rem",
        width: "fit-content"
      }
    }
  ), (vendor.website || vendor.product_url) && /* @__PURE__ */ React.createElement(
    Button,
    {
      fullWidth: true,
      variant: "contained",
      component: "a",
      href: vendor.website || vendor.product_url,
      target: "_blank",
      sx: {
        bgcolor: "#7cb342",
        "&:hover": { bgcolor: "#689f38" }
      }
    },
    "Visit Store "
  )))))))));
}
const useState$t = window["React"].useState;
const useEffect$p = window["React"].useEffect;
const useCallback$8 = window["React"].useCallback;
const useRef$3 = window["React"].useRef;
function DispensaryFinder({ onBack, strainSlug }) {
  const [dispensaries, setDispensaries] = useState$t([]);
  const [loading, setLoading] = useState$t(false);
  const [error, setError] = useState$t(null);
  const [userLocation, setUserLocation] = useState$t(null);
  const [radius, setRadius] = useState$t(10);
  const [locationStatus, setLocationStatus] = useState$t("detecting");
  const initialRadiusRef = useRef$3(10);
  const searchDispensaries = useCallback$8((lat, lng, searchRadius) => __async(null, null, function* () {
    setLoading(true);
    setError(null);
    try {
      let url = `${API_BASE}/api/dispensaries-live?lat=${lat}&lng=${lng}&radius=${searchRadius}`;
      if (strainSlug) {
        url += `&strain=${strainSlug}`;
      }
      const response = yield fetch(url);
      if (!response.ok) throw new Error("Search failed");
      const data = yield response.json();
      setDispensaries(data.results || []);
    } catch (err) {
      console.error("Dispensary search failed:", err);
      setError("Failed to find dispensaries. Please try again.");
    } finally {
      setLoading(false);
    }
  }), [strainSlug]);
  useEffect$p(() => {
    if (navigator.geolocation) {
      setLocationStatus("detecting");
      const timeoutId = setTimeout(() => {
        console.warn("Location request timed out, using fallback");
        setLocationStatus("denied");
        const fallback = { lat: 37.7749, lng: -122.4194 };
        setUserLocation(fallback);
        searchDispensaries(fallback.lat, fallback.lng, initialRadiusRef.current);
      }, 1e4);
      navigator.geolocation.getCurrentPosition(
        (position2) => {
          clearTimeout(timeoutId);
          const location = {
            lat: position2.coords.latitude,
            lng: position2.coords.longitude
          };
          setUserLocation(location);
          setLocationStatus("success");
          searchDispensaries(location.lat, location.lng, initialRadiusRef.current);
        },
        (error2) => {
          clearTimeout(timeoutId);
          console.error("Location access error:", error2);
          setLocationStatus("denied");
          const fallback = { lat: 37.7749, lng: -122.4194 };
          setUserLocation(fallback);
          searchDispensaries(fallback.lat, fallback.lng, initialRadiusRef.current);
        },
        {
          timeout: 1e4,
          // 10 second timeout (increased from 5)
          maximumAge: 0,
          enableHighAccuracy: true
          // Changed to true for better accuracy
        }
      );
    } else {
      setLocationStatus("unsupported");
      setError("Geolocation is not supported by your browser");
    }
  }, [searchDispensaries]);
  const handleRadiusChange = (event, newValue) => {
    setRadius(newValue);
  };
  const handleSearch = () => {
    if (userLocation) {
      searchDispensaries(userLocation.lat, userLocation.lng, radius);
    }
  };
  const getDirections = (lat, lng) => {
    window.open(`https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`, "_blank");
  };
  return /* @__PURE__ */ React.createElement(Box, { sx: {
    minHeight: "100vh",
    pt: "calc(env(safe-area-inset-top) + 32px)",
    px: 2,
    pb: 2,
    background: "none"
  } }, onBack && /* @__PURE__ */ React.createElement(
    Button,
    {
      size: "small",
      variant: "outlined",
      onClick: onBack,
      startIcon: /* @__PURE__ */ React.createElement(ArrowBack, null),
      sx: {
        color: "#fff",
        borderColor: "rgba(124, 179, 66, 0.6)",
        fontSize: "0.875rem",
        mb: 2,
        "&:hover": {
          borderColor: "rgba(124, 179, 66, 1)",
          bgcolor: "rgba(124, 179, 66, 0.1)"
        }
      }
    },
    "Back"
  ), /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 2, mb: 2 }, /* @__PURE__ */ React.createElement(StoreIcon, { sx: { fontSize: 32, color: "#7cb342" } }), /* @__PURE__ */ React.createElement(Typography, { variant: "h5", sx: { color: "#fff", fontWeight: 700 } }, "Dispensary Finder")), locationStatus === "detecting" && /* @__PURE__ */ React.createElement(Alert, { severity: "info", sx: { mb: 2 } }, "Detecting your location..."), locationStatus === "denied" && /* @__PURE__ */ React.createElement(Alert, { severity: "info", icon: /* @__PURE__ */ React.createElement(StoreIcon, null), sx: { mb: 2, bgcolor: "rgba(124, 179, 66, 0.15)", color: "#fff", border: "1px solid rgba(124, 179, 66, 0.4)" } }, "Using San Francisco, CA as default location. Enable location access in your device settings to see nearby dispensaries."), /* @__PURE__ */ React.createElement(Paper, { sx: {
    p: 2,
    mb: 2,
    background: "rgba(255,255,255,0.1)",
    backdropFilter: "blur(20px)",
    border: "1px solid rgba(124, 179, 66, 0.3)",
    borderRadius: 2
  } }, /* @__PURE__ */ React.createElement(Stack, { spacing: 2 }, /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#fff", mb: 1 } }, "Search Radius: ", radius, " miles"), /* @__PURE__ */ React.createElement(
    Slider,
    {
      value: radius,
      onChange: handleRadiusChange,
      min: 1,
      max: 50,
      step: 1,
      marks: [
        { value: 1, label: "1mi" },
        { value: 10, label: "10mi" },
        { value: 25, label: "25mi" },
        { value: 50, label: "50mi" }
      ],
      sx: {
        color: "#7cb342",
        "& .MuiSlider-markLabel": { color: "#fff", fontSize: "0.75rem" }
      }
    }
  )), /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "contained",
      onClick: handleSearch,
      disabled: !userLocation || loading,
      sx: {
        bgcolor: "#7cb342",
        "&:hover": { bgcolor: "#689f38" }
      }
    },
    loading ? "Searching..." : "Search Dispensaries"
  ))), error && /* @__PURE__ */ React.createElement(Alert, { severity: "error", sx: { mb: 2 } }, error), loading && /* @__PURE__ */ React.createElement(Box, { sx: { display: "flex", justifyContent: "center", py: 8 } }, /* @__PURE__ */ React.createElement(CircularProgress, { sx: { color: "#7cb342" } })), !loading && dispensaries.length === 0 && /* @__PURE__ */ React.createElement(Paper, { sx: {
    p: 4,
    textAlign: "center",
    background: "rgba(255,255,255,0.1)",
    backdropFilter: "blur(20px)",
    border: "1px solid rgba(124, 179, 66, 0.3)",
    borderRadius: 2
  } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { color: "#fff", mb: 2 } }, "No dispensaries found"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#e0e0e0" } }, "Try increasing the search radius or check back later.")), !loading && dispensaries.length > 0 && /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#e0e0e0", mb: 2 } }, "Found ", dispensaries.length, " dispensaries within ", radius, " miles"), /* @__PURE__ */ React.createElement(Stack, { spacing: 2 }, dispensaries.map((dispensary) => /* @__PURE__ */ React.createElement(Card, { key: dispensary.id, sx: {
    background: "rgba(255,255,255,0.1)",
    backdropFilter: "blur(20px)",
    border: "1px solid rgba(124, 179, 66, 0.3)",
    borderRadius: 2
  } }, /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Stack, { direction: "row", justifyContent: "space-between", alignItems: "flex-start", mb: 2 }, /* @__PURE__ */ React.createElement(Box, { flex: 1 }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 1, mb: 1 }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { color: "#fff", fontWeight: 600 } }, dispensary.name), dispensary.verified && /* @__PURE__ */ React.createElement(Chip, { label: "Verified", size: "small", sx: { bgcolor: "#7cb342", color: "#fff", fontSize: "0.7rem", height: 20 } }), /* @__PURE__ */ React.createElement(
    Chip,
    {
      label: dispensary.source,
      size: "small",
      sx: { bgcolor: "rgba(255,255,255,0.2)", color: "#fff", fontSize: "0.65rem", height: 18 }
    }
  )), /* @__PURE__ */ React.createElement(Stack, { spacing: 0.5 }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 1 }, /* @__PURE__ */ React.createElement(LocationOn, { sx: { fontSize: 16, color: "#7cb342" } }), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#e0e0e0" } }, dispensary.address || `${dispensary.city}, ${dispensary.state}`)), dispensary.distance !== void 0 && /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#7cb342", fontWeight: 600 } }, " ", dispensary.distance.toFixed(1), " miles away"), dispensary.rating > 0 && /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 0.5 }, /* @__PURE__ */ React.createElement(StarIcon, { sx: { fontSize: 16, color: "#ffd600" } }), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#fff" } }, dispensary.rating, " (", dispensary.review_count, " reviews)")), dispensary.open_now !== void 0 && /* @__PURE__ */ React.createElement(
    Chip,
    {
      label: dispensary.open_now ? "Open Now" : "Closed",
      size: "small",
      sx: {
        bgcolor: dispensary.open_now ? "rgba(76, 175, 80, 0.3)" : "rgba(244, 67, 54, 0.3)",
        color: "#fff",
        fontSize: "0.75rem",
        width: "fit-content"
      }
    }
  ))), /* @__PURE__ */ React.createElement(Stack, { spacing: 1 }, dispensary.latitude && dispensary.longitude && /* @__PURE__ */ React.createElement(
    IconButton,
    {
      size: "small",
      onClick: () => getDirections(dispensary.latitude, dispensary.longitude),
      sx: { color: "#7cb342" },
      title: "Get Directions"
    },
    /* @__PURE__ */ React.createElement(DirectionsIcon, null)
  ), dispensary.phone && /* @__PURE__ */ React.createElement(
    IconButton,
    {
      size: "small",
      component: "a",
      href: `tel:${dispensary.phone}`,
      sx: { color: "#7cb342" },
      title: "Call"
    },
    /* @__PURE__ */ React.createElement(PhoneIcon, null)
  ), dispensary.website && /* @__PURE__ */ React.createElement(
    IconButton,
    {
      size: "small",
      component: "a",
      href: dispensary.website,
      target: "_blank",
      sx: { color: "#7cb342" },
      title: "Visit Website"
    },
    /* @__PURE__ */ React.createElement(LanguageIcon, null)
  ))), dispensary.description && /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#e0e0e0", mt: 1 } }, dispensary.description)))))));
}
const useState$s = window["React"].useState;
function FeedbackModal({ open, onClose, user }) {
  const [input, setInput] = useState$s("");
  const [submitting, setSubmitting] = useState$s(false);
  const [success, setSuccess] = useState$s(false);
  const [error, setError] = useState$s(null);
  const handleSubmit = () => __async(null, null, function* () {
    if (!input.trim()) return;
    if (!user || !user.id) {
      setError("Please log in to submit feedback.");
      return;
    }
    setSubmitting(true);
    setError(null);
    try {
      const res = yield fetch(`${API_BASE}/api/feedback/messages`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ content: input, user_id: user.id })
      });
      if (res.ok) {
        setSuccess(true);
        setInput("");
        setTimeout(() => {
          setSuccess(false);
          onClose();
        }, 2e3);
      } else {
        const data = yield res.json();
        setError(data.error || "Failed to send feedback.");
      }
    } catch (err) {
      setError("Network error. Please try again.");
    }
    setSubmitting(false);
  });
  return /* @__PURE__ */ React.createElement(Modal, { open, onClose }, /* @__PURE__ */ React.createElement(Box, { sx: {
    position: "absolute",
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)",
    width: 380,
    bgcolor: "rgba(255,255,255,0.15)",
    backdropFilter: "blur(12px)",
    border: "2px solid #4caf50",
    boxShadow: 24,
    p: 4,
    borderRadius: 3
  } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { mb: 2, color: "black", fontWeight: 700 } }, "Send Feedback"), !user || !user.id ? /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { sx: { mb: 2, color: "black" } }, "Please log in to submit feedback. This helps us follow up with you if needed."), /* @__PURE__ */ React.createElement(Button, { variant: "outlined", onClick: onClose, sx: { fontWeight: 700, color: "black", borderColor: "#4caf50" } }, "Close")) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    TextField,
    {
      multiline: true,
      minRows: 3,
      maxRows: 6,
      fullWidth: true,
      placeholder: "Share your thoughts, suggestions, or issues...",
      value: input,
      onChange: (e) => setInput(e.target.value),
      sx: { mb: 2, background: "rgba(255,255,255,0.10)", borderRadius: 2, input: { color: "black" } }
    }
  ), error && /* @__PURE__ */ React.createElement(Typography, { color: "error", sx: { mb: 1 } }, error), success && /* @__PURE__ */ React.createElement(Typography, { color: "success.main", sx: { mb: 1 } }, "Thank you for your feedback!"), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 2 }, /* @__PURE__ */ React.createElement(Button, { variant: "contained", onClick: handleSubmit, disabled: submitting || !input.trim(), sx: { fontWeight: 700, background: "#4caf50", color: "black" } }, submitting ? "Sending" : "Send"), /* @__PURE__ */ React.createElement(Button, { variant: "outlined", onClick: onClose, sx: { fontWeight: 700, color: "black", borderColor: "#4caf50" } }, "Cancel")))));
}
const useRef$2 = window["React"].useRef;
const useState$r = window["React"].useState;
const useEffect$o = window["React"].useEffect;
const useCallback$7 = window["React"].useCallback;
function ScanWizard({ onBack }) {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
  const fileInputRef = useRef$2(null);
  const [membershipComplete, setMembershipComplete] = useState$r(true);
  const [loading, setLoading] = useState$r(false);
  const [scanStatus, setScanStatus] = useState$r("");
  const [result, setResult] = useState$r(null);
  const [match2, setMatch] = useState$r(null);
  const [plantHealth, setPlantHealth] = useState$r(null);
  const [scanHistory, setScanHistory] = useState$r([]);
  const [alertOpen, setAlertOpen] = useState$r(false);
  const [alertMsg, setAlertMsg] = useState$r("");
  const [detailsOpen, setDetailsOpen] = useState$r(false);
  const [detailsTab, setDetailsTab] = useState$r(0);
  const [showReviewForm, setShowReviewForm] = useState$r(false);
  const [reviewText, setReviewText] = useState$r("");
  const [reviewEffects, setReviewEffects] = useState$r("");
  const [reviewFlavors, setReviewFlavors] = useState$r("");
  const [reviewRating, setReviewRating] = useState$r(5);
  const [submittingReview, setSubmittingReview] = useState$r(false);
  const [existingReviews, setExistingReviews] = useState$r([]);
  const [showSeedVendorFinder, setShowSeedVendorFinder] = useState$r(false);
  const [showDispensaryFinder, setShowDispensaryFinder] = useState$r(false);
  const [showFeedback, setShowFeedback] = useState$r(false);
  const [currentUser, setCurrentUser] = useState$r(null);
  const [showMembershipDialog, setShowMembershipDialog] = useState$r(false);
  const [creditSummary, setCreditSummary] = useState$r(null);
  const [creditsLoading, setCreditsLoading] = useState$r(false);
  const [showTopUpDialog, setShowTopUpDialog] = useState$r(false);
  const [topUpMessage, setTopUpMessage] = useState$r("");
  const topUpOptions = [
    { credits: 10, price: "$4.99" },
    { credits: 20, price: "$7.99" },
    { credits: 50, price: "$17.99" },
    { credits: 100, price: "$29.99" }
  ];
  const membershipTier = (((_a2 = currentUser == null ? void 0 : currentUser.user_metadata) == null ? void 0 : _a2.membership) || ((_b = currentUser == null ? void 0 : currentUser.user_metadata) == null ? void 0 : _b.tier) || "").toString().toLowerCase();
  const metadataMembershipActive = ["club", "full-access", "pro", "owner", "admin", "garden", "member"].some((token2) => membershipTier.includes(token2));
  const canUseEdgeUploads = typeof FUNCTIONS_BASE === "string" && FUNCTIONS_BASE.length > 0 && FUNCTIONS_BASE !== `${API_BASE}/api`;
  const uploadViaEdgeFunction = useCallback$7((_0) => __async(null, [_0], function* ({ base64, filename, contentType, userId }) {
    if (!canUseEdgeUploads || !base64) return null;
    try {
      const headers = { "Content-Type": "application/json" };
      if (SUPABASE_ANON_KEY) {
        headers.Authorization = `Bearer ${SUPABASE_ANON_KEY}`;
        headers.apikey = SUPABASE_ANON_KEY;
      }
      const resp = yield fetch(`${FUNCTIONS_BASE}/uploads`, {
        method: "POST",
        headers,
        body: JSON.stringify({ filename, base64, contentType, user_id: userId })
      });
      if (!resp.ok) {
        const text = yield resp.text().catch(() => "");
        console.warn("[ScanWizard] Edge upload failed:", resp.status, text);
        return null;
      }
      const data = yield resp.json();
      if (data == null ? void 0 : data.id) {
        return data;
      }
    } catch (err) {
      console.warn("[ScanWizard] Edge upload exception:", err);
    }
    return null;
  }), [canUseEdgeUploads, FUNCTIONS_BASE]);
  useEffect$o(() => {
    if (!supabase) return;
    supabase.auth.getSession().then(({ data: { session } }) => {
      var _a3;
      setCurrentUser((_a3 = session == null ? void 0 : session.user) != null ? _a3 : null);
    });
    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
      var _a3;
      setCurrentUser((_a3 = session == null ? void 0 : session.user) != null ? _a3 : null);
    });
    return () => subscription.unsubscribe();
  }, []);
  const loadCredits = useCallback$7(() => __async(null, null, function* () {
    if (!currentUser) {
      setCreditSummary(null);
      return;
    }
    setCreditsLoading(true);
    try {
      const resp = yield fetch(`${API_BASE}/api/scans/credits?user_id=${currentUser.id}`);
      if (resp.ok) {
        const data = yield resp.json();
        setCreditSummary(data);
      } else {
        const err = yield resp.json().catch(() => ({}));
        console.error("Failed to load credits", err);
        if (metadataMembershipActive) {
          setCreditSummary((prev2) => prev2 != null ? prev2 : {
            credits: 999,
            membershipActive: true,
            starterExpired: false,
            trialDaysRemaining: null,
            monthlyBundle: 999
          });
        }
      }
    } catch (err) {
      console.error("Credit summary error:", err);
      if (metadataMembershipActive) {
        setCreditSummary((prev2) => prev2 != null ? prev2 : {
          credits: 999,
          membershipActive: true,
          starterExpired: false,
          trialDaysRemaining: null,
          monthlyBundle: 999
        });
      }
    } finally {
      setCreditsLoading(false);
    }
  }), [currentUser, metadataMembershipActive]);
  useEffect$o(() => {
    if (!currentUser) {
      setCreditSummary(null);
      return;
    }
    loadCredits();
  }, [currentUser, loadCredits]);
  useEffect$o(() => {
    var _a3;
    if ((_a3 = match2 == null ? void 0 : match2.strain) == null ? void 0 : _a3.slug) {
      fetch(`${API_BASE}/api/reviews?strain_slug=${match2.strain.slug}`).then((res) => res.json()).then((data) => {
        setExistingReviews(Array.isArray(data) ? data : []);
      }).catch(() => {
        setExistingReviews([]);
      });
    }
  }, [(_c = match2 == null ? void 0 : match2.strain) == null ? void 0 : _c.slug]);
  const handleLeaveReviewClick = () => {
    if (!currentUser) {
      setShowMembershipDialog(true);
      return;
    }
    setShowReviewForm(true);
  };
  const handleSubmitReview = () => __async(null, null, function* () {
    var _a3;
    if (!((_a3 = match2 == null ? void 0 : match2.strain) == null ? void 0 : _a3.slug) || !currentUser) return;
    setSubmittingReview(true);
    try {
      let fullReview = reviewText;
      if (reviewEffects.trim()) {
        fullReview += `

Effects: ${reviewEffects}`;
      }
      if (reviewFlavors.trim()) {
        fullReview += `

Flavors: ${reviewFlavors}`;
      }
      const response = yield fetch(`${API_BASE}/api/reviews`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          user_id: currentUser.id,
          strain_slug: match2.strain.slug,
          rating: reviewRating,
          comment: fullReview
        })
      });
      if (response.ok) {
        setAlertMsg("Thank you for your review! It helps the community learn about this strain.");
        setAlertOpen(true);
        setShowReviewForm(false);
        setReviewText("");
        setReviewEffects("");
        setReviewFlavors("");
        setReviewRating(5);
        const reviewsResponse = yield fetch(`${API_BASE}/api/reviews?strain_slug=${match2.strain.slug}`);
        const reviewsData = yield reviewsResponse.json();
        setExistingReviews(reviewsData || []);
      } else {
        const errorData = yield response.json();
        throw new Error(errorData.error || "Failed to submit review");
      }
    } catch (err) {
      setAlertMsg(err.message || "Failed to submit review. Please try again.");
      setAlertOpen(true);
    } finally {
      setSubmittingReview(false);
    }
  });
  const parseErrorResponse = (response) => __async(null, null, function* () {
    try {
      const data = yield response.json();
      return data.error || data.message || response.statusText || "Unexpected error";
    } catch (e) {
      return response.statusText || "Unexpected error";
    }
  });
  const handleFileChange = (e) => __async(null, null, function* () {
    var _a3;
    const file = (_a3 = e.target.files) == null ? void 0 : _a3[0];
    if (!file) return;
    setLoading(true);
    setScanStatus("Uploading image...");
    try {
      const reader = new FileReader();
      reader.onload = () => __async(null, null, function* () {
        try {
          const base64 = reader.result.split(",")[1];
          let uploadData = null;
          if (canUseEdgeUploads && currentUser) {
            setScanStatus("Uploading image to Supabase...");
            const edge = yield uploadViaEdgeFunction({
              base64,
              filename: file.name,
              contentType: file.type,
              userId: currentUser.id
            });
            if (edge == null ? void 0 : edge.id) {
              uploadData = edge;
            }
          }
          if (!uploadData) {
            setScanStatus("Uploading image to backend...");
            const uploadResp = yield fetch(`${API_BASE}/api/uploads`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                filename: file.name,
                contentType: file.type,
                base64,
                user_id: (currentUser == null ? void 0 : currentUser.id) || null
              })
            });
            if (!uploadResp.ok) {
              const message = yield parseErrorResponse(uploadResp);
              throw new Error(message || "Upload failed");
            }
            uploadData = yield uploadResp.json();
          }
          const scanId = uploadData.id;
          setScanStatus("Processing scan...");
          const processResp = yield fetch(`${API_BASE}/api/scans/${scanId}/process`, {
            method: "POST",
            headers: { "Content-Type": "application/json" }
          });
          if (processResp.status === 402) {
            let errorPayload = {};
            try {
              errorPayload = yield processResp.json();
            } catch (e2) {
            }
            const tier = errorPayload.tier || "free";
            const creditsRemaining2 = errorPayload.creditsRemaining || 0;
            const needsUpgrade = errorPayload.needsUpgrade || false;
            let message = errorPayload.message || "No scan credits remaining.";
            if (needsUpgrade) {
              message = " You've used all 10 free scans! Upgrade to Member ($4.99/mo) for 200 scans/month or buy a top-up pack!";
            } else if (tier === "member") {
              message = " You've used all 200 scans this month! Upgrade to Premium ($14.99/mo) for 1200 scans/month or buy a top-up pack!";
            } else if (tier === "premium") {
              message = " You've used all 1200 scans this month! Buy a top-up pack to continue scanning.";
            }
            setAlertMsg(message);
            setAlertOpen(true);
            setTopUpMessage(message);
            setShowTopUpDialog(true);
            setScanStatus("Out of credits");
            yield loadCredits();
            return;
          }
          if (!processResp.ok) {
            const message = yield parseErrorResponse(processResp);
            throw new Error(message || "Scan processing failed");
          }
          const processData = yield processResp.json();
          setResult(processData.result);
          setPlantHealth(processData.plantHealth || null);
          setScanStatus("Matching strain...");
          const matchResp = yield fetch(`${API_BASE}/api/visual-match`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ visionResult: processData.result })
          });
          if (matchResp.ok) {
            const matchData = yield matchResp.json();
            if (matchData.matches && matchData.matches.length > 0) {
              const topMatch = matchData.matches[0];
              setMatch(topMatch);
              try {
                yield fetch(`${API_BASE}/api/scans/${scanId}/save-match`, {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    matched_strain_slug: topMatch.strain.slug,
                    user_id: currentUser.id
                  })
                });
              } catch (saveErr) {
                console.error("Failed to save match:", saveErr);
              }
              setScanStatus("Scan complete!");
            } else {
              setScanStatus("No matches found");
            }
          } else {
            setScanStatus("No matches found");
          }
          yield loadCredits();
        } catch (err) {
          console.error("Scan error:", err);
          setScanStatus(err.message || "Error: Upload or scan failed");
          setAlertMsg(err.message || "Scan failed. Please try again.");
          setAlertOpen(true);
        } finally {
          setLoading(false);
        }
      });
      reader.onerror = () => {
        setScanStatus("Error reading file");
        setAlertMsg("Unable to read the selected file.");
        setAlertOpen(true);
        setLoading(false);
      };
      reader.readAsDataURL(file);
    } catch (err) {
      console.error("Scan error:", err);
      setScanStatus(err.message || "Error: Upload or scan failed");
      setAlertMsg(err.message || "Scan failed. Please try again.");
      setAlertOpen(true);
      setLoading(false);
    }
  });
  useEffect$o(() => {
    const poll = setInterval(() => __async(null, null, function* () {
      try {
        const resp = yield fetch(`${API_BASE}/api/scans`);
        if (resp.ok) {
          const data = yield resp.json();
          const scans = data.scans || [];
          const completed = scans.filter((s) => s.status === "complete");
          if (completed.length > 0) {
            setAlertMsg(`Scan matched: ${completed.map((s) => {
              var _a3;
              return ((_a3 = s.strain) == null ? void 0 : _a3.name) || "Unknown";
            }).join(", ")}`);
            setAlertOpen(true);
          }
          setScanHistory(scans);
        }
      } catch (err) {
        console.error("Poll error:", err);
      }
    }), 3e4);
    return () => clearInterval(poll);
  }, []);
  const renderDetailsDialog = () => {
    if (!match2 || !match2.strain) return null;
    const { strain } = match2;
    return /* @__PURE__ */ React.createElement(
      Dialog,
      {
        open: detailsOpen,
        onClose: () => setDetailsOpen(false),
        maxWidth: "md",
        fullWidth: true,
        fullScreen: true,
        PaperProps: {
          sx: {
            bgcolor: "rgba(0,0,0,0.95)",
            m: 0,
            maxHeight: "100vh"
          }
        }
      },
      /* @__PURE__ */ React.createElement(DialogTitle, { sx: { borderBottom: "1px solid rgba(124,179,66,0.3)", display: "flex", justifyContent: "space-between", alignItems: "center" } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6" }, strain.name, " Details"), /* @__PURE__ */ React.createElement(IconButton, { onClick: () => setDetailsOpen(false), sx: { color: "#fff" } }, /* @__PURE__ */ React.createElement(CloseIcon, null))),
      /* @__PURE__ */ React.createElement(Tabs, { value: detailsTab, onChange: (_e2, v) => setDetailsTab(v), sx: { borderBottom: "1px solid rgba(124,179,66,0.2)" } }, /* @__PURE__ */ React.createElement(Tab, { label: "Overview", sx: { color: "#c8ff9e" } }), /* @__PURE__ */ React.createElement(Tab, { label: "Dispensaries", sx: { color: "#c8ff9e" } }), /* @__PURE__ */ React.createElement(Tab, { label: "Seeds", sx: { color: "#c8ff9e" } }), /* @__PURE__ */ React.createElement(Tab, { label: "Care Guide", sx: { color: "#c8ff9e" } })),
      /* @__PURE__ */ React.createElement(DialogContent, { sx: { bgcolor: "rgba(0,0,0,0.95)" } }, detailsTab === 0 && /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle1", fontWeight: 700 }, "Overview"), strain.description && /* @__PURE__ */ React.createElement(Typography, null, strain.description)), detailsTab === 1 && /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle1", fontWeight: 700 }, "Dispensaries"), /* @__PURE__ */ React.createElement(Typography, null, "Nearby dispensaries feature coming soon.")), detailsTab === 2 && /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle1", fontWeight: 700 }, "Seeds"), /* @__PURE__ */ React.createElement(Typography, null, "Seed info feature coming soon.")), detailsTab === 3 && /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle1", fontWeight: 700 }, "Care Guide"), /* @__PURE__ */ React.createElement(Typography, null, "Care guide feature coming soon.")))
    );
  };
  const membershipActive = (() => {
    if (typeof (creditSummary == null ? void 0 : creditSummary.membershipActive) === "boolean") {
      if (creditSummary.membershipActive) return true;
      if (metadataMembershipActive) return true;
      if (typeof creditSummary.monthlyBundle === "number" && creditSummary.monthlyBundle > 0) return true;
      return false;
    }
    return metadataMembershipActive;
  })();
  const creditsRemaining = typeof (creditSummary == null ? void 0 : creditSummary.credits) === "number" ? creditSummary.credits : null;
  const monthlyBundle = typeof (creditSummary == null ? void 0 : creditSummary.monthlyBundle) === "number" ? creditSummary.monthlyBundle : null;
  const resetAt = (creditSummary == null ? void 0 : creditSummary.resetAt) ? new Date(creditSummary.resetAt) : null;
  const accessExpiresAt = (creditSummary == null ? void 0 : creditSummary.accessExpiresAt) ? new Date(creditSummary.accessExpiresAt) : null;
  const starterExpired = Boolean(creditSummary == null ? void 0 : creditSummary.starterExpired) && !membershipActive;
  const trialDaysRemaining = typeof (creditSummary == null ? void 0 : creditSummary.trialDaysRemaining) === "number" ? creditSummary.trialDaysRemaining : accessExpiresAt ? Math.max(0, Math.ceil((accessExpiresAt.getTime() - Date.now()) / (1e3 * 60 * 60 * 24))) : null;
  const lowCredits = typeof creditsRemaining === "number" && creditsRemaining <= 5;
  const disableScanning = !membershipActive && Boolean(creditSummary) && (starterExpired || typeof creditsRemaining === "number" && creditsRemaining <= 0);
  const trialMessage = (() => {
    if (membershipActive) return null;
    if (!accessExpiresAt) return null;
    if (starterExpired) {
      return "Your starter access has ended. Join the Garden to keep scanning with full AI access.";
    }
    const diffDays = trialDaysRemaining != null ? trialDaysRemaining : Math.ceil((accessExpiresAt.getTime() - Date.now()) / (1e3 * 60 * 60 * 24));
    if (diffDays <= 0) {
      return "Starter access ends today. Join the Garden to keep scanning with full AI access.";
    }
    return `Starter access ends in ${diffDays} day${diffDays === 1 ? "" : "s"}. Join the Garden or grab a top-up pack to keep scanning.`;
  })();
  const nextResetLabel = (() => {
    if (!resetAt) return null;
    return resetAt.toLocaleDateString(void 0, { month: "short", day: "numeric", year: "numeric" });
  })();
  const accessExpiresLabel = accessExpiresAt ? accessExpiresAt.toLocaleDateString(void 0, { month: "short", day: "numeric", year: "numeric" }) : null;
  if (showSeedVendorFinder) {
    return /* @__PURE__ */ React.createElement(SeedVendorFinder, { onBack: () => setShowSeedVendorFinder(false) });
  }
  if (showDispensaryFinder) {
    return /* @__PURE__ */ React.createElement(DispensaryFinder, { onBack: () => setShowDispensaryFinder(false) });
  }
  return /* @__PURE__ */ React.createElement(ErrorBoundary$1, null, !membershipComplete ? /* @__PURE__ */ React.createElement(MembershipLogin, { onSuccess: () => setMembershipComplete(true) }) : /* @__PURE__ */ React.createElement(
    Container,
    {
      maxWidth: "sm",
      sx: {
        minHeight: { xs: "auto", sm: "100vh" },
        width: "100%",
        maxWidth: { xs: "100%", sm: "600px" },
        py: { xs: 1, sm: 2 },
        pb: { xs: 2, sm: 10 },
        px: { xs: 1.5, sm: 3 },
        background: "none",
        backdropFilter: "none",
        boxShadow: "none",
        opacity: 1,
        borderRadius: 0,
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: { xs: "flex-start", sm: "center" },
        mx: "auto"
      }
    },
    /* @__PURE__ */ React.createElement(Box, { sx: {
      position: "absolute",
      top: { xs: "120px", sm: 24 },
      left: { xs: 12, sm: 24 },
      right: { xs: 12, sm: "auto" },
      zIndex: 100,
      display: "flex",
      gap: 1,
      flexWrap: "wrap"
    } }, /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "contained",
        size: "small",
        onClick: () => onBack ? onBack() : window.history.back(),
        sx: {
          fontWeight: 700,
          borderRadius: "8px",
          px: { xs: 2, sm: 3 },
          py: 1,
          fontSize: { xs: "0.875rem", sm: "1rem" },
          boxShadow: "none",
          bgcolor: "#7CB342",
          color: "#fff",
          textTransform: "none",
          "&:active": {
            bgcolor: "#689f38",
            transform: "scale(0.98)"
          }
        }
      },
      " Back"
    ), currentUser && /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "contained",
        size: "small",
        onClick: () => __async(null, null, function* () {
          try {
            yield supabase.auth.signOut();
            setCurrentUser(null);
            setAlertMsg("Logged out successfully");
            setAlertOpen(true);
            setTimeout(() => {
              if (onBack) {
                onBack();
              } else {
                window.location.href = "/";
              }
            }, 1e3);
          } catch (err) {
            console.error("Logout error:", err);
            setAlertMsg("Logout failed");
            setAlertOpen(true);
          }
        }),
        sx: {
          fontWeight: 700,
          borderRadius: "8px",
          px: { xs: 2, sm: 3 },
          py: 1,
          fontSize: { xs: "0.875rem", sm: "1rem" },
          boxShadow: "none",
          bgcolor: "#7CB342",
          color: "#fff",
          textTransform: "none",
          "&:active": {
            bgcolor: "#689f38",
            transform: "scale(0.98)"
          }
        }
      },
      "Logout"
    )),
    /* @__PURE__ */ React.createElement(Box, { sx: { display: "flex", justifyContent: "center", mb: { xs: 1, sm: 2 }, mt: { xs: "180px", sm: 0 } } }, /* @__PURE__ */ React.createElement(
      Box,
      {
        sx: {
          width: { xs: 50, sm: 70 },
          height: { xs: 50, sm: 70 },
          borderRadius: "50%",
          background: "transparent",
          border: "2px solid rgba(124, 179, 66, 0.5)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          boxShadow: "0 0 30px rgba(124, 179, 66, 0.5)",
          overflow: "hidden"
        }
      },
      /* @__PURE__ */ React.createElement(
        "img",
        {
          src: "/hero.png?v=13",
          alt: "StrainSpotter",
          style: { width: "100%", height: "100%", objectFit: "cover" }
        }
      )
    )),
    /* @__PURE__ */ React.createElement(
      Typography,
      {
        variant: "h3",
        align: "center",
        sx: {
          fontWeight: 900,
          letterSpacing: 1,
          color: "#fff",
          mb: { xs: 0.5, sm: 1 },
          fontSize: { xs: "1.5rem", sm: "2.5rem" },
          textShadow: "0 2px 12px #388e3c, 0 0px 2px #000",
          filter: "drop-shadow(0 0 8px #00e676)",
          fontFamily: "Montserrat, Arial, sans-serif"
        }
      },
      "Identify Your Cannabis Plant"
    ),
    /* @__PURE__ */ React.createElement(
      Typography,
      {
        align: "center",
        sx: {
          mt: { xs: 1, sm: 2 },
          color: "#fff",
          fontSize: { xs: "0.875rem", sm: "1.375rem" },
          fontWeight: 600,
          px: { xs: 1, sm: 0 },
          textShadow: "0 1px 8px #388e3c",
          fontFamily: "Montserrat, Arial, sans-serif"
        }
      },
      "Snap a photo of your cannabis and let our AI deliver the full strain breakdown",
      /* @__PURE__ */ React.createElement("span", { style: { color: "#00e676", fontWeight: 900 } }, "no hype"),
      ", just ",
      /* @__PURE__ */ React.createElement("span", { style: { color: "#ffd600", fontWeight: 900 } }, "next-gen science"),
      "."
    ),
    currentUser && /* @__PURE__ */ React.createElement(
      Paper,
      {
        sx: {
          mt: { xs: 2, sm: 4 },
          mb: { xs: 2, sm: 3 },
          p: { xs: 2, sm: 3 },
          width: "100%",
          maxWidth: 720,
          background: "rgba(0, 0, 0, 0.45)",
          borderRadius: { xs: 2, sm: 4 },
          border: "1px solid rgba(124, 179, 66, 0.4)",
          color: "#e8f5e9"
        }
      },
      /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", sx: { textTransform: "uppercase", letterSpacing: 1, color: "#c8ff9e", fontSize: { xs: "0.7rem", sm: "0.875rem" } } }, "Scan Credits"), /* @__PURE__ */ React.createElement(Typography, { variant: "h3", sx: { fontWeight: 800, color: "#fff", display: "flex", alignItems: "baseline", gap: 1, fontSize: { xs: "2rem", sm: "3rem" } } }, creditsLoading ? /* @__PURE__ */ React.createElement(CircularProgress, { size: 28, sx: { color: "#c8ff9e" } }) : creditsRemaining != null ? creditsRemaining : "--", /* @__PURE__ */ React.createElement(Typography, { component: "span", variant: "h6", sx: { color: "#c8ff9e", fontWeight: 500, fontSize: { xs: "1rem", sm: "1.25rem" } } }, "left")), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#d0ffd6", maxWidth: 420, fontSize: { xs: "0.75rem", sm: "0.875rem" } } }, membershipActive ? "Membership perks active  we auto-refresh your bundle every month so you never lose your streak." : "Starter bundle includes 20 scans. After 3 days you'll need a membership or a top-up pack to keep scanning."), membershipActive && nextResetLabel && /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { display: "block", mt: 1, color: "#b2fab4", fontSize: { xs: "0.65rem", sm: "0.75rem" } } }, "Next monthly reset: ", nextResetLabel), !membershipActive && accessExpiresLabel && /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { display: "block", mt: 1, color: "#ffcc80", fontSize: { xs: "0.65rem", sm: "0.75rem" } } }, "Starter access expires: ", accessExpiresLabel)),
      !membershipActive && trialMessage && /* @__PURE__ */ React.createElement(
        Alert,
        {
          severity: starterExpired ? "error" : "info",
          sx: {
            mt: 2,
            bgcolor: starterExpired ? "rgba(244, 67, 54, 0.2)" : "rgba(124, 179, 66, 0.18)",
            color: "#fff",
            "& .MuiAlert-icon": { color: starterExpired ? "#ffccbc" : "#c8ff9e" }
          }
        },
        trialMessage
      ),
      membershipActive && monthlyBundle && /* @__PURE__ */ React.createElement(
        Alert,
        {
          severity: "success",
          sx: {
            mt: 2,
            bgcolor: "rgba(76, 175, 80, 0.18)",
            color: "#e8f5e9",
            "& .MuiAlert-icon": { color: "#c8ff9e" }
          }
        },
        "Your membership includes a ",
        monthlyBundle,
        "-scan bundle each month. Well keep it topped up automatically."
      ),
      !membershipActive && lowCredits && !starterExpired && /* @__PURE__ */ React.createElement(
        Alert,
        {
          severity: "warning",
          sx: {
            mt: 2,
            bgcolor: "rgba(255, 193, 7, 0.18)",
            color: "#fff",
            "& .MuiAlert-icon": { color: "#ffe082" }
          }
        },
        "Only ",
        creditsRemaining,
        " scan",
        creditsRemaining === 1 ? "" : "s",
        " left. Add a top-up pack or join the Garden to keep results flowing."
      ),
      !membershipActive && starterExpired && /* @__PURE__ */ React.createElement(
        Alert,
        {
          severity: "error",
          sx: {
            mt: 2,
            bgcolor: "rgba(244, 67, 54, 0.25)",
            color: "#fff",
            "& .MuiAlert-icon": { color: "#ffccbc" }
          }
        },
        "Starter access has ended. Join the Garden membership or redeem a top-up pack within the app stores to continue scanning."
      )
    ),
    /* @__PURE__ */ React.createElement(Box, { sx: { mt: { xs: 2, sm: 4 }, textAlign: "center", width: "100%" } }, /* @__PURE__ */ React.createElement(
      "input",
      {
        type: "file",
        accept: "image/*",
        style: { display: "none" },
        ref: fileInputRef,
        onChange: handleFileChange
      }
    ), /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "contained",
        color: "success",
        sx: {
          fontWeight: 700,
          borderRadius: 999,
          px: { xs: 3, sm: 5 },
          py: { xs: 1.25, sm: 1.5 },
          fontSize: { xs: "1rem", sm: "1.25rem" },
          boxShadow: "none",
          mb: { xs: 1.5, sm: 2 },
          bgcolor: "rgba(255,255,255,0.15)",
          backdropFilter: "blur(8px)",
          color: "#388e3c",
          textTransform: "none",
          width: { xs: "90%", sm: "auto" },
          maxWidth: { xs: "320px", sm: "none" }
        },
        disabled: loading,
        onClick: () => {
          var _a3;
          if (disableScanning) {
            const message = starterExpired ? "Your starter access window has ended. Join the Garden membership or purchase a top-up pack within 3 days to keep scanning." : "You are out of scan credits. Join the Garden or purchase a top-up pack to continue scanning.";
            setAlertMsg(message);
            setAlertOpen(true);
            setTopUpMessage(message);
            setShowTopUpDialog(true);
            return;
          }
          (_a3 = fileInputRef.current) == null ? void 0 : _a3.click();
        }
      },
      /* @__PURE__ */ React.createElement("span", { role: "img", "aria-label": "camera", style: { marginRight: 8 } }, ""),
      "Add Photo & Scan"
    ), disableScanning && /* @__PURE__ */ React.createElement(Typography, { align: "center", sx: { mt: 1, color: "#ffcc80", fontWeight: 600, fontSize: { xs: "0.75rem", sm: "1rem" } } }, "Add credits or join the Garden to unlock new scans."), loading && /* @__PURE__ */ React.createElement(CircularProgress, { color: "success", sx: { mt: { xs: 1, sm: 2 } } }), scanStatus && !loading && /* @__PURE__ */ React.createElement(Typography, { align: "center", sx: { mt: { xs: 1, sm: 2 }, color: "#388e3c", fontWeight: 700, fontSize: { xs: "0.875rem", sm: "1rem" } } }, scanStatus)),
    match2 && /* @__PURE__ */ React.createElement(Box, { sx: {
      mt: { xs: 2, sm: 4 },
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center",
      borderRadius: { xs: 3, sm: 6 },
      p: { xs: 2, sm: 3 },
      maxWidth: 600,
      minHeight: { xs: "auto", sm: 200 },
      width: "100%",
      opacity: 1,
      boxShadow: "none",
      border: "none"
    } }, /* @__PURE__ */ React.createElement(Typography, { sx: {
      fontSize: { xs: "1.5rem", sm: "2rem" },
      fontWeight: 900,
      color: "#00e676",
      letterSpacing: { xs: 1, sm: 2 },
      mb: { xs: 0.5, sm: 1 },
      textShadow: "0 2px 12px #388e3c, 0 0px 2px #000",
      filter: "drop-shadow(0 0 8px #00e676)",
      fontFamily: "Montserrat, Arial, sans-serif"
    } }, "Strain Identified!"), /* @__PURE__ */ React.createElement(Typography, { sx: {
      fontSize: { xs: "1.25rem", sm: "1.625rem" },
      fontWeight: 900,
      color: "#ffd600",
      mb: { xs: 1, sm: 2 },
      textShadow: "0 2px 8px #388e3c",
      fontFamily: "Montserrat, Arial, sans-serif"
    } }, (_d = match2.strain) == null ? void 0 : _d.name), ((_e = match2.strain) == null ? void 0 : _e.type) && /* @__PURE__ */ React.createElement(
      Chip,
      {
        label: match2.strain.type,
        color: match2.strain.type === "Indica" ? "primary" : match2.strain.type === "Sativa" ? "success" : "secondary",
        sx: { mb: { xs: 1, sm: 2 }, fontSize: { xs: "0.875rem", sm: "1rem" }, fontWeight: 700 }
      }
    ), (((_f = match2.strain) == null ? void 0 : _f.thc) || ((_g = match2.strain) == null ? void 0 : _g.cbd)) && /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: { xs: 1, sm: 2 }, sx: { mb: { xs: 2, sm: 3 } } }, match2.strain.thc && /* @__PURE__ */ React.createElement(
      Chip,
      {
        label: `THC: ${match2.strain.thc}%`,
        sx: {
          bgcolor: "rgba(255, 152, 0, 0.3)",
          color: "#fff",
          fontWeight: 700,
          border: "2px solid rgba(255, 152, 0, 0.6)",
          fontSize: { xs: "0.75rem", sm: "0.875rem" }
        }
      }
    ), match2.strain.cbd && /* @__PURE__ */ React.createElement(
      Chip,
      {
        label: `CBD: ${match2.strain.cbd}%`,
        sx: {
          bgcolor: "rgba(33, 150, 243, 0.3)",
          color: "#fff",
          fontWeight: 700,
          border: "2px solid rgba(33, 150, 243, 0.6)",
          fontSize: { xs: "0.75rem", sm: "0.875rem" }
        }
      }
    )), ((_h = match2.strain) == null ? void 0 : _h.description) && /* @__PURE__ */ React.createElement(Typography, { variant: "body1", sx: { color: "#fff", mb: { xs: 2, sm: 3 }, fontSize: { xs: "0.875rem", sm: "1rem" }, lineHeight: 1.6, px: { xs: 1, sm: 0 } } }, match2.strain.description), plantHealth && /* @__PURE__ */ React.createElement(Box, { sx: {
      mb: { xs: 2, sm: 3 },
      p: { xs: 2, sm: 3 },
      bgcolor: "rgba(0, 0, 0, 0.4)",
      borderRadius: { xs: 2, sm: 3 },
      border: `2px solid ${plantHealth.healthStatus.color}`,
      boxShadow: `0 0 20px ${plantHealth.healthStatus.color}40`,
      width: "100%"
    } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { color: "#fff", fontWeight: 700, mb: { xs: 1.5, sm: 2 }, display: "flex", alignItems: "center", gap: 1, fontSize: { xs: "1rem", sm: "1.25rem" } } }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 1 }, /* @__PURE__ */ React.createElement(Box, { component: "img", src: "/hero.png?v=13", alt: "", sx: { width: 18, height: 18, filter: "drop-shadow(0 0 4px rgba(124, 179, 66, 0.6))" } }), /* @__PURE__ */ React.createElement("span", null, "Plant Analysis"))), /* @__PURE__ */ React.createElement(Box, { sx: { mb: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#9CCC65", fontWeight: 700, mb: 0.5 } }, "Growth Stage:"), /* @__PURE__ */ React.createElement(Typography, { variant: "body1", sx: { color: "#fff", fontSize: 18, fontWeight: 600 } }, plantHealth.growthStage.icon, " ", plantHealth.growthStage.stage), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#b0b0b0", mt: 0.5 } }, plantHealth.growthStage.description), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "#808080" } }, "Timeframe: ", plantHealth.growthStage.timeframe)), /* @__PURE__ */ React.createElement(Box, { sx: { mb: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#9CCC65", fontWeight: 700, mb: 0.5 } }, "Health Status:"), /* @__PURE__ */ React.createElement(
      Chip,
      {
        label: plantHealth.healthStatus.status,
        sx: {
          bgcolor: `${plantHealth.healthStatus.color}30`,
          color: plantHealth.healthStatus.color,
          fontWeight: 700,
          border: `2px solid ${plantHealth.healthStatus.color}`,
          fontSize: 16,
          px: 2,
          py: 2.5
        }
      }
    ), plantHealth.healthStatus.issues.length > 0 && /* @__PURE__ */ React.createElement(Box, { sx: { mt: 1 } }, plantHealth.healthStatus.issues.map((issue, idx) => /* @__PURE__ */ React.createElement(Typography, { key: idx, variant: "body2", sx: { color: "#fff", mt: 0.5 } }, " ", issue)))), plantHealth.recommendations && plantHealth.recommendations.length > 0 && /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#9CCC65", fontWeight: 700, mb: 1 } }, "Care Recommendations:"), /* @__PURE__ */ React.createElement(Stack, { spacing: 0.5 }, plantHealth.recommendations.map((rec, idx) => /* @__PURE__ */ React.createElement(Typography, { key: idx, variant: "body2", sx: { color: "#fff", fontSize: 14 } }, rec)))), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "#808080", mt: 2, display: "block" } }, "Analysis Confidence: ", plantHealth.confidence, "%")), ((_i = match2.strain) == null ? void 0 : _i.effects) && match2.strain.effects.length > 0 && /* @__PURE__ */ React.createElement(Box, { sx: { mb: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#00e676", fontWeight: 700, mb: 1 } }, "Effects:"), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1, flexWrap: "wrap", useFlexGap: true }, match2.strain.effects.map((effect2, i) => /* @__PURE__ */ React.createElement(
      Chip,
      {
        key: i,
        label: effect2,
        size: "small",
        sx: {
          bgcolor: "rgba(0, 230, 118, 0.2)",
          color: "#fff",
          border: "1px solid rgba(0, 230, 118, 0.4)"
        }
      }
    )))), ((_j = match2.strain) == null ? void 0 : _j.flavors) && match2.strain.flavors.length > 0 && /* @__PURE__ */ React.createElement(Box, { sx: { mb: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#ffd600", fontWeight: 700, mb: 1 } }, "Flavors:"), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1, flexWrap: "wrap", useFlexGap: true }, match2.strain.flavors.map((flavor, i) => /* @__PURE__ */ React.createElement(
      Chip,
      {
        key: i,
        label: flavor,
        size: "small",
        sx: {
          bgcolor: "rgba(255, 214, 0, 0.2)",
          color: "#fff",
          border: "1px solid rgba(255, 214, 0, 0.4)"
        }
      }
    )))), ((_k = match2.strain) == null ? void 0 : _k.lineage) && /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "#fff", sx: { mb: 2 } }, /* @__PURE__ */ React.createElement("strong", { style: { color: "#00e676" } }, "Lineage:"), " ", typeof match2.strain.lineage === "string" ? match2.strain.lineage : match2.strain.lineage.join("  ")), typeof ((_l = match2.strain) == null ? void 0 : _l.indicaPercent) === "number" && typeof ((_m = match2.strain) == null ? void 0 : _m.sativaPercent) === "number" ? /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "#fff", sx: { mb: 2 } }, /* @__PURE__ */ React.createElement("strong", { style: { color: "#00e676" } }, "Ratio:"), " ", match2.strain.indicaPercent, "% Indica / ", match2.strain.sativaPercent, "% Sativa") : ((_n = match2.strain) == null ? void 0 : _n.ratio) ? /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "#fff", sx: { mb: 2 } }, /* @__PURE__ */ React.createElement("strong", { style: { color: "#00e676" } }, "Ratio:"), " ", match2.strain.ratio) : null, (((_o = match2.strain) == null ? void 0 : _o.growDifficulty) || ((_p = match2.strain) == null ? void 0 : _p.floweringTime) || ((_q = match2.strain) == null ? void 0 : _q.yield)) && /* @__PURE__ */ React.createElement(Box, { sx: { mb: 2, p: 2, bgcolor: "rgba(0, 0, 0, 0.3)", borderRadius: 2, border: "1px solid rgba(124, 179, 66, 0.3)" } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#00e676", fontWeight: 700, mb: 1 } }, "Growing Information:"), match2.strain.growDifficulty && /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "#fff", sx: { mb: 0.5 } }, " Difficulty: ", match2.strain.growDifficulty), match2.strain.floweringTime && /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "#fff", sx: { mb: 0.5 } }, " Flowering Time: ", match2.strain.floweringTime), match2.strain.yield && /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "#fff" }, " Yield: ", match2.strain.yield)), ((_r = match2.strain) == null ? void 0 : _r.medicalUses) && match2.strain.medicalUses.length > 0 && /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "#fff", sx: { mb: 2 } }, /* @__PURE__ */ React.createElement("strong", { style: { color: "#00e676" } }, "Medical Uses:"), " ", match2.strain.medicalUses.join(", ")), ((_s = match2.strain) == null ? void 0 : _s.terpeneProfile) && match2.strain.terpeneProfile.length > 0 && /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "#fff", sx: { mb: 2 } }, /* @__PURE__ */ React.createElement("strong", { style: { color: "#00e676" } }, "Terpenes:"), " ", match2.strain.terpeneProfile.join(", ")), ((_t = match2.strain) == null ? void 0 : _t.awards) && match2.strain.awards.length > 0 && /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#ffd600", mb: 2 } }, /* @__PURE__ */ React.createElement("strong", null, " Awards:"), " ", match2.strain.awards.join(", ")), /* @__PURE__ */ React.createElement(Box, { sx: {
      mt: 3,
      mb: 3,
      p: 3,
      bgcolor: "rgba(0, 0, 0, 0.3)",
      borderRadius: 3,
      border: "2px solid rgba(124, 179, 66, 0.3)",
      width: "100%"
    } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { color: "#00e676", fontWeight: 700, mb: 2 } }, " Share Your Experience"), !showReviewForm ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "#fff", sx: { mb: 2 } }, "Have you tried ", (_u = match2.strain) == null ? void 0 : _u.name, "? Help the community by sharing your experience with effects, flavors, and overall rating."), /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "contained",
        sx: {
          fontWeight: 700,
          borderRadius: 999,
          px: 4,
          py: 1,
          fontSize: 16,
          boxShadow: "none",
          bgcolor: "rgba(124, 179, 66, 0.3)",
          border: "2px solid rgba(124, 179, 66, 0.6)",
          backdropFilter: "blur(10px)",
          color: "#fff",
          textTransform: "none",
          "&:hover": {
            bgcolor: "rgba(124, 179, 66, 0.5)",
            border: "2px solid rgba(124, 179, 66, 0.8)"
          }
        },
        onClick: handleLeaveReviewClick
      },
      " Leave a Review ",
      !currentUser && "(Members Only)"
    )) : /* @__PURE__ */ React.createElement(Box, { sx: { display: "flex", flexDirection: "column", gap: 2 } }, /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: "Your Review",
        multiline: true,
        rows: 4,
        value: reviewText,
        onChange: (e) => setReviewText(e.target.value),
        placeholder: "Share your experience with this strain...",
        fullWidth: true,
        sx: {
          "& .MuiOutlinedInput-root": {
            color: "#fff",
            "& fieldset": { borderColor: "rgba(124, 179, 66, 0.5)" },
            "&:hover fieldset": { borderColor: "rgba(124, 179, 66, 0.7)" },
            "&.Mui-focused fieldset": { borderColor: "rgba(124, 179, 66, 0.9)" }
          },
          "& .MuiInputLabel-root": { color: "#fff" }
        }
      }
    ), /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: "Effects (comma-separated)",
        value: reviewEffects,
        onChange: (e) => setReviewEffects(e.target.value),
        placeholder: "e.g., relaxed, happy, euphoric",
        fullWidth: true,
        sx: {
          "& .MuiOutlinedInput-root": {
            color: "#fff",
            "& fieldset": { borderColor: "rgba(124, 179, 66, 0.5)" },
            "&:hover fieldset": { borderColor: "rgba(124, 179, 66, 0.7)" },
            "&.Mui-focused fieldset": { borderColor: "rgba(124, 179, 66, 0.9)" }
          },
          "& .MuiInputLabel-root": { color: "#fff" }
        }
      }
    ), /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: "Flavors (comma-separated)",
        value: reviewFlavors,
        onChange: (e) => setReviewFlavors(e.target.value),
        placeholder: "e.g., berry, sweet, earthy",
        fullWidth: true,
        sx: {
          "& .MuiOutlinedInput-root": {
            color: "#fff",
            "& fieldset": { borderColor: "rgba(124, 179, 66, 0.5)" },
            "&:hover fieldset": { borderColor: "rgba(124, 179, 66, 0.7)" },
            "&.Mui-focused fieldset": { borderColor: "rgba(124, 179, 66, 0.9)" }
          },
          "& .MuiInputLabel-root": { color: "#fff" }
        }
      }
    ), /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "#fff", sx: { mb: 1 } }, "Rating: ", reviewRating, "/10"), /* @__PURE__ */ React.createElement(
      "input",
      {
        type: "range",
        min: "1",
        max: "10",
        value: reviewRating,
        onChange: (e) => setReviewRating(parseInt(e.target.value)),
        style: { width: "100%" }
      }
    )), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 2 }, /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "contained",
        disabled: submittingReview || !reviewText.trim(),
        sx: {
          fontWeight: 700,
          borderRadius: 999,
          px: 4,
          py: 1,
          fontSize: 16,
          boxShadow: "none",
          bgcolor: "rgba(124, 179, 66, 0.3)",
          border: "2px solid rgba(124, 179, 66, 0.6)",
          backdropFilter: "blur(10px)",
          color: "#fff",
          textTransform: "none",
          "&:hover": {
            bgcolor: "rgba(124, 179, 66, 0.5)",
            border: "2px solid rgba(124, 179, 66, 0.8)"
          }
        },
        onClick: handleSubmitReview
      },
      submittingReview ? /* @__PURE__ */ React.createElement(CircularProgress, { size: 20, color: "inherit" }) : "Submit Review"
    ), /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "outlined",
        disabled: submittingReview,
        sx: {
          fontWeight: 700,
          borderRadius: 999,
          px: 4,
          py: 1,
          fontSize: 16,
          boxShadow: "none",
          bgcolor: "rgba(124, 179, 66, 0.2)",
          border: "2px solid rgba(124, 179, 66, 0.5)",
          backdropFilter: "blur(10px)",
          color: "#fff",
          textTransform: "none",
          "&:hover": {
            bgcolor: "rgba(124, 179, 66, 0.3)",
            border: "2px solid rgba(124, 179, 66, 0.7)"
          }
        },
        onClick: () => setShowReviewForm(false)
      },
      "Cancel"
    )))), existingReviews.length > 0 && /* @__PURE__ */ React.createElement(Box, { sx: {
      mt: 3,
      mb: 3,
      p: 3,
      bgcolor: "rgba(0, 0, 0, 0.3)",
      borderRadius: 3,
      border: "2px solid rgba(124, 179, 66, 0.3)",
      width: "100%"
    } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { color: "#00e676", fontWeight: 700, mb: 2 } }, " Community Reviews (", existingReviews.length, ")"), /* @__PURE__ */ React.createElement(Stack, { spacing: 2 }, existingReviews.map((review, idx) => {
      var _a3;
      return /* @__PURE__ */ React.createElement(
        Box,
        {
          key: idx,
          sx: {
            p: 2,
            bgcolor: "rgba(255, 255, 255, 0.05)",
            borderRadius: 2,
            borderLeft: "3px solid rgba(124, 179, 66, 0.6)"
          }
        },
        /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#ffd600", fontWeight: 700, mb: 1 } }, ((_a3 = review.users) == null ? void 0 : _a3.username) || review.user || "Anonymous", "  ", new Date(review.created_at || review.date).toLocaleDateString()),
        /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#fff", whiteSpace: "pre-line" } }, review.comment || review.review),
        review.rating && /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#00e676", mt: 1 } }, " Rating: ", review.rating, "/5")
      );
    }))), /* @__PURE__ */ React.createElement(Box, { sx: {
      display: "flex",
      flexDirection: "column",
      gap: 2,
      mt: 3,
      width: "100%",
      maxWidth: "400px",
      mx: "auto",
      px: 2
    } }, /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "contained",
        fullWidth: true,
        onClick: () => {
          var _a3, _b2;
          if (currentUser) {
            setShowSeedVendorFinder(true);
          } else {
            const strainName = ((_a3 = match2.strain) == null ? void 0 : _a3.slug) || ((_b2 = match2.strain) == null ? void 0 : _b2.name);
            window.open(`https://www.seedsman.com/en/search?q=${encodeURIComponent(strainName)}`, "_blank");
          }
        },
        sx: {
          py: 2,
          fontSize: "1rem",
          fontWeight: 700,
          borderRadius: "12px",
          background: "linear-gradient(135deg, #7CB342 0%, #9CCC65 100%)",
          boxShadow: "0 4px 12px rgba(124, 179, 66, 0.3)",
          textTransform: "none",
          transition: "all 0.2s ease",
          "&:active": {
            transform: "scale(0.98)",
            boxShadow: "0 2px 8px rgba(124, 179, 66, 0.4)"
          }
        }
      },
      " Buy Seeds"
    ), /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "outlined",
        fullWidth: true,
        onClick: () => {
          var _a3, _b2;
          if (currentUser) {
            setShowDispensaryFinder(true);
          } else {
            const strainName = ((_a3 = match2.strain) == null ? void 0 : _a3.name) || ((_b2 = match2.strain) == null ? void 0 : _b2.slug);
            window.open(`https://www.google.com/search?q=${encodeURIComponent(strainName + " cannabis dispensary near me")}`, "_blank");
          }
        },
        sx: {
          py: 2,
          fontSize: "1rem",
          fontWeight: 700,
          borderRadius: "12px",
          border: "2px solid rgba(124, 179, 66, 0.6)",
          color: "#9CCC65",
          textTransform: "none",
          transition: "all 0.2s ease",
          "&:active": {
            transform: "scale(0.98)",
            background: "rgba(124, 179, 66, 0.15)",
            border: "2px solid rgba(124, 179, 66, 0.8)"
          }
        }
      },
      " Find Dispensaries"
    )), /* @__PURE__ */ React.createElement(Box, { sx: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap: { xs: 1.5, sm: 2 },
      mt: { xs: 2, sm: 3 },
      background: "rgba(30,30,30,0.25)",
      backdropFilter: "blur(16px) saturate(180%)",
      borderRadius: { xs: 3, sm: 6 },
      px: { xs: 2, sm: 4 },
      py: { xs: 2, sm: 3 },
      boxShadow: "0 4px 32px 0 rgba(0,0,0,0.12)",
      border: "1px solid rgba(255,255,255,0.18)",
      width: "100%"
    } }, /* @__PURE__ */ React.createElement(
      "input",
      {
        type: "file",
        accept: "image/*",
        style: { display: "none" },
        ref: fileInputRef,
        onChange: handleFileChange
      }
    ), /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "contained",
        color: "success",
        fullWidth: true,
        sx: {
          fontWeight: 700,
          borderRadius: 999,
          px: { xs: 3, sm: 5 },
          py: { xs: 1.25, sm: 1.5 },
          fontSize: { xs: "0.95rem", sm: "1.125rem" },
          boxShadow: "none",
          bgcolor: "rgba(124, 179, 66, 0.3)",
          border: "2px solid rgba(124, 179, 66, 0.6)",
          backdropFilter: "blur(10px)",
          color: "#fff",
          textTransform: "none",
          maxWidth: { xs: "100%", sm: "400px" },
          "&:hover": {
            bgcolor: "rgba(124, 179, 66, 0.5)",
            border: "2px solid rgba(124, 179, 66, 0.8)"
          },
          "&:active": {
            transform: "scale(0.98)"
          }
        },
        onClick: () => {
          var _a3;
          return (_a3 = fileInputRef.current) == null ? void 0 : _a3.click();
        }
      },
      /* @__PURE__ */ React.createElement("span", { role: "img", "aria-label": "camera", style: { marginRight: 8 } }, ""),
      "Scan Another Strain"
    ), loading && /* @__PURE__ */ React.createElement(CircularProgress, { color: "success", sx: { mt: { xs: 1, sm: 2 } } }), scanStatus && !loading && /* @__PURE__ */ React.createElement(Typography, { align: "center", sx: { mt: { xs: 1, sm: 2 }, color: "#00e676", fontWeight: 700, fontSize: { xs: "0.875rem", sm: "1rem" } } }, scanStatus)), ((_v = match2.strain) == null ? void 0 : _v.labTestResults) && match2.strain.labTestResults.length > 0 && /* @__PURE__ */ React.createElement(Box, { sx: { mb: 2, width: "100%" } }, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", color: "#fff", gutterBottom: true }, "Lab Test Results:"), /* @__PURE__ */ React.createElement(Stack, { spacing: 1 }, match2.strain.labTestResults.map((test, idx) => /* @__PURE__ */ React.createElement(Box, { key: idx, sx: { bgcolor: "rgba(255,255,255,0.10)", backdropFilter: "blur(6px)", borderRadius: 2, p: 1 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "#fff" }, test.date && /* @__PURE__ */ React.createElement("span", null, /* @__PURE__ */ React.createElement("strong", null, "Date:"), " ", test.date, " "), test.lab && /* @__PURE__ */ React.createElement("span", null, /* @__PURE__ */ React.createElement("strong", null, "Lab:"), " ", test.lab, " "), test.testType && /* @__PURE__ */ React.createElement("span", null, /* @__PURE__ */ React.createElement("strong", null, "Type:"), " ", test.testType, " "), typeof test.thc === "number" && /* @__PURE__ */ React.createElement("span", null, /* @__PURE__ */ React.createElement("strong", null, "THC:"), " ", test.thc, "% "), typeof test.cbd === "number" && /* @__PURE__ */ React.createElement("span", null, /* @__PURE__ */ React.createElement("strong", null, "CBD:"), " ", test.cbd, "% "), test.comment && /* @__PURE__ */ React.createElement("span", null, /* @__PURE__ */ React.createElement("strong", null, "Note:"), " ", test.comment)))))), ((_w = match2.strain) == null ? void 0 : _w.growTips) && /* @__PURE__ */ React.createElement(Box, { sx: { mb: 2, width: "100%" } }, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", color: "#fff", gutterBottom: true }, "Grow Tips:"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "#fff" }, match2.strain.growTips)), ((_x = match2.strain) == null ? void 0 : _x.seedVendors) && match2.strain.seedVendors.length > 0 && /* @__PURE__ */ React.createElement(Box, { sx: { mb: 2, width: "100%" } }, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", color: "#fff", gutterBottom: true }, "Seed Vendors:"), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1, flexWrap: "wrap", useFlexGap: true }, match2.strain.seedVendors.map((vendor, idx) => /* @__PURE__ */ React.createElement(
      Chip,
      {
        key: idx,
        label: vendor.name,
        size: "small",
        variant: "outlined",
        component: "a",
        href: vendor.url,
        clickable: true,
        sx: {
          borderColor: "#7CB342",
          color: "#9CCC65",
          "&:hover": {
            borderColor: "#9CCC65",
            bgcolor: "rgba(124, 179, 66, 0.1)"
          }
        }
      }
    )))), ((_y = match2.strain) == null ? void 0 : _y.breeder) && /* @__PURE__ */ React.createElement(Box, { sx: { mb: 2, width: "100%" } }, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", color: "#fff", gutterBottom: true }, "Breeder:"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "#fff" }, match2.strain.breeder))),
    currentUser && /* @__PURE__ */ React.createElement(Box, { sx: { mt: 4 } }, /* @__PURE__ */ React.createElement(Box, { sx: {
      borderRadius: 6,
      p: 3,
      boxShadow: "none",
      border: "none"
    } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { mb: 2, color: "#fff" } }, "Your Scan History"), /* @__PURE__ */ React.createElement(Stack, { spacing: 2 }, scanHistory && Array.isArray(scanHistory) && scanHistory.length === 0 ? /* @__PURE__ */ React.createElement(Typography, { sx: { color: "#e0e0e0" } }, "No scans yet.") : (scanHistory || []).map((scan, idx) => {
      var _a3;
      return /* @__PURE__ */ React.createElement(Paper, { key: (scan == null ? void 0 : scan.id) || idx, sx: {
        p: 2,
        borderRadius: 2,
        bgcolor: "rgba(255,255,255,0.1)",
        backdropFilter: "blur(10px)",
        border: "1px solid rgba(124, 179, 66, 0.3)",
        boxShadow: "none"
      } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#fff" } }, (scan == null ? void 0 : scan.status) === "pending" ? "Pending scan..." : `Matched: ${((_a3 = scan == null ? void 0 : scan.strain) == null ? void 0 : _a3.name) || "Unknown"}`), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "#e0e0e0" } }, scan == null ? void 0 : scan.created));
    })))),
    result && !match2 && /* @__PURE__ */ React.createElement(Box, { sx: { mt: 3 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle1", fontWeight: 700 }, "Raw Scan Result"), /* @__PURE__ */ React.createElement(Box, { sx: { mt: 1, p: 2, borderRadius: 4 } }, /* @__PURE__ */ React.createElement("pre", { style: { textAlign: "left", fontSize: 14 } }, JSON.stringify(result, null, 2)))),
    renderDetailsDialog(),
    /* @__PURE__ */ React.createElement(
      Dialog,
      {
        open: showTopUpDialog,
        onClose: () => setShowTopUpDialog(false),
        maxWidth: "sm",
        fullWidth: true,
        fullScreen: true,
        PaperProps: {
          sx: {
            bgcolor: "#111",
            m: 0,
            maxHeight: "100vh"
          }
        }
      },
      /* @__PURE__ */ React.createElement(DialogTitle, { sx: { bgcolor: "#111", color: "#c8ff9e", fontWeight: 700, borderBottom: "1px solid rgba(124,179,66,0.3)", display: "flex", justifyContent: "space-between", alignItems: "center" } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6" }, "Keep Your Scans Going"), /* @__PURE__ */ React.createElement(IconButton, { onClick: () => setShowTopUpDialog(false), sx: { color: "#c8ff9e" } }, /* @__PURE__ */ React.createElement(CloseIcon, null))),
      /* @__PURE__ */ React.createElement(DialogContent, { sx: { bgcolor: "#111", color: "#fff", pt: 3 } }, topUpMessage && /* @__PURE__ */ React.createElement(DialogContentText, { sx: { color: "#e0ffe3", mb: 2 } }, topUpMessage), !membershipActive && /* @__PURE__ */ React.createElement(
        Paper,
        {
          sx: {
            p: 2,
            mb: 3,
            background: "linear-gradient(135deg, rgba(124,179,66,0.25), rgba(0,0,0,0.65))",
            border: "1px solid rgba(124,179,66,0.4)",
            borderRadius: 3
          }
        },
        /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { fontWeight: 700, color: "#c8ff9e", mb: 1 } }, "Garden Membership  $7.99 / month"),
        /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#e8f5e9", mb: 1 } }, "Unlimited monthly scan bundles, private grower community access, and priority support. Perfect if you scan often or want the full Garden experience."),
        /* @__PURE__ */ React.createElement(
          Button,
          {
            variant: "contained",
            color: "success",
            fullWidth: true,
            sx: { mt: 1, borderRadius: 999, textTransform: "none", fontWeight: 700 },
            onClick: () => {
              setShowTopUpDialog(false);
              setShowMembershipDialog(true);
            }
          },
          "Join the Garden"
        )
      ), /* @__PURE__ */ React.createElement(Divider, { sx: { borderColor: "rgba(255,255,255,0.12)", mb: 3 } }), /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle1", sx: { fontWeight: 700, color: "#c8ff9e", mb: 1 } }, "Quick Top-Up Packs (3-day access window)"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#e8f5e9", mb: 2 } }, "Redeem on iOS or Android. Each pack reloads your credits instantly and keeps your non-member access alive for 3 more days."), /* @__PURE__ */ React.createElement(Stack, { spacing: 2, sx: { mb: 3 } }, topUpOptions.map((pack) => /* @__PURE__ */ React.createElement(
        Paper,
        {
          key: pack.credits,
          sx: {
            p: 2,
            borderRadius: 3,
            background: "rgba(255,255,255,0.06)",
            border: "1px solid rgba(124,179,66,0.3)",
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center"
          }
        },
        /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle1", sx: { color: "#fff", fontWeight: 700 } }, pack.credits, " scans"), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "#c8ff9e" } }, "Expires 3 days after activation")),
        /* @__PURE__ */ React.createElement(
          Button,
          {
            variant: "outlined",
            sx: {
              borderColor: "rgba(200,255,158,0.7)",
              color: "#c8ff9e",
              textTransform: "none",
              borderRadius: 999,
              fontWeight: 600,
              "&:hover": { borderColor: "rgba(200,255,158,1)" }
            },
            onClick: () => {
              setAlertMsg("Checkout for scan packs happens through Apple App Store or Google Play. Launch the mobile app to complete your purchase.");
              setAlertOpen(true);
            }
          },
          pack.price
        )
      ))), /* @__PURE__ */ React.createElement(
        Alert,
        {
          severity: "info",
          sx: {
            bgcolor: "rgba(124, 179, 66, 0.2)",
            color: "#e8f5e9",
            "& .MuiAlert-icon": { color: "#c8ff9e" }
          }
        },
        "Purchases finalize inside the Apple App Store or Google Play app. Once the store confirms your order we auto-sync credits to your account. Need a hand? Email support@strainspotter.com."
      )),
      /* @__PURE__ */ React.createElement(DialogActions, { sx: { bgcolor: "#111", borderTop: "1px solid rgba(255,255,255,0.12)" } }, /* @__PURE__ */ React.createElement(Button, { onClick: () => setShowTopUpDialog(false), sx: { color: "#c8ff9e", textTransform: "none" } }, "Close"))
    ),
    /* @__PURE__ */ React.createElement(
      Dialog,
      {
        open: showMembershipDialog,
        onClose: () => setShowMembershipDialog(false),
        maxWidth: "sm",
        fullWidth: true,
        fullScreen: true,
        PaperProps: {
          sx: {
            bgcolor: "rgba(0, 0, 0, 0.95)",
            m: 0,
            maxHeight: "100vh"
          }
        }
      },
      /* @__PURE__ */ React.createElement(DialogTitle, { sx: {
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        bgcolor: "rgba(0, 0, 0, 0.9)",
        color: "#00e676",
        borderBottom: "1px solid rgba(124,179,66,0.3)"
      } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { fontWeight: 700 } }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 1 }, /* @__PURE__ */ React.createElement(Box, { component: "img", src: "/hero.png?v=13", alt: "", sx: { width: 18, height: 18, filter: "drop-shadow(0 0 4px rgba(124, 179, 66, 0.6))" } }), /* @__PURE__ */ React.createElement("span", null, "Garden Membership Access"))), /* @__PURE__ */ React.createElement(
        IconButton,
        {
          onClick: () => setShowMembershipDialog(false),
          sx: { color: "#fff" }
        },
        /* @__PURE__ */ React.createElement(CloseIcon, null)
      )),
      /* @__PURE__ */ React.createElement(DialogContent, { sx: { bgcolor: "rgba(0, 0, 0, 0.9)", color: "#fff", pt: 3 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body1", sx: { mb: 3 } }, "Membership unlocks unlimited scan refills, in-depth strain tools, and the private grower community. Join the StrainSpotter Garden to:"), /* @__PURE__ */ React.createElement(Box, { component: "ul", sx: { pl: 3, mb: 3 } }, /* @__PURE__ */ React.createElement("li", null, "Access unlimited AI scan bundles every month"), /* @__PURE__ */ React.createElement("li", null, "Unlock reviews, ratings, and premium strain breakdowns"), /* @__PURE__ */ React.createElement("li", null, "Connect with certified growers in members-only chats"), /* @__PURE__ */ React.createElement("li", null, "Get early access to new cultivation features"), /* @__PURE__ */ React.createElement("li", null, "Support the AI lab that keeps strain matching sharp")), /* @__PURE__ */ React.createElement(MembershipLogin, { onSuccess: () => {
        setShowMembershipDialog(false);
        setAlertMsg("Welcome to the Garden! Membership perks are now active.");
        setAlertOpen(true);
        loadCredits();
      } }))
    ),
    /* @__PURE__ */ React.createElement(
      Snackbar,
      {
        open: alertOpen,
        autoHideDuration: 4e3,
        onClose: () => setAlertOpen(false),
        message: alertMsg,
        anchorOrigin: { vertical: "top", horizontal: "center" }
      }
    ),
    /* @__PURE__ */ React.createElement(Tooltip, { title: "Send Feedback", placement: "left" }, /* @__PURE__ */ React.createElement(
      Fab,
      {
        color: "primary",
        onClick: () => setShowFeedback(true),
        sx: {
          position: "fixed",
          bottom: 24,
          right: 24,
          zIndex: 1e3,
          background: "linear-gradient(135deg, #7CB342 0%, #9CCC65 100%)",
          boxShadow: "0 8px 30px rgba(124, 179, 66, 0.4)",
          "&:hover": {
            background: "linear-gradient(135deg, #9CCC65 0%, #7CB342 100%)",
            boxShadow: "0 12px 40px rgba(124, 179, 66, 0.6)",
            transform: "scale(1.05)"
          }
        }
      },
      /* @__PURE__ */ React.createElement(FeedbackIcon, null)
    )),
    /* @__PURE__ */ React.createElement(
      FeedbackModal,
      {
        open: showFeedback,
        onClose: () => setShowFeedback(false),
        user: currentUser
      }
    )
  ));
}
const useEffect$n = window["React"].useEffect;
const useState$q = window["React"].useState;
function FeedbackChat({ onBack }) {
  const [messages, setMessages] = useState$q([]);
  const [input, setInput] = useState$q("");
  const [posting, setPosting] = useState$q(false);
  const [testingEmail, setTestingEmail] = useState$q(false);
  const [testResult, setTestResult] = useState$q(null);
  const load = () => __async(null, null, function* () {
    try {
      const res = yield fetch(`${API_BASE}/api/feedback/messages`);
      if (res.ok) {
        setMessages(yield res.json());
      }
    } catch (e) {
      console.error("[Feedback] Load error:", e);
    }
  });
  const sendTestEmail = () => __async(null, null, function* () {
    setTestingEmail(true);
    setTestResult(null);
    try {
      const res = yield fetch(`${API_BASE}/diagnostic/email-test`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ to: "strainspotter25feedback@gmail.com" })
      });
      const data = yield res.json();
      setTestResult(data.ok ? "Email sent!" : `Error: ${data.error || "Unknown"}`);
    } catch (e) {
      setTestResult("Network error");
    }
    setTestingEmail(false);
  });
  useEffect$n(() => {
    load();
  }, []);
  const send = () => __async(null, null, function* () {
    const content = input.trim();
    if (!content) return;
    setPosting(true);
    try {
      console.log("[Feedback] Sending to:", `${API_BASE}/api/feedback/messages`);
      const res = yield fetch(`${API_BASE}/api/feedback/messages`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "apikey": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJkcXB4aXhzYnFjc3lmZXdjbWJ6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAxMjI3NTMsImV4cCI6MjA3NTY5ODc1M30.rTbYZNKNv1szvzjA2D828OVt7qUZVSXgi4G_tUqm3mA"
        },
        body: JSON.stringify({ content, user_id: null })
      });
      if (res.ok) {
        setInput("");
        yield load();
      } else {
        const errText = yield res.text();
        console.error("[Feedback] Send failed:", errText);
        alert("Failed to send feedback. Please try again.");
      }
    } catch (e) {
      console.error("[Feedback] Error:", e);
      alert("Network error sending feedback.");
    } finally {
      setPosting(false);
    }
  });
  const handleKeyPress = (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      send();
    }
  };
  return /* @__PURE__ */ React.createElement(Box, { sx: { p: 2 } }, onBack && /* @__PURE__ */ React.createElement(
    Button,
    {
      onClick: onBack,
      size: "small",
      variant: "contained",
      sx: {
        bgcolor: "white",
        color: "black",
        textTransform: "none",
        fontWeight: 700,
        borderRadius: 999,
        mb: 2,
        "&:hover": { bgcolor: "grey.100" }
      }
    },
    "Home"
  ), /* @__PURE__ */ React.createElement(Card, { sx: {
    bgcolor: "rgba(255,255,255,0.7)",
    boxShadow: "0 8px 32px 0 rgba(31, 38, 135, 0.37)",
    backdropFilter: "blur(12px)",
    borderRadius: 4,
    border: "1px solid rgba(255,255,255,0.18)"
  } }, /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { mb: 2 } }, "Feedback"), /* @__PURE__ */ React.createElement(Stack, { spacing: 1, sx: { mb: 2, maxHeight: 300, overflow: "auto" } }, messages.map((m) => /* @__PURE__ */ React.createElement(Box, { key: m.id, sx: { p: 1, bgcolor: "background.default", borderRadius: 1 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, new Date(m.created_at).toLocaleString()), /* @__PURE__ */ React.createElement(Typography, { variant: "body1" }, m.content))), messages.length === 0 && /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, "No feedback yet. Be the first!")), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1 }, /* @__PURE__ */ React.createElement(
    TextField,
    {
      fullWidth: true,
      size: "small",
      placeholder: "Type feedback... (press Enter to send)",
      value: input,
      onChange: (e) => setInput(e.target.value),
      onKeyPress: handleKeyPress
    }
  ), /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "outlined",
      size: "small",
      onClick: sendTestEmail,
      disabled: testingEmail,
      sx: { textTransform: "none" }
    },
    testingEmail ? "Sending..." : "Send Test Email"
  ), /* @__PURE__ */ React.createElement(Button, { variant: "contained", onClick: send, disabled: posting }, "Send")), testResult && /* @__PURE__ */ React.createElement(Box, { sx: { px: 2, pb: 1 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: testResult === "Email sent!" ? "success.main" : "error.main" }, testResult)))));
}
const useState$p = window["React"].useState;
const useEffect$m = window["React"].useEffect;
function GardenGate({ onSuccess, onBack }) {
  const [mode, setMode2] = useState$p("welcome");
  const [loading, setLoading] = useState$p(false);
  const [error, setError] = useState$p("");
  const [checkingAuth, setCheckingAuth] = useState$p(true);
  const [signupEmail, setSignupEmail] = useState$p("");
  const [signupPassword, setSignupPassword] = useState$p("");
  const [signupName, setSignupName] = useState$p("");
  const [loginEmail, setLoginEmail] = useState$p("");
  const [loginPassword, setLoginPassword] = useState$p("");
  const [paymentComplete, setPaymentComplete] = useState$p(false);
  const authConfigured = isAuthConfigured();
  useEffect$m(() => {
    if (!supabase) {
      setCheckingAuth(false);
      return;
    }
    let isMounted = true;
    const checkAuthStatus = () => __async(null, null, function* () {
      var _a2;
      if (!supabase) return;
      try {
        const { data: { session } } = yield supabase.auth.getSession();
        if (!isMounted) return;
        if (session == null ? void 0 : session.user) {
          const membership = (_a2 = session.user.user_metadata) == null ? void 0 : _a2.membership;
          if (membership === "club") {
            onSuccess == null ? void 0 : onSuccess();
          } else {
            setMode2("payment");
          }
        }
      } catch (e) {
        console.error("Auth check failed:", e);
      } finally {
        if (isMounted) {
          setCheckingAuth(false);
        }
      }
    });
    checkAuthStatus();
    return () => {
      isMounted = false;
    };
  }, [onSuccess, supabase]);
  const handleSignup = () => __async(null, null, function* () {
    if (!supabase) {
      setError("Supabase authentication is not configured for this deployment. Please contact support.");
      return;
    }
    setError("");
    if (!signupEmail || !signupPassword || !signupName) {
      setError("Please fill in all fields");
      return;
    }
    setLoading(true);
    try {
      const { data, error: signupError } = yield supabase.auth.signUp({
        email: signupEmail,
        password: signupPassword,
        options: {
          data: {
            username: signupName,
            membership: "none"
            // Will be upgraded after payment
          }
        }
      });
      if (signupError) throw signupError;
      if (data.user) {
        setMode2("payment");
      }
    } catch (e) {
      setError(e.message || "Signup failed");
    } finally {
      setLoading(false);
    }
  });
  const handleLogin = () => __async(null, null, function* () {
    var _a2, _b;
    if (!supabase) {
      setError("Supabase authentication is not configured for this deployment. Please contact support.");
      return;
    }
    setError("");
    if (!loginEmail || !loginPassword) {
      setError("Please enter email and password");
      return;
    }
    setLoading(true);
    try {
      console.log(" Attempting login for:", loginEmail);
      const { data, error: loginError } = yield supabase.auth.signInWithPassword({
        email: loginEmail,
        password: loginPassword
      });
      console.log("Login response:", { data, error: loginError });
      if (loginError) {
        console.error("Login error:", loginError);
        throw loginError;
      }
      if ((_a2 = data.session) == null ? void 0 : _a2.user) {
        console.log(" Login successful!", data.session.user);
        const membership = (_b = data.session.user.user_metadata) == null ? void 0 : _b.membership;
        console.log("Membership status:", membership);
        if (membership === "club") {
          console.log(" User is a club member, granting access");
          onSuccess == null ? void 0 : onSuccess();
        } else {
          console.log(" User needs to pay for membership");
          setMode2("payment");
        }
      }
    } catch (e) {
      console.error(" Login failed:", e);
      setError(e.message || "Login failed");
    } finally {
      setLoading(false);
    }
  });
  const handlePayment = () => __async(null, null, function* () {
    var _a2;
    if (!supabase) {
      setError("Supabase authentication is not configured for this deployment. Please contact support.");
      return;
    }
    setLoading(true);
    setError("");
    try {
      const { data: { user } } = yield supabase.auth.getUser();
      if (!user) throw new Error("Not logged in");
      const { error: updateError } = yield supabase.auth.updateUser({
        data: {
          membership: "club",
          membership_started: (/* @__PURE__ */ new Date()).toISOString(),
          payment_status: "active",
          subscription_tier: "premium"
        }
      });
      if (updateError) throw updateError;
      if (signupName && !((_a2 = user.user_metadata) == null ? void 0 : _a2.username)) {
        yield supabase.auth.updateUser({
          data: {
            username: signupName
          }
        });
      }
      setPaymentComplete(true);
      setTimeout(() => {
        onSuccess == null ? void 0 : onSuccess();
      }, 2e3);
    } catch (e) {
      setError(e.message || "Payment failed");
    } finally {
      setLoading(false);
    }
  });
  if (checkingAuth) {
    return /* @__PURE__ */ React.createElement(Box, { sx: { minHeight: "100vh", display: "flex", alignItems: "center", justifyContent: "center" } }, /* @__PURE__ */ React.createElement(CircularProgress, { sx: { color: "#7cb342" } }));
  }
  if (!authConfigured) {
    return /* @__PURE__ */ React.createElement(Box, { sx: { minHeight: "100vh", display: "flex", alignItems: "center", justifyContent: "center", p: 3 } }, /* @__PURE__ */ React.createElement(Paper, { sx: { p: 4, borderRadius: 6, maxWidth: 420, textAlign: "center", bgcolor: "rgba(0,0,0,0.6)", color: "#fff" } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h5", sx: { mb: 2, fontWeight: 700 } }, "Authentication Offline"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, "The StrainSpotter authentication service is not configured for this deployment. Please reach out to the site administrator or try again later."), onBack && /* @__PURE__ */ React.createElement(Button, { variant: "outlined", sx: { mt: 3, color: "#fff", borderColor: "rgba(255,255,255,0.4)" }, onClick: onBack }, " Back")));
  }
  return /* @__PURE__ */ React.createElement(Box, { sx: {
    minHeight: "100vh",
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "center",
    p: { xs: 2, sm: 3 }
  } }, /* @__PURE__ */ React.createElement(Paper, { sx: {
    p: { xs: 3, sm: 4 },
    borderRadius: 6,
    width: "100%",
    maxWidth: 480,
    textAlign: "center",
    background: "rgba(255,255,255,0.15)",
    backdropFilter: "blur(20px)",
    border: "2px solid rgba(124, 179, 66, 0.3)"
  } }, mode === "welcome" && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h3", sx: { mb: 2, color: "#fff", fontWeight: 900 } }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 1 }, /* @__PURE__ */ React.createElement(Box, { component: "img", src: "/hero.png?v=13", alt: "", sx: { width: 20, height: 20, filter: "drop-shadow(0 0 4px rgba(124, 179, 66, 0.6))" } }), /* @__PURE__ */ React.createElement("span", null, "Enter the Garden"), /* @__PURE__ */ React.createElement(Box, { component: "img", src: "/hero.png?v=13", alt: "", sx: { width: 20, height: 20, filter: "drop-shadow(0 0 4px rgba(124, 179, 66, 0.6))" } }))), /* @__PURE__ */ React.createElement(Typography, { variant: "body1", sx: { mb: 4, color: "#e0e0e0" } }, "Join the StrainSpotter community to access exclusive features, unlimited scans, and connect with growers worldwide."), /* @__PURE__ */ React.createElement(Stack, { spacing: 2 }, /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "contained",
      size: "large",
      onClick: () => setMode2("signup"),
      sx: {
        width: "100%",
        py: 2,
        fontSize: "1.1rem",
        fontWeight: 700,
        bgcolor: "rgba(124, 179, 66, 0.8)",
        "&:hover": { bgcolor: "rgba(124, 179, 66, 1)" }
      }
    },
    "Sign Up & Join"
  ), /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "outlined",
      size: "large",
      onClick: () => setMode2("login"),
      sx: {
        width: "100%",
        py: 2,
        fontSize: "1.1rem",
        fontWeight: 700,
        color: "#fff",
        borderColor: "rgba(124, 179, 66, 0.6)",
        "&:hover": { borderColor: "rgba(124, 179, 66, 1)", bgcolor: "rgba(124, 179, 66, 0.1)" }
      }
    },
    "I'm Already a Member"
  ), onBack && /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "text",
      onClick: onBack,
      sx: { color: "#ccc", mt: 2 }
    },
    " Back to Home"
  ))), mode === "signup" && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h4", sx: { mb: 3, color: "#fff", fontWeight: 900 } }, "Create Account"), error && /* @__PURE__ */ React.createElement(Alert, { severity: "error", sx: { mb: 2 } }, error), /* @__PURE__ */ React.createElement(Stack, { spacing: 2 }, /* @__PURE__ */ React.createElement(
    TextField,
    {
      label: "Full Name",
      value: signupName,
      onChange: (e) => setSignupName(e.target.value),
      fullWidth: true,
      sx: {
        "& .MuiOutlinedInput-root": { color: "#fff" },
        "& .MuiInputLabel-root": { color: "#ccc" },
        "& .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.5)" }
      }
    }
  ), /* @__PURE__ */ React.createElement(
    TextField,
    {
      label: "Email",
      type: "email",
      value: signupEmail,
      onChange: (e) => setSignupEmail(e.target.value),
      fullWidth: true,
      sx: {
        "& .MuiOutlinedInput-root": { color: "#fff" },
        "& .MuiInputLabel-root": { color: "#ccc" },
        "& .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.5)" }
      }
    }
  ), /* @__PURE__ */ React.createElement(
    TextField,
    {
      label: "Password",
      type: "password",
      value: signupPassword,
      onChange: (e) => setSignupPassword(e.target.value),
      fullWidth: true,
      sx: {
        "& .MuiOutlinedInput-root": { color: "#fff" },
        "& .MuiInputLabel-root": { color: "#ccc" },
        "& .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.5)" }
      }
    }
  ), /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "contained",
      onClick: handleSignup,
      disabled: loading,
      sx: {
        width: "100%",
        py: 2,
        fontSize: "1.1rem",
        fontWeight: 700,
        bgcolor: "rgba(124, 179, 66, 0.8)",
        "&:hover": { bgcolor: "rgba(124, 179, 66, 1)" }
      }
    },
    loading ? /* @__PURE__ */ React.createElement(CircularProgress, { size: 24, sx: { color: "#fff" } }) : "Continue to Payment"
  ), /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "text",
      onClick: () => setMode2("welcome"),
      sx: { color: "#ccc" }
    },
    " Back"
  ))), mode === "login" && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h4", sx: { mb: 3, color: "#fff", fontWeight: 900 } }, "Welcome Back"), error && /* @__PURE__ */ React.createElement(Alert, { severity: "error", sx: { mb: 2 } }, error), /* @__PURE__ */ React.createElement(Stack, { spacing: 2 }, /* @__PURE__ */ React.createElement(
    TextField,
    {
      label: "Email",
      type: "email",
      value: loginEmail,
      onChange: (e) => setLoginEmail(e.target.value),
      fullWidth: true,
      sx: {
        "& .MuiOutlinedInput-root": { color: "#fff" },
        "& .MuiInputLabel-root": { color: "#ccc" },
        "& .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.5)" }
      }
    }
  ), /* @__PURE__ */ React.createElement(
    TextField,
    {
      label: "Password",
      type: "password",
      value: loginPassword,
      onChange: (e) => setLoginPassword(e.target.value),
      fullWidth: true,
      sx: {
        "& .MuiOutlinedInput-root": { color: "#fff" },
        "& .MuiInputLabel-root": { color: "#ccc" },
        "& .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.5)" }
      }
    }
  ), /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "contained",
      onClick: handleLogin,
      disabled: loading,
      sx: {
        width: "100%",
        py: 2,
        fontSize: "1.1rem",
        fontWeight: 700,
        bgcolor: "rgba(124, 179, 66, 0.8)",
        "&:hover": { bgcolor: "rgba(124, 179, 66, 1)" }
      }
    },
    loading ? /* @__PURE__ */ React.createElement(CircularProgress, { size: 24, sx: { color: "#fff" } }) : "Login"
  ), /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "text",
      onClick: () => setMode2("welcome"),
      sx: { color: "#ccc" }
    },
    " Back"
  ))), mode === "payment" && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h4", sx: { mb: 2, color: "#fff", fontWeight: 900 } }, "Join the Club"), /* @__PURE__ */ React.createElement(Typography, { variant: "body1", sx: { mb: 3, color: "#e0e0e0" } }, "Get unlimited access to all features for just $4.99/month"), error && /* @__PURE__ */ React.createElement(Alert, { severity: "error", sx: { mb: 2 } }, error), paymentComplete ? /* @__PURE__ */ React.createElement(Alert, { severity: "success", sx: { mb: 2 } }, " Payment successful! Welcome to the Garden!") : /* @__PURE__ */ React.createElement(Stack, { spacing: 2 }, /* @__PURE__ */ React.createElement(Box, { sx: { p: 3, bgcolor: "rgba(0,0,0,0.3)", borderRadius: 2, mb: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { color: "#fff", mb: 1 } }, "Membership Benefits:"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#e0e0e0", textAlign: "left" } }, " Unlimited AI scans", /* @__PURE__ */ React.createElement("br", null), " Leave reviews & ratings", /* @__PURE__ */ React.createElement("br", null), " Access to community groups", /* @__PURE__ */ React.createElement("br", null), " Grow coach & expert tips", /* @__PURE__ */ React.createElement("br", null), " Strain browser & database", /* @__PURE__ */ React.createElement("br", null), " Priority support")), /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "contained",
      onClick: handlePayment,
      disabled: loading,
      sx: {
        width: "100%",
        py: 2,
        fontSize: "1.1rem",
        fontWeight: 700,
        bgcolor: "rgba(124, 179, 66, 0.8)",
        "&:hover": { bgcolor: "rgba(124, 179, 66, 1)" }
      }
    },
    loading ? /* @__PURE__ */ React.createElement(CircularProgress, { size: 24, sx: { color: "#fff" } }) : "Pay $4.99/month"
  ), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "#ccc", mt: 2 } }, "Cancel anytime. No commitments.")))));
}
const useState$o = window["React"].useState;
const useEffect$l = window["React"].useEffect;
const useCallback$6 = window["React"].useCallback;
function useMembershipGuard() {
  const [user, setUser] = useState$o(null);
  const [isMember, setIsMember] = useState$o(false);
  const [isExpired, setIsExpired] = useState$o(false);
  const [loading, setLoading] = useState$o(true);
  const checkMembership = useCallback$6(() => __async(null, null, function* () {
    var _a2, _b;
    try {
      const { data: { session } } = yield supabase.auth.getSession();
      const currentUser = (session == null ? void 0 : session.user) || null;
      setUser(currentUser);
      if (currentUser) {
        const membership = (_a2 = currentUser.user_metadata) == null ? void 0 : _a2.membership;
        const membershipStarted = (_b = currentUser.user_metadata) == null ? void 0 : _b.membership_started;
        setIsMember(membership === "club");
        if (membership === "club" && membershipStarted) {
          const startDate = new Date(membershipStarted);
          const now = /* @__PURE__ */ new Date();
          const daysSinceStart = (now - startDate) / (1e3 * 60 * 60 * 24);
          setIsExpired(daysSinceStart > 30);
        }
      } else {
        setIsMember(false);
        setIsExpired(false);
      }
    } catch (e) {
      console.error("Membership check failed:", e);
    } finally {
      setLoading(false);
    }
  }), []);
  useEffect$l(() => {
    checkMembership();
    const { data: { subscription } } = supabase.auth.onAuthStateChange(() => {
      checkMembership();
    });
    return () => subscription.unsubscribe();
  }, [checkMembership]);
  const isAdmin = (user == null ? void 0 : user.email) === "strainspotter25@gmail.com" || (user == null ? void 0 : user.email) === "admin@strainspotter.com";
  const canLogout = isAdmin || !isMember || !isExpired;
  return {
    user,
    isMember,
    isExpired,
    canLogout,
    loading,
    refreshMembership: checkMembership
  };
}
const useState$n = window["React"].useState;
const useEffect$k = window["React"].useEffect;
const useRef$1 = window["React"].useRef;
const useCallback$5 = window["React"].useCallback;
const STRAINS_PER_PAGE = 100;
const FETCH_BATCH_SIZE = 1e3;
function StrainBrowser({ onBack }) {
  const [strains, setStrains] = useState$n([]);
  const [filteredStrains, setFilteredStrains] = useState$n([]);
  const [displayedStrains, setDisplayedStrains] = useState$n([]);
  const [loading, setLoading] = useState$n(true);
  const [searchQuery, setSearchQuery] = useState$n("");
  const [typeFilter, setTypeFilter] = useState$n("all");
  const [selectedStrain, setSelectedStrain] = useState$n(null);
  const [detailsOpen, setDetailsOpen] = useState$n(false);
  const [detailsTab, setDetailsTab] = useState$n(0);
  const [vendors, setVendors] = useState$n([]);
  const [dispensaries, setDispensaries] = useState$n([]);
  const [reviews, setReviews] = useState$n([]);
  const [userLocation, setUserLocation] = useState$n(null);
  const [loadingLocation, setLoadingLocation] = useState$n(true);
  const [page, setPage] = useState$n(0);
  const [hasMore, setHasMore] = useState$n(true);
  const [allStrainsLoaded, setAllStrainsLoaded] = useState$n(false);
  const [sortBy, setSortBy] = useState$n("type");
  const [thcRange, setThcRange] = useState$n([0, 35]);
  const [favorites, setFavorites] = useState$n([]);
  const [showFilters, setShowFilters] = useState$n(false);
  const [snackbar, setSnackbar] = useState$n({ open: false, message: "", severity: "success" });
  const [showSeedFinder, setShowSeedFinder] = useState$n(false);
  const [seedFinderStrain, setSeedFinderStrain] = useState$n(null);
  const observerTarget = useRef$1(null);
  useEffect$k(() => {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (position2) => {
          console.log("[StrainBrowser] Location obtained successfully");
          setUserLocation({
            lat: position2.coords.latitude,
            lng: position2.coords.longitude
          });
          setLoadingLocation(false);
        },
        (error) => {
          console.log("[StrainBrowser] Location denied or unavailable:", error.message);
          setUserLocation({ lat: 37.7749, lng: -122.4194 });
          setLoadingLocation(false);
        },
        {
          timeout: 5e3,
          maximumAge: 3e5,
          // 5 min cache
          enableHighAccuracy: false
        }
      );
    } else {
      console.log("[StrainBrowser] Geolocation not supported");
      setUserLocation({ lat: 37.7749, lng: -122.4194 });
      setLoadingLocation(false);
    }
  }, []);
  const fetchStrainsFromSupabase = useCallback$5(() => __async(null, null, function* () {
    if (!supabase) return [];
    let allData = [];
    let from2 = 0;
    const batchSize = FETCH_BATCH_SIZE;
    let hasMoreData = true;
    while (hasMoreData) {
      const to = from2 + batchSize - 1;
      const { data, error, count } = yield supabase.from("strains").select("*", { count: "exact" }).order("name").range(from2, to);
      if (error) throw error;
      if (data && data.length > 0) {
        allData = [...allData, ...data];
        if (count && allData.length < count) {
          from2 += batchSize;
        } else {
          hasMoreData = false;
        }
      } else {
        hasMoreData = false;
      }
    }
    return allData;
  }), [supabase]);
  const fetchStrainsFromApi = useCallback$5(() => __async(null, null, function* () {
    let results = [];
    let pageIndex = 1;
    let totalPages = 1;
    while (pageIndex <= totalPages) {
      const res = yield fetch(`${API_BASE}/api/strains?page=${pageIndex}&limit=${FETCH_BATCH_SIZE}`);
      if (!res.ok) {
        throw new Error(`HTTP ${res.status} when fetching strains from API`);
      }
      const payload = yield res.json();
      const pageStrains = Array.isArray(payload == null ? void 0 : payload.strains) ? payload.strains : [];
      results = [...results, ...pageStrains];
      totalPages = (payload == null ? void 0 : payload.pages) || 1;
      if (pageStrains.length === 0) {
        break;
      }
      pageIndex += 1;
    }
    return results;
  }), [API_BASE]);
  const fetchAllStrains = useCallback$5(() => __async(null, null, function* () {
    try {
      setLoading(true);
      console.log(" Fetching ALL strains from database...");
      let allData = [];
      let usedSupabase = false;
      if (supabase) {
        try {
          allData = yield fetchStrainsFromSupabase();
          usedSupabase = allData.length > 0;
          if (usedSupabase) {
            console.log(` Loaded ${allData.length} total strains from Supabase!`);
          } else {
            console.warn("Supabase returned 0 strains, attempting API fallback...");
          }
        } catch (supabaseError) {
          console.error(" Supabase error fetching strains:", supabaseError);
        }
      }
      if (!allData.length) {
        console.log(" Falling back to local API for strain data...");
        allData = yield fetchStrainsFromApi();
        console.log(` Loaded ${allData.length} strains via API fallback`);
      }
      if (!allData.length) {
        throw new Error("No strain data returned from Supabase or API");
      }
      setStrains(allData);
      setAllStrainsLoaded(true);
      setHasMore(false);
    } catch (error) {
      console.error(" Error fetching strains:", error);
      setStrains([]);
    } finally {
      setLoading(false);
    }
  }), [fetchStrainsFromApi, fetchStrainsFromSupabase, supabase]);
  useEffect$k(() => {
    fetchAllStrains();
  }, [fetchAllStrains]);
  const sortStrains = useCallback$5((strainsToSort) => {
    const sorted = [...strainsToSort];
    const typeOrder = { "indica": 1, "sativa": 2, "hybrid": 3 };
    switch (sortBy) {
      case "type": {
        return sorted.sort((a, b) => {
          const aType = (a.type || "unknown").toLowerCase();
          const bType = (b.type || "unknown").toLowerCase();
          const aOrder = typeOrder[aType] || 4;
          const bOrder = typeOrder[bType] || 4;
          if (aOrder !== bOrder) return aOrder - bOrder;
          return (a.name || "").localeCompare(b.name || "");
        });
      }
      case "name":
        return sorted.sort((a, b) => (a.name || "").localeCompare(b.name || ""));
      case "thc":
        return sorted.sort((a, b) => (parseFloat(b.thc) || 0) - (parseFloat(a.thc) || 0));
      case "rating":
        return sorted.sort((a, b) => (a.name || "").localeCompare(b.name || ""));
      default:
        return sorted;
    }
  }, [sortBy]);
  const applyThcFilter = useCallback$5((strainsToFilter) => {
    return strainsToFilter.filter((strain) => {
      const thc = parseFloat(strain.thc) || 0;
      return thc >= thcRange[0] && thc <= thcRange[1];
    });
  }, [thcRange]);
  const filterStrains = useCallback$5(() => {
    let filtered = [...strains];
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      filtered = filtered.filter(
        (s) => {
          var _a2, _b, _c, _d;
          return ((_a2 = s.name) == null ? void 0 : _a2.toLowerCase().includes(query)) || ((_b = s.description) == null ? void 0 : _b.toLowerCase().includes(query)) || ((_c = s.effects) == null ? void 0 : _c.some((e) => e.toLowerCase().includes(query))) || ((_d = s.flavors) == null ? void 0 : _d.some((f) => f.toLowerCase().includes(query)));
        }
      );
    }
    if (typeFilter !== "all") {
      filtered = filtered.filter((s) => {
        var _a2;
        return ((_a2 = s.type) == null ? void 0 : _a2.toLowerCase()) === typeFilter;
      });
    }
    if (showFilters) {
      filtered = applyThcFilter(filtered);
    } else {
      filtered = filtered.filter((s) => {
        var _a2;
        const thcValue = (_a2 = s.thc) != null ? _a2 : 0;
        return thcValue >= thcRange[0] && thcValue <= thcRange[1];
      });
    }
    filtered = sortStrains(filtered);
    setFilteredStrains(filtered);
  }, [strains, searchQuery, typeFilter, showFilters, thcRange, sortStrains, applyThcFilter]);
  useEffect$k(() => {
    filterStrains();
  }, [filterStrains]);
  useEffect$k(() => {
    setDisplayedStrains(filteredStrains.slice(0, STRAINS_PER_PAGE));
    setPage(0);
    setHasMore(filteredStrains.length > STRAINS_PER_PAGE);
  }, [filteredStrains]);
  useEffect$k(() => {
    const loadMoreDisplayedStrains = () => {
      const nextPage = page + 1;
      const start2 = nextPage * STRAINS_PER_PAGE;
      const end2 = start2 + STRAINS_PER_PAGE;
      const moreStrains = filteredStrains.slice(start2, end2);
      if (moreStrains.length > 0) {
        setDisplayedStrains((prev2) => [...prev2, ...moreStrains]);
        setPage(nextPage);
      }
      const hasMoreToDisplay = end2 < filteredStrains.length;
      setHasMore(hasMoreToDisplay);
    };
    const currentTarget = observerTarget.current;
    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && hasMore && !loading) {
          loadMoreDisplayedStrains();
        }
      },
      { threshold: 0.1 }
    );
    if (currentTarget) {
      observer.observe(currentTarget);
    }
    return () => {
      if (currentTarget) {
        observer.unobserve(currentTarget);
      }
    };
  }, [hasMore, loading, page, filteredStrains]);
  const handleStrainClick = (strain) => __async(null, null, function* () {
    setSelectedStrain(strain);
    setDetailsOpen(true);
    setDetailsTab(0);
    fetchVendorsForStrain(strain.name);
    fetchDispensariesForStrain();
    fetchReviewsForStrain(strain.slug, strain);
  });
  const fetchVendorsForStrain = (strainName) => __async(null, null, function* () {
    try {
      const apiBase = API_BASE || "http://localhost:5181";
      const response = yield fetch(`${apiBase}/api/seeds-live?strain=${encodeURIComponent(strainName)}&limit=20`);
      const data = yield response.json();
      const transformedVendors = (data.results || []).map((vendor) => ({
        seed_vendors: {
          name: vendor.name,
          website: vendor.website,
          country: vendor.country,
          rating: vendor.rating || 0,
          verified: vendor.verified || false
        },
        price: vendor.price || "N/A",
        seed_count: vendor.seed_count || 10,
        url: vendor.website,
        in_stock: vendor.in_stock !== false
      }));
      setVendors(transformedVendors);
    } catch (error) {
      console.error("Error fetching vendors:", error);
      setVendors([]);
    }
  });
  const fetchDispensariesForStrain = () => __async(null, null, function* () {
    try {
      if (!userLocation) {
        setDispensaries([]);
        return;
      }
      const apiBase = API_BASE || "http://localhost:5181";
      const response = yield fetch(
        `${apiBase}/api/dispensaries-live?lat=${userLocation.lat}&lng=${userLocation.lng}&radius=100&limit=20`
      );
      const data = yield response.json();
      const transformedDispensaries = (data.results || []).map((disp) => {
        var _a2, _b, _c, _d;
        return {
          dispensaries: {
            name: disp.name,
            city: disp.city || ((_b = (_a2 = disp.address) == null ? void 0 : _a2.split(",")[1]) == null ? void 0 : _b.trim()) || "Unknown",
            state: disp.state || ((_d = (_c = disp.address) == null ? void 0 : _c.split(",")[2]) == null ? void 0 : _d.trim()) || "",
            rating: disp.rating || 0,
            verified: disp.verified || false,
            website: disp.website || null
          },
          price_per_eighth: disp.price_per_eighth || "N/A",
          price_per_ounce: disp.price_per_ounce || "N/A",
          distance: disp.distance,
          in_stock: true
        };
      });
      setDispensaries(transformedDispensaries);
    } catch (error) {
      console.error("Error fetching dispensaries:", error);
      setDispensaries([]);
    }
  });
  const fetchReviewsForStrain = (strainSlug, strainForFallback) => __async(null, null, function* () {
    try {
      if (supabase) {
        const { data, error } = yield supabase.from("reviews").select("*").eq("strain_slug", strainSlug).order("created_at", { ascending: false }).limit(10);
        if (error) throw error;
        if (data && data.length) {
          setReviews(data);
          return;
        }
      }
      const res = yield fetch(`${API_BASE}/api/strains/${strainSlug}/reviews`);
      if (res.ok) {
        const payload = yield res.json().catch(() => ({}));
        const reviewList = Array.isArray(payload == null ? void 0 : payload.reviews) ? payload.reviews : [];
        setReviews(reviewList);
        return;
      }
      throw new Error(`HTTP ${res.status} when fetching reviews`);
    } catch (error) {
      console.error("Error fetching reviews:", error);
      const fallbackReviews = strainForFallback == null ? void 0 : strainForFallback.reviews;
      setReviews(Array.isArray(fallbackReviews) ? fallbackReviews : []);
    }
  });
  const getTypeColor = (type) => {
    switch (type == null ? void 0 : type.toLowerCase()) {
      case "indica":
        return "#9c27b0";
      case "sativa":
        return "#ff9800";
      case "hybrid":
        return "#4caf50";
      default:
        return "#757575";
    }
  };
  useEffect$k(() => {
    const savedFavorites = localStorage.getItem("strainFavorites");
    if (savedFavorites) {
      try {
        setFavorites(JSON.parse(savedFavorites));
      } catch (e) {
        console.error("Error loading favorites:", e);
      }
    }
  }, []);
  useEffect$k(() => {
    localStorage.setItem("strainFavorites", JSON.stringify(favorites));
  }, [favorites]);
  const toggleFavorite = (strainSlug) => {
    setFavorites((prev2) => {
      const isFavorite = prev2.includes(strainSlug);
      if (isFavorite) {
        setSnackbar({ open: true, message: "Removed from favorites", severity: "info" });
        return prev2.filter((s) => s !== strainSlug);
      } else {
        setSnackbar({ open: true, message: "Added to favorites! ", severity: "success" });
        return [...prev2, strainSlug];
      }
    });
  };
  const renderDetailsTab = () => {
    if (!selectedStrain) return null;
    switch (detailsTab) {
      case 0:
        return /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "body1", sx: { color: "#fff", mb: 2 } }, selectedStrain.description || "No description available"), selectedStrain.effects && selectedStrain.effects.length > 0 && /* @__PURE__ */ React.createElement(Box, { sx: { mb: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", sx: { color: "#7cb342", fontWeight: 700, mb: 1 } }, "Effects:"), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1, flexWrap: "wrap" }, selectedStrain.effects.map((effect2, idx) => /* @__PURE__ */ React.createElement(Chip, { key: idx, label: effect2, size: "small", sx: { bgcolor: "rgba(124, 179, 66, 0.3)", color: "#fff", mb: 1 } })))), selectedStrain.flavors && selectedStrain.flavors.length > 0 && /* @__PURE__ */ React.createElement(Box, { sx: { mb: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", sx: { color: "#7cb342", fontWeight: 700, mb: 1 } }, "Flavors:"), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1, flexWrap: "wrap" }, selectedStrain.flavors.map((flavor, idx) => /* @__PURE__ */ React.createElement(Chip, { key: idx, label: flavor, size: "small", sx: { bgcolor: "rgba(255, 152, 0, 0.3)", color: "#fff", mb: 1 } })))), /* @__PURE__ */ React.createElement(Grid, { container: true, spacing: 2, sx: { mt: 2 } }, selectedStrain.thc && /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 6 }, /* @__PURE__ */ React.createElement(Paper, { sx: { p: 2, bgcolor: "rgba(124, 179, 66, 0.2)", borderRadius: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "#e0e0e0" } }, "THC"), /* @__PURE__ */ React.createElement(Typography, { variant: "h5", sx: { color: "#7cb342", fontWeight: 700 } }, selectedStrain.thc, "%"))), selectedStrain.cbd && /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 6 }, /* @__PURE__ */ React.createElement(Paper, { sx: { p: 2, bgcolor: "rgba(33, 150, 243, 0.2)", borderRadius: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "#e0e0e0" } }, "CBD"), /* @__PURE__ */ React.createElement(Typography, { variant: "h5", sx: { color: "#2196f3", fontWeight: 700 } }, selectedStrain.cbd, "%")))));
      case 1:
        return /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Stack, { spacing: 2, sx: { mb: 3 } }, /* @__PURE__ */ React.createElement(
          Button,
          {
            variant: "contained",
            size: "small",
            startIcon: /* @__PURE__ */ React.createElement(SearchIcon, null),
            onClick: () => {
              setSeedFinderStrain({ name: selectedStrain.name, slug: selectedStrain.slug });
              setShowSeedFinder(true);
              setDetailsOpen(false);
            },
            sx: {
              bgcolor: "rgba(124, 179, 66, 0.3)",
              color: "#fff",
              border: "1px solid rgba(124, 179, 66, 0.6)",
              backdropFilter: "blur(10px)",
              "&:hover": {
                bgcolor: "rgba(124, 179, 66, 0.5)",
                border: "1px solid rgba(124, 179, 66, 0.8)"
              }
            }
          },
          "Search All Seed Banks for ",
          selectedStrain == null ? void 0 : selectedStrain.name
        )), vendors.length === 0 ? /* @__PURE__ */ React.createElement(Stack, { spacing: 2, sx: { textAlign: "center", py: 4 } }, /* @__PURE__ */ React.createElement(Typography, { sx: { color: "#e0e0e0" } }, "No seed vendors found for this strain"), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "#aaa" } }, "Click the button above to search all seed banks")) : /* @__PURE__ */ React.createElement(List$1, null, vendors.map((v, idx) => {
          var _a2, _b, _c, _d;
          return /* @__PURE__ */ React.createElement(ListItem, { key: idx, sx: { bgcolor: "rgba(255,255,255,0.05)", borderRadius: 2, mb: 2, border: "1px solid rgba(124, 179, 66, 0.3)" } }, /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(LocalFloristIcon, { sx: { color: "#7cb342" } })), /* @__PURE__ */ React.createElement(
            ListItemText,
            {
              primary: /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1, alignItems: "center" }, /* @__PURE__ */ React.createElement(Typography, { sx: { color: "#fff", fontWeight: 600 } }, (_a2 = v.seed_vendors) == null ? void 0 : _a2.name), ((_b = v.seed_vendors) == null ? void 0 : _b.verified) && /* @__PURE__ */ React.createElement(VerifiedIcon, { sx: { fontSize: 16, color: "#2196f3" } })),
              secondary: /* @__PURE__ */ React.createElement(Stack, { spacing: 0.5, sx: { mt: 1 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#e0e0e0" } }, /* @__PURE__ */ React.createElement(AttachMoneyIcon, { sx: { fontSize: 14, verticalAlign: "middle", mr: 0.5 } }), "$", v.price, " for ", v.seed_count, " seeds"), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "#aaa" } }, (_c = v.seed_vendors) == null ? void 0 : _c.country, "  Rating: ", (_d = v.seed_vendors) == null ? void 0 : _d.rating, "/5"), v.url && /* @__PURE__ */ React.createElement(Button, { size: "small", href: v.url, target: "_blank", sx: { mt: 1, color: "#7cb342" } }, "Visit Store "))
            }
          ));
        })));
      case 2:
        return /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Alert, { severity: "info", sx: { mb: 2, bgcolor: "rgba(33, 150, 243, 0.1)", color: "#90caf9", border: "1px solid rgba(33, 150, 243, 0.3)" } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, "Showing dispensaries within 100 miles of your location. Call ahead to confirm ", selectedStrain == null ? void 0 : selectedStrain.name, " is in stock.")), dispensaries.length === 0 ? /* @__PURE__ */ React.createElement(Stack, { spacing: 2, sx: { textAlign: "center", py: 4 } }, /* @__PURE__ */ React.createElement(Typography, { sx: { color: "#e0e0e0" } }, loadingLocation ? "Detecting your location..." : "No dispensaries found within 100 miles"), userLocation && /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "#aaa" } }, "Searching near: ", userLocation.lat.toFixed(4), ", ", userLocation.lng.toFixed(4))) : /* @__PURE__ */ React.createElement(List$1, null, dispensaries.map((d, idx) => {
          var _a2, _b, _c, _d, _e, _f;
          return /* @__PURE__ */ React.createElement(ListItem, { key: idx, sx: { bgcolor: "rgba(255,255,255,0.05)", borderRadius: 2, mb: 2, border: "1px solid rgba(124, 179, 66, 0.3)" } }, /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(StoreIcon, { sx: { color: "#7cb342" } })), /* @__PURE__ */ React.createElement(
            ListItemText,
            {
              primary: /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1, alignItems: "center" }, /* @__PURE__ */ React.createElement(Typography, { sx: { color: "#fff", fontWeight: 600 } }, (_a2 = d.dispensaries) == null ? void 0 : _a2.name), ((_b = d.dispensaries) == null ? void 0 : _b.verified) && /* @__PURE__ */ React.createElement(VerifiedIcon, { sx: { fontSize: 16, color: "#2196f3" } })),
              secondary: /* @__PURE__ */ React.createElement(Stack, { spacing: 0.5, sx: { mt: 1 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#e0e0e0" } }, /* @__PURE__ */ React.createElement(LocationOn, { sx: { fontSize: 14, verticalAlign: "middle", mr: 0.5 } }), (_c = d.dispensaries) == null ? void 0 : _c.city, ", ", (_d = d.dispensaries) == null ? void 0 : _d.state, d.distance && /* @__PURE__ */ React.createElement(Chip, { label: `${d.distance.toFixed(1)} mi`, size: "small", sx: { ml: 1, height: 18, fontSize: "0.65rem", bgcolor: "rgba(124, 179, 66, 0.2)", color: "#7cb342" } })), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#e0e0e0" } }, /* @__PURE__ */ React.createElement(AttachMoneyIcon, { sx: { fontSize: 14, verticalAlign: "middle", mr: 0.5 } }), d.price_per_eighth !== "N/A" ? `$${d.price_per_eighth}/eighth` : "Price varies", d.price_per_ounce !== "N/A" && `  $${d.price_per_ounce}/oz`), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "#aaa" } }, "Rating: ", (_e = d.dispensaries) == null ? void 0 : _e.rating, "/5"), ((_f = d.dispensaries) == null ? void 0 : _f.website) && /* @__PURE__ */ React.createElement(Button, { size: "small", href: d.dispensaries.website, target: "_blank", sx: { mt: 1, color: "#7cb342" } }, "Visit Website "))
            }
          ));
        })));
      case 3:
        return /* @__PURE__ */ React.createElement(Box, null, reviews.length === 0 ? /* @__PURE__ */ React.createElement(Typography, { sx: { color: "#e0e0e0", textAlign: "center", py: 4 } }, "No reviews yet for this strain") : /* @__PURE__ */ React.createElement(Stack, { spacing: 2 }, reviews.map((review) => /* @__PURE__ */ React.createElement(Paper, { key: review.id, sx: { p: 2, bgcolor: "rgba(255,255,255,0.05)", border: "1px solid rgba(124, 179, 66, 0.3)", borderRadius: 2 } }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", justifyContent: "space-between", alignItems: "center", mb: 1 }, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", sx: { color: "#7cb342", fontWeight: 600 } }, "Rating: ", review.rating, "/5"), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "#aaa" } }, new Date(review.created_at).toLocaleDateString())), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#fff" } }, review.comment)))));
      default:
        return null;
    }
  };
  if (showSeedFinder && seedFinderStrain) {
    return /* @__PURE__ */ React.createElement(
      SeedVendorFinder,
      {
        onBack: () => {
          setShowSeedFinder(false);
          setSeedFinderStrain(null);
          setDetailsOpen(true);
        },
        strainName: seedFinderStrain.name,
        strainSlug: seedFinderStrain.slug
      }
    );
  }
  return /* @__PURE__ */ React.createElement(Box, { sx: {
    minHeight: "100vh",
    pt: "calc(env(safe-area-inset-top) + 60px)",
    px: 2,
    pb: 2,
    background: "none"
  } }, onBack && /* @__PURE__ */ React.createElement(Button, { size: "small", variant: "outlined", onClick: onBack, sx: { color: "#fff", borderColor: "rgba(124, 179, 66, 0.6)", fontSize: "0.875rem", mb: 2, "&:hover": { borderColor: "rgba(124, 179, 66, 1)", bgcolor: "rgba(124, 179, 66, 0.1)" } } }, " Back"), /* @__PURE__ */ React.createElement(Box, { sx: { display: "flex", justifyContent: "center", mb: 3 } }, /* @__PURE__ */ React.createElement(
    Box,
    {
      sx: {
        width: { xs: 80, sm: 100 },
        height: { xs: 80, sm: 100 },
        borderRadius: "50%",
        background: "transparent",
        border: "2px solid rgba(124, 179, 66, 0.5)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        boxShadow: "0 0 30px rgba(124, 179, 66, 0.5)",
        overflow: "hidden",
        animation: "pulse 3s ease-in-out infinite",
        "@keyframes pulse": {
          "0%": { boxShadow: "0 0 20px rgba(124, 179, 66, 0.4)" },
          "50%": { boxShadow: "0 0 40px rgba(124, 179, 66, 0.7)" },
          "100%": { boxShadow: "0 0 20px rgba(124, 179, 66, 0.4)" }
        }
      }
    },
    /* @__PURE__ */ React.createElement(
      "img",
      {
        src: "/hero.png?v=13",
        alt: "StrainSpotter",
        style: { width: "100%", height: "100%", objectFit: "cover" }
      }
    )
  )), /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", justifyContent: "center", spacing: 1, sx: { mb: 2 } }, /* @__PURE__ */ React.createElement(Box, { component: "img", src: "/hero.png?v=13", alt: "", sx: { width: 24, height: 24, borderRadius: "50%", filter: "drop-shadow(0 0 4px rgba(124, 179, 66, 0.6))" } }), /* @__PURE__ */ React.createElement(Typography, { variant: "h5", sx: { color: "#fff", fontWeight: 700 } }, "Strain Browser")), /* @__PURE__ */ React.createElement(Paper, { sx: { p: 2, mb: 2, background: "rgba(255,255,255,0.1)", backdropFilter: "blur(20px)", border: "1px solid rgba(124, 179, 66, 0.3)", borderRadius: 2 } }, /* @__PURE__ */ React.createElement(Grid, { container: true, spacing: 1.5 }, /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, md: 6 }, /* @__PURE__ */ React.createElement(
    TextField,
    {
      fullWidth: true,
      size: "small",
      placeholder: "Search strains by name, effects, flavors...",
      value: searchQuery,
      onChange: (e) => setSearchQuery(e.target.value),
      onKeyPress: (e) => {
        if (e.key === "Enter") {
          filterStrains();
        }
      },
      slotProps: {
        input: {
          startAdornment: /* @__PURE__ */ React.createElement(InputAdornment, { position: "start" }, /* @__PURE__ */ React.createElement(SearchIcon, { sx: { color: "#7cb342", fontSize: 20 } })),
          endAdornment: searchQuery && /* @__PURE__ */ React.createElement(InputAdornment, { position: "end" }, /* @__PURE__ */ React.createElement(
            IconButton,
            {
              size: "small",
              onClick: () => setSearchQuery(""),
              sx: { color: "#fff", padding: "4px" }
            },
            /* @__PURE__ */ React.createElement(CloseIcon, { sx: { fontSize: 18 } })
          )),
          sx: { color: "#fff", fontSize: "0.875rem", "& .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.5)" }, "&:hover .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.8)" }, "&.Mui-focused .MuiOutlinedInput-notchedOutline": { borderColor: "#7cb342" } }
        }
      }
    }
  )), /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 6, sm: 4, md: 2 }, /* @__PURE__ */ React.createElement(FormControl, { fullWidth: true, size: "small" }, /* @__PURE__ */ React.createElement(InputLabel, { sx: { color: "#fff", fontSize: "0.875rem" } }, "Type"), /* @__PURE__ */ React.createElement(Select, { value: typeFilter, onChange: (e) => setTypeFilter(e.target.value), label: "Type", sx: { color: "#fff", fontSize: "0.875rem", "& .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.5)" }, "&:hover .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.8)" }, "&.Mui-focused .MuiOutlinedInput-notchedOutline": { borderColor: "#7cb342" } } }, /* @__PURE__ */ React.createElement(MenuItem, { value: "all" }, "All"), /* @__PURE__ */ React.createElement(MenuItem, { value: "indica" }, "Indica"), /* @__PURE__ */ React.createElement(MenuItem, { value: "sativa" }, "Sativa"), /* @__PURE__ */ React.createElement(MenuItem, { value: "hybrid" }, "Hybrid")))), /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 6, sm: 4, md: 2 }, /* @__PURE__ */ React.createElement(FormControl, { fullWidth: true, size: "small" }, /* @__PURE__ */ React.createElement(InputLabel, { sx: { color: "#fff", fontSize: "0.875rem" } }, "Sort"), /* @__PURE__ */ React.createElement(Select, { value: sortBy, onChange: (e) => setSortBy(e.target.value), label: "Sort", sx: { color: "#fff", fontSize: "0.875rem", "& .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.5)" }, "&:hover .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.8)" }, "&.Mui-focused .MuiOutlinedInput-notchedOutline": { borderColor: "#7cb342" } } }, /* @__PURE__ */ React.createElement(MenuItem, { value: "type" }, "Type (ISH)"), /* @__PURE__ */ React.createElement(MenuItem, { value: "name" }, "Name"), /* @__PURE__ */ React.createElement(MenuItem, { value: "thc" }, "THC %"), /* @__PURE__ */ React.createElement(MenuItem, { value: "rating" }, "Rating")))), /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, sm: 4, md: 2 }, /* @__PURE__ */ React.createElement(
    Button,
    {
      fullWidth: true,
      size: "small",
      variant: showFilters ? "contained" : "outlined",
      onClick: () => setShowFilters(!showFilters),
      startIcon: /* @__PURE__ */ React.createElement(FilterListIcon, { fontSize: "small" }),
      sx: {
        color: showFilters ? "#000" : "#fff",
        bgcolor: showFilters ? "#7cb342" : "transparent",
        borderColor: "rgba(124, 179, 66, 0.6)",
        fontSize: "0.875rem",
        "&:hover": {
          borderColor: "rgba(124, 179, 66, 1)",
          bgcolor: showFilters ? "#7cb342" : "rgba(124, 179, 66, 0.1)"
        }
      }
    },
    "Filters"
  ))), showFilters && /* @__PURE__ */ React.createElement(Box, { sx: { mt: 3, p: 2, background: "rgba(124, 179, 66, 0.1)", borderRadius: 2, border: "1px solid rgba(124, 179, 66, 0.3)" } }, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", sx: { color: "#7cb342", fontWeight: 700, mb: 2 } }, "Advanced Filters"), /* @__PURE__ */ React.createElement(Box, { sx: { px: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#fff", mb: 1 } }, "THC Range: ", thcRange[0], "% - ", thcRange[1], "%"), /* @__PURE__ */ React.createElement(
    Slider,
    {
      value: thcRange,
      onChange: (e, newValue) => setThcRange(newValue),
      valueLabelDisplay: "auto",
      min: 0,
      max: 35,
      sx: {
        color: "#7cb342",
        "& .MuiSlider-thumb": {
          bgcolor: "#7cb342"
        },
        "& .MuiSlider-track": {
          bgcolor: "#7cb342"
        },
        "& .MuiSlider-rail": {
          bgcolor: "rgba(124, 179, 66, 0.3)"
        }
      }
    }
  ))), /* @__PURE__ */ React.createElement(Stack, { direction: "row", justifyContent: "space-between", alignItems: "center", mt: 2 }, /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "#e0e0e0", fontSize: "0.8rem" } }, loading ? "Loading strains..." : /* @__PURE__ */ React.createElement(React.Fragment, null, "Showing ", displayedStrains.length, " of ", filteredStrains.length, " strains", filteredStrains.length < strains.length && ` (filtered from ${strains.length} total)`, !allStrainsLoaded && " - Loading all strains...")), favorites.length > 0 && /* @__PURE__ */ React.createElement(Tooltip, { title: "View favorites" }, /* @__PURE__ */ React.createElement(
    Chip,
    {
      size: "small",
      icon: /* @__PURE__ */ React.createElement(FavoriteIcon, { sx: { fontSize: 16 } }),
      label: `${favorites.length}`,
      onClick: () => {
        setSearchQuery("");
        setTypeFilter("all");
        const favStrains = strains.filter((s) => favorites.includes(s.slug));
        setFilteredStrains(favStrains);
        setSnackbar({ open: true, message: "Showing favorites only", severity: "info" });
      },
      sx: {
        bgcolor: "rgba(255, 64, 129, 0.2)",
        color: "#ff4081",
        cursor: "pointer",
        fontSize: "0.75rem",
        height: 24,
        "&:hover": { bgcolor: "rgba(255, 64, 129, 0.3)" }
      }
    }
  )))), loading ? /* @__PURE__ */ React.createElement(Box, { sx: { display: "flex", justifyContent: "center", py: 8 } }, /* @__PURE__ */ React.createElement(CircularProgress, { sx: { color: "#7cb342" } })) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Stack, { spacing: 1 }, displayedStrains.map((strain, index2) => {
    const indicaPercent = strain.type === "indica" ? 100 : strain.type === "sativa" ? 0 : 50;
    const sativaPercent = 100 - indicaPercent;
    const typeColor = strain.type === "indica" ? "#7b1fa2" : strain.type === "sativa" ? "#f57c00" : "#00897b";
    const strainNumber = filteredStrains.findIndex((s) => s.slug === strain.slug) + 1;
    return /* @__PURE__ */ React.createElement(
      Paper,
      {
        key: strain.slug,
        onClick: () => handleStrainClick(strain),
        sx: {
          p: 1.5,
          cursor: "pointer",
          background: "rgba(255,255,255,0.1)",
          backdropFilter: "blur(20px)",
          border: `2px solid ${typeColor}40`,
          borderRadius: 2,
          transition: "all 0.2s ease",
          "&:hover": {
            transform: "translateX(4px)",
            border: `2px solid ${typeColor}`,
            boxShadow: `0 4px 16px ${typeColor}40`
          }
        }
      },
      /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 1 }, /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: {
        color: "#7cb342",
        fontWeight: 700,
        fontSize: "0.7rem",
        minWidth: 32,
        textAlign: "right",
        opacity: 0.7
      } }, "#", strainNumber), /* @__PURE__ */ React.createElement(
        IconButton,
        {
          size: "small",
          onClick: (e) => {
            e.stopPropagation();
            toggleFavorite(strain.slug);
          },
          sx: {
            color: favorites.includes(strain.slug) ? "#ff4081" : "#666",
            padding: "2px",
            "&:hover": {
              color: "#ff4081",
              transform: "scale(1.2)"
            }
          }
        },
        favorites.includes(strain.slug) ? /* @__PURE__ */ React.createElement(FavoriteIcon, { sx: { fontSize: 18 } }) : /* @__PURE__ */ React.createElement(FavoriteBorderIcon, { sx: { fontSize: 18 } })
      ), /* @__PURE__ */ React.createElement(Typography, { variant: "body1", sx: {
        color: "#fff",
        fontWeight: 700,
        flex: 1,
        fontSize: "0.85rem",
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      } }, strain.name), /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 0.3, sx: { minWidth: 55, flexShrink: 0 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "#7b1fa2", fontWeight: 600, fontSize: "0.65rem" } }, "I", indicaPercent), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "#666", fontSize: "0.65rem" } }, "|"), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "#f57c00", fontWeight: 600, fontSize: "0.65rem" } }, "S", sativaPercent)), strain.thc && /* @__PURE__ */ React.createElement(
        Chip,
        {
          label: `${strain.thc}%`,
          size: "small",
          sx: {
            bgcolor: "#7cb342",
            color: "#fff",
            fontWeight: 700,
            fontSize: "0.65rem",
            height: 20,
            minWidth: 40,
            flexShrink: 0,
            "& .MuiChip-label": { px: 0.5 }
          }
        }
      ), /* @__PURE__ */ React.createElement(
        Chip,
        {
          label: strain.type || "Unk",
          size: "small",
          sx: {
            bgcolor: typeColor,
            color: "#fff",
            fontWeight: 700,
            fontSize: "0.65rem",
            height: 20,
            minWidth: 45,
            flexShrink: 0,
            textTransform: "capitalize",
            "& .MuiChip-label": { px: 0.5 }
          }
        }
      ))
    );
  })), /* @__PURE__ */ React.createElement(Box, { ref: observerTarget, sx: { py: 4, display: "flex", flexDirection: "column", alignItems: "center", gap: 2 } }, hasMore && displayedStrains.length > 0 && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(CircularProgress, { size: 30, sx: { color: "#7cb342" } }), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#7cb342", fontWeight: 600 } }, "Loading more strains...")), !hasMore && displayedStrains.length > 0 && displayedStrains.length === filteredStrains.length && /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 1 }, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#e0e0e0" } }, "All ", filteredStrains.length, " strains displayed!"), /* @__PURE__ */ React.createElement(Box, { component: "img", src: "/hero.png?v=13", alt: "", sx: { width: 16, height: 16, borderRadius: "50%", filter: "drop-shadow(0 0 4px rgba(124, 179, 66, 0.6))" } })))), /* @__PURE__ */ React.createElement(
    Dialog,
    {
      open: detailsOpen,
      onClose: () => setDetailsOpen(false),
      maxWidth: "md",
      fullWidth: true,
      fullScreen: true,
      slotProps: {
        paper: {
          sx: {
            background: "linear-gradient(135deg, rgba(30, 30, 30, 0.98) 0%, rgba(20, 20, 20, 0.98) 100%)",
            backdropFilter: "blur(20px)",
            border: "2px solid rgba(124, 179, 66, 0.3)",
            borderRadius: { xs: 0, sm: 4 },
            m: 0,
            maxHeight: "100vh"
          }
        }
      }
    },
    /* @__PURE__ */ React.createElement(DialogTitle, { sx: {
      color: "#fff",
      fontWeight: 700,
      borderBottom: "1px solid rgba(124, 179, 66, 0.3)",
      pt: "calc(env(safe-area-inset-top) + 16px)"
    } }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", justifyContent: "space-between", alignItems: "center" }, /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h5", sx: { fontWeight: 700, fontSize: { xs: "1.25rem", sm: "1.5rem" } } }, selectedStrain == null ? void 0 : selectedStrain.name), /* @__PURE__ */ React.createElement(Chip, { label: (selectedStrain == null ? void 0 : selectedStrain.type) || "Unknown", size: "small", sx: { bgcolor: getTypeColor(selectedStrain == null ? void 0 : selectedStrain.type), color: "#fff", fontWeight: 600, mt: 1 } })), /* @__PURE__ */ React.createElement(IconButton, { onClick: () => setDetailsOpen(false), sx: { color: "#fff" } }, /* @__PURE__ */ React.createElement(CloseIcon, null)))),
    /* @__PURE__ */ React.createElement(DialogContent, { sx: { pt: 2 } }, /* @__PURE__ */ React.createElement(Tabs, { value: detailsTab, onChange: (e, v) => setDetailsTab(v), sx: { borderBottom: "1px solid rgba(124, 179, 66, 0.3)", mb: 3 } }, /* @__PURE__ */ React.createElement(Tab, { label: "Overview", sx: { color: "#fff", "&.Mui-selected": { color: "#7cb342" } } }), /* @__PURE__ */ React.createElement(Tab, { label: `Seed Vendors (${vendors.length})`, sx: { color: "#fff", "&.Mui-selected": { color: "#7cb342" } } }), /* @__PURE__ */ React.createElement(Tab, { label: `Dispensaries (${dispensaries.length})`, sx: { color: "#fff", "&.Mui-selected": { color: "#7cb342" } } }), /* @__PURE__ */ React.createElement(Tab, { label: `Reviews (${reviews.length})`, sx: { color: "#fff", "&.Mui-selected": { color: "#7cb342" } } })), renderDetailsTab())
  ), /* @__PURE__ */ React.createElement(
    Snackbar,
    {
      open: snackbar.open,
      autoHideDuration: 3e3,
      onClose: () => setSnackbar(__spreadProps(__spreadValues({}, snackbar), { open: false })),
      anchorOrigin: { vertical: "bottom", horizontal: "center" }
    },
    /* @__PURE__ */ React.createElement(
      Alert,
      {
        onClose: () => setSnackbar(__spreadProps(__spreadValues({}, snackbar), { open: false })),
        severity: snackbar.severity,
        sx: { width: "100%" }
      },
      snackbar.message
    )
  ));
}
const useState$m = window["React"].useState;
const useEffect$j = window["React"].useEffect;
const useCallback$4 = window["React"].useCallback;
function ReviewsHub({ onBack, currentUser }) {
  const [tab, setTab] = useState$m(0);
  const [myReviews, setMyReviews] = useState$m([]);
  const [allReviews, setAllReviews] = useState$m([]);
  const [loading, setLoading] = useState$m(true);
  const [editDialog, setEditDialog] = useState$m(false);
  const [editingReview, setEditingReview] = useState$m(null);
  const [editRating, setEditRating] = useState$m(5);
  const [editComment, setEditComment] = useState$m("");
  const fetchMyReviews = useCallback$4(() => __async(null, null, function* () {
    if (!(currentUser == null ? void 0 : currentUser.id)) return;
    try {
      setLoading(true);
      const { data, error } = yield supabase.from("reviews").select("*, strains(name, slug, type)").eq("user_id", currentUser.id).order("created_at", { ascending: false });
      if (error) throw error;
      setMyReviews(data || []);
    } catch (error) {
      console.error("Error fetching my reviews:", error);
    } finally {
      setLoading(false);
    }
  }), [currentUser == null ? void 0 : currentUser.id]);
  const fetchAllReviews = useCallback$4(() => __async(null, null, function* () {
    try {
      const { data, error } = yield supabase.from("reviews").select("*, strains(name, slug, type)").order("created_at", { ascending: false }).limit(50);
      if (error) throw error;
      setAllReviews(data || []);
    } catch (error) {
      console.error("Error fetching all reviews:", error);
    }
  }), []);
  useEffect$j(() => {
    if (currentUser) {
      fetchMyReviews();
    }
    fetchAllReviews();
  }, [currentUser, fetchMyReviews, fetchAllReviews]);
  const handleEditClick = (review) => {
    setEditingReview(review);
    setEditRating(review.rating);
    setEditComment(review.comment || "");
    setEditDialog(true);
  };
  const handleUpdateReview = () => __async(null, null, function* () {
    try {
      const { error } = yield supabase.from("reviews").update({
        rating: editRating,
        comment: editComment,
        updated_at: (/* @__PURE__ */ new Date()).toISOString()
      }).eq("id", editingReview.id);
      if (error) throw error;
      setEditDialog(false);
      fetchMyReviews();
      fetchAllReviews();
    } catch (error) {
      console.error("Error updating review:", error);
      alert("Failed to update review");
    }
  });
  const handleDeleteReview = (reviewId) => __async(null, null, function* () {
    if (!confirm("Are you sure you want to delete this review?")) return;
    try {
      const { error } = yield supabase.from("reviews").delete().eq("id", reviewId);
      if (error) throw error;
      fetchMyReviews();
      fetchAllReviews();
    } catch (error) {
      console.error("Error deleting review:", error);
      alert("Failed to delete review");
    }
  });
  const getTypeColor = (type) => {
    switch (type == null ? void 0 : type.toLowerCase()) {
      case "indica":
        return "#9c27b0";
      case "sativa":
        return "#ff9800";
      case "hybrid":
        return "#4caf50";
      default:
        return "#757575";
    }
  };
  const ReviewCard = ({ review, showActions = false }) => {
    var _a2, _b;
    return /* @__PURE__ */ React.createElement(Card, { sx: {
      background: "rgba(255,255,255,0.1)",
      backdropFilter: "blur(20px)",
      border: "1px solid rgba(124, 179, 66, 0.3)",
      borderRadius: 2,
      mb: 2
    } }, /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Stack, { direction: "row", justifyContent: "space-between", alignItems: "flex-start", mb: 2 }, /* @__PURE__ */ React.createElement(Stack, { spacing: 1, flex: 1 }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 1 }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { color: "#fff", fontWeight: 600 } }, ((_a2 = review.strains) == null ? void 0 : _a2.name) || "Unknown Strain"), ((_b = review.strains) == null ? void 0 : _b.type) && /* @__PURE__ */ React.createElement(
      Chip,
      {
        label: review.strains.type,
        size: "small",
        sx: {
          bgcolor: getTypeColor(review.strains.type),
          color: "#fff",
          fontSize: "0.7rem",
          height: 20
        }
      }
    )), /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 2 }, /* @__PURE__ */ React.createElement(Rating, { value: review.rating, readOnly: true, size: "small" }), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "#aaa" } }, new Date(review.created_at).toLocaleDateString()))), showActions && /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1 }, /* @__PURE__ */ React.createElement(
      IconButton,
      {
        size: "small",
        onClick: () => handleEditClick(review),
        sx: { color: "#7cb342" }
      },
      /* @__PURE__ */ React.createElement(EditIcon, { fontSize: "small" })
    ), /* @__PURE__ */ React.createElement(
      IconButton,
      {
        size: "small",
        onClick: () => handleDeleteReview(review.id),
        sx: { color: "#f44336" }
      },
      /* @__PURE__ */ React.createElement(DeleteIcon, { fontSize: "small" })
    ))), review.comment && /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#e0e0e0", whiteSpace: "pre-line" } }, review.comment)));
  };
  return /* @__PURE__ */ React.createElement(Box, { sx: {
    minHeight: "100vh",
    pt: "calc(env(safe-area-inset-top) + 32px)",
    px: 2,
    pb: 2,
    background: "none"
  } }, onBack && /* @__PURE__ */ React.createElement(
    Button,
    {
      size: "small",
      variant: "outlined",
      onClick: onBack,
      startIcon: /* @__PURE__ */ React.createElement(ArrowBack, null),
      sx: {
        color: "#fff",
        borderColor: "rgba(124, 179, 66, 0.6)",
        fontSize: "0.875rem",
        mb: 2,
        "&:hover": {
          borderColor: "rgba(124, 179, 66, 1)",
          bgcolor: "rgba(124, 179, 66, 0.1)"
        }
      }
    },
    "Back"
  ), /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 2, mb: 2 }, /* @__PURE__ */ React.createElement(RateReviewIcon, { sx: { fontSize: 32, color: "#7cb342" } }), /* @__PURE__ */ React.createElement(Typography, { variant: "h5", sx: { color: "#fff", fontWeight: 700 } }, "Reviews Hub")), /* @__PURE__ */ React.createElement(Paper, { sx: {
    mb: 2,
    background: "rgba(255,255,255,0.1)",
    backdropFilter: "blur(20px)",
    border: "1px solid rgba(124, 179, 66, 0.3)",
    borderRadius: 2
  } }, /* @__PURE__ */ React.createElement(
    Tabs,
    {
      value: tab,
      onChange: (e, v) => setTab(v),
      sx: {
        borderBottom: "1px solid rgba(124, 179, 66, 0.3)",
        "& .MuiTab-root": { color: "#fff" },
        "& .Mui-selected": { color: "#7cb342" }
      }
    },
    /* @__PURE__ */ React.createElement(Tab, { label: `My Reviews (${myReviews.length})` }),
    /* @__PURE__ */ React.createElement(Tab, { label: "Community Reviews" })
  )), loading ? /* @__PURE__ */ React.createElement(Box, { sx: { display: "flex", justifyContent: "center", py: 8 } }, /* @__PURE__ */ React.createElement(CircularProgress, { sx: { color: "#7cb342" } })) : /* @__PURE__ */ React.createElement(Box, null, tab === 0 ? (
    // My Reviews
    /* @__PURE__ */ React.createElement(Box, null, !currentUser ? /* @__PURE__ */ React.createElement(Paper, { sx: {
      p: 4,
      textAlign: "center",
      background: "rgba(255,255,255,0.1)",
      backdropFilter: "blur(20px)",
      border: "1px solid rgba(124, 179, 66, 0.3)",
      borderRadius: 2
    } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { color: "#fff", mb: 2 } }, "Please log in to view your reviews")) : myReviews.length === 0 ? /* @__PURE__ */ React.createElement(Paper, { sx: {
      p: 4,
      textAlign: "center",
      background: "rgba(255,255,255,0.1)",
      backdropFilter: "blur(20px)",
      border: "1px solid rgba(124, 179, 66, 0.3)",
      borderRadius: 2
    } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { color: "#fff", mb: 2 } }, "You haven't written any reviews yet"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#e0e0e0" } }, "Try strains and share your experience with the community!")) : /* @__PURE__ */ React.createElement(Box, null, myReviews.map((review) => /* @__PURE__ */ React.createElement(ReviewCard, { key: review.id, review, showActions: true }))))
  ) : (
    // All Reviews
    /* @__PURE__ */ React.createElement(Box, null, allReviews.length === 0 ? /* @__PURE__ */ React.createElement(Paper, { sx: {
      p: 4,
      textAlign: "center",
      background: "rgba(255,255,255,0.1)",
      backdropFilter: "blur(20px)",
      border: "1px solid rgba(124, 179, 66, 0.3)",
      borderRadius: 2
    } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { color: "#fff" } }, "No reviews yet")) : /* @__PURE__ */ React.createElement(Box, null, allReviews.map((review) => /* @__PURE__ */ React.createElement(ReviewCard, { key: review.id, review, showActions: false }))))
  )), /* @__PURE__ */ React.createElement(
    Dialog,
    {
      open: editDialog,
      onClose: () => setEditDialog(false),
      maxWidth: "sm",
      fullWidth: true,
      fullScreen: true,
      PaperProps: {
        sx: {
          background: "rgba(30, 30, 30, 0.95)",
          backdropFilter: "blur(20px)",
          border: "2px solid rgba(124, 179, 66, 0.5)",
          borderRadius: { xs: 0, sm: 3 },
          m: 0,
          maxHeight: "100vh"
        }
      }
    },
    /* @__PURE__ */ React.createElement(DialogTitle, { sx: { color: "#fff", borderBottom: "1px solid rgba(124, 179, 66, 0.3)", display: "flex", justifyContent: "space-between", alignItems: "center" } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6" }, "Edit Review"), /* @__PURE__ */ React.createElement(IconButton, { onClick: () => setEditDialog(false), sx: { color: "#fff" } }, /* @__PURE__ */ React.createElement(ArrowBack, null))),
    /* @__PURE__ */ React.createElement(DialogContent, { sx: { pt: 3 } }, /* @__PURE__ */ React.createElement(Stack, { spacing: 3 }, /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#e0e0e0", mb: 1 } }, "Rating"), /* @__PURE__ */ React.createElement(
      Rating,
      {
        value: editRating,
        onChange: (e, v) => setEditRating(v || 1),
        size: "large"
      }
    )), /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: "Your Review",
        multiline: true,
        rows: 4,
        value: editComment,
        onChange: (e) => setEditComment(e.target.value),
        fullWidth: true,
        sx: {
          "& .MuiOutlinedInput-root": {
            color: "#fff",
            "& fieldset": { borderColor: "rgba(124, 179, 66, 0.5)" },
            "&:hover fieldset": { borderColor: "rgba(124, 179, 66, 0.7)" },
            "&.Mui-focused fieldset": { borderColor: "#7cb342" }
          },
          "& .MuiInputLabel-root": { color: "#fff" }
        }
      }
    ))),
    /* @__PURE__ */ React.createElement(DialogActions, { sx: { p: 2, borderTop: "1px solid rgba(124, 179, 66, 0.3)" } }, /* @__PURE__ */ React.createElement(Button, { onClick: () => setEditDialog(false), sx: { color: "#fff" } }, "Cancel"), /* @__PURE__ */ React.createElement(
      Button,
      {
        onClick: handleUpdateReview,
        variant: "contained",
        sx: {
          bgcolor: "#7cb342",
          "&:hover": { bgcolor: "#689f38" }
        }
      },
      "Update"
    ))
  ));
}
const useCallback$3 = window["React"].useCallback;
const useEffect$i = window["React"].useEffect;
const useMemo$3 = window["React"].useMemo;
const useState$l = window["React"].useState;
function Groups({ userId: userIdProp, onNavigate, onBack }) {
  const { user: authUser } = useAuth();
  const [groups, setGroups] = useState$l([]);
  const [userId, setUserId] = useState$l(userIdProp || (authUser == null ? void 0 : authUser.id) || null);
  const [selectedGroup, setSelectedGroup] = useState$l(null);
  const [groupDialogOpen, setGroupDialogOpen] = useState$l(false);
  const [members, setMembers] = useState$l([]);
  const [messages, setMessages] = useState$l([]);
  const [input, setInput] = useState$l("");
  const [loading, setLoading] = useState$l(true);
  const ALLOWED_GROUPS = [
    "Growers",
    "Budtenders",
    "Medical",
    "Recreational",
    "Local Chat",
    "General",
    "Dispensary Owners",
    "Seed Swap",
    "Events",
    "Help & Advice"
  ];
  const [isMember, setIsMember] = useState$l(false);
  const [reportDialogOpen, setReportDialogOpen] = useState$l(false);
  const [reportingMessage, setReportingMessage] = useState$l(null);
  const [reportReason, setReportReason] = useState$l("inappropriate");
  const [reportDetails, setReportDetails] = useState$l("");
  const [guidelinesOpen, setGuidelinesOpen] = useState$l(false);
  const [guidelinesChecked, setGuidelinesChecked] = useState$l(false);
  const [guidelinesAccepted, setGuidelinesAccepted] = useState$l(false);
  const [snackbar, setSnackbar] = useState$l({ open: false, message: "", severity: "success" });
  const guidelinesKey = useMemo$3(() => `ss_guidelines_accepted_${userId || "guest"}`, [userId]);
  const handleSnackbarClose = (_event, reason) => {
    if (reason === "clickaway") return;
    setSnackbar((prev2) => __spreadProps(__spreadValues({}, prev2), { open: false }));
  };
  const [adminUserId, setAdminUserId] = useState$l(null);
  const formatTimestamp = useCallback$3((iso) => {
    if (!iso) return "";
    const date = new Date(iso);
    const diffSeconds = (Date.now() - date.getTime()) / 1e3;
    if (diffSeconds < 45) return "just now";
    if (diffSeconds < 90) return "1 min ago";
    const diffMinutes = diffSeconds / 60;
    if (diffMinutes < 60) return `${Math.round(diffMinutes)} min ago`;
    const diffHours = diffMinutes / 60;
    if (diffHours < 24) return `${Math.round(diffHours)} hr${Math.round(diffHours) === 1 ? "" : "s"} ago`;
    const diffDays = diffHours / 24;
    if (diffDays < 30) return `${Math.round(diffDays)} day${Math.round(diffDays) === 1 ? "" : "s"} ago`;
    return date.toLocaleDateString();
  }, []);
  const messageSnippet = useCallback$3((content) => {
    if (!content) return "";
    return content.length > 90 ? `${content.slice(0, 87)}` : content;
  }, []);
  const currentUserName = useMemo$3(() => {
    var _a2, _b;
    return ((_a2 = authUser == null ? void 0 : authUser.user_metadata) == null ? void 0 : _a2.username) || ((_b = authUser == null ? void 0 : authUser.email) == null ? void 0 : _b.split("@")[0]) || "You";
  }, [authUser]);
  useEffect$i(() => {
    var _a2;
    if (userIdProp) {
      setUserId(userIdProp);
      return;
    }
    if (authUser == null ? void 0 : authUser.id) {
      setUserId(authUser.id);
      console.log("[Groups] Using auth context user:", authUser.email);
      return;
    }
    let sub;
    (() => __async(null, null, function* () {
      var _a3, _b;
      try {
        if (!supabase) return;
        const { data } = yield supabase.auth.getSession();
        const sessionUserId = ((_b = (_a3 = data == null ? void 0 : data.session) == null ? void 0 : _a3.user) == null ? void 0 : _b.id) || null;
        console.log("[Groups] Session user ID:", sessionUserId);
        setUserId(sessionUserId);
      } catch (e) {
        console.error("Groups: getSession failed");
      }
    }))();
    if (supabase) {
      const listener = supabase.auth.onAuthStateChange((_e, session) => {
        var _a3;
        setUserId(((_a3 = session == null ? void 0 : session.user) == null ? void 0 : _a3.id) || null);
      });
      sub = (_a2 = listener == null ? void 0 : listener.data) == null ? void 0 : _a2.subscription;
    }
    return () => {
      var _a3;
      return (_a3 = sub == null ? void 0 : sub.unsubscribe) == null ? void 0 : _a3.call(sub);
    };
  }, [userIdProp, authUser]);
  useEffect$i(() => {
    (() => __async(null, null, function* () {
      var _a2, _b, _c, _d;
      if (userId) {
        try {
          console.log("[Groups] Auto-setting up user account for:", userId);
          const { data: { session } } = yield supabase.auth.getSession();
          const email = (_a2 = session == null ? void 0 : session.user) == null ? void 0 : _a2.email;
          const userName = ((_c = (_b = session == null ? void 0 : session.user) == null ? void 0 : _b.user_metadata) == null ? void 0 : _c.username) || (email ? email.split("@")[0] : null) || `user_${userId.substring(0, 8)}`;
          if (email) {
            console.log("[Groups] Ensuring user record exists for:", userId, email);
            const ensureRes = yield fetch(`${API_BASE}/api/users/ensure`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ user_id: userId, email, username: userName })
            });
            if (ensureRes.ok) {
              console.log("[Groups] User account ready");
            }
          }
        } catch (e) {
          console.error("[Groups] Auto-setup error:", e);
        }
      }
      try {
        console.log("[Groups] Fetching from:", `${API_BASE}/api/groups`);
        const res = yield fetch(`${API_BASE}/api/groups`);
        console.log("[Groups] Response status:", res.status, res.statusText);
        if (res.ok) {
          const payload = yield res.json();
          console.log("[Groups] Received groups:", (payload == null ? void 0 : payload.length) || 0);
          const curated = Array.isArray(payload) ? payload.filter((group) => ALLOWED_GROUPS.includes(group.name)) : [];
          setGroups(curated);
          if (!adminUserId && Array.isArray(payload) && payload.length) {
            setAdminUserId(((_d = payload[0]) == null ? void 0 : _d.admin_user_id) || null);
          }
        } else {
          console.error("[Groups] Failed to fetch groups:", res.status, res.statusText);
        }
      } catch (err) {
        console.error("[Groups] Fetch error:", err);
      } finally {
        setLoading(false);
      }
    }))();
    const stored = localStorage.getItem(guidelinesKey);
    if (stored === "true") setGuidelinesAccepted(true);
  }, [guidelinesKey, userId, adminUserId]);
  const loadMessages = (groupId) => __async(null, null, function* () {
    const res = yield fetch(`${API_BASE}/api/groups/${groupId}/messages`);
    if (res.ok) setMessages(yield res.json());
  });
  const loadMembers = (groupId) => __async(null, null, function* () {
    const res = yield fetch(`${API_BASE}/api/groups/${groupId}/members`);
    if (res.ok) {
      const data = yield res.json();
      setMembers(data);
      setIsMember(userId ? data.some((m) => m.user_id === userId) : false);
      return data;
    }
    return [];
  });
  const selectGroup = (g) => __async(null, null, function* () {
    setSelectedGroup(g);
    setGroupDialogOpen(true);
    yield loadMessages(g.id);
    const currentMembers = yield loadMembers(g.id);
    const alreadyMember = userId ? currentMembers.some((m) => m.user_id === userId) : false;
    if (userId && !alreadyMember) {
      yield joinGroup({ group: g, silent: true });
      yield loadMembers(g.id);
      yield loadMessages(g.id);
    }
  });
  const joinGroup = (..._0) => __async(null, [..._0], function* ({ group = selectedGroup, silent: silent2 = false } = {}) {
    const targetGroup = group;
    if (!targetGroup) return;
    try {
      if (!userId) {
        if (!silent2) {
          alert("Please log in to join groups.");
          onNavigate && onNavigate("login");
        }
        return;
      }
      const res = yield fetch(`${API_BASE}/api/groups/${targetGroup.id}/join`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ user_id: userId })
      });
      if (res.ok) {
        yield loadMembers(targetGroup.id);
        setIsMember(true);
        if (!silent2) {
          setSnackbar({ open: true, message: "Joined group!", severity: "success" });
        }
        return;
      }
      const err = yield res.json().catch(() => ({}));
      const message = err.error || "";
      if (typeof message === "string" && message.toLowerCase().includes("already a member")) {
        yield loadMembers(targetGroup.id);
        setIsMember(true);
        if (!silent2) {
          setSnackbar({ open: true, message: "You are already in this group.", severity: "info" });
        }
        return;
      }
      if (!silent2) {
        alert(message || "Failed to join group");
      } else {
        console.error("Failed to join group silently:", message || "Unknown error");
      }
    } catch (e) {
      console.error("Failed to join group", e);
      if (!silent2) {
        alert("Failed to join group");
      }
    }
  });
  const leaveGroup = () => __async(null, null, function* () {
    if (!selectedGroup) return;
    try {
      if (!userId) {
        alert("Please log in to leave groups.");
        onNavigate && onNavigate("login");
        return;
      }
      const res = yield fetch(`${API_BASE}/api/groups/${selectedGroup.id}/leave`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ user_id: userId })
      });
      if (res.ok) {
        yield loadMembers(selectedGroup.id);
      } else {
        const err = yield res.json().catch(() => ({}));
        alert(err.error || "Failed to leave group");
      }
    } catch (e) {
      console.error("Failed to leave group", e);
      alert("Failed to leave group");
    }
  });
  const sendMessage = () => __async(null, null, function* () {
    const content = input.trim();
    if (!content || !selectedGroup) return;
    if (!guidelinesAccepted) {
      setGuidelinesOpen(true);
      return;
    }
    if (!userId) {
      alert("Please log in to send messages.");
      onNavigate && onNavigate("login");
      return;
    }
    const accessToken = localStorage.getItem("sb-access-token");
    const optimisticId = `temp-${Date.now()}`;
    const optimisticMessage = {
      id: optimisticId,
      content,
      created_at: (/* @__PURE__ */ new Date()).toISOString(),
      user_id: userId,
      users: {
        id: userId,
        username: currentUserName,
        avatar_url: null
      },
      optimistic: true
    };
    setMessages((prev2) => [...prev2, optimisticMessage]);
    setInput("");
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 15e3);
      const res = yield fetch(`${API_BASE}/api/groups/${selectedGroup.id}/messages`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${accessToken}`
        },
        body: JSON.stringify({ content, user_id: userId }),
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (res.ok) {
        yield loadMessages(selectedGroup.id);
      } else {
        const err = yield res.json();
        setMessages((prev2) => prev2.filter((m) => m.id !== optimisticId));
        alert(err.error || "Failed to send message");
      }
    } catch (e) {
      setMessages((prev2) => prev2.filter((m) => m.id !== optimisticId));
      if (e.name === "AbortError") {
        alert("Message sending timed out. Please check your connection and try again.");
      } else {
        alert("Failed to send message");
      }
    }
  });
  const handleReport = () => __async(null, null, function* () {
    if (!reportingMessage) return;
    try {
      if (!userId) {
        alert("Please log in to report messages.");
        onNavigate && onNavigate("login");
        return;
      }
      const res = yield fetch(`${API_BASE}/api/moderation/report`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          message_id: reportingMessage.id,
          reported_by: userId,
          reason: reportReason,
          details: reportDetails
        })
      });
      if (res.ok) {
        alert("Report submitted. Thank you for helping keep our community safe.");
        setReportDialogOpen(false);
        setReportingMessage(null);
        setReportDetails("");
      } else {
        const err = yield res.json();
        alert(err.error || "Failed to submit report");
      }
    } catch (e) {
      console.error("Failed to submit report", e);
      alert("Failed to submit report");
    }
  });
  useEffect$i(() => {
    if (!selectedGroup) return;
    const updated = groups.find((g) => g.id === selectedGroup.id);
    if (updated && updated !== selectedGroup) {
      setSelectedGroup(updated);
    }
  }, [groups, selectedGroup]);
  const sortedGroups = useMemo$3(() => {
    const copy2 = [...groups];
    return copy2.sort((a, b) => {
      var _a2, _b;
      const aTime = ((_a2 = a == null ? void 0 : a.last_message) == null ? void 0 : _a2.created_at) || (a == null ? void 0 : a.created_at) || 0;
      const bTime = ((_b = b == null ? void 0 : b.last_message) == null ? void 0 : _b.created_at) || (b == null ? void 0 : b.created_at) || 0;
      return new Date(bTime).getTime() - new Date(aTime).getTime();
    });
  }, [groups]);
  const renderGroupButton = (group) => {
    var _a2, _b;
    const last = group.last_message;
    const snippet = last ? `${((_a2 = last.user) == null ? void 0 : _a2.username) ? `${last.user.username}: ` : ""}${messageSnippet(last.content)}` : "No conversations yet.";
    const timestamp = formatTimestamp((last == null ? void 0 : last.created_at) || group.created_at);
    return /* @__PURE__ */ React.createElement(
      Button,
      {
        key: group.id,
        variant: "outlined",
        onClick: () => selectGroup(group),
        fullWidth: true,
        sx: {
          justifyContent: "space-between",
          alignItems: "flex-start",
          textAlign: "left",
          p: 2,
          borderRadius: 3,
          borderColor: "rgba(124,179,66,0.35)",
          bgcolor: "rgba(255,255,255,0.8)",
          color: "#1f3320",
          "&:hover": {
            bgcolor: "rgba(124,179,66,0.3)"
          }
        }
      },
      /* @__PURE__ */ React.createElement(Stack, { spacing: 0.5, sx: { flex: 1, pr: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle1", sx: { fontWeight: 700 } }, group.name), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "rgba(22,34,22,0.75)" } }, snippet), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1, alignItems: "center", flexWrap: "wrap" }, /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "rgba(22,34,22,0.6)" } }, group.member_count || 0, " member", group.member_count === 1 ? "" : "s"), (_b = group.member_preview) == null ? void 0 : _b.map((member) => /* @__PURE__ */ React.createElement(
        Chip,
        {
          key: `${group.id}-${member.id}`,
          label: member.username,
          size: "small",
          sx: { maxWidth: 120 }
        }
      )))),
      /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "rgba(22,34,22,0.6)" } }, timestamp)
    );
  };
  const renderMessageAuthor = (message) => {
    var _a2;
    const name2 = ((_a2 = message.users) == null ? void 0 : _a2.username) || "Member";
    const initials = name2.slice(0, 2).toUpperCase();
    return /* @__PURE__ */ React.createElement(ListItemAvatar, null, /* @__PURE__ */ React.createElement(Avatar$1, { sx: { bgcolor: "rgba(124,179,66,0.35)", color: "#0c220f" } }, initials));
  };
  const isAdminMessage = (message) => {
    if (!adminUserId) return false;
    return message.user_id === adminUserId;
  };
  return /* @__PURE__ */ React.createElement(
    Box,
    {
      sx: {
        position: "relative",
        minHeight: "100vh",
        py: { xs: 3, md: 6 },
        px: { xs: 1.5, md: 4 },
        display: "flex",
        justifyContent: "center"
      }
    },
    /* @__PURE__ */ React.createElement(
      Box,
      {
        sx: {
          position: "absolute",
          inset: { xs: 16, md: 48 },
          zIndex: 0,
          borderRadius: 6,
          background: "rgba(6, 20, 7, 0.78)",
          backdropFilter: "blur(12px)",
          WebkitBackdropFilter: "blur(12px)",
          boxShadow: "0 32px 80px rgba(0,0,0,0.55)"
        }
      }
    ),
    /* @__PURE__ */ React.createElement(
      Container,
      {
        maxWidth: "lg",
        sx: {
          position: "relative",
          zIndex: 1,
          color: "#f5f5f5",
          pt: "120px",
          pb: 3
        }
      },
      onBack && /* @__PURE__ */ React.createElement(
        Button,
        {
          onClick: onBack,
          size: "small",
          variant: "contained",
          sx: {
            bgcolor: "rgba(255,255,255,0.9)",
            color: "#1a1a1a",
            textTransform: "none",
            fontWeight: 700,
            borderRadius: 999,
            mb: 1,
            "&:hover": { bgcolor: "rgba(255,255,255,1)" }
          }
        },
        " Back to Garden"
      ),
      /* @__PURE__ */ React.createElement(Box, { sx: { display: "flex", alignItems: "center", gap: 2, mb: 3 } }, /* @__PURE__ */ React.createElement(
        Box,
        {
          sx: {
            width: 60,
            height: 60,
            borderRadius: "50%",
            background: "transparent",
            border: "2px solid rgba(124, 179, 66, 0.5)",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            boxShadow: "0 0 20px rgba(124, 179, 66, 0.4)",
            overflow: "hidden",
            flexShrink: 0
          }
        },
        /* @__PURE__ */ React.createElement(
          "img",
          {
            src: "/hero.png?v=13",
            alt: "StrainSpotter",
            style: { width: "100%", height: "100%", objectFit: "cover" }
          }
        )
      ), /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { fontWeight: 700, fontSize: "1.25rem", color: "#1a1a1a" } }, "Groups & Chat")),
      /* @__PURE__ */ React.createElement(Card, { sx: {
        bgcolor: "rgba(255,255,255,0.9)",
        color: "#1f3320",
        boxShadow: "0 12px 30px rgba(0,0,0,0.25)",
        backdropFilter: "blur(10px)",
        borderRadius: 3,
        border: "1px solid rgba(255,255,255,0.18)"
      } }, /* @__PURE__ */ React.createElement(CardContent, { sx: { p: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle1", sx: { mb: 1.5, fontWeight: 600, fontSize: "1rem" } }, "Groups"), /* @__PURE__ */ React.createElement(Stack, { spacing: 1.5 }, /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { mb: 0.5, color: "rgba(22,34,22,0.8)", fontSize: "0.75rem" } }, userId ? "Tap a group to open the chat." : "Sign in to join groups."), !userId && /* @__PURE__ */ React.createElement(
        Button,
        {
          variant: "contained",
          color: "primary",
          fullWidth: true,
          onClick: () => onNavigate && onNavigate("login"),
          sx: { mb: 2 }
        },
        "Sign In to Continue"
      ), loading ? /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "rgba(22,34,22,0.6)" } }, "Loading...") : sortedGroups.length === 0 ? /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, "No groups yet.") : /* @__PURE__ */ React.createElement(Stack, { spacing: 1.5 }, sortedGroups.map(renderGroupButton))))),
      /* @__PURE__ */ React.createElement(
        Dialog,
        {
          open: groupDialogOpen,
          onClose: () => setGroupDialogOpen(false),
          maxWidth: "md",
          fullWidth: true,
          fullScreen: true,
          PaperProps: {
            sx: {
              bgcolor: "rgba(255,255,255,0.95)",
              backdropFilter: "blur(20px)",
              m: 0,
              maxHeight: "100vh",
              display: "flex",
              flexDirection: "column"
            }
          }
        },
        /* @__PURE__ */ React.createElement(DialogTitle, { sx: {
          borderBottom: "1px solid rgba(124,179,66,0.3)",
          bgcolor: "rgba(124,179,66,0.1)",
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          p: 2,
          pt: "120px"
        } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { fontWeight: 600, color: "#1a1a1a" } }, selectedGroup == null ? void 0 : selectedGroup.name), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1 }, isMember ? /* @__PURE__ */ React.createElement(Button, { size: "small", variant: "outlined", color: "error", onClick: leaveGroup }, "Leave") : /* @__PURE__ */ React.createElement(Button, { size: "small", variant: "contained", onClick: () => joinGroup() }, "Join"), /* @__PURE__ */ React.createElement(Button, { size: "small", onClick: () => setGroupDialogOpen(false) }, "Close"))),
        /* @__PURE__ */ React.createElement(DialogContent, { sx: {
          flex: 1,
          display: "flex",
          flexDirection: "column",
          p: 2,
          overflow: "hidden"
        } }, /* @__PURE__ */ React.createElement(Stack, { spacing: 1.5, sx: { flex: 1, display: "flex", flexDirection: "column", minHeight: 0 } }, !guidelinesAccepted && /* @__PURE__ */ React.createElement(
          Alert,
          {
            severity: "warning",
            icon: false,
            sx: {
              background: "rgba(255,193,7,0.18)",
              color: "#3f2c02",
              border: "1px solid rgba(255,193,7,0.4)",
              flexShrink: 0
            }
          },
          "By participating, you agree to our",
          " ",
          /* @__PURE__ */ React.createElement(Link$1, { component: "button", onClick: () => onNavigate && onNavigate("guidelines"), sx: { fontWeight: 700 } }, "Community Guidelines"),
          "."
        ), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", color: "text.secondary", sx: { flexShrink: 0 } }, members.length, " member", members.length !== 1 ? "s" : "", members.length > 0 && ": ", members.slice(0, 5).map((m) => {
          var _a2;
          return ((_a2 = m.users) == null ? void 0 : _a2.username) || "Unknown";
        }).join(", "), members.length > 5 && "..."), /* @__PURE__ */ React.createElement(Box, { sx: {
          flex: 1,
          overflow: "auto",
          minHeight: 0,
          border: "1px solid rgba(124,179,66,0.2)",
          borderRadius: 2,
          p: 1,
          bgcolor: "rgba(255,255,255,0.5)"
        } }, /* @__PURE__ */ React.createElement(List$1, { sx: { p: 0 } }, messages.length === 0 ? /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(
          ListItemText,
          {
            secondary: /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, "Be the first to say hello! Share what brings you here or ask a quick question to get the conversation rolling.")
          }
        )) : messages.map((m) => {
          var _a2;
          return /* @__PURE__ */ React.createElement(
            ListItem,
            {
              key: m.id,
              alignItems: "flex-start",
              sx: {
                alignItems: "flex-start",
                bgcolor: isAdminMessage(m) ? "rgba(124,179,66,0.12)" : "transparent",
                borderLeft: isAdminMessage(m) ? "4px solid rgba(124,179,66,0.8)" : "4px solid transparent",
                mb: 1,
                borderRadius: 2,
                pr: 6
              },
              secondaryAction: /* @__PURE__ */ React.createElement(Tooltip, { title: "Report this message" }, /* @__PURE__ */ React.createElement(
                IconButton,
                {
                  edge: "end",
                  size: "small",
                  onClick: () => {
                    setReportingMessage(m);
                    setReportDialogOpen(true);
                  }
                },
                /* @__PURE__ */ React.createElement(FlagIcon, { fontSize: "small" })
              ))
            },
            renderMessageAuthor(m),
            /* @__PURE__ */ React.createElement(
              ListItemText,
              {
                primary: /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#112516" } }, m.content),
                secondary: /* @__PURE__ */ React.createElement(Typography, { variant: "caption", color: "text.secondary" }, ((_a2 = m.users) == null ? void 0 : _a2.username) || "Member", "  ", new Date(m.created_at).toLocaleString(), m.optimistic ? "  sending" : "")
              }
            )
          );
        }))), isMember ? /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1, sx: { flexShrink: 0 } }, /* @__PURE__ */ React.createElement(
          TextField,
          {
            fullWidth: true,
            size: "small",
            placeholder: "Type a message...",
            value: input,
            onChange: (e) => setInput(e.target.value),
            onKeyDown: (e) => e.key === "Enter" && !e.shiftKey && sendMessage(),
            multiline: true,
            maxRows: 3,
            sx: {
              "& .MuiInputBase-input": { color: "#1a1a1a" },
              "& .MuiInputBase-input::placeholder": { color: "#666", opacity: 1 }
            }
          }
        ), /* @__PURE__ */ React.createElement(Button, { variant: "contained", onClick: sendMessage, sx: { minWidth: "80px", color: "#fff" } }, "Send")) : /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary", sx: { textAlign: "center", flexShrink: 0 } }, "Join this group to send messages.")))
      ),
      /* @__PURE__ */ React.createElement(Dialog, { open: reportDialogOpen, onClose: () => setReportDialogOpen(false), maxWidth: "sm", fullWidth: true }, /* @__PURE__ */ React.createElement(DialogTitle, { sx: {
        bgcolor: "rgba(255,255,255,0.7)",
        boxShadow: "0 8px 32px 0 rgba(31, 38, 135, 0.37)",
        backdropFilter: "blur(12px)",
        borderRadius: 4,
        border: "1px solid rgba(255,255,255,0.18)"
      } }, "Report Message"), /* @__PURE__ */ React.createElement(DialogContent, { sx: {
        bgcolor: "rgba(255,255,255,0.7)",
        boxShadow: "0 8px 32px 0 rgba(31, 38, 135, 0.37)",
        backdropFilter: "blur(12px)",
        borderRadius: 4,
        border: "1px solid rgba(255,255,255,0.18)"
      } }, reportingMessage && /* @__PURE__ */ React.createElement(Box, { sx: { mb: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", color: "text.secondary" }, "Message:"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { p: 1, bgcolor: "grey.100", borderRadius: 1 } }, reportingMessage.content)), /* @__PURE__ */ React.createElement(Stack, { spacing: 2, sx: { mt: 2 } }, /* @__PURE__ */ React.createElement(
        TextField,
        {
          select: true,
          label: "Reason",
          value: reportReason,
          onChange: (e) => setReportReason(e.target.value),
          fullWidth: true,
          SelectProps: { native: true }
        },
        /* @__PURE__ */ React.createElement("option", { value: "inappropriate" }, "Inappropriate content"),
        /* @__PURE__ */ React.createElement("option", { value: "harassment" }, "Harassment or bullying"),
        /* @__PURE__ */ React.createElement("option", { value: "spam" }, "Spam or advertising"),
        /* @__PURE__ */ React.createElement("option", { value: "hate" }, "Hate speech"),
        /* @__PURE__ */ React.createElement("option", { value: "threats" }, "Threats or violence"),
        /* @__PURE__ */ React.createElement("option", { value: "other" }, "Other")
      ), /* @__PURE__ */ React.createElement(
        TextField,
        {
          label: "Additional details (optional)",
          multiline: true,
          rows: 3,
          fullWidth: true,
          value: reportDetails,
          onChange: (e) => setReportDetails(e.target.value),
          placeholder: "Provide any additional context..."
        }
      ))), /* @__PURE__ */ React.createElement(DialogActions, null, /* @__PURE__ */ React.createElement(Button, { onClick: () => setReportDialogOpen(false) }, "Cancel"), /* @__PURE__ */ React.createElement(Button, { onClick: handleReport, variant: "contained", color: "error" }, "Submit Report"))),
      /* @__PURE__ */ React.createElement(Dialog, { open: guidelinesOpen, onClose: () => setGuidelinesOpen(false), maxWidth: "sm", fullWidth: true }, /* @__PURE__ */ React.createElement(DialogTitle, null, "Agree to Community Guidelines"), /* @__PURE__ */ React.createElement(DialogContent, null, /* @__PURE__ */ React.createElement(Stack, { spacing: 2, sx: { mt: 1 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, "To keep conversations helpful and safe, please agree to follow our community rules (no solicitations, no personal contact info, no harassment, obey local laws)."), /* @__PURE__ */ React.createElement(Link$1, { component: "button", onClick: () => onNavigate && onNavigate("guidelines"), sx: { alignSelf: "flex-start" } }, "View full Community Guidelines"), /* @__PURE__ */ React.createElement(
        FormControlLabel,
        {
          control: /* @__PURE__ */ React.createElement(Checkbox, { checked: guidelinesChecked, onChange: (e) => setGuidelinesChecked(e.target.checked) }),
          label: "I agree to follow the Community Guidelines"
        }
      ))), /* @__PURE__ */ React.createElement(DialogActions, null, /* @__PURE__ */ React.createElement(Button, { onClick: () => setGuidelinesOpen(false) }, "Cancel"), /* @__PURE__ */ React.createElement(
        Button,
        {
          onClick: () => {
            localStorage.setItem(guidelinesKey, "true");
            setGuidelinesAccepted(true);
            setGuidelinesOpen(false);
          },
          variant: "contained",
          disabled: !guidelinesChecked
        },
        "Accept & Continue"
      ))),
      /* @__PURE__ */ React.createElement(
        Snackbar,
        {
          open: snackbar.open,
          autoHideDuration: 4e3,
          onClose: handleSnackbarClose,
          anchorOrigin: { vertical: "bottom", horizontal: "center" }
        },
        /* @__PURE__ */ React.createElement(
          Alert,
          {
            onClose: handleSnackbarClose,
            severity: snackbar.severity,
            sx: { width: "100%" }
          },
          snackbar.message
        )
      )
    )
  );
}
const useCallback$2 = window["React"].useCallback;
const useEffect$h = window["React"].useEffect;
const useMemo$2 = window["React"].useMemo;
const useState$k = window["React"].useState;
const stageOptions = [
  "Planning",
  "Germination",
  "Seedling",
  "Vegetative",
  "Early Flower",
  "Mid Flower",
  "Late Flower",
  "Flush",
  "Harvest",
  "Dry & Cure",
  "Maintenance"
];
const initialForm = () => ({
  runLabel: "",
  strainSlug: "",
  stage: "Vegetative",
  day: "",
  entryDate: (/* @__PURE__ */ new Date()).toISOString().slice(0, 10),
  notes: "",
  highlight: "",
  healthIssues: "",
  remedies: "",
  nextActions: "",
  tasksCompleted: "",
  nutrientsUsed: "",
  medium: "",
  waterVolume: "",
  environmentNotes: "",
  aiPrompt: "",
  imageUrls: "",
  metrics: {
    temperature: "",
    humidity: "",
    vpd: "",
    ec: "",
    ph: "",
    co2: "",
    height: ""
  },
  shareEnabled: true,
  shareMessage: "",
  shareTags: "#StrainSpotter #GrowLog",
  vigor: "Thriving",
  pestCheck: "No pests detected"
});
const parseList = (value) => value.split(",").map((item) => item.trim()).filter(Boolean);
const buildShareSummary = (log) => {
  var _a2, _b, _c, _d, _e;
  const progress = log.progress || {};
  const environment = progress.metrics || {};
  const share = progress.share || {};
  const lines = [
    `Grow Update  ${progress.run_label || "Untitled Run"}`,
    progress.day ? `Day ${progress.day}` : null,
    log.stage ? `Stage: ${log.stage}` : null,
    log.strain_slug ? `Strain: ${log.strain_slug}` : null,
    environment.temperature || environment.humidity || environment.ec || environment.ph ? `Vitals  Temp: ${environment.temperature || ""} | RH: ${environment.humidity || ""} | EC: ${environment.ec || ""} | pH: ${environment.ph || ""}` : null,
    log.notes ? `Highlights: ${log.notes}` : null,
    ((_a2 = progress.tasks_completed) == null ? void 0 : _a2.length) ? `Tasks: ${progress.tasks_completed.join(", ")}` : null,
    ((_b = progress.next_actions) == null ? void 0 : _b.length) ? `Next: ${progress.next_actions.join(", ")}` : null,
    ((_d = (_c = log.health_status) == null ? void 0 : _c.issues) == null ? void 0 : _d.length) ? `Watch: ${log.health_status.issues.join(", ")}` : null,
    ((_e = share.tags) == null ? void 0 : _e.length) ? `Tags: ${share.tags.map((tag) => tag.startsWith("#") ? tag : `#${tag}`).join(" ")}` : null
  ].filter(Boolean);
  if (share.summary) {
    return share.summary;
  }
  return lines.join("\n");
};
function GrowLogBook() {
  const [form, setForm] = useState$k(() => initialForm());
  const [logs, setLogs] = useState$k([]);
  const [user, setUser] = useState$k(null);
  const [loading, setLoading] = useState$k(true);
  const [saving, setSaving] = useState$k(false);
  const [error, setError] = useState$k(null);
  const [snackbar, setSnackbar] = useState$k({ open: false, message: "" });
  const loadUserAndLogs = useCallback$2(() => __async(null, null, function* () {
    var _a2;
    setLoading(true);
    setError(null);
    try {
      const { data } = yield supabase.auth.getSession();
      const sessionUser = ((_a2 = data == null ? void 0 : data.session) == null ? void 0 : _a2.user) || null;
      setUser(sessionUser);
      if (!(sessionUser == null ? void 0 : sessionUser.id)) {
        setLogs([]);
        setLoading(false);
        return;
      }
      const resp = yield fetch(`${API_BASE}/api/growlogs?user_id=${sessionUser.id}`);
      if (!resp.ok) {
        const body2 = yield resp.json().catch(() => ({}));
        throw new Error(body2.error || "Failed to load grow logs.");
      }
      const dataLogs = yield resp.json();
      setLogs(Array.isArray(dataLogs) ? dataLogs : []);
    } catch (err) {
      console.error("[grow-logbook] load failed", err);
      setError(err.message || "Unable to load grow logs.");
    } finally {
      setLoading(false);
    }
  }), []);
  useEffect$h(() => {
    loadUserAndLogs();
  }, [loadUserAndLogs]);
  const groupedLogs = useMemo$2(() => {
    const groups = /* @__PURE__ */ new Map();
    logs.forEach((log) => {
      var _a2;
      const label = ((_a2 = log.progress) == null ? void 0 : _a2.run_label) || "Unlabeled Run";
      if (!groups.has(label)) {
        groups.set(label, []);
      }
      groups.get(label).push(log);
    });
    return Array.from(groups.entries()).map(([label, items]) => ({
      label,
      items: items.sort((a, b) => {
        var _a2, _b;
        const dateA = new Date(((_a2 = a.progress) == null ? void 0 : _a2.entry_date) || a.created_at || 0).getTime();
        const dateB = new Date(((_b = b.progress) == null ? void 0 : _b.entry_date) || b.created_at || 0).getTime();
        return dateB - dateA;
      })
    }));
  }, [logs]);
  const handleFormChange = (field) => (event) => {
    const value = event.target.value;
    if (field.startsWith("metrics.")) {
      const key = field.split(".")[1];
      setForm((prev2) => __spreadProps(__spreadValues({}, prev2), {
        metrics: __spreadProps(__spreadValues({}, prev2.metrics), {
          [key]: value
        })
      }));
      return;
    }
    setForm((prev2) => __spreadProps(__spreadValues({}, prev2), {
      [field]: value
    }));
  };
  const handleToggleShare = (_event, checked) => {
    setForm((prev2) => __spreadProps(__spreadValues({}, prev2), {
      shareEnabled: checked
    }));
  };
  const handleSubmit = () => __async(null, null, function* () {
    if (!(user == null ? void 0 : user.id)) {
      setError("You need to be signed in to save grow logs.");
      return;
    }
    setSaving(true);
    setError(null);
    try {
      const shareSummary = form.shareMessage || [
        `${form.runLabel || "Grow Log"}  ${form.stage}`,
        form.day ? `Day ${form.day}` : null,
        form.highlight || form.notes || null,
        form.nextActions ? `Next: ${form.nextActions}` : null
      ].filter(Boolean).join("\n");
      const payload = {
        user_id: user.id,
        strain_slug: form.strainSlug || null,
        stage: form.stage,
        notes: form.notes,
        images: parseList(form.imageUrls).slice(0, 6),
        health_status: {
          vigor: form.vigor,
          highlight: form.highlight,
          issues: parseList(form.healthIssues),
          medium: form.medium,
          pest_check: form.pestCheck,
          environment_notes: form.environmentNotes,
          water_volume: form.waterVolume
        },
        remedies: {
          actions: parseList(form.remedies),
          next_actions: parseList(form.nextActions),
          ai_prompt: form.aiPrompt
        },
        progress: {
          run_label: form.runLabel || "Untitled Run",
          day: form.day ? Number(form.day) : null,
          entry_date: form.entryDate,
          metrics: form.metrics,
          tasks_completed: parseList(form.tasksCompleted),
          next_actions: parseList(form.nextActions),
          nutrients: parseList(form.nutrientsUsed),
          environment_notes: form.environmentNotes,
          share: {
            enabled: form.shareEnabled,
            summary: shareSummary,
            tags: parseList(form.shareTags),
            token: form.shareEnabled ? crypto.randomUUID() : null
          },
          created_with: "grow-logbook-v1",
          last_updated: (/* @__PURE__ */ new Date()).toISOString()
        }
      };
      const resp = yield fetch(`${API_BASE}/api/growlogs`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      const data = yield resp.json().catch(() => ({}));
      if (!resp.ok) {
        throw new Error(data.error || "Failed to save grow log entry.");
      }
      setLogs((prev2) => [data, ...prev2]);
      setForm((prev2) => __spreadProps(__spreadValues({}, initialForm()), {
        runLabel: prev2.runLabel,
        strainSlug: prev2.strainSlug,
        stage: prev2.stage
      }));
      setSnackbar({ open: true, message: "Grow log entry saved." });
    } catch (err) {
      console.error("[grow-logbook] save failed", err);
      setError(err.message || "Unable to save grow log entry.");
    } finally {
      setSaving(false);
    }
  });
  const handleCopyShare = (log) => __async(null, null, function* () {
    const summary = buildShareSummary(log);
    try {
      yield navigator.clipboard.writeText(summary);
      setSnackbar({ open: true, message: "Share summary copied to clipboard." });
    } catch (err) {
      console.error("[grow-logbook] copy share failed", err);
      setError("Could not copy to clipboard. Please copy manually.");
    }
  });
  return /* @__PURE__ */ React.createElement(Stack, { spacing: 3 }, /* @__PURE__ */ React.createElement(
    Paper,
    {
      elevation: 0,
      sx: {
        p: 3,
        borderRadius: 3,
        background: "rgba(255,255,255,0.96)",
        border: "1px solid rgba(0,0,0,0.08)"
      }
    },
    /* @__PURE__ */ React.createElement(Stack, { direction: { xs: "column", sm: "row" }, spacing: 2, justifyContent: "space-between", alignItems: { xs: "flex-start", sm: "center" } }, /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1, alignItems: "center", sx: { mb: 1 } }, /* @__PURE__ */ React.createElement(NoteAdd, { sx: { color: "#7CB342" } }), /* @__PURE__ */ React.createElement(Typography, { variant: "h6", fontWeight: 800 }, "Capture Todays Grow Session")), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#333", maxWidth: 520 } }, "Log environment vitals, training moves, feed adjustments, and AI prompts so every run builds on real data. Entries sync with your private grow log and can be shared with peers in a single tap.")), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1 }, /* @__PURE__ */ React.createElement(Tooltip, { title: "Refresh entries" }, /* @__PURE__ */ React.createElement(IconButton, { onClick: loadUserAndLogs, color: "success" }, /* @__PURE__ */ React.createElement(RefreshIcon, null)))))
  ), error && /* @__PURE__ */ React.createElement(Alert, { severity: "error", onClose: () => setError(null) }, error), !user && !loading && /* @__PURE__ */ React.createElement(Alert, { severity: "info" }, "Sign in to unlock the Grow Logbook and keep detailed records of every run."), /* @__PURE__ */ React.createElement(
    Paper,
    {
      elevation: 0,
      sx: {
        p: 3,
        borderRadius: 3,
        background: "rgba(255,255,255,0.97)",
        border: "1px solid rgba(0,0,0,0.08)"
      }
    },
    /* @__PURE__ */ React.createElement(Stack, { spacing: 2 }, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle1", fontWeight: 800 }, "Log Entry"), /* @__PURE__ */ React.createElement(Grid, { container: true, spacing: 2 }, /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, md: 6 }, /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: "Grow / Run Label",
        value: form.runLabel,
        onChange: handleFormChange("runLabel"),
        fullWidth: true
      }
    )), /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, md: 3 }, /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: "Day",
        value: form.day,
        onChange: handleFormChange("day"),
        fullWidth: true,
        type: "number",
        inputProps: { min: 0 }
      }
    )), /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, md: 3 }, /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: "Entry Date",
        type: "date",
        value: form.entryDate,
        onChange: handleFormChange("entryDate"),
        fullWidth: true,
        InputLabelProps: { shrink: true }
      }
    )), /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, md: 6 }, /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: "Strain (slug or nickname)",
        value: form.strainSlug,
        onChange: handleFormChange("strainSlug"),
        fullWidth: true
      }
    )), /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, md: 6 }, /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: "Growth Stage",
        select: true,
        value: form.stage,
        onChange: handleFormChange("stage"),
        fullWidth: true
      },
      stageOptions.map((option) => /* @__PURE__ */ React.createElement(MenuItem, { key: option, value: option }, option))
    )), /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12 }, /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: "Session Notes / Highlights",
        value: form.notes,
        onChange: handleFormChange("notes"),
        multiline: true,
        minRows: 3,
        fullWidth: true
      }
    )), /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12 }, /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: "Key Highlight",
        value: form.highlight,
        onChange: handleFormChange("highlight"),
        fullWidth: true
      }
    )), /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, md: 6 }, /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: "Tasks Completed (comma separated)",
        value: form.tasksCompleted,
        onChange: handleFormChange("tasksCompleted"),
        fullWidth: true
      }
    )), /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, md: 6 }, /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: "Upcoming Actions (comma separated)",
        value: form.nextActions,
        onChange: handleFormChange("nextActions"),
        fullWidth: true
      }
    )), /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, md: 4 }, /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: "Nutrients or additives",
        value: form.nutrientsUsed,
        onChange: handleFormChange("nutrientsUsed"),
        fullWidth: true
      }
    )), /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, md: 4 }, /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: "Medium",
        value: form.medium,
        onChange: handleFormChange("medium"),
        fullWidth: true
      }
    )), /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, md: 4 }, /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: "Water volume / feed rate",
        value: form.waterVolume,
        onChange: handleFormChange("waterVolume"),
        fullWidth: true
      }
    )), /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12 }, /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: "Environment Notes",
        value: form.environmentNotes,
        onChange: handleFormChange("environmentNotes"),
        multiline: true,
        minRows: 2,
        fullWidth: true
      }
    ))), /* @__PURE__ */ React.createElement(Divider, null), /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", fontWeight: 700 }, "Vital Metrics"), /* @__PURE__ */ React.createElement(Grid, { container: true, spacing: 2 }, Object.entries(form.metrics).map(([key, value]) => /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 6, sm: 4, md: 3, key }, /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: key.toUpperCase(),
        value,
        onChange: handleFormChange(`metrics.${key}`),
        fullWidth: true
      }
    )))), /* @__PURE__ */ React.createElement(Divider, null), /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", fontWeight: 700 }, "Health Check"), /* @__PURE__ */ React.createElement(Grid, { container: true, spacing: 2 }, /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, md: 4 }, /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: "Plant vigor",
        value: form.vigor,
        onChange: handleFormChange("vigor"),
        fullWidth: true
      }
    )), /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, md: 4 }, /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: "Health Issues (comma separated)",
        value: form.healthIssues,
        onChange: handleFormChange("healthIssues"),
        fullWidth: true
      }
    )), /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, md: 4 }, /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: "Pest check result",
        value: form.pestCheck,
        onChange: handleFormChange("pestCheck"),
        fullWidth: true
      }
    )), /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, md: 6 }, /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: "Corrective actions (comma separated)",
        value: form.remedies,
        onChange: handleFormChange("remedies"),
        fullWidth: true
      }
    )), /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, md: 6 }, /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: "AI prompt to revisit",
        value: form.aiPrompt,
        onChange: handleFormChange("aiPrompt"),
        fullWidth: true
      }
    ))), /* @__PURE__ */ React.createElement(Divider, null), /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", fontWeight: 700 }, "Media & Sharing"), /* @__PURE__ */ React.createElement(Grid, { container: true, spacing: 2, alignItems: "center" }, /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, md: 8 }, /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: "Image URLs (comma separated)",
        value: form.imageUrls,
        onChange: handleFormChange("imageUrls"),
        fullWidth: true
      }
    )), /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, md: 4 }, /* @__PURE__ */ React.createElement(
      FormControlLabel,
      {
        control: /* @__PURE__ */ React.createElement(Switch, { checked: form.shareEnabled, onChange: handleToggleShare, color: "success" }),
        label: "Generate share summary"
      }
    )), form.shareEnabled && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12 }, /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: "Share summary override",
        value: form.shareMessage,
        onChange: handleFormChange("shareMessage"),
        multiline: true,
        minRows: 2,
        fullWidth: true,
        placeholder: "Optional custom message for social posts or group chats"
      }
    )), /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12 }, /* @__PURE__ */ React.createElement(
      TextField,
      {
        label: "Share tags (comma separated)",
        value: form.shareTags,
        onChange: handleFormChange("shareTags"),
        fullWidth: true
      }
    )))), /* @__PURE__ */ React.createElement(Stack, { direction: { xs: "column", sm: "row" }, spacing: 2, justifyContent: "flex-end" }, /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "outlined",
        startIcon: /* @__PURE__ */ React.createElement(AutoAwesome, null),
        onClick: () => {
          const autoShare = [
            `${form.runLabel || "Grow Log"}  ${form.stage}`,
            form.highlight && `Highlight: ${form.highlight}`,
            form.tasksCompleted && `Tasks: ${form.tasksCompleted}`,
            form.nextActions && `Next: ${form.nextActions}`
          ].filter(Boolean).join("\n");
          setForm((prev2) => __spreadProps(__spreadValues({}, prev2), { shareMessage: autoShare }));
        }
      },
      "Generate Summary"
    ), /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "contained",
        color: "success",
        startIcon: /* @__PURE__ */ React.createElement(Save, null),
        onClick: handleSubmit,
        disabled: saving || !user
      },
      saving ? "Saving" : "Save Entry"
    )))
  ), /* @__PURE__ */ React.createElement(
    Paper,
    {
      elevation: 0,
      sx: {
        p: 3,
        borderRadius: 3,
        background: "rgba(255,255,255,0.97)",
        border: "1px solid rgba(0,0,0,0.08)"
      }
    },
    /* @__PURE__ */ React.createElement(Stack, { direction: { xs: "column", sm: "row" }, justifyContent: "space-between", alignItems: { xs: "flex-start", sm: "center" }, spacing: 2, sx: { mb: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle1", fontWeight: 800 }, "Logged Sessions"), /* @__PURE__ */ React.createElement(Chip, { label: `${logs.length} entries`, color: "success", variant: "outlined" })),
    loading ? /* @__PURE__ */ React.createElement(Box, { sx: { display: "flex", justifyContent: "center", py: 4 } }, /* @__PURE__ */ React.createElement(CircularProgress, { color: "success" })) : groupedLogs.length === 0 ? /* @__PURE__ */ React.createElement(Alert, { severity: "info" }, "No log entries yet. Start by documenting todays tasks and vitals above.") : /* @__PURE__ */ React.createElement(Stack, { spacing: 3 }, groupedLogs.map(({ label, items }) => /* @__PURE__ */ React.createElement(
      Paper,
      {
        key: label,
        elevation: 0,
        sx: {
          p: 2,
          borderRadius: 3,
          border: "1px solid rgba(0,0,0,0.06)",
          background: "rgba(255,255,255,0.92)"
        }
      },
      /* @__PURE__ */ React.createElement(Stack, { direction: { xs: "column", sm: "row" }, spacing: 1, justifyContent: "space-between", alignItems: { xs: "flex-start", sm: "center" }, sx: { mb: 1 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", fontWeight: 800, sx: { color: "#2e7d32" } }, label), /* @__PURE__ */ React.createElement(Chip, { label: `${items.length} updates`, size: "small" })),
      /* @__PURE__ */ React.createElement(Stack, { spacing: 2 }, items.map((log) => {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _i;
        return /* @__PURE__ */ React.createElement(
          Paper,
          {
            key: log.id,
            elevation: 0,
            sx: {
              p: 2,
              borderRadius: 2,
              border: "1px solid rgba(0,0,0,0.05)",
              background: "rgba(250,250,250,0.95)"
            }
          },
          /* @__PURE__ */ React.createElement(Stack, { direction: { xs: "column", sm: "row" }, spacing: 1, justifyContent: "space-between" }, /* @__PURE__ */ React.createElement(Stack, { spacing: 0.5 }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1, alignItems: "center" }, /* @__PURE__ */ React.createElement(Chip, { label: log.stage || "Stage?", size: "small", color: "success", variant: "outlined" }), ((_a2 = log.progress) == null ? void 0 : _a2.day) && /* @__PURE__ */ React.createElement(Chip, { label: `Day ${log.progress.day}`, size: "small" }), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "#666" } }, new Date(((_b = log.progress) == null ? void 0 : _b.entry_date) || log.created_at).toLocaleString())), log.notes && /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#1b5e20" } }, log.notes), ((_d = (_c = log.progress) == null ? void 0 : _c.tasks_completed) == null ? void 0 : _d.length) ? /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#2f4f2f" } }, "Tasks: ", log.progress.tasks_completed.join(", ")) : null, ((_f = (_e = log.progress) == null ? void 0 : _e.next_actions) == null ? void 0 : _f.length) ? /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#2f4f2f" } }, "Next: ", log.progress.next_actions.join(", ")) : null, ((_h = (_g = log.health_status) == null ? void 0 : _g.issues) == null ? void 0 : _h.length) ? /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#c62828" } }, "Watch: ", log.health_status.issues.join(", ")) : null, ((_i = log.progress) == null ? void 0 : _i.metrics) ? /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "#455a64" } }, "Vitals  Temp ", log.progress.metrics.temperature || "", " | RH ", log.progress.metrics.humidity || "", " | EC ", log.progress.metrics.ec || "", " | pH ", log.progress.metrics.ph || "") : null), /* @__PURE__ */ React.createElement(Stack, { spacing: 1, direction: { xs: "row", sm: "column" }, justifyContent: "flex-start", alignItems: { xs: "center", sm: "flex-end" } }, /* @__PURE__ */ React.createElement(Tooltip, { title: "Copy share summary" }, /* @__PURE__ */ React.createElement(IconButton, { color: "success", onClick: () => handleCopyShare(log) }, /* @__PURE__ */ React.createElement(Share, null))), /* @__PURE__ */ React.createElement(Tooltip, { title: "Copy raw entry JSON" }, /* @__PURE__ */ React.createElement(
            IconButton,
            {
              onClick: () => __async(null, null, function* () {
                try {
                  yield navigator.clipboard.writeText(JSON.stringify(log, null, 2));
                  setSnackbar({ open: true, message: "Entry JSON copied." });
                } catch (e) {
                  setError("Unable to copy JSON to clipboard.");
                }
              })
            },
            /* @__PURE__ */ React.createElement(ContentCopy, null)
          ))))
        );
      }))
    )))
  ), /* @__PURE__ */ React.createElement(
    Snackbar,
    {
      open: snackbar.open,
      autoHideDuration: 4e3,
      onClose: () => setSnackbar({ open: false, message: "" }),
      message: snackbar.message
    }
  ));
}
const useEffect$g = window["React"].useEffect;
const useMemo$1 = window["React"].useMemo;
const useState$j = window["React"].useState;
function Section({ title, children }) {
  return /* @__PURE__ */ React.createElement(
    Box,
    {
      sx: {
        mb: 3,
        p: 2,
        borderRadius: 3,
        backgroundColor: "rgba(255,255,255,0.95)",
        border: "1px solid rgba(0,0,0,0.08)",
        boxShadow: "0 6px 18px rgba(20,40,20,0.08)"
      }
    },
    /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle1", fontWeight: 800, gutterBottom: true, sx: { color: "#000" } }, title),
    /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#000" } }, children)
  );
}
const LOGBOOK_TAB_INDEX = 13;
function GrowCoach({ onBack, initialTab = 0 }) {
  const [tab, setTab] = useState$j(initialTab);
  const [timelineIndex, setTimelineIndex] = useState$j(0);
  useEffect$g(() => {
    setTab(initialTab);
  }, [initialTab]);
  const overviewSections = useMemo$1(
    () => [
      {
        title: "The Four Pillars of Success",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("strong", null, "Environment:"), " Hold temperature, humidity, VPD, airflow, and CO inside target ranges for every stage. Stable rooms prevent most problems.", /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("strong", null, "Genetics:"), " Choose cultivars that fit your ceiling height, flowering window, and desired chemotype. Verify breeder data, germination rates, and lab tests.", /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("strong", null, "Nutrition & Water:"), " Deliver balanced feed at the correct EC and pH. Adjust based on runoff data and leaf feedback instead of bottle recommendations alone.", /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("strong", null, "Observation & Logging:"), " Inspect plants daily, record metrics, and photograph everything. Consistent logs unlock AI-driven insights and make troubleshooting fast.")
      },
      {
        title: "Baseline Targets",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Grid, { container: true, spacing: 2 }, [
          { stage: "Seedling", temp: "75-80F", rh: "65-75% RH", vpd: "0.4-0.8 kPa", light: "200-300 PPFD (18-24 hrs)" },
          { stage: "Vegetative", temp: "76-82F", rh: "55-65% RH", vpd: "1.0-1.2 kPa", light: "350-550 PPFD (18/6 or 20/4)" },
          { stage: "Early Flower", temp: "76-80F", rh: "45-55% RH", vpd: "1.1-1.3 kPa", light: "650-750 PPFD (12/12)" },
          { stage: "Mid/Late Flower", temp: "74-78F", rh: "40-50% RH", vpd: "1.2-1.4 kPa", light: "750-900 PPFD (12/12)" },
          { stage: "Dry + Cure", temp: "60-65F", rh: "55-60% RH", vpd: "0.7-0.8 kPa", light: "Complete darkness" }
        ].map((row) => /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, sm: 6, key: row.stage }, /* @__PURE__ */ React.createElement(Paper, { elevation: 0, sx: { p: 2, borderRadius: 3, background: "rgba(255,255,255,0.96)", border: "1px solid rgba(0,0,0,0.06)" } }, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", fontWeight: 700 }, row.stage), /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, "Temperature: ", row.temp), /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, "Humidity: ", row.rh), /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, "VPD: ", row.vpd), /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, "Lighting: ", row.light))))))
      },
      {
        title: "Core Equipment Checklist",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("strong", null, "Space:"), " 2244 reflective tent, inline exhaust + carbon filter (CFM  tent volume 1.25), passive or filtered active intake, oscillating clip fans for canopy and under-canopy airflow.", /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("strong", null, "Lighting:"), " Full-spectrum dimmable LED (PPF 2.4 mol/J) with timer/smart plug. Reference manufacturer PPFD map to set hanging height.", /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("strong", null, "Mediums:"), " Fabric pots (37 gal). Choose living soil (amended), coco/perlite (70/30), or soilless peat. Always use quality water (RO or filtered tap + Cal-Mag as required).", /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("strong", null, "Monitoring:"), " Calibrated pH pen, EC/TDS meter, hygrometer/thermometer at canopy, jewelers loupe (60), optional Bluetooth sensors for remote logging.", /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("strong", null, "Supplies:"), " Two- or three-part base nutrients, silica, Cal-Mag, microbial inoculant, IPM toolkit (biologicals, neem alternatives), enzyme or flushing solution, scissors, alcohol wipes.", /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("strong", null, "Automation Ready:"), " Smart plugs, leak trays, Wi-Fi sensors, StrainSpotter Grow Log templates for daily data capture.")
      },
      {
        title: "Your First Cycle Roadmap",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("strong", null, "Week 0:"), " Sanitize space, assemble equipment, run empty test for 24 hours.", /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("strong", null, "Weeks 1-2:"), " Germinate, establish seedlings, record emergence.", /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("strong", null, "Weeks 3-6:"), " Vegetative growth, training, transplant, canopy leveling.", /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("strong", null, "Weeks 7-16:"), " Flower stretch, bud formation, bulking, ripening.", /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("strong", null, "Weeks 17-18:"), " Harvest, dry, cure, and review analytics for next run.", /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("br", null), "Pair this roadmap with the Stage Timelines tab for detailed weekly objectives.")
      }
    ],
    []
  );
  const setupSections = useMemo$1(
    () => [
      {
        title: "Space & Environmental Control",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Position tent away from direct sunlight and HVAC vents; ensure dedicated electrical circuit.", /* @__PURE__ */ React.createElement("br", null), " Calculate exhaust fan size: ", /* @__PURE__ */ React.createElement("em", null, "CFM = tent volume  air exchange target (1.25-1.5)"), ". Add 25% headroom for filter resistance.", /* @__PURE__ */ React.createElement("br", null), " Configure air path: passive lower intake or filtered active intake; carbon filter at canopy height exhausting outdoors or into lung room.", /* @__PURE__ */ React.createElement("br", null), " Install two oscillating fans (above and below canopy) for gentle non-stop airflow.", /* @__PURE__ */ React.createElement("br", null), " Lightproof the spacepatch pinholes with foil tape, double up flaps to prevent light leaks during flower.")
      },
      {
        title: "Medium Recipes",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("strong", null, "Living Soil (per 10 gal):"), " 5 gal sphagnum peat, 3 gal aeration (pumice/perlite), 2 gal compost. Amend with 2 cups kelp meal, 2 cups neem/karanja, 2 cups crustacean meal, 1 cup gypsum, 1 cup basalt, 1 cup dolomite lime. Moisture to field capacity, rest 2-4 weeks, inoculate with mycorrhizae at transplant.", /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("strong", null, "Coco/Perlite 70/30:"), " Rinse buffered coco until runoff EC <0.6 mS/cm, mix with medium perlite. Feed 1.0 EC from day one, 10-15% runoff each watering, maintain root-zone pH 5.8-6.2.", /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("strong", null, "Soilless Peat (Pro-Mix style):"), " 80% peat, 20% perlite with mycorrhizae. Requires full nutrient program similar to coco but slower dryback. Maintain pH 6.0-6.3.")
      },
      {
        title: "Containers & Irrigation",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Fabric pots promote air pruning and faster oxygen exchange; pair with saucers and risers.", /* @__PURE__ */ React.createElement("br", null), " Plastic pots retain moisture longerreduce watering frequency or increase airflow.", /* @__PURE__ */ React.createElement("br", null), " Automated options: drip rings, Blumat carrots, or ebb-and-flow trays. Log irrigation events and volumes in StrainSpotter.", /* @__PURE__ */ React.createElement("br", null), " Sterilise irrigation lines monthly; flush with 3% peroxide solution during turnaround.")
      },
      {
        title: "Monitoring & Calibration",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Place hygrometer at canopy height and second sensor near root zone to monitor gradients.", /* @__PURE__ */ React.createElement("br", null), " Calibrate pH pen weekly if high-use; store probe in KCl solution, never dry.", /* @__PURE__ */ React.createElement("br", null), " Rinse EC meter with RO after use; calibrate monthly with 1413 S/cm solution.", /* @__PURE__ */ React.createElement("br", null), " Log calibration dates, filter changes, and cleanings for compliance.", /* @__PURE__ */ React.createElement("br", null), " Use lux meter (or reliable phone app) with conversion factor (lux  0.015  PPFD for white LEDs) when PAR meter absent.")
      },
      {
        title: "Automation & Data Readiness",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Connect smart plugs to StrainSpotter webhook for automated light cycle logging.", /* @__PURE__ */ React.createElement("br", null), " Install Wi-Fi or Bluetooth sensors and sync to mobile dashboards for instant alerts.", /* @__PURE__ */ React.createElement("br", null), " Build a StrainSpotter daily log template capturing: ambient temp, RH, CO, irrigation volume, input EC/pH, runoff EC/pH, observations.", /* @__PURE__ */ React.createElement("br", null), " Photograph final setup (lights on/off) and upload to AI for placement review (fan orientation, light height, potential hotspots).")
      }
    ],
    []
  );
  const germinationSections = useMemo$1(
    () => [
      {
        title: "Germination Workflow (Days 0-7)",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, "1. ", /* @__PURE__ */ React.createElement("strong", null, "Hydrate:"), " Soak seeds 12-18 hours in 68-70F filtered water (dark environment). Seeds often sink after a few hoursfloating seeds can be coaxed under.", /* @__PURE__ */ React.createElement("br", null), "2. ", /* @__PURE__ */ React.createElement("strong", null, "Incubate:"), " Transfer to moist (not soaked) paper towels between plates or inside a germination tray. Maintain 75-80F and 70-80% RH.", /* @__PURE__ */ React.createElement("br", null), "3. ", /* @__PURE__ */ React.createElement("strong", null, "Monitor:"), " Check twice daily. Keep towels damp. Wait for 0.25-0.5 inch taproot before planting.", /* @__PURE__ */ React.createElement("br", null), "4. ", /* @__PURE__ */ React.createElement("strong", null, "Plant:"), " Place taproot-down in pre-moistened medium 0.25-0.5 inch deep. Cover lightly and mist surface.", /* @__PURE__ */ React.createElement("br", null), "5. ", /* @__PURE__ */ React.createElement("strong", null, "Acclimate:"), " Use humidity dome for first 3-5 days, vent gradually to harden seedlings.", /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("br", null), "Track seed lot, soak time, and sprout date in StrainSpotter to build cultivar-specific averages.")
      },
      {
        title: "Environmental Targets",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Temperature 75-80F, RH 70-80%, gentle airflow directed above seedlings.", /* @__PURE__ */ React.createElement("br", null), " Lighting 18-24 hours per day, ~200 PPFD at canopy, LED 24-30 inches away.", /* @__PURE__ */ React.createElement("br", null), " Media moisture: evenly moist but never waterlogged. Mist surface daily; allow top layer to dry between waterings to prevent damping-off.", /* @__PURE__ */ React.createElement("br", null), " Avoid fertiliser until first true leaves emerge; use pH 6.0-6.2 water (or 5.8 in coco).")
      },
      {
        title: "Troubleshooting Germination",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Seed fails to crack after 48 hours: gently scarify with fine sandpaper, re-soak 12 hours, retry.", /* @__PURE__ */ React.createElement("br", null), " Taproot stalls: temperature likely lowmove incubator to 78F zone.", /* @__PURE__ */ React.createElement("br", null), " Helmet head: mist husk, wait 30 minutes, use sterile tweezers to ease shell off.", /* @__PURE__ */ React.createElement("br", null), " Stretching seedling: increase light intensity or lower fixture; support stem with a small stake.", /* @__PURE__ */ React.createElement("br", null), " Leaf spotting: photograph and run through StrainSpotter AI to confirm whether it is splash, deficiency, or pathogen.")
      },
      {
        title: "AI & Data Touchpoints",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Log emergence date and cultivar inside Grow Log to populate later-stage timelines automatically.", /* @__PURE__ */ React.createElement("br", null), " Upload day 3 and day 7 photosAI flags stretch, colour deviations, or early deficiency signals.", /* @__PURE__ */ React.createElement("br", null), " Record irrigation volume and intervals; AI will calculate dryback rate to inform veg watering schedule.")
      }
    ],
    []
  );
  const vegetativeSections = useMemo$1(
    () => [
      {
        title: "Environmental & Nutrient Targets",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Lighting: 18/6 or 20/4. Provide 350-550 PPFD. Maintain LED 18-24 inches above canopy.", /* @__PURE__ */ React.createElement("br", null), " Temperature: 76-82F day / 70-72F night. RH 55-65% (VPD 1.0-1.2 kPa).", /* @__PURE__ */ React.createElement("br", null), " Feeding: EC 1.0-1.4 depending on medium. Maintain N:K ratio around 3:2. Always include calcium/magnesium under LED lighting.", /* @__PURE__ */ React.createElement("br", null), " Watering: allow 10-20% runoff in coco; in soil water when top inch dry. Alternate feed/water as required by runoff data.")
      },
      {
        title: "Training Protocol",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Week 3: Top above node 4 or 5. Begin low-stress training (LST) to spread canopy.", /* @__PURE__ */ React.createElement("br", null), " Week 4: Install SCROG net 8-10 inches above pots. Tuck branches daily to maintain level canopy.", /* @__PURE__ */ React.createElement("br", null), " Week 5: Remove interior growth/shaded shoots receiving <200 PPFD. Maintain airflow through centre.", /* @__PURE__ */ React.createElement("br", null), " Week 6: Final canopy leveling. Ensure even height before transition to 12/12. Document training actions with photos.")
      },
      {
        title: "Weekly Checklist",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Inspect foliage (top/bottom) for pests, deficiencies, mechanical damage.", /* @__PURE__ */ React.createElement("br", null), " Clean and sterilise scissors, ties, and support stakes.", /* @__PURE__ */ React.createElement("br", null), " Recalibrate sensors and meters once per week.", /* @__PURE__ */ React.createElement("br", null), " Photograph canopy top-down for AI analysis of light distribution.", /* @__PURE__ */ React.createElement("br", null), " Record plant height, node count, training adjustments, and irrigation data inside StrainSpotter.")
      },
      {
        title: "AI Utilisation",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Weekly StrainSpotter Scan of canopy to detect colour shift, tip burn, or early nutrient issues.", /* @__PURE__ */ React.createElement("br", null), " Prompt example: Predict final harvest height with veg height 18 inches and cultivar stretch factor 2.", /* @__PURE__ */ React.createElement("br", null), " Upload canopy map; AI suggests additional tie-down points or defoliation targets.")
      }
    ],
    []
  );
  const floweringSections = useMemo$1(
    () => [
      {
        title: "Transition (Weeks 1-3 of Flower)",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Switch to 12/12 photoperiod; optionally add 15-minute far-red flash at lights-off to reduce stretch.  Increase PPFD to 650-750; adjust fixture height daily during stretch.  Maintain temperature 76-80F day / 68-70F night; RH 45-55% (VPD 1.1-1.3 kPa).  Transition feed over 7-10 days: reduce nitrogen, increase phosphorus/potassium gradually.  Install second trellis or plant yoyos once stretch exceeds 6 inches.  Scout daily for powdery mildew and pest pressure; document observations in Grow Log.")
      },
      {
        title: "Mid Flower (Weeks 4-7)",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Hold PPFD 750-850; CO (if supplementing) 900-1000 ppm during lights-on.  Maintain RH 40-50% to prevent botrytis; increase airflow beneath canopy.  Feed EC 1.4-1.8 depending on cultivar response; monitor runoff to keep input-output EC differential 0.3.  Perform single targeted defoliation at start of week 4 to open airflow; avoid repeated heavy stripping.  Record bud development photos weekly; AI compares to cultivar norms and flags lagging cola growth.")
      },
      {
        title: "Late Flower & Ripening (Weeks 8+)",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Begin ripening flush 10-14 days before planned harvest (RO or finishing solution). Aim for runoff EC <0.6 mS/cm by final days.  Lower night temperature to 65-68F to preserve volatile terpenes and tighten buds.  Reduce RH to 38-45%; ensure dehumidifier sized to handle transpiration load.  Inspect trichomes with 60 loupe: clear  cloudy indicates peak potency; aim for 5-10% amber for balanced effect unless cultivar-specific.  Secure heavy branches with yoyos. Eliminate light leaks to avoid foxtailing or re-veg.")
      },
      {
        title: "AI & Data Touchpoints",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Upload weekly macro photosAI detects early botrytis, nutrient tip burn, or foxtail formation.  Prompt example: Provide harvest readiness checklist for cultivar X at week 8 with 20% amber trichomes.  Record aroma notes and environmental deltas; AI correlates data with final terpene profile.")
      }
    ],
    []
  );
  const harvestSections = useMemo$1(
    () => [
      {
        title: "Harvest Preparation",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Stop foliar sprays minimum 14 days pre-harvest.", /* @__PURE__ */ React.createElement("br", null), " Clean trimming tools with isopropyl alcohol; prepare gloves, trays, drying lines.", /* @__PURE__ */ React.createElement("br", null), " Plan dark period: 24-36 hours darkness optional for terpene preservation (ensure environment stable).", /* @__PURE__ */ React.createElement("br", null), " Verify drying space conditions: 60F 2, 55-60% RH, gentle air exchange, total darkness.")
      },
      {
        title: "Cutting & Initial Processing",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Harvest just before lights-on to maximise terpene retention.", /* @__PURE__ */ React.createElement("br", null), " Remove large fan leaves immediately; optional wet trim to reduce drying RH load.", /* @__PURE__ */ React.createElement("br", null), " Hang branches evenly spaced with good airflow; avoid bud-to-bud contact.", /* @__PURE__ */ React.createElement("br", null), " Label each cultivar batch with harvest date, cultivar, phenotypic notes.", /* @__PURE__ */ React.createElement("br", null), " Log wet weight per plant for yield tracking (wet weight 0.20  expected dry weight).")
      },
      {
        title: "AI Support",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Upload harvest photos for AI to verify bud density, potential mould, or trim quality.", /* @__PURE__ */ React.createElement("br", null), " Prompt example: Confirm if these trichomes show optimal maturity for sedative effect.")
      }
    ],
    []
  );
  const dryCureSections = useMemo$1(
    () => [
      {
        title: "Drying (Days 1-10)",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Maintain 60F / 55-60% RH with slow air exchange; no direct fans on buds.", /* @__PURE__ */ React.createElement("br", null), " Inspect daily for mould, adjust RH 2% as needed to keep 7-10 day dry time.", /* @__PURE__ */ React.createElement("br", null), " Check small branches: when they snap (not bend), move to trimming.", /* @__PURE__ */ React.createElement("br", null), " Log dry-room temp/RH daily; AI monitors for deviations that risk terpene loss.")
      },
      {
        title: "Curing (Day 10+)",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Trim buds cleanly; store in airtight glass jars filled 65-70% (allow headspace).  Initial cure: burp jars 10 minutes twice daily for first 3 days, then once daily for days 4-7, every other day thereafter.  Use humidity packs (58-62%) once jar RH stable at 58-60%.  Cure for minimum 21 days before full evaluation; premium cure 6-8 weeks.  Record jar RH with digital mini-hygrometer; log terpene/aroma notes in StrainSpotter.")
      },
      {
        title: "Quality Assurance",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Test small sample for moisture using hygrometer or moisture meter (target 11-13%).  Upload cured bud photosAI evaluates trim quality, mould risk, and bag appeal.  Prompt example: Suggest corrective steps: jar RH 66% with grassy aroma at day 5 of cure.")
      }
    ],
    []
  );
  const wateringSections = useMemo$1(
    () => [
      {
        title: "Water Source & Conditioning",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Use reverse osmosis or filtered tap (ensure chlorine/chloramine removal).", /* @__PURE__ */ React.createElement("br", null), " Ideal input temperature 65-70F to maintain dissolved oxygen.", /* @__PURE__ */ React.createElement("br", null), " For living soil, dechlorinate by aerating water 24 hours or using Campden tablet.", /* @__PURE__ */ React.createElement("br", null), " Record water source, EC, and pH before mixing nutrients.")
      },
      {
        title: "Watering Techniques by Medium",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("strong", null, "Soil:"), " Water when top inch dry; saturate until 10-20% runoff. Allow full dryback (pot light) before next irrigation.", /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("strong", null, "Coco:"), " Feed every watering, every 1-2 days early veg then daily in late veg/flower. Always achieve 10-15% runoff to prevent salt buildup.", /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("strong", null, "Hydro:"), " Maintain reservoir temps 66-68F, dissolved oxygen >6 ppm, refresh nutrient solution weekly.")
      },
      {
        title: "Soil Moisture Monitoring",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Use pot weight method (lift pots) or soil moisture probes for consistency.", /* @__PURE__ */ React.createElement("br", null), " Record irrigation volume, EC, pH, and runoff data in StrainSpotter; AI spots overwatering trends.", /* @__PURE__ */ React.createElement("br", null), " Integrate volumetric water sensors (optional) to stream data into mobile dashboard.")
      }
    ],
    []
  );
  const nutrientSections = useMemo$1(
    () => [
      {
        title: "Feeding Strategy",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Base nutrients: follow manufacturer schedule at 30-50% strength initially; adjust using runoff EC and plant response.", /* @__PURE__ */ React.createElement("br", null), " Maintain veg pH 5.8-6.2 (coco/hydro) or 6.2-6.8 (soil). Flower pH 5.8-6.3 / 6.2-6.7 respectively.", /* @__PURE__ */ React.createElement("br", null), " Alternate feed/water or feed/feed/water depending on runoff EC trends.", /* @__PURE__ */ React.createElement("br", null), " Add silica in veg/early flower, Cal-Mag as needed, beneficial bacteria weekly.")
      },
      {
        title: "Deficiency & Toxicity Quick Reference",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Grid, { container: true, spacing: 2 }, [
          { name: "Nitrogen", deficiency: "Uniform yellowing of lower leaves, slow growth.", toxicity: "Very dark leaves, clawing, fragile stems." },
          { name: "Phosphorus", deficiency: "Dark, dull leaves with purple stems, slow budding.", toxicity: "Nutrient lockout causing micronutrient deficiencies." },
          { name: "Potassium", deficiency: "Leaf edge burn, weak stems, poor bud set.", toxicity: "Lockout of calcium and magnesium, crispy leaves." },
          { name: "Calcium", deficiency: "Rust spots on new growth, twisted leaves.", toxicity: "Rare, usually manifests as high EC runoff." },
          { name: "Magnesium", deficiency: "Interveinal yellowing on older leaves.", toxicity: "Can antagonise calcium uptake." }
        ].map((row) => /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, sm: 6, key: row.name }, /* @__PURE__ */ React.createElement(Paper, { elevation: 0, sx: { p: 2, borderRadius: 3, background: "rgba(255,255,255,0.96)", border: "1px solid rgba(0,0,0,0.06)" } }, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", fontWeight: 700 }, row.name), /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, /* @__PURE__ */ React.createElement("strong", null, "Deficiency:"), " ", row.deficiency), /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, /* @__PURE__ */ React.createElement("strong", null, "Toxicity:"), " ", row.toxicity))))))
      },
      {
        title: "AI Troubleshooting Workflow",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Capture close-up and whole-plant photos; upload to StrainSpotter AI to classify issue (deficiency vs toxicity vs pest).", /* @__PURE__ */ React.createElement("br", null), " Log corrective action (feed adjustment, flush, foliar) and follow up with photo 48 hours later to confirm improvement.", /* @__PURE__ */ React.createElement("br", null), " Prompt example: Run diagnostic: week 5 flower, EC 1.6 input/2.0 runoff, leaf edges burnt.")
      }
    ],
    []
  );
  const pestSections = useMemo$1(
    () => [
      {
        title: "Integrated Pest Management (IPM) Baseline",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Keep room clean; remove plant waste immediately, sterilise tools regularly.", /* @__PURE__ */ React.createElement("br", null), " Quarantine new clones for 10-14 days; treat preventatively before entering main space.", /* @__PURE__ */ React.createElement("br", null), " Apply biologicals (Bacillus subtilis, beneficial mites) on schedulealternate modes of action.")
      },
      {
        title: "Common Pests & Responses",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Grid, { container: true, spacing: 2 }, [
          { pest: "Spider Mites", sign: "Speckled leaves, webbing under leaves.", action: "Increase humidity temporarily, spray with horticultural oil or release predatory mites (Phytoseiulus persimilis)." },
          { pest: "Fungus Gnats", sign: "Tiny flies, larvae in topsoil.", action: "Allow top layer to dry, top-dress with GnatNix, apply Bacillus thuringiensis israelensis (BTi)." },
          { pest: "Powdery Mildew", sign: "White powder on leaves.", action: "Lower humidity, increase airflow, apply potassium bicarbonate or biological fungicide. Remove infected leaves." },
          { pest: "Bud Rot (Botrytis)", sign: "Gray mould inside buds.", action: "Remove infected material immediately, lower RH to &lt;45%, increase airflow, consider hydrogen peroxide spray on surrounding area." }
        ].map((row) => /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, sm: 6, key: row.pest }, /* @__PURE__ */ React.createElement(Paper, { elevation: 0, sx: { p: 2, borderRadius: 3, background: "rgba(255,255,255,0.96)", border: "1px solid rgba(0,0,0,0.06)" } }, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", fontWeight: 700 }, row.pest), /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, /* @__PURE__ */ React.createElement("strong", null, "Signs:"), " ", row.sign), /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, /* @__PURE__ */ React.createElement("strong", null, "Response:"), " ", row.action))))))
      },
      {
        title: "AI-Assisted Monitoring",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Use macro lens attachments on mobile to capture pest images; upload to StrainSpotter for classification and treatment recommendations.", /* @__PURE__ */ React.createElement("br", null), " Log every spray/application with date, product, rate, and coverage; AI ensures rotation of active ingredients.", /* @__PURE__ */ React.createElement("br", null), " Prompt example: Identify cause: Week 6 flower, RH 48%, white spots underside leaves.")
      }
    ],
    []
  );
  const timeline = useMemo$1(
    () => [
      {
        label: "Week 0",
        stage: "Pre-Plant Planning",
        focus: "Select genetics, prep environment, sterilise tools.",
        tasks: [
          "Review grow goals: yield target (g/watt), cannabinoid profile, flowering length.",
          "Select genetics suited to space height and flowering duration; order seeds/clones from vetted suppliers.",
          "Sanitise grow space with 3% hydrogen peroxide or 1:10 bleach solution; dry thoroughly.",
          "Verify electrical load capacity and timer accuracy; install surge protection.",
          "Calibrate pH and EC meters; record calibration date in log."
        ],
        aiPrompts: [
          "Recommend three cultivars for 8 ft ceiling, 9-week flower, balanced THC:CBD.",
          "Upload previous harvest images for AI review; note phenotype traits to replicate or avoid."
        ],
        metrics: ["Room temp 68-72F empty", "RH 45-55%", "Baseline VPD 1.0-1.2 kPa"]
      },
      {
        label: "Week 1",
        stage: "Germination & Emergence",
        focus: "Even germination, gentle environment.",
        tasks: [
          "Hydrate seeds 12-18 hours, incubate in moist paper towel at 78F.",
          "Transfer to medium once taproot 0.25-0.5 inches; label cultivar and date.",
          "Maintain humidity dome 70-80% until cotyledons fully open.",
          "Provide 18-24 hour light at ~200 PPFD; ensure gentle airflow above seedlings.",
          "Log emergence dates in StrainSpotter to start growth timeline."
        ],
        aiPrompts: [
          "Is this seedling stretching? Suggest light distance adjustment.",
          "Upload seedling photo to confirm healthy colour and cotyledon shape."
        ],
        metrics: ["Temp 75-80F", "RH 70-80%", "pH 5.8-6.2", "EC 0.4"]
      },
      {
        label: "Week 2",
        stage: "Seedling Establishment",
        focus: "Root expansion, prepare for transplant.",
        tasks: [
          "Remove humidity dome; increase gentle airflow to prevent damping-off.",
          "Water 5-10% pot volume with pH 6.0, 150-200 ppm solution (or dechlorinated water for amended soil).",
          "Transplant into solo cups or 1-gal pots once roots circle starter cube.",
          "Introduce low-stress training anchors (soft wire) to prepare for future training.",
          "Record first true leaf size and colour in log."
        ],
        aiPrompts: [
          "Calculate dryback time for 1-gal coco at 78F with 55% RH.",
          "Upload leaf photo to distinguish splash marks vs deficiency."
        ],
        metrics: ["Temp 75-80F", "RH 60-70%", "VPD 0.8-1.0 kPa"]
      },
      {
        label: "Weeks 3-4",
        stage: "Vegetative Ramp",
        focus: "Build structure, accelerate root mass.",
        tasks: [
          "Transplant into final containers with microbial inoculant.",
          "Top above node 4 or 5, begin low-stress training to even canopy.",
          "Feed 0.8-1.2 EC solution; monitor runoff to prevent salt build-up.",
          "Defoliate damaged or shading leaves to improve airflow.",
          "Document plant height, node count, training actions."
        ],
        aiPrompts: [
          "Estimate final height with current veg height 18 inches and stretch factor 2.",
          "Upload canopy photo for AI tie-down recommendations."
        ],
        metrics: ["PPFD 350-450", "RH 55-65%", "VPD 1.0-1.2 kPa"]
      },
      {
        label: "Weeks 5-6",
        stage: "Late Vegetative / Flip Prep",
        focus: "Even canopy, pathogen prevention.",
        tasks: [
          "Install trellis net, finalise canopy height.",
          "Perform lollipop pruning on lower growth receiving &lt;200 PPFD.",
          "Conduct final preventative IPM spray (biologicals).",
          "Verify timer accuracy and dark-period integrity.",
          "Plan nutrient transition schedule for flower."
        ],
        aiPrompts: [
          "List defoliation order for SCROG canopy one week before flip.",
          "Upload canopy map to check PPFD uniformity."
        ],
        metrics: ["RH 50-60%", "Runoff pH 5.8-6.3", "Leaf surface vs ambient delta &lt;2F"]
      },
      {
        label: "Weeks 7-10",
        stage: "Early Flower (Stretch)",
        focus: "Manage stretch, initiate buds.",
        tasks: [
          "Switch to 12/12, ramp PPFD to 650-750.",
          "Support branches with ties/yoyos as stretch progresses.",
          "Increase bloom nutrients gradually, maintain nitrogen moderate.",
          "Inspect daily for powdery mildew and pests.",
          "Log bud site count weekly via photos."
        ],
        aiPrompts: [
          "Upload bud site photos to track stretch uniformity.",
          "Predict harvest date given pre-flower date and cultivar flowering length."
        ],
        metrics: ["Temp 76-80F / 68-70F night", "RH 45-55%", "VPD 1.1-1.3 kPa"]
      },
      {
        label: "Weeks 11-14",
        stage: "Mid Flower",
        focus: "Bulk buds, preserve terpenes.",
        tasks: [
          "Hold PPFD 750-850; keep RH 40-50%.",
          "Feed EC 1.4-1.8, adjust based on runoff trend.",
          "Inspect for botrytis; remove susceptible leaves near buds.",
          "Optional CO supplementation to 900-1000 ppm.",
          "Document aroma changes and frost development."
        ],
        aiPrompts: [
          "Upload macro shots; AI detects early bud rot or nutrient stress.",
          "Is leaf fade normal at week 6 flower given current feed data?"
        ],
        metrics: ["VPD 1.2-1.4 kPa", "Runoff EC within 0.3 of input"]
      },
      {
        label: "Weeks 15-16",
        stage: "Ripening",
        focus: "Flush, monitor maturity.",
        tasks: [
          "Begin flush 10-14 days before harvest; aim for runoff EC &lt;0.6.",
          "Lower RH to 38-45%; run dehumidifier overnight.",
          "Secure heavy branches; eliminate light leaks.",
          "Inspect trichomes every 2-3 days.",
          "Plan harvest schedule and post-harvest workflow."
        ],
        aiPrompts: [
          "Upload trichome images for AI amber/cloudy ratio.",
          "Provide final week ripening checklist for cultivar X."
        ],
        metrics: ["Night temp 65-68F", "Dark period fully sealed"]
      },
      {
        label: "Week 17",
        stage: "Harvest",
        focus: "Cut, trim, hang.",
        tasks: [
          "Harvest before lights-on; remove large fan leaves immediately.",
          "Hang branches evenly spaced with gentle airflow.",
          "Label batches with cultivar, harvest date, wet weight.",
          "Sanitise trimming tools between plants.",
          "Document wet weight and notes in Grow Log."
        ],
        aiPrompts: [
          "Calculate ideal dry-room settings for 6 lb wet weight in 48 space.",
          "Upload harvest room photo for AI layout check."
        ],
        metrics: ["Dry room 60F", "RH 55-60%", "Airflow indirect"]
      },
      {
        label: "Week 18+",
        stage: "Dry & Cure",
        focus: "Equalise moisture, preserve terpenes.",
        tasks: [
          "Dry 7-10 days until small stems snap; trim buds and jar.",
          "Burp jars daily first week, every other day second week.",
          "Stabilise jar RH at 58-62% with humidity packs.",
          "Log final dry weight, potency tests, and sensory notes.",
          "Store long-term in cool, dark location (55F, 55% RH)."
        ],
        aiPrompts: [
          "Troubleshoot hay aroma in jar at 64% RH day 5 of cure.",
          "Upload cured bud photo for AI review of trim quality and mould risk."
        ],
        metrics: ["Jar RH 58-62%", "Cure duration minimum 21 days"]
      }
    ],
    []
  );
  const safeTimelineIndex = timeline.length > 0 ? Math.min(Math.max(timelineIndex, 0), timeline.length - 1) : 0;
  const currentTimeline = timeline.length > 0 ? timeline[safeTimelineIndex] : null;
  const dailyPlaybook = useMemo$1(
    () => [
      {
        stage: "Vegetative",
        tasks: {
          Morning: ["Record ambient temp/RH and CO", "Inspect leaves (top/bottom) for pests or deficiencies", "Water/feed if pots are light (target 10-15% runoff)"],
          Midday: ["Adjust LST ties or SCROG tucks", "Check light height and PPFD map", "Update StrainSpotter log with observations"],
          Evening: ["Final canopy inspection, remove debris", "Confirm timers and environmental controls", "Capture photo set for AI comparison"]
        }
      },
      {
        stage: "Flower  Weeks 1-5",
        tasks: {
          Morning: ["Measure temp/RH and VPD at canopy", "Check for powdery mildew or pest pressure", "Irrigate based on dryback schedule"],
          Midday: ["Review trichomes with loupe on sample buds", "Log runoff EC/pH values", "Upload bud photo for AI stretch monitoring"],
          Evening: ["Verify dark period light-proofing", "Adjust dehumidifier settings for night", "Note aroma or colour changes in log"]
        }
      },
      {
        stage: "Flower  Weeks 6+",
        tasks: {
          Morning: ["Measure jar/drying room conditions (if applicable)", "Inspect for botrytis, remove compromised buds immediately", "Irrigate with flush solution as scheduled"],
          Midday: ["Check support ties/yoyos, redistribute weight", "Record trichome maturity (clear/cloudy/amber %)", "Upload macro photo for AI ripeness assessment"],
          Evening: ["Lower night humidity, ensure airflow is unobstructed", "Plan next-day harvest or flush tasks", "Document any fade/purple expression"]
        }
      },
      {
        stage: "Dry & Cure",
        tasks: {
          Morning: ["Check drying room temp/RH, adjust humidifier/dehumidifier", "Inspect hanging buds for mould or overdry tips"],
          Midday: ["Burp jars (5-10 minutes) if curing", "Log jar RH and aroma impressions", "Upload cured bud photo for AI storage guidance"],
          Evening: ["Re-seal jars, rotate positions, ensure storage in dark cool location", "Plan next day QA (moisture %, jar RH)"]
        }
      }
    ],
    []
  );
  const sensorSections = useMemo$1(
    () => [
      {
        title: "Essential Sensors & Placement",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Canopy-level temp/RH sensor (digital with logging capability).", /* @__PURE__ */ React.createElement("br", null), " Root-zone probe for media temperature and moisture (optional but valuable for disease prevention).", /* @__PURE__ */ React.createElement("br", null), " CO monitor (NDIR) if supplementing; place at canopy height away from CO source.", /* @__PURE__ */ React.createElement("br", null), " PAR meter or calibrated lux meter for light intensity profiling.", /* @__PURE__ */ React.createElement("br", null), " Optional leaf temperature IR gun to calculate actual VPD accurately.")
      },
      {
        title: "Data Logging Workflow",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Log data twice daily (lights-on and lights-off) in StrainSpotter or linked spreadsheet: temp, RH, VPD, CO, EC, pH, water volume.", /* @__PURE__ */ React.createElement("br", null), " Sync Bluetooth/Wi-Fi sensors to mobile dashboard for alerts if thresholds breached.", /* @__PURE__ */ React.createElement("br", null), " Use AI to analyse trends: Highlight any VPD deviations >0.2 kPa over last 7 days.", /* @__PURE__ */ React.createElement("br", null), " Export data at harvest for post-mortem review; adjust environment targets next cycle.")
      },
      {
        title: "Automation Opportunities",
        body: /* @__PURE__ */ React.createElement(React.Fragment, null, " Integrate smart plugs with irrigation pumps or humidifiers; automate via StrainSpotter webhook and set guardrails to avoid overwatering.", /* @__PURE__ */ React.createElement("br", null), " Use controllers (Inkbird, TrolMaster) for closed-loop temp/RH management; log set-points and adjustments.", /* @__PURE__ */ React.createElement("br", null), " Capture camera time-lapse to correlate growth spurts with environmental changes.")
      }
    ],
    []
  );
  const renderSections = (sections) => /* @__PURE__ */ React.createElement(Box, null, sections.map(({ title, body: body2 }) => /* @__PURE__ */ React.createElement(Section, { key: title, title }, body2)));
  const renderDailyPlaybook = () => /* @__PURE__ */ React.createElement(Stack, { spacing: 3 }, dailyPlaybook.map(({ stage, tasks }) => /* @__PURE__ */ React.createElement(Paper, { key: stage, elevation: 0, sx: { p: 3, borderRadius: 3, background: "rgba(255,255,255,0.96)", border: "1px solid rgba(0,0,0,0.06)" } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", fontWeight: 800, gutterBottom: true, sx: { color: "#000" } }, stage), /* @__PURE__ */ React.createElement(Grid, { container: true, spacing: 2 }, Object.entries(tasks).map(([time, list]) => /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, sm: 4, key: time }, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", fontWeight: 700, sx: { color: "#000" } }, time), /* @__PURE__ */ React.createElement(Stack, { spacing: 0.5, sx: { mt: 1 } }, list.map((item) => /* @__PURE__ */ React.createElement(Typography, { key: item, variant: "body2", sx: { color: "#000" } }, " ", item)))))))));
  const renderTimeline = () => /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Stack, { spacing: 2, sx: { mb: 3 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle1", fontWeight: 800, sx: { color: "#000" } }, "Weekly Timeline"), /* @__PURE__ */ React.createElement(
    Slider,
    {
      value: safeTimelineIndex,
      min: 0,
      max: Math.max(timeline.length - 1, 0),
      step: 1,
      marks: timeline.map((entry, idx) => ({ value: idx, label: entry.label })),
      onChange: (_e, value) => {
        const nextValue = Array.isArray(value) ? value[0] : value;
        setTimelineIndex(typeof nextValue === "number" ? nextValue : 0);
      }
    }
  )), /* @__PURE__ */ React.createElement(Paper, { elevation: 0, sx: { p: 3, borderRadius: 3, background: "rgba(255,255,255,0.97)", border: "1px solid rgba(0,0,0,0.06)" } }, currentTimeline ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", fontWeight: 800, gutterBottom: true, sx: { color: "#000" } }, currentTimeline.stage), /* @__PURE__ */ React.createElement(Chip, { label: `Focus: ${currentTimeline.focus}`, color: "success", size: "small", sx: { mb: 2 } }), /* @__PURE__ */ React.createElement(Divider, { sx: { mb: 2 } }), /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", fontWeight: 700, sx: { color: "#000" } }, "Core Tasks"), /* @__PURE__ */ React.createElement(Stack, { spacing: 0.5, sx: { mt: 1, mb: 2 } }, currentTimeline.tasks.map((task) => /* @__PURE__ */ React.createElement(Typography, { key: task, variant: "body2", sx: { color: "#000" } }, " ", task))), /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", fontWeight: 700, sx: { color: "#000" } }, "AI Prompts"), /* @__PURE__ */ React.createElement(Stack, { spacing: 0.5, sx: { mt: 1, mb: 2 } }, currentTimeline.aiPrompts.map((prompt) => /* @__PURE__ */ React.createElement(Typography, { key: prompt, variant: "body2", sx: { color: "#000" } }, " ", prompt))), /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", fontWeight: 700, sx: { color: "#000" } }, "Target Metrics"), /* @__PURE__ */ React.createElement(Stack, { spacing: 0.5, sx: { mt: 1 } }, currentTimeline.metrics.map((metric) => /* @__PURE__ */ React.createElement(Typography, { key: metric, variant: "body2", sx: { color: "#000" } }, " ", metric)))) : /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "#000" } }, "Timeline data unavailable.")));
  const renderContent = () => {
    switch (tab) {
      case 0:
        return renderSections(overviewSections);
      case 1:
        return renderSections(setupSections);
      case 2:
        return renderSections(germinationSections);
      case 3:
        return renderSections(vegetativeSections);
      case 4:
        return renderSections(floweringSections);
      case 5:
        return renderSections(harvestSections);
      case 6:
        return renderSections(dryCureSections);
      case 7:
        return renderSections(wateringSections);
      case 8:
        return renderSections(nutrientSections);
      case 9:
        return renderSections(pestSections);
      case 10:
        return renderTimeline();
      case 11:
        return renderDailyPlaybook();
      case 12:
        return renderSections(sensorSections);
      case LOGBOOK_TAB_INDEX:
        return /* @__PURE__ */ React.createElement(GrowLogBook, null);
      default:
        return null;
    }
  };
  return /* @__PURE__ */ React.createElement(
    Container,
    {
      maxWidth: "md",
      sx: {
        pt: "calc(env(safe-area-inset-top) + 40px)",
        pb: 3,
        px: { xs: 2, sm: 3 },
        background: "rgba(248,252,248,0.96)",
        backdropFilter: "blur(20px)",
        WebkitBackdropFilter: "blur(20px)",
        border: "1px solid rgba(0,0,0,0.12)",
        boxShadow: "0 20px 40px rgba(18,36,18,0.18)",
        minHeight: "100vh",
        position: "relative",
        zIndex: 2
      }
    },
    onBack && /* @__PURE__ */ React.createElement(
      Button,
      {
        onClick: onBack,
        startIcon: /* @__PURE__ */ React.createElement(ArrowBack, null),
        sx: { mb: 1, textTransform: "none", fontWeight: 700, color: "#000" }
      },
      "Back to Garden"
    ),
    /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 2, sx: { mb: 1 } }, /* @__PURE__ */ React.createElement(
      Box,
      {
        sx: {
          width: 50,
          height: 50,
          borderRadius: "50%",
          background: "transparent",
          border: "2px solid rgba(124, 179, 66, 0.5)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          boxShadow: "0 0 20px rgba(124, 179, 66, 0.4)",
          overflow: "hidden",
          flexShrink: 0
        }
      },
      /* @__PURE__ */ React.createElement(
        "img",
        {
          src: "/hero.png?v=13",
          alt: "StrainSpotter",
          style: { width: "100%", height: "100%", objectFit: "cover" }
        }
      )
    ), /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 1 }, /* @__PURE__ */ React.createElement(MenuBookIcon, { sx: { color: "#7CB342" } }), /* @__PURE__ */ React.createElement(Typography, { variant: "h5", fontWeight: 900, sx: { color: "#000" } }, "Grow Coach")))),
    /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { mb: 2, color: "#000" } }, "Complete, step-by-step guidance from seed selection to curing, tailored for consistent mobile use. Follow the tabs in order and log every action so StrainSpotter AI can spot trends early."),
    /* @__PURE__ */ React.createElement(
      Tabs,
      {
        value: tab,
        onChange: (e, value) => setTab(value),
        variant: "scrollable",
        allowScrollButtonsMobile: true,
        sx: { mb: 2 }
      },
      /* @__PURE__ */ React.createElement(Tab, { icon: /* @__PURE__ */ React.createElement(LocalFloristIcon, null), iconPosition: "start", label: "Overview" }),
      /* @__PURE__ */ React.createElement(Tab, { icon: /* @__PURE__ */ React.createElement(Engineering, null), iconPosition: "start", label: "Setup" }),
      /* @__PURE__ */ React.createElement(Tab, { icon: /* @__PURE__ */ React.createElement(Grain, null), iconPosition: "start", label: "Germination" }),
      /* @__PURE__ */ React.createElement(Tab, { icon: /* @__PURE__ */ React.createElement(WbSunny, null), iconPosition: "start", label: "Vegetative" }),
      /* @__PURE__ */ React.createElement(Tab, { icon: /* @__PURE__ */ React.createElement(SpaIcon, null), iconPosition: "start", label: "Flowering" }),
      /* @__PURE__ */ React.createElement(Tab, { icon: /* @__PURE__ */ React.createElement(MenuBookIcon, null), iconPosition: "start", label: "Harvest" }),
      /* @__PURE__ */ React.createElement(Tab, { icon: /* @__PURE__ */ React.createElement(Opacity, null), iconPosition: "start", label: "Dry & Cure" }),
      /* @__PURE__ */ React.createElement(Tab, { icon: /* @__PURE__ */ React.createElement(WaterDrop, null), iconPosition: "start", label: "Watering & Media" }),
      /* @__PURE__ */ React.createElement(Tab, { icon: /* @__PURE__ */ React.createElement(Science, null), iconPosition: "start", label: "Nutrients" }),
      /* @__PURE__ */ React.createElement(Tab, { icon: /* @__PURE__ */ React.createElement(BugReport, null), iconPosition: "start", label: "Pests & IPM" }),
      /* @__PURE__ */ React.createElement(Tab, { icon: /* @__PURE__ */ React.createElement(Timeline, null), iconPosition: "start", label: "Stage Timelines" }),
      /* @__PURE__ */ React.createElement(Tab, { icon: /* @__PURE__ */ React.createElement(Checklist, null), iconPosition: "start", label: "Daily Tasks" }),
      /* @__PURE__ */ React.createElement(Tab, { icon: /* @__PURE__ */ React.createElement(MonitorHeart, null), iconPosition: "start", label: "Sensors & Data" }),
      /* @__PURE__ */ React.createElement(Tab, { icon: /* @__PURE__ */ React.createElement(NoteAlt, null), iconPosition: "start", label: "Logbook" })
    ),
    /* @__PURE__ */ React.createElement(Alert, { severity: "info", sx: { mb: 3 } }, "Use this coach in tandem with StrainSpotter Grow Logs. Capture photos, enter metrics, and ask AI follow-up questions whenever something looks unfamiliar."),
    renderContent()
  );
}
const React$5 = window["React"];
const useMemo = window["React"].useMemo;
const useState$i = window["React"].useState;
function GrowerRegistration({ onBack }) {
  const [mode, setMode2] = useState$i("non-certified");
  const [form, setForm] = useState$i({
    growerId: "",
    farmName: "",
    city: "",
    state: "",
    specialties: "",
    bio: "",
    experienceYears: 3,
    licenseStatus: "not_applicable",
    acceptsMessages: true,
    optInDirectory: true,
    phone: "",
    address: "",
    contactRiskAcknowledged: false,
    moderatorOptIn: false,
    moderatorMotivation: "",
    moderatorAvailability: "",
    moderatorExperience: "",
    moderatorNotes: ""
  });
  const [loading, setLoading] = useState$i(false);
  const [error, setError] = useState$i(null);
  const [snack, setSnack] = useState$i("");
  const handleChange = (key) => (e) => setForm(__spreadProps(__spreadValues({}, form), { [key]: e.target.value }));
  const handleBoolean = (key) => (e) => setForm(__spreadProps(__spreadValues({}, form), { [key]: e.target.checked }));
  const licenseOptions = useMemo(() => [
    { value: "licensed", label: "Licensed" },
    { value: "unlicensed", label: "Unlicensed" },
    { value: "not_applicable", label: "Not Applicable" }
  ], []);
  const resetForm = () => setForm({
    growerId: "",
    farmName: "",
    city: "",
    state: "",
    specialties: "",
    bio: "",
    experienceYears: 3,
    licenseStatus: mode === "certified" ? "licensed" : "not_applicable",
    acceptsMessages: true,
    optInDirectory: true,
    phone: "",
    address: "",
    contactRiskAcknowledged: false,
    moderatorOptIn: false,
    moderatorMotivation: "",
    moderatorAvailability: "",
    moderatorExperience: "",
    moderatorNotes: ""
  });
  function submit() {
    return __async(this, null, function* () {
      var _a2, _b;
      setLoading(true);
      setError(null);
      try {
        const { data: sessionData, error: sessionErr } = yield supabase.auth.getSession();
        if (sessionErr) throw sessionErr;
        const userId = (_b = (_a2 = sessionData == null ? void 0 : sessionData.session) == null ? void 0 : _a2.user) == null ? void 0 : _b.id;
        if (!userId) {
          throw new Error("Please sign in before registering as a grower.");
        }
        const certified = mode === "certified";
        const basePayload = {
          userId,
          isGrower: true,
          licenseStatus: certified ? "licensed" : form.licenseStatus,
          experienceYears: Number(form.experienceYears) || 0,
          bio: form.bio,
          specialties: form.specialties,
          city: form.city,
          state: form.state,
          country: "USA",
          farmName: form.farmName,
          acceptsMessages: form.acceptsMessages,
          optInDirectory: form.optInDirectory,
          phone: form.phone || null,
          address: form.address || null,
          contactRiskAcknowledged: form.contactRiskAcknowledged,
          certified,
          moderatorOptIn: certified && form.moderatorOptIn
        };
        if ((basePayload.phone || basePayload.address) && !basePayload.contactRiskAcknowledged) {
          throw new Error("Please acknowledge the risks of sharing contact information.");
        }
        if (certified && !form.growerId) {
          throw new Error("Certified growers must provide their certification or license ID.");
        }
        let moderatorApplication = null;
        if (certified && form.moderatorOptIn) {
          const motivation = form.moderatorMotivation.trim();
          const availability = form.moderatorAvailability.trim();
          const experience = form.moderatorExperience.trim();
          const notes = form.moderatorNotes.trim();
          if (!motivation || !availability) {
            throw new Error("Please tell us why you would be a great moderator and when you are available.");
          }
          moderatorApplication = __spreadValues(__spreadValues({
            motivation,
            availability
          }, experience ? { experience } : {}), notes ? { notes } : {});
        }
        const payload = __spreadProps(__spreadValues({}, basePayload), {
          growerId: certified ? form.growerId : null,
          moderatorApplication
        });
        const res = yield fetch(`${API_BASE}/api/growers/profile/setup`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        if (!res.ok) {
          const message = yield res.json().catch(() => ({}));
          throw new Error(message.error || "Failed to register grower profile.");
        }
        setSnack("Registration submitted!");
        resetForm();
      } catch (e) {
        setError(e.message);
      } finally {
        setLoading(false);
      }
    });
  }
  return /* @__PURE__ */ React$5.createElement(Box, { sx: { maxWidth: 720, mx: "auto", py: 4 } }, onBack && /* @__PURE__ */ React$5.createElement(Button, { onClick: onBack, size: "small", variant: "contained", sx: { bgcolor: "white", color: "black", textTransform: "none", fontWeight: 700, borderRadius: 999, mb: 1, "&:hover": { bgcolor: "grey.100" } } }, "Home"), /* @__PURE__ */ React$5.createElement(Card, null, /* @__PURE__ */ React$5.createElement(CardContent, null, /* @__PURE__ */ React$5.createElement(Stack, { spacing: 2 }, /* @__PURE__ */ React$5.createElement(Typography, { variant: "h5" }, "Grower Registration"), /* @__PURE__ */ React$5.createElement(
    TextField,
    {
      select: true,
      label: "Registration Type",
      value: mode,
      onChange: (e) => {
        const value = e.target.value;
        setMode2(value);
        setForm((prev2) => __spreadProps(__spreadValues({}, prev2), {
          licenseStatus: value === "certified" ? "licensed" : prev2.licenseStatus === "licensed" ? "licensed" : "not_applicable",
          moderatorOptIn: value === "certified" ? prev2.moderatorOptIn : false,
          moderatorMotivation: value === "certified" ? prev2.moderatorMotivation : "",
          moderatorAvailability: value === "certified" ? prev2.moderatorAvailability : "",
          moderatorExperience: value === "certified" ? prev2.moderatorExperience : "",
          moderatorNotes: value === "certified" ? prev2.moderatorNotes : ""
        }));
      }
    },
    /* @__PURE__ */ React$5.createElement(MenuItem, { value: "certified" }, "Certified Grower"),
    /* @__PURE__ */ React$5.createElement(MenuItem, { value: "non-certified" }, "Non-Certified Grower")
  ), mode === "certified" && /* @__PURE__ */ React$5.createElement(TextField, { label: "Grower ID", value: form.growerId, onChange: handleChange("growerId"), required: true }), /* @__PURE__ */ React$5.createElement(Grid, { container: true, spacing: 2 }, /* @__PURE__ */ React$5.createElement(Grid, { item: true, xs: 12, sm: 6 }, /* @__PURE__ */ React$5.createElement(TextField, { label: "Farm / Brand Name", value: form.farmName, onChange: handleChange("farmName"), fullWidth: true })), /* @__PURE__ */ React$5.createElement(Grid, { item: true, xs: 12, sm: 6 }, /* @__PURE__ */ React$5.createElement(TextField, { label: "City", value: form.city, onChange: handleChange("city"), fullWidth: true })), /* @__PURE__ */ React$5.createElement(Grid, { item: true, xs: 12, sm: 6 }, /* @__PURE__ */ React$5.createElement(TextField, { label: "State", value: form.state, onChange: handleChange("state"), fullWidth: true })), /* @__PURE__ */ React$5.createElement(Grid, { item: true, xs: 12, sm: 6 }, /* @__PURE__ */ React$5.createElement(
    TextField,
    {
      label: "Years of Experience",
      type: "number",
      inputProps: { min: 0 },
      value: form.experienceYears,
      onChange: handleChange("experienceYears"),
      fullWidth: true
    }
  )), /* @__PURE__ */ React$5.createElement(Grid, { item: true, xs: 12 }, /* @__PURE__ */ React$5.createElement(TextField, { label: "Specialties (comma-separated)", value: form.specialties, onChange: handleChange("specialties"), fullWidth: true })), /* @__PURE__ */ React$5.createElement(Grid, { item: true, xs: 12 }, /* @__PURE__ */ React$5.createElement(TextField, { label: "Bio", value: form.bio, onChange: handleChange("bio"), fullWidth: true, multiline: true, minRows: 3 })), /* @__PURE__ */ React$5.createElement(Grid, { item: true, xs: 12, sm: 6 }, /* @__PURE__ */ React$5.createElement(
    TextField,
    {
      select: true,
      label: "License Status",
      value: form.licenseStatus,
      onChange: handleChange("licenseStatus"),
      fullWidth: true,
      disabled: mode === "certified"
    },
    licenseOptions.map((opt) => /* @__PURE__ */ React$5.createElement(MenuItem, { key: opt.value, value: opt.value }, opt.label))
  )), /* @__PURE__ */ React$5.createElement(Grid, { item: true, xs: 12, sm: 6, sx: { display: "flex", alignItems: "center" } }, /* @__PURE__ */ React$5.createElement(
    FormControlLabel,
    {
      control: /* @__PURE__ */ React$5.createElement(
        Switch,
        {
          checked: form.acceptsMessages,
          onChange: handleBoolean("acceptsMessages")
        }
      ),
      label: "Accept direct messages from members"
    }
  ))), /* @__PURE__ */ React$5.createElement(Divider, null), /* @__PURE__ */ React$5.createElement(
    FormControlLabel,
    {
      control: /* @__PURE__ */ React$5.createElement(
        Switch,
        {
          checked: form.optInDirectory,
          onChange: handleBoolean("optInDirectory")
        }
      ),
      label: "List me in the public grower directory"
    }
  ), /* @__PURE__ */ React$5.createElement(Typography, { variant: "caption", color: "text.secondary" }, "New growers are welcome  we highlight certified growers separately and sort the list by experience so members can find the right fit."), /* @__PURE__ */ React$5.createElement(Grid, { container: true, spacing: 2 }, /* @__PURE__ */ React$5.createElement(Grid, { item: true, xs: 12, sm: 6 }, /* @__PURE__ */ React$5.createElement(TextField, { label: "Public Phone (optional)", value: form.phone, onChange: handleChange("phone"), fullWidth: true })), /* @__PURE__ */ React$5.createElement(Grid, { item: true, xs: 12, sm: 6 }, /* @__PURE__ */ React$5.createElement(TextField, { label: "Public Address (optional)", value: form.address, onChange: handleChange("address"), fullWidth: true }))), (form.phone || form.address) && /* @__PURE__ */ React$5.createElement(
    FormControlLabel,
    {
      control: /* @__PURE__ */ React$5.createElement(
        Checkbox,
        {
          checked: form.contactRiskAcknowledged,
          onChange: handleBoolean("contactRiskAcknowledged")
        }
      ),
      label: "I understand the risks of sharing my contact information publicly."
    }
  ), mode === "certified" && /* @__PURE__ */ React$5.createElement(
    FormControlLabel,
    {
      control: /* @__PURE__ */ React$5.createElement(
        Switch,
        {
          checked: form.moderatorOptIn,
          onChange: (e) => {
            const checked = e.target.checked;
            setForm((prev2) => __spreadProps(__spreadValues({}, prev2), {
              moderatorOptIn: checked,
              moderatorMotivation: checked ? prev2.moderatorMotivation : "",
              moderatorAvailability: checked ? prev2.moderatorAvailability : "",
              moderatorExperience: checked ? prev2.moderatorExperience : "",
              moderatorNotes: checked ? prev2.moderatorNotes : ""
            }));
          }
        }
      ),
      label: "I'll earn that free membership by helping moderate the community (you gotta earn it!)"
    }
  ), mode === "certified" && form.moderatorOptIn && /* @__PURE__ */ React$5.createElement(Stack, { spacing: 2, sx: { p: 2, bgcolor: "rgba(124,179,66,0.08)", borderRadius: 2, border: "1px solid rgba(124,179,66,0.3)" } }, /* @__PURE__ */ React$5.createElement(Alert, { severity: "info", sx: { bgcolor: "rgba(255,255,255,0.7)" } }, "Certified moderators help keep conversations safe and on-topic. Share a quick note about how you can contribute so we can activate your complimentary membership."), /* @__PURE__ */ React$5.createElement(
    TextField,
    {
      label: "Why you'd be a great moderator",
      value: form.moderatorMotivation,
      onChange: handleChange("moderatorMotivation"),
      fullWidth: true,
      multiline: true,
      minRows: 2,
      required: true
    }
  ), /* @__PURE__ */ React$5.createElement(
    TextField,
    {
      label: "Weekly availability (hours / time windows)",
      value: form.moderatorAvailability,
      onChange: handleChange("moderatorAvailability"),
      fullWidth: true,
      multiline: true,
      minRows: 2,
      required: true
    }
  ), /* @__PURE__ */ React$5.createElement(
    TextField,
    {
      label: "Experience moderating or supporting communities",
      value: form.moderatorExperience,
      onChange: handleChange("moderatorExperience"),
      fullWidth: true,
      multiline: true,
      minRows: 2
    }
  ), /* @__PURE__ */ React$5.createElement(
    TextField,
    {
      label: "Anything else we should know?",
      value: form.moderatorNotes,
      onChange: handleChange("moderatorNotes"),
      fullWidth: true,
      multiline: true,
      minRows: 2
    }
  )), error && /* @__PURE__ */ React$5.createElement(Alert, { severity: "error" }, error), /* @__PURE__ */ React$5.createElement(Stack, { direction: "row", spacing: 2 }, /* @__PURE__ */ React$5.createElement(Button, { variant: "contained", onClick: submit, disabled: loading }, loading ? "Submitting" : "Submit"))))), /* @__PURE__ */ React$5.createElement(Snackbar, { open: !!snack, autoHideDuration: 2500, onClose: () => setSnack(""), message: snack }));
}
const useEffect$f = window["React"].useEffect;
const useState$h = window["React"].useState;
function GrowerDirectory({ onBack }) {
  const [growers, setGrowers] = useState$h([]);
  const [loading, setLoading] = useState$h(true);
  const [showRegistration, setShowRegistration] = useState$h(false);
  useEffect$f(() => {
    (() => __async(null, null, function* () {
      try {
        const res = yield fetch(`${API_BASE}/api/growers`);
        if (res.ok) {
          const payload = yield res.json();
          const list = Array.isArray(payload) ? payload : Array.isArray(payload.growers) ? payload.growers : [];
          setGrowers(list);
        }
      } finally {
        setLoading(false);
      }
    }))();
  }, []);
  const renderGrowerCard = (g) => /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, sm: 6, md: 4, key: g.user_id || g.id }, /* @__PURE__ */ React.createElement(Card, { sx: { height: "100%", background: "rgba(255,255,255,0.10)", backdropFilter: "blur(12px)", border: "2px solid black", boxShadow: "none" } }, /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Stack, { spacing: 2 }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 2, alignItems: "center" }, /* @__PURE__ */ React.createElement(Avatar$1, { sx: { bgcolor: "primary.main", width: 56, height: 56 } }, (g.grower_farm_name || g.grower_city || "??").substring(0, 2).toUpperCase()), /* @__PURE__ */ React.createElement(Box, { sx: { flex: 1 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6" }, g.grower_farm_name || "Grower"), g.grower_certified && /* @__PURE__ */ React.createElement(
    Chip,
    {
      label: "Certified",
      color: "success",
      size: "small",
      sx: { mt: 0.5, alignSelf: "flex-start" }
    }
  ), g.grower_city && /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 0.5, alignItems: "center" }, /* @__PURE__ */ React.createElement(LocationOn, { fontSize: "small", color: "action" }), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, g.grower_city, g.grower_state ? `, ${g.grower_state}` : "")))), Array.isArray(g.grower_specialties) && g.grower_specialties.length > 0 && /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "caption", color: "text.secondary" }, "Specialties:"), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 0.5, flexWrap: "wrap", sx: { mt: 0.5 } }, g.grower_specialties.map((s, i) => /* @__PURE__ */ React.createElement(Chip, { key: i, label: s, size: "small", color: "success", variant: "outlined" })))), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, "Experience: ", g.grower_experience_years || 0, " years"), /* @__PURE__ */ React.createElement(
    Chip,
    {
      icon: /* @__PURE__ */ React.createElement(EmojiEvents, { fontSize: "small" }),
      label: g.grower_license_status === "licensed" ? "Licensed" : "Community",
      size: "small",
      sx: { alignSelf: "flex-start" }
    }
  ), /* @__PURE__ */ React.createElement(Button, { variant: "outlined", size: "small" }, "View Profile")))));
  const renderSection = (title, list) => {
    if (!list || list.length === 0) return null;
    const sorted = [...list].sort((a, b) => {
      const experienceA = Number(a.grower_experience_years) || 0;
      const experienceB = Number(b.grower_experience_years) || 0;
      return experienceB - experienceA;
    });
    return /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h5", sx: { mb: 2, fontWeight: 700 } }, title), /* @__PURE__ */ React.createElement(Grid, { container: true, spacing: 2 }, sorted.map(renderGrowerCard)));
  };
  if (showRegistration) {
    return /* @__PURE__ */ React.createElement(
      GrowerRegistration,
      {
        onBack: () => {
          setShowRegistration(false);
          (() => __async(null, null, function* () {
            try {
              const res = yield fetch(`${API_BASE}/api/growers`);
              if (res.ok) {
                const payload = yield res.json();
                const list = Array.isArray(payload) ? payload : Array.isArray(payload.growers) ? payload.growers : [];
                setGrowers(list);
              }
            } catch (err) {
              console.error("Error refreshing growers:", err);
            }
          }))();
        }
      }
    );
  }
  return /* @__PURE__ */ React.createElement(Container, { maxWidth: "lg", sx: {
    pt: "calc(env(safe-area-inset-top) + 48px)",
    pb: 4
  } }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", justifyContent: "space-between", alignItems: "center", sx: { mb: 3 } }, onBack && /* @__PURE__ */ React.createElement(Button, { onClick: onBack, size: "small", variant: "contained", sx: { bgcolor: "#7CB342", color: "white", textTransform: "none", fontWeight: 700, borderRadius: 999, "&:hover": { bgcolor: "#689f38" } } }, " Back to Garden"), /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "contained",
      color: "primary",
      onClick: () => setShowRegistration(true),
      sx: { textTransform: "none", fontWeight: 600 }
    },
    "Register as Grower"
  )), /* @__PURE__ */ React.createElement(Box, { sx: { display: "flex", alignItems: "center", gap: 2, mb: 3 } }, /* @__PURE__ */ React.createElement(
    Box,
    {
      sx: {
        width: 60,
        height: 60,
        borderRadius: "50%",
        background: "transparent",
        border: "2px solid rgba(124, 179, 66, 0.5)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        boxShadow: "0 0 20px rgba(124, 179, 66, 0.4)",
        overflow: "hidden",
        flexShrink: 0
      }
    },
    /* @__PURE__ */ React.createElement(
      "img",
      {
        src: "/hero.png?v=13",
        alt: "StrainSpotter",
        style: { width: "100%", height: "100%", objectFit: "cover" }
      }
    )
  ), /* @__PURE__ */ React.createElement(Typography, { variant: "h4", sx: { fontWeight: 700 } }, "Grower Directory")), loading ? /* @__PURE__ */ React.createElement(Typography, null, "Loading...") : growers.length === 0 ? /* @__PURE__ */ React.createElement(Card, null, /* @__PURE__ */ React.createElement(CardContent, { sx: { textAlign: "center", py: 5 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body1", color: "text.secondary" }, "No growers yet. Be the first to register!"))) : /* @__PURE__ */ React.createElement(Stack, { spacing: 4 }, renderSection("Certified Growers", growers.filter((g) => g.grower_certified)), renderSection("Community Growers", growers.filter((g) => !g.grower_certified))));
}
const useState$g = window["React"].useState;
const useEffect$e = window["React"].useEffect;
function FeedbackReader({ user, onBack }) {
  const [feedback, setFeedback] = useState$g([]);
  const [loading, setLoading] = useState$g(true);
  const [error, setError] = useState$g(null);
  const [refreshing, setRefreshing] = useState$g(false);
  const [deleting, setDeleting] = useState$g(null);
  const loadFeedback = () => __async(null, null, function* () {
    try {
      setRefreshing(true);
      const res = yield fetch(`${API_BASE}/api/feedback/messages`);
      if (!res.ok) {
        throw new Error("Failed to load feedback");
      }
      const data = yield res.json();
      setFeedback(data || []);
      setError(null);
    } catch (err) {
      console.error("Error loading feedback:", err);
      setError(err.message);
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  });
  const handleDelete = (messageId) => __async(null, null, function* () {
    if (!confirm("Are you sure you want to delete this feedback?")) {
      return;
    }
    try {
      setDeleting(messageId);
      const res = yield fetch(`${API_BASE}/api/feedback/messages/${messageId}`, {
        method: "DELETE",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ admin_user_id: user == null ? void 0 : user.id })
      });
      if (!res.ok) {
        const data = yield res.json();
        throw new Error(data.error || "Failed to delete feedback");
      }
      setFeedback((prev2) => prev2.filter((f) => f.id !== messageId));
    } catch (err) {
      console.error("Error deleting feedback:", err);
      alert("Failed to delete: " + err.message);
    } finally {
      setDeleting(null);
    }
  });
  useEffect$e(() => {
    loadFeedback();
  }, []);
  const formatDate = (dateString) => {
    const date = new Date(dateString);
    const now = /* @__PURE__ */ new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 6e4);
    const diffHours = Math.floor(diffMs / 36e5);
    const diffDays = Math.floor(diffMs / 864e5);
    if (diffMins < 1) return "Just now";
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    if (diffDays < 7) return `${diffDays}d ago`;
    return date.toLocaleDateString("en-US", {
      month: "short",
      day: "numeric",
      year: date.getFullYear() !== now.getFullYear() ? "numeric" : void 0
    });
  };
  const formatFullDate = (dateString) => {
    return new Date(dateString).toLocaleString("en-US", {
      month: "long",
      day: "numeric",
      year: "numeric",
      hour: "numeric",
      minute: "2-digit",
      hour12: true
    });
  };
  if (loading) {
    return /* @__PURE__ */ React.createElement(Box, { sx: {
      minHeight: "100vh",
      background: "linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    } }, /* @__PURE__ */ React.createElement(CircularProgress, { sx: { color: "#7CB342" } }));
  }
  return /* @__PURE__ */ React.createElement(Box, { sx: {
    minHeight: "100vh",
    background: "linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%)",
    py: 4,
    px: 2
  } }, /* @__PURE__ */ React.createElement(Box, { sx: { maxWidth: 900, mx: "auto" } }, /* @__PURE__ */ React.createElement(Paper, { sx: {
    p: 3,
    mb: 3,
    background: "linear-gradient(135deg, rgba(124, 179, 66, 0.1) 0%, rgba(156, 204, 101, 0.05) 100%)",
    backdropFilter: "blur(10px)",
    border: "1px solid rgba(124, 179, 66, 0.2)",
    borderRadius: 3
  } }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", justifyContent: "space-between" }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 2 }, /* @__PURE__ */ React.createElement(Avatar$1, { sx: {
    bgcolor: "#7CB342",
    width: 56,
    height: 56
  } }, /* @__PURE__ */ React.createElement(FeedbackIcon, { sx: { fontSize: 32 } })), /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h4", sx: {
    fontWeight: 700,
    color: "#fff",
    mb: 0.5
  } }, "Feedback Reader"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "rgba(255,255,255,0.7)" } }, feedback.length, " ", feedback.length === 1 ? "submission" : "submissions"))), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1 }, /* @__PURE__ */ React.createElement(Tooltip, { title: "Refresh" }, /* @__PURE__ */ React.createElement(
    IconButton,
    {
      onClick: loadFeedback,
      disabled: refreshing,
      sx: {
        color: "#7CB342",
        "&:hover": { bgcolor: "rgba(124, 179, 66, 0.1)" }
      }
    },
    /* @__PURE__ */ React.createElement(RefreshIcon, { sx: {
      animation: refreshing ? "spin 1s linear infinite" : "none",
      "@keyframes spin": {
        "0%": { transform: "rotate(0deg)" },
        "100%": { transform: "rotate(360deg)" }
      }
    } })
  )), onBack && /* @__PURE__ */ React.createElement(
    Chip,
    {
      label: "Back",
      onClick: onBack,
      sx: {
        bgcolor: "rgba(124, 179, 66, 0.2)",
        color: "#7CB342",
        fontWeight: 600,
        "&:hover": { bgcolor: "rgba(124, 179, 66, 0.3)" }
      }
    }
  )))), error && /* @__PURE__ */ React.createElement(Alert, { severity: "error", sx: { mb: 3 } }, error), !loading && feedback.length === 0 && /* @__PURE__ */ React.createElement(Paper, { sx: {
    p: 6,
    textAlign: "center",
    background: "rgba(255,255,255,0.05)",
    backdropFilter: "blur(10px)",
    border: "1px solid rgba(255,255,255,0.1)",
    borderRadius: 3
  } }, /* @__PURE__ */ React.createElement(FeedbackIcon, { sx: { fontSize: 64, color: "rgba(255,255,255,0.3)", mb: 2 } }), /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { color: "#fff", mb: 1 } }, "No Feedback Yet"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "rgba(255,255,255,0.6)" } }, "Feedback submissions will appear here")), /* @__PURE__ */ React.createElement(Stack, { spacing: 2 }, feedback.map((item, index2) => {
    var _a2, _b, _c, _d, _e, _f;
    return /* @__PURE__ */ React.createElement(Card, { key: item.id || index2, sx: {
      background: "rgba(255,255,255,0.05)",
      backdropFilter: "blur(10px)",
      border: "1px solid rgba(124, 179, 66, 0.2)",
      borderRadius: 2,
      transition: "all 0.3s ease",
      "&:hover": {
        transform: "translateY(-2px)",
        boxShadow: "0 8px 24px rgba(124, 179, 66, 0.2)",
        border: "1px solid rgba(124, 179, 66, 0.4)"
      }
    } }, /* @__PURE__ */ React.createElement(CardContent, { sx: { p: 3 } }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", justifyContent: "space-between", mb: 2 }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 1.5 }, /* @__PURE__ */ React.createElement(
      Avatar$1,
      {
        src: (_a2 = item.sender) == null ? void 0 : _a2.avatar_url,
        sx: {
          bgcolor: "rgba(124, 179, 66, 0.2)",
          width: 32,
          height: 32
        }
      },
      !((_b = item.sender) == null ? void 0 : _b.avatar_url) && /* @__PURE__ */ React.createElement(PersonIcon, { sx: { fontSize: 18, color: "#7CB342" } })
    ), /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: {
      color: "#7CB342",
      fontWeight: 600
    } }, ((_c = item.sender) == null ? void 0 : _c.display_name) || ((_d = item.sender) == null ? void 0 : _d.username) || `User ${(_e = item.sender_id) == null ? void 0 : _e.substring(0, 8)}`), /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 1 }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 0.5 }, /* @__PURE__ */ React.createElement(AccessTimeIcon, { sx: { fontSize: 14, color: "rgba(255,255,255,0.5)" } }), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "rgba(255,255,255,0.5)" } }, formatDate(item.created_at))), ((_f = item.sender) == null ? void 0 : _f.username) && /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "rgba(255,255,255,0.4)" } }, " @", item.sender.username)))), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1, alignItems: "center" }, /* @__PURE__ */ React.createElement(Tooltip, { title: formatFullDate(item.created_at) }, /* @__PURE__ */ React.createElement(
      Chip,
      {
        label: item.message_type || "text",
        size: "small",
        sx: {
          bgcolor: "rgba(124, 179, 66, 0.2)",
          color: "#7CB342",
          fontSize: "0.75rem",
          fontWeight: 600
        }
      }
    )), /* @__PURE__ */ React.createElement(Tooltip, { title: "Delete feedback" }, /* @__PURE__ */ React.createElement(
      IconButton,
      {
        size: "small",
        onClick: () => handleDelete(item.id),
        disabled: deleting === item.id,
        sx: {
          color: "#ff5252",
          "&:hover": {
            bgcolor: "rgba(255, 82, 82, 0.1)"
          }
        }
      },
      /* @__PURE__ */ React.createElement(DeleteIcon, { sx: { fontSize: 18 } })
    )))), /* @__PURE__ */ React.createElement(Divider, { sx: { mb: 2, borderColor: "rgba(255,255,255,0.1)" } }), /* @__PURE__ */ React.createElement(Typography, { sx: {
      color: "#fff",
      fontSize: "1rem",
      lineHeight: 1.6,
      whiteSpace: "pre-wrap",
      wordBreak: "break-word"
    } }, item.content), (item.is_flagged || item.is_moderated) && /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1, mt: 2 }, item.is_flagged && /* @__PURE__ */ React.createElement(
      Chip,
      {
        label: "Flagged",
        size: "small",
        color: "warning",
        sx: { fontSize: "0.7rem" }
      }
    ), item.is_moderated && /* @__PURE__ */ React.createElement(
      Chip,
      {
        label: `Moderated: ${item.moderation_action || "reviewed"}`,
        size: "small",
        color: "info",
        sx: { fontSize: "0.7rem" }
      }
    ))));
  }))));
}
const useState$f = window["React"].useState;
const useEffect$d = window["React"].useEffect;
function CreditBalance() {
  const [credits, setCredits] = useState$f(null);
  const [loading, setLoading] = useState$f(true);
  const [tier, setTier] = useState$f("free");
  useEffect$d(() => {
    fetchCredits();
  }, []);
  const fetchCredits = () => __async(null, null, function* () {
    try {
      const { data: { session } } = yield supabase.auth.getSession();
      if (!session) {
        setLoading(false);
        return;
      }
      const response = yield fetch(`${void 0}/api/credits/balance`, {
        headers: {
          "Authorization": `Bearer ${session.access_token}`
        }
      });
      if (response.ok) {
        const data = yield response.json();
        setCredits(data.creditsRemaining);
        setTier(data.tier);
      }
    } catch (error) {
      console.error("Failed to fetch credits:", error);
    } finally {
      setLoading(false);
    }
  });
  if (loading) {
    return /* @__PURE__ */ React.createElement(Box, { sx: { display: "flex", alignItems: "center", gap: 1 } }, /* @__PURE__ */ React.createElement(CircularProgress, { size: 20, sx: { color: "rgba(124, 179, 66, 0.8)" } }));
  }
  if (credits === null) {
    return null;
  }
  const getColor = () => {
    if (tier === "admin") return "primary";
    if (credits === 0) return "error";
    if (credits <= 5) return "warning";
    return "success";
  };
  const getLabel = () => {
    if (tier === "admin") return " Scans";
    return `${credits} Scans`;
  };
  const getTooltip = () => {
    if (tier === "admin") return "Unlimited scans (Admin)";
    if (tier === "free") return `${credits} free scans remaining`;
    if (tier === "member") return `${credits} scans remaining this month (Member)`;
    if (tier === "premium") return `${credits} scans remaining this month (Premium)`;
    if (tier === "moderator") return `${credits} scans remaining this month (Moderator)`;
    return `${credits} scans remaining`;
  };
  return /* @__PURE__ */ React.createElement(Tooltip, { title: getTooltip(), arrow: true }, /* @__PURE__ */ React.createElement(
    Chip,
    {
      icon: /* @__PURE__ */ React.createElement(BoltIcon, null),
      label: getLabel(),
      color: getColor(),
      size: "small",
      sx: {
        fontWeight: 600,
        background: tier === "admin" ? "linear-gradient(135deg, rgba(255, 215, 0, 0.2) 0%, rgba(255, 165, 0, 0.2) 100%)" : void 0,
        backdropFilter: "blur(10px)",
        border: tier === "admin" ? "1px solid rgba(255, 215, 0, 0.5)" : void 0,
        boxShadow: credits <= 5 && tier !== "admin" ? "0 0 10px rgba(255, 152, 0, 0.5)" : void 0,
        animation: credits === 0 ? "pulse 2s ease-in-out infinite" : void 0,
        "@keyframes pulse": {
          "0%, 100%": { opacity: 1 },
          "50%": { opacity: 0.7 }
        }
      }
    }
  ));
}
const useState$e = window["React"].useState;
const useEffect$c = window["React"].useEffect;
function BuyScansModal({ open, onClose, currentTier = "free", creditsRemaining = 0 }) {
  const [packages, setPackages] = useState$e([]);
  const [tiers, setTiers] = useState$e([]);
  const [loading, setLoading] = useState$e(true);
  const [purchasing, setPurchasing] = useState$e(false);
  const [error, setError] = useState$e(null);
  const [success, setSuccess] = useState$e(null);
  useEffect$c(() => {
    if (open) {
      fetchPackages();
    }
  }, [open]);
  const fetchPackages = () => __async(null, null, function* () {
    try {
      const response = yield fetch(`${void 0}/api/credits/packages`);
      const data = yield response.json();
      if (data.success) {
        setPackages(data.packages);
        setTiers(data.tiers);
      }
    } catch (err) {
      console.error("Failed to fetch packages:", err);
      setError("Failed to load packages");
    } finally {
      setLoading(false);
    }
  });
  const handlePurchasePackage = (packageId) => __async(null, null, function* () {
    setPurchasing(true);
    setError(null);
    setSuccess(null);
    try {
      const { data: { session } } = yield supabase.auth.getSession();
      if (!session) {
        setError("Please sign in to purchase credits");
        setPurchasing(false);
        return;
      }
      setError("Payment integration coming soon! Please contact support to purchase credits.");
    } catch (err) {
      console.error("Purchase error:", err);
      setError("Purchase failed. Please try again.");
    } finally {
      setPurchasing(false);
    }
  });
  const handleUpgradeTier = (tierId) => __async(null, null, function* () {
    setPurchasing(true);
    setError(null);
    setSuccess(null);
    try {
      const { data: { session } } = yield supabase.auth.getSession();
      if (!session) {
        setError("Please sign in to upgrade");
        setPurchasing(false);
        return;
      }
      setError("Membership upgrades coming soon! Please contact support to upgrade.");
    } catch (err) {
      console.error("Upgrade error:", err);
      setError("Upgrade failed. Please try again.");
    } finally {
      setPurchasing(false);
    }
  });
  return /* @__PURE__ */ React.createElement(
    Dialog,
    {
      open,
      onClose,
      maxWidth: "md",
      fullWidth: true,
      PaperProps: {
        sx: {
          background: "linear-gradient(135deg, rgba(18, 18, 18, 0.98) 0%, rgba(30, 30, 30, 0.98) 100%)",
          backdropFilter: "blur(20px)",
          border: "1px solid rgba(124, 179, 66, 0.2)"
        }
      }
    },
    /* @__PURE__ */ React.createElement(DialogTitle, { sx: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      borderBottom: "1px solid rgba(124, 179, 66, 0.2)"
    } }, /* @__PURE__ */ React.createElement(Box, { sx: { display: "flex", alignItems: "center", gap: 1 } }, /* @__PURE__ */ React.createElement(BoltIcon, { sx: { color: "#7CB342" } }), /* @__PURE__ */ React.createElement(Typography, { variant: "h6" }, "Get More Scans")), /* @__PURE__ */ React.createElement(IconButton, { onClick: onClose, size: "small" }, /* @__PURE__ */ React.createElement(CloseIcon, null))),
    /* @__PURE__ */ React.createElement(DialogContent, { sx: { mt: 2 } }, loading ? /* @__PURE__ */ React.createElement(Box, { sx: { display: "flex", justifyContent: "center", p: 4 } }, /* @__PURE__ */ React.createElement(CircularProgress, null)) : /* @__PURE__ */ React.createElement(React.Fragment, null, error && /* @__PURE__ */ React.createElement(Alert, { severity: "error", sx: { mb: 2 }, onClose: () => setError(null) }, error), success && /* @__PURE__ */ React.createElement(Alert, { severity: "success", sx: { mb: 2 } }, success), /* @__PURE__ */ React.createElement(Box, { sx: { mb: 3, p: 2, background: "rgba(124, 179, 66, 0.1)", borderRadius: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, "Current Plan: ", /* @__PURE__ */ React.createElement("strong", null, currentTier.toUpperCase())), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, "Scans Remaining: ", /* @__PURE__ */ React.createElement("strong", null, creditsRemaining))), currentTier === "free" && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { mb: 2, display: "flex", alignItems: "center", gap: 1 } }, /* @__PURE__ */ React.createElement(StarIcon, { sx: { color: "#FFD700" } }), "Upgrade Membership"), /* @__PURE__ */ React.createElement(Box, { sx: { display: "grid", gridTemplateColumns: { xs: "1fr", sm: "1fr 1fr" }, gap: 2, mb: 4 } }, tiers.filter((t) => t.id !== "free").map((tier) => /* @__PURE__ */ React.createElement(
      Card,
      {
        key: tier.id,
        sx: {
          background: "linear-gradient(135deg, rgba(124, 179, 66, 0.1) 0%, rgba(156, 204, 101, 0.1) 100%)",
          border: "1px solid rgba(124, 179, 66, 0.3)",
          position: "relative",
          overflow: "visible"
        }
      },
      tier.id === "member" && /* @__PURE__ */ React.createElement(
        Chip,
        {
          label: "BEST VALUE",
          size: "small",
          color: "success",
          sx: {
            position: "absolute",
            top: -10,
            right: 10,
            fontWeight: 700
          }
        }
      ),
      /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", gutterBottom: true }, tier.name), /* @__PURE__ */ React.createElement(Typography, { variant: "h4", color: "primary", gutterBottom: true }, "$", tier.price, /* @__PURE__ */ React.createElement(Typography, { component: "span", variant: "body2", color: "text.secondary" }, "/month")), /* @__PURE__ */ React.createElement(Typography, { variant: "body1", color: "text.secondary", gutterBottom: true }, tier.scans, " scans/month"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, tier.description)),
      /* @__PURE__ */ React.createElement(CardActions, null, /* @__PURE__ */ React.createElement(
        Button,
        {
          fullWidth: true,
          variant: "contained",
          color: "primary",
          disabled: purchasing,
          onClick: () => handleUpgradeTier(tier.id)
        },
        "Upgrade to ",
        tier.name
      ))
    )))), /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { mb: 2, display: "flex", alignItems: "center", gap: 1 } }, /* @__PURE__ */ React.createElement(OfferIcon, { sx: { color: "#7CB342" } }), "Buy Credit Packs"), /* @__PURE__ */ React.createElement(Box, { sx: { display: "grid", gridTemplateColumns: { xs: "1fr", sm: "1fr 1fr" }, gap: 2 } }, packages.map((pkg) => /* @__PURE__ */ React.createElement(
      Card,
      {
        key: pkg.id,
        sx: {
          background: "rgba(255, 255, 255, 0.05)",
          border: "1px solid rgba(124, 179, 66, 0.2)",
          transition: "all 0.2s ease",
          "&:hover": {
            transform: "translateY(-2px)",
            border: "1px solid rgba(124, 179, 66, 0.5)"
          }
        }
      },
      /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", gutterBottom: true }, pkg.credits, " Scans"), /* @__PURE__ */ React.createElement(Typography, { variant: "h5", color: "primary", gutterBottom: true }, "$", pkg.price.toFixed(2)), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, "$", (pkg.perScanCost * 100).toFixed(1), " per scan")),
      /* @__PURE__ */ React.createElement(CardActions, null, /* @__PURE__ */ React.createElement(
        Button,
        {
          fullWidth: true,
          variant: "outlined",
          color: "primary",
          disabled: purchasing,
          onClick: () => handlePurchasePackage(pkg.id)
        },
        "Buy Now"
      ))
    ))))),
    /* @__PURE__ */ React.createElement(DialogActions, { sx: { borderTop: "1px solid rgba(124, 179, 66, 0.2)", p: 2 } }, /* @__PURE__ */ React.createElement(Button, { onClick: onClose, color: "inherit" }, "Close"))
  );
}
const useState$d = window["React"].useState;
function Garden({ onBack, onNavigate }) {
  const { user, isExpired, canLogout, loading } = useMembershipGuard();
  const [showLogoutWarning, setShowLogoutWarning] = useState$d(false);
  const [showComingSoon, setShowComingSoon] = useState$d(false);
  const [selectedFeature, setSelectedFeature] = useState$d("");
  const [showScan, setShowScan] = useState$d(false);
  const [showStrainBrowser, setShowStrainBrowser] = useState$d(false);
  const [showReviews, setShowReviews] = useState$d(false);
  const [showDispensaryFinder, setShowDispensaryFinder] = useState$d(false);
  const [showSeedFinder, setShowSeedFinder] = useState$d(false);
  const [showGroups, setShowGroups] = useState$d(false);
  const [showGrowCoach, setShowGrowCoach] = useState$d(false);
  const [showGrowerDirectory, setShowGrowerDirectory] = useState$d(false);
  const [showFeedback, setShowFeedback] = useState$d(false);
  const [showFeedbackReader, setShowFeedbackReader] = useState$d(false);
  const [showBuyScans, setShowBuyScans] = useState$d(false);
  const handleLogout = () => __async(null, null, function* () {
    const isAdminUser = (user == null ? void 0 : user.email) === "topher.cook7@gmail.com" || (user == null ? void 0 : user.email) === "strainspotter25@gmail.com" || (user == null ? void 0 : user.email) === "admin@strainspotter.com" || (user == null ? void 0 : user.email) === "andrewbeck209@gmail.com";
    if (!canLogout && !isAdminUser) {
      setShowLogoutWarning(true);
      return;
    }
    try {
      yield supabase.auth.signOut();
      localStorage.clear();
      sessionStorage.clear();
      onBack == null ? void 0 : onBack();
    } catch (e) {
      console.error("Logout failed:", e);
    }
  });
  const handleFeatureClick = (featureName, nav) => {
    if (nav === "scan") {
      setShowScan(true);
      return;
    }
    if (nav === "strains") {
      setShowStrainBrowser(true);
      return;
    }
    if (nav === "reviews") {
      setShowReviews(true);
      return;
    }
    if (nav === "dispensaries") {
      setShowDispensaryFinder(true);
      return;
    }
    if (nav === "seeds") {
      setShowSeedFinder(true);
      return;
    }
    if (nav === "groups") {
      setShowGroups(true);
      return;
    }
    if (nav === "grow-coach") {
      setShowGrowCoach(true);
      return;
    }
    if (nav === "growers") {
      setShowGrowerDirectory(true);
      return;
    }
    if (nav === "feedback-reader") {
      setShowFeedbackReader(true);
      return;
    }
    setSelectedFeature(featureName);
    setShowComingSoon(true);
  };
  const isAdmin = (user == null ? void 0 : user.email) === "topher.cook7@gmail.com" || (user == null ? void 0 : user.email) === "strainspotter25@gmail.com" || (user == null ? void 0 : user.email) === "admin@strainspotter.com" || (user == null ? void 0 : user.email) === "andrewbeck209@gmail.com";
  const tiles = [
    { title: "AI Strain Scan", icon: /* @__PURE__ */ React.createElement(CameraAltIcon, null), nav: "scan", color: "#00e676", description: "Identify any strain instantly" },
    { title: "Strain Browser", icon: /* @__PURE__ */ React.createElement(SpaIcon, null), nav: "strains", color: "#7cb342", description: "Explore 1000+ strains" },
    { title: "Reviews Hub", icon: /* @__PURE__ */ React.createElement(RateReviewIcon, null), nav: "reviews", color: "#ffd600", description: "Read & share experiences" },
    { title: "Community Groups", icon: /* @__PURE__ */ React.createElement(GroupsIcon, null), nav: "groups", color: "#66bb6a", description: "Connect with growers" },
    { title: "Grow Coach", icon: /* @__PURE__ */ React.createElement(LocalFloristIcon, null), nav: "grow-coach", color: "#9ccc65", description: "Expert growing tips" },
    { title: "Grower Directory", icon: /* @__PURE__ */ React.createElement(PeopleIcon, null), nav: "growers", color: "#8bc34a", description: "Find local cultivators" },
    { title: "Seed Vendors", icon: /* @__PURE__ */ React.createElement(MenuBookIcon, null), nav: "seeds", color: "#aed581", description: "Trusted seed sources" },
    { title: "Dispensaries", icon: /* @__PURE__ */ React.createElement(StoreIcon, null), nav: "dispensaries", color: "#c5e1a5", description: "Find nearby shops" }
  ];
  if (isAdmin) {
    tiles.push({
      title: "Feedback Reader",
      icon: /* @__PURE__ */ React.createElement(FeedbackIcon, null),
      nav: "feedback-reader",
      color: "#ff6b6b",
      description: "Admin feedback tool",
      adminOnly: true
    });
  }
  if (loading) {
    return /* @__PURE__ */ React.createElement(Box, { sx: { minHeight: "100vh", display: "flex", alignItems: "center", justifyContent: "center" } }, /* @__PURE__ */ React.createElement(Typography, { sx: { color: "#fff" } }, "Loading..."));
  }
  if (showScan) {
    return /* @__PURE__ */ React.createElement(ScanWizard, { onBack: () => setShowScan(false) });
  }
  if (showStrainBrowser) {
    return /* @__PURE__ */ React.createElement(StrainBrowser, { onBack: () => setShowStrainBrowser(false) });
  }
  if (showReviews) {
    return /* @__PURE__ */ React.createElement(ReviewsHub, { onBack: () => setShowReviews(false), currentUser: user });
  }
  if (showDispensaryFinder) {
    return /* @__PURE__ */ React.createElement(DispensaryFinder, { onBack: () => setShowDispensaryFinder(false) });
  }
  if (showSeedFinder) {
    return /* @__PURE__ */ React.createElement(SeedVendorFinder, { onBack: () => setShowSeedFinder(false) });
  }
  if (showGroups) {
    return /* @__PURE__ */ React.createElement(Groups, { onBack: () => setShowGroups(false) });
  }
  if (showGrowCoach) {
    return /* @__PURE__ */ React.createElement(GrowCoach, { onBack: () => setShowGrowCoach(false) });
  }
  if (showGrowerDirectory) {
    return /* @__PURE__ */ React.createElement(GrowerDirectory, { onBack: () => setShowGrowerDirectory(false) });
  }
  if (showFeedbackReader) {
    return /* @__PURE__ */ React.createElement(FeedbackReader, { user, onBack: () => setShowFeedbackReader(false) });
  }
  return /* @__PURE__ */ React.createElement(Box, { sx: {
    minHeight: "100vh",
    paddingTop: "120px",
    // Fixed padding to clear the notch
    pb: "calc(env(safe-area-inset-bottom) + 12px)",
    px: 2,
    background: "none"
  } }, isExpired && /* @__PURE__ */ React.createElement(
    Alert,
    {
      severity: "error",
      icon: /* @__PURE__ */ React.createElement(WarningIcon, null),
      sx: { mb: 1.5, py: 0.5, fontSize: "0.75rem" }
    },
    "Payment overdue. Update payment to continue."
  ), /* @__PURE__ */ React.createElement(Paper, { sx: {
    p: 1.5,
    mb: 1.5,
    background: "linear-gradient(135deg, rgba(124, 179, 66, 0.15) 0%, rgba(156, 204, 101, 0.1) 100%)",
    backdropFilter: "blur(20px)",
    border: "1.5px solid rgba(124, 179, 66, 0.4)",
    borderRadius: 3,
    boxShadow: "0 4px 20px rgba(124, 179, 66, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1)",
    transition: "all 0.15s ease"
  } }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1, alignItems: "center", justifyContent: "space-between" }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1.5, alignItems: "center" }, /* @__PURE__ */ React.createElement(
    Box,
    {
      sx: {
        width: 48,
        height: 48,
        borderRadius: "50%",
        background: "transparent",
        border: "2px solid rgba(124, 179, 66, 0.6)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        overflow: "hidden"
      }
    },
    /* @__PURE__ */ React.createElement(
      "img",
      {
        src: "/hero.png?v=13",
        alt: "StrainSpotter",
        style: { width: "100%", height: "100%", objectFit: "cover" }
      }
    )
  ), /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { color: "#fff", fontWeight: 700, fontSize: "1.4rem", lineHeight: 1.2, mb: 0.25 } }, "The Garden"), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "#7cb342", fontWeight: 600, fontSize: "0.75rem" } }, isAdmin ? " Member  Admin & Moderator" : " Member"))), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 0.5, alignItems: "center" }, /* @__PURE__ */ React.createElement(Box, { onClick: () => setShowBuyScans(true), sx: { cursor: "pointer" } }, /* @__PURE__ */ React.createElement(CreditBalance, null)), onBack && /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "outlined",
      size: "small",
      onClick: onBack,
      sx: {
        color: "#CDDC39",
        borderColor: "rgba(124, 179, 66, 0.5)",
        fontSize: "0.7rem",
        py: 0.5,
        px: 1,
        minWidth: "auto",
        background: "rgba(124, 179, 66, 0.1)",
        backdropFilter: "blur(5px)",
        transition: "all 0.15s cubic-bezier(0.4, 0, 0.2, 1)",
        "&:hover": {
          borderColor: "rgba(124, 179, 66, 1)",
          background: "rgba(124, 179, 66, 0.2)",
          transform: "scale(1.05)",
          color: "#fff"
        },
        "&:active": {
          transform: "scale(0.95)",
          transition: "all 0.05s ease"
        }
      }
    },
    "Home"
  ), /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "outlined",
      size: "small",
      onClick: handleLogout,
      sx: {
        color: "#CDDC39",
        borderColor: "rgba(124, 179, 66, 0.5)",
        fontSize: "0.7rem",
        py: 0.5,
        px: 1,
        minWidth: "auto",
        background: "rgba(124, 179, 66, 0.1)",
        backdropFilter: "blur(5px)",
        transition: "all 0.15s cubic-bezier(0.4, 0, 0.2, 1)",
        "&:hover": {
          borderColor: "rgba(124, 179, 66, 1)",
          background: "rgba(124, 179, 66, 0.2)",
          transform: "scale(1.05)",
          color: "#fff"
        },
        "&:active": {
          transform: "scale(0.95)",
          transition: "all 0.05s ease"
        }
      }
    },
    "Logout"
  )))), /* @__PURE__ */ React.createElement(Paper, { sx: {
    p: 2,
    mb: 2,
    background: "linear-gradient(135deg, rgba(124, 179, 66, 0.08) 0%, rgba(156, 204, 101, 0.05) 100%)",
    backdropFilter: "blur(15px)",
    border: "1.5px solid rgba(124, 179, 66, 0.25)",
    borderRadius: 3,
    boxShadow: "0 2px 12px rgba(0, 0, 0, 0.2)"
  } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: {
    color: "#CDDC39",
    fontWeight: 700,
    fontSize: "1.1rem",
    mb: 1,
    textShadow: "0 1px 3px rgba(0, 0, 0, 0.5)"
  } }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", alignItems: "center", spacing: 1, justifyContent: "center" }, /* @__PURE__ */ React.createElement("span", null, "Welcome to The Garden"), /* @__PURE__ */ React.createElement(Box, { component: "img", src: "/hero.png?v=13", alt: "", sx: { width: 20, height: 20, borderRadius: "50%", filter: "drop-shadow(0 0 4px rgba(124, 179, 66, 0.6))" } }))), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: {
    color: "#e8e8e8",
    fontSize: "0.85rem",
    lineHeight: 1.6,
    textShadow: "0 1px 2px rgba(0, 0, 0, 0.3)"
  } }, "Your premium cannabis companion. Identify strains instantly, track your favorites, find nearby dispensaries, and connect with the community. Every feature is designed to enhance your cannabis experience.")), /* @__PURE__ */ React.createElement(Grid, { container: true, spacing: 2 }, tiles.map((tile) => /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 6, key: tile.nav }, /* @__PURE__ */ React.createElement(
    Paper,
    {
      onClick: () => handleFeatureClick(tile.title, tile.nav),
      sx: {
        p: 2,
        textAlign: "center",
        cursor: "pointer",
        background: "linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(124, 179, 66, 0.08) 100%)",
        backdropFilter: "blur(15px)",
        border: "1.5px solid rgba(124, 179, 66, 0.3)",
        borderRadius: 2.5,
        transition: "all 0.15s cubic-bezier(0.4, 0, 0.2, 1)",
        boxShadow: "0 2px 8px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1)",
        position: "relative",
        overflow: "hidden",
        minHeight: "120px",
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center",
        "&::before": {
          content: '""',
          position: "absolute",
          top: "-50%",
          left: "-50%",
          width: "200%",
          height: "200%",
          background: "radial-gradient(circle, rgba(124, 179, 66, 0.1) 0%, transparent 70%)",
          opacity: 0,
          transition: "opacity 0.15s ease"
        },
        "&:hover": {
          background: "linear-gradient(135deg, rgba(124, 179, 66, 0.2) 0%, rgba(156, 204, 101, 0.15) 100%)",
          border: "1.5px solid rgba(124, 179, 66, 0.6)",
          transform: "translateY(-4px) scale(1.05)",
          boxShadow: "0 8px 24px rgba(124, 179, 66, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2)",
          "&::before": {
            opacity: 1
          }
        },
        "&:active": {
          transform: "translateY(-2px) scale(1.02)",
          transition: "all 0.05s ease"
        }
      }
    },
    /* @__PURE__ */ React.createElement(Box, { sx: {
      width: 48,
      height: 48,
      margin: "0 auto 8px auto",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      background: `linear-gradient(135deg, ${tile.color} 0%, ${tile.color}dd 100%)`,
      borderRadius: "50%",
      boxShadow: `0 3px 10px ${tile.color}66, inset 0 1px 0 rgba(255, 255, 255, 0.3)`,
      transition: "all 0.15s ease",
      "& svg": { fontSize: 28, color: "#fff", filter: "drop-shadow(0 2px 4px rgba(0,0,0,0.3))" }
    } }, tile.icon),
    /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: {
      color: "#fff",
      fontWeight: 700,
      fontSize: "0.9rem",
      lineHeight: 1.2,
      mb: 0.5,
      display: "block",
      textShadow: "0 1px 3px rgba(0, 0, 0, 0.5)",
      transition: "all 0.15s ease"
    } }, tile.title),
    /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: {
      color: "#b0b0b0",
      fontSize: "0.7rem",
      lineHeight: 1.3,
      display: "block",
      textShadow: "0 1px 2px rgba(0, 0, 0, 0.5)"
    } }, tile.description)
  )))), /* @__PURE__ */ React.createElement(Paper, { sx: {
    p: 1.5,
    mt: 1.5,
    background: "linear-gradient(135deg, rgba(124, 179, 66, 0.12) 0%, rgba(156, 204, 101, 0.08) 100%)",
    backdropFilter: "blur(15px)",
    border: "1.5px solid rgba(124, 179, 66, 0.3)",
    borderRadius: 3,
    boxShadow: "0 2px 12px rgba(124, 179, 66, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.1)",
    transition: "all 0.15s ease"
  } }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1, alignItems: "center", justifyContent: "space-between" }, /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: {
    color: "#e8e8e8",
    fontSize: "0.7rem",
    textShadow: "0 1px 2px rgba(0, 0, 0, 0.3)"
  } }, /* @__PURE__ */ React.createElement("strong", { style: { color: "#CDDC39" } }, "Plan:"), " $4.99/mo  Active Member"), /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "text",
      size: "small",
      sx: {
        color: "#ff5252",
        fontSize: "0.65rem",
        py: 0.25,
        px: 1,
        minWidth: "auto",
        transition: "all 0.15s ease",
        "&:hover": {
          bgcolor: "rgba(255, 82, 82, 0.15)",
          transform: "scale(1.05)"
        },
        "&:active": {
          transform: "scale(0.95)",
          transition: "all 0.05s ease"
        }
      }
    },
    "Cancel"
  ))), /* @__PURE__ */ React.createElement(
    Dialog,
    {
      open: showLogoutWarning,
      onClose: () => setShowLogoutWarning(false),
      fullScreen: true,
      PaperProps: {
        sx: {
          bgcolor: "#1a1a1a",
          m: 0,
          maxHeight: "100vh"
        }
      }
    },
    /* @__PURE__ */ React.createElement(DialogTitle, { sx: { bgcolor: "#ff5252", color: "#fff", borderBottom: "1px solid rgba(255,255,255,0.2)" } }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1, alignItems: "center" }, /* @__PURE__ */ React.createElement(WarningIcon, null), /* @__PURE__ */ React.createElement("span", null, "Cannot Logout"))),
    /* @__PURE__ */ React.createElement(DialogContent, { sx: { mt: 2, bgcolor: "#1a1a1a", color: "#fff" } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body1", sx: { mb: 2 } }, "Your membership payment is overdue. You must resolve your payment before you can logout."), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, "Please update your payment method or contact support for assistance."), /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "contained",
        fullWidth: true,
        sx: { mt: 3, bgcolor: "#7cb342", "&:hover": { bgcolor: "#689f38" } },
        onClick: () => setShowLogoutWarning(false)
      },
      "Update Payment Method"
    ), /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "outlined",
        fullWidth: true,
        color: "error",
        sx: { mt: 1 },
        onClick: () => __async(null, null, function* () {
          try {
            yield supabase.auth.signOut();
            localStorage.clear();
            sessionStorage.clear();
            setShowLogoutWarning(false);
            onBack == null ? void 0 : onBack();
          } catch (e) {
            console.error("Force logout failed:", e);
          }
        })
      },
      "Force Logout Anyway"
    ), /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "text",
        fullWidth: true,
        sx: { mt: 1 },
        onClick: () => setShowLogoutWarning(false)
      },
      "Close"
    ))
  ), /* @__PURE__ */ React.createElement(
    Dialog,
    {
      open: showComingSoon,
      onClose: () => setShowComingSoon(false),
      fullScreen: true,
      PaperProps: {
        sx: {
          background: "linear-gradient(135deg, rgba(124, 179, 66, 0.95) 0%, rgba(104, 159, 56, 0.95) 100%)",
          backdropFilter: "blur(20px)",
          borderRadius: { xs: 0, sm: 4 },
          border: "2px solid rgba(255, 255, 255, 0.2)",
          m: 0,
          maxHeight: "100vh"
        }
      }
    },
    /* @__PURE__ */ React.createElement(DialogTitle, { sx: { color: "#fff", fontWeight: 700, borderBottom: "1px solid rgba(255,255,255,0.2)" } }, " Coming Soon!"),
    /* @__PURE__ */ React.createElement(DialogContent, { sx: { display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", textAlign: "center", p: 4 } }, /* @__PURE__ */ React.createElement(Typography, { sx: { color: "#fff", mb: 2 } }, /* @__PURE__ */ React.createElement("strong", null, selectedFeature), " is currently under development."), /* @__PURE__ */ React.createElement(Typography, { sx: { color: "#e0e0e0", mb: 2 } }, "We're working hard to bring you this feature soon! In the meantime, enjoy scanning strains and exploring the community."), /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "contained",
        fullWidth: true,
        sx: {
          mt: 2,
          bgcolor: "#fff",
          color: "#7cb342",
          "&:hover": { bgcolor: "#f0f0f0" }
        },
        onClick: () => setShowComingSoon(false)
      },
      "Got it!"
    ))
  ), /* @__PURE__ */ React.createElement(Tooltip, { title: "Send Feedback", placement: "left" }, /* @__PURE__ */ React.createElement(
    Fab,
    {
      color: "primary",
      onClick: () => setShowFeedback(true),
      sx: {
        position: "fixed",
        bottom: 24,
        right: 24,
        zIndex: 1e3,
        background: "linear-gradient(135deg, #7CB342 0%, #9CCC65 100%)",
        boxShadow: "0 8px 30px rgba(124, 179, 66, 0.4)",
        "&:hover": {
          background: "linear-gradient(135deg, #9CCC65 0%, #7CB342 100%)",
          boxShadow: "0 12px 40px rgba(124, 179, 66, 0.6)",
          transform: "scale(1.05)"
        }
      }
    },
    /* @__PURE__ */ React.createElement(FeedbackIcon, null)
  )), /* @__PURE__ */ React.createElement(
    FeedbackModal,
    {
      open: showFeedback,
      onClose: () => setShowFeedback(false),
      user
    }
  ), /* @__PURE__ */ React.createElement(
    BuyScansModal,
    {
      open: showBuyScans,
      onClose: () => setShowBuyScans(false),
      currentTier: "free",
      creditsRemaining: 0
    }
  ));
}
const useState$c = window["React"].useState;
function Home({ onNavigate }) {
  const [showScan, setShowScan] = useState$c(false);
  const [showGarden, setShowGarden] = useState$c(false);
  const [inGarden, setInGarden] = useState$c(false);
  const [showFeedback, setShowFeedback] = useState$c(false);
  if (showScan) {
    return /* @__PURE__ */ React.createElement(ScanWizard, { onBack: () => setShowScan(false) });
  }
  if (showGarden && !inGarden) {
    return /* @__PURE__ */ React.createElement(
      GardenGate,
      {
        onSuccess: () => {
          setInGarden(true);
        },
        onBack: () => setShowGarden(false)
      }
    );
  }
  if (inGarden) {
    return /* @__PURE__ */ React.createElement(
      Garden,
      {
        onNavigate,
        onBack: () => {
          setInGarden(false);
          setShowGarden(false);
        }
      }
    );
  }
  return /* @__PURE__ */ React.createElement(
    Box,
    {
      sx: {
        minHeight: "100vh",
        width: "100%",
        backgroundColor: "#0a0a0a",
        backgroundImage: "url(/strainspotter-bg.jpg)",
        backgroundSize: "cover",
        backgroundPosition: "center",
        backgroundAttachment: "fixed",
        backgroundRepeat: "no-repeat",
        position: "relative",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        "&::before": {
          content: '""',
          position: "absolute",
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          background: "rgba(0, 0, 0, 0.6)",
          pointerEvents: "none",
          zIndex: 0
        }
      }
    },
    /* @__PURE__ */ React.createElement(Container, { maxWidth: "xs", sx: { position: "relative", zIndex: 1, px: 3 } }, /* @__PURE__ */ React.createElement(Stack, { spacing: 3, alignItems: "center", textAlign: "center" }, /* @__PURE__ */ React.createElement(
      Box,
      {
        sx: {
          width: 100,
          height: 100,
          borderRadius: "50%",
          background: "linear-gradient(135deg, rgba(124, 179, 66, 0.2) 0%, rgba(156, 204, 101, 0.2) 100%)",
          border: "3px solid rgba(124, 179, 66, 0.6)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          boxShadow: "0 0 40px rgba(124, 179, 66, 0.6), 0 0 80px rgba(124, 179, 66, 0.3), inset 0 0 20px rgba(124, 179, 66, 0.1)",
          animation: "pulse 3s ease-in-out infinite",
          "@keyframes pulse": {
            "0%, 100%": { boxShadow: "0 0 40px rgba(124, 179, 66, 0.6), 0 0 80px rgba(124, 179, 66, 0.3)" },
            "50%": { boxShadow: "0 0 60px rgba(124, 179, 66, 0.8), 0 0 120px rgba(124, 179, 66, 0.4)" }
          }
        }
      },
      /* @__PURE__ */ React.createElement(
        "img",
        {
          src: "/hero.png?v=13",
          alt: "StrainSpotter",
          style: { width: "100%", height: "100%", objectFit: "cover", borderRadius: "50%" }
        }
      )
    ), /* @__PURE__ */ React.createElement(
      Typography,
      {
        variant: "h4",
        sx: {
          fontFamily: "Poppins, sans-serif",
          fontWeight: 900,
          background: "linear-gradient(135deg, #CDDC39 0%, #9CCC65 50%, #7CB342 100%)",
          WebkitBackgroundClip: "text",
          WebkitTextFillColor: "transparent",
          backgroundClip: "text",
          fontSize: "2.5rem",
          lineHeight: 1.1,
          textShadow: "0 0 30px rgba(124, 179, 66, 0.5)",
          filter: "drop-shadow(0 0 20px rgba(124, 179, 66, 0.4))"
        }
      },
      "StrainSpotter"
    ), /* @__PURE__ */ React.createElement(
      Typography,
      {
        variant: "body1",
        sx: {
          color: "#d0d0d0",
          fontSize: "1rem",
          maxWidth: 320,
          lineHeight: 1.5,
          textShadow: "0 2px 8px rgba(0, 0, 0, 0.5)"
        }
      },
      "AI-Powered Cannabis Strain Identification"
    ), /* @__PURE__ */ React.createElement(Stack, { spacing: 2, sx: { width: "100%", maxWidth: 300, mt: 2 } }, /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "contained",
        size: "large",
        fullWidth: true,
        onClick: () => setShowScan(true),
        startIcon: /* @__PURE__ */ React.createElement(CameraAltIcon, null),
        sx: {
          py: 2,
          fontSize: "1.1rem",
          fontWeight: 700,
          borderRadius: "16px",
          background: "linear-gradient(135deg, #7CB342 0%, #9CCC65 50%, #CDDC39 100%)",
          boxShadow: "0 8px 32px rgba(124, 179, 66, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.2)",
          textTransform: "none",
          transition: "all 0.15s cubic-bezier(0.4, 0, 0.2, 1)",
          position: "relative",
          overflow: "hidden",
          "&::before": {
            content: '""',
            position: "absolute",
            top: 0,
            left: "-100%",
            width: "100%",
            height: "100%",
            background: "linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent)",
            transition: "left 0.5s ease"
          },
          "&:hover": {
            transform: "translateY(-3px) scale(1.02)",
            boxShadow: "0 12px 40px rgba(124, 179, 66, 0.7), 0 0 60px rgba(124, 179, 66, 0.3)",
            background: "linear-gradient(135deg, #8BC34A 0%, #AED581 50%, #CDDC39 100%)",
            "&::before": {
              left: "100%"
            }
          },
          "&:active": {
            transform: "translateY(-1px) scale(0.98)",
            transition: "all 0.05s ease"
          }
        }
      },
      "Start AI Scan"
    ), /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "outlined",
        size: "large",
        fullWidth: true,
        onClick: () => setShowGarden(true),
        startIcon: /* @__PURE__ */ React.createElement(SpaIcon, null),
        sx: {
          py: 2,
          fontSize: "1.1rem",
          fontWeight: 700,
          borderRadius: "16px",
          border: "2px solid rgba(124, 179, 66, 0.7)",
          color: "#CDDC39",
          background: "rgba(124, 179, 66, 0.1)",
          backdropFilter: "blur(10px)",
          textTransform: "none",
          transition: "all 0.15s cubic-bezier(0.4, 0, 0.2, 1)",
          boxShadow: "0 4px 16px rgba(124, 179, 66, 0.2), inset 0 1px 0 rgba(124, 179, 66, 0.2)",
          "&:hover": {
            border: "2px solid rgba(124, 179, 66, 1)",
            background: "rgba(124, 179, 66, 0.2)",
            transform: "translateY(-3px) scale(1.02)",
            boxShadow: "0 8px 32px rgba(124, 179, 66, 0.4), inset 0 1px 0 rgba(124, 179, 66, 0.3)",
            color: "#fff"
          },
          "&:active": {
            transform: "translateY(-1px) scale(0.98)",
            transition: "all 0.05s ease"
          }
        }
      },
      "Enter the Garden"
    )), /* @__PURE__ */ React.createElement(
      Typography,
      {
        variant: "caption",
        sx: {
          color: "#7CB342",
          fontSize: "0.875rem",
          fontWeight: 600,
          mt: 2
        }
      },
      "35,000+ Strains  Instant Results  AI-Powered"
    ))),
    /* @__PURE__ */ React.createElement(
      Fab,
      {
        color: "primary",
        size: "small",
        onClick: () => setShowFeedback(true),
        sx: {
          position: "fixed",
          bottom: 16,
          right: 16,
          zIndex: 1e3,
          background: "linear-gradient(135deg, #7CB342 0%, #9CCC65 100%)",
          boxShadow: "0 4px 12px rgba(124, 179, 66, 0.3)",
          width: 48,
          height: 48
        }
      },
      /* @__PURE__ */ React.createElement(FeedbackIcon, { fontSize: "small" })
    ),
    /* @__PURE__ */ React.createElement(
      FeedbackModal,
      {
        open: showFeedback,
        onClose: () => setShowFeedback(false),
        user: null
      }
    )
  );
}
const React$4 = window["React"];
const useEffect$b = window["React"].useEffect;
const useState$b = window["React"].useState;
function Seeds({ onBack }) {
  const navigate = useNavigate();
  const [seeds, setSeeds] = useState$b([]);
  const [loading, setLoading] = useState$b(true);
  const [error, setError] = useState$b(null);
  useEffect$b(() => {
    const fallbackSeeds = [
      { id: "ilgm", name: "I Love Growing Marijuana (ILGM)", breeder: "ILGM", type: "seed bank", description: "Premium cannabis seeds with germination guarantee. Feminized, autoflower, and regular seeds available.", url: "https://ilgm.com" },
      { id: "seedsman", name: "Seedsman", breeder: "Seedsman", type: "seed bank", description: "One of the oldest and most trusted online seed banks. Huge selection from top breeders worldwide.", url: "https://www.seedsman.com" },
      { id: "crop-king", name: "Crop King Seeds", breeder: "Crop King", type: "seed bank", description: "Canadian seed bank with fast shipping to US. Great selection of feminized and autoflower strains.", url: "https://www.cropkingseeds.com" },
      { id: "msnl", name: "Marijuana Seeds NL", breeder: "MSNL", type: "seed bank", description: "Established seed bank with stealth shipping worldwide. Competitive prices and frequent sales.", url: "https://www.msnl.com" },
      { id: "growers-choice", name: "Growers Choice Seeds", breeder: "Growers Choice", type: "seed bank", description: "US-based seed company with 90% germination guarantee. Fast domestic shipping.", url: "https://growerschoiceseeds.com" },
      { id: "homegrown", name: "Homegrown Cannabis Co.", breeder: "Homegrown", type: "seed bank", description: "Premium genetics with expert growing advice. Free seeds with every order.", url: "https://homegrowncannabisco.com" }
    ];
    fetch(`${API_BASE}/api/seeds`).then((res) => {
      if (!res.ok) throw new Error("Failed to load seeds");
      return res.json();
    }).then((data) => {
      const allSeeds = [...data, ...fallbackSeeds].filter(
        (seed, idx, arr) => arr.findIndex((s) => s.id === seed.id) === idx
      );
      setSeeds(allSeeds);
    }).catch((e) => {
      console.error("[Seeds] Error:", e);
      setSeeds(fallbackSeeds);
      setError(null);
    }).finally(() => setLoading(false));
  }, []);
  const showPlaceholder = !seeds || seeds.length === 0;
  return /* @__PURE__ */ React$4.createElement(Container, { maxWidth: "lg", sx: { py: 3 } }, /* @__PURE__ */ React$4.createElement(
    "button",
    {
      style: {
        position: "absolute",
        top: 16,
        left: 16,
        zIndex: 100,
        background: "rgba(34, 139, 34, 0.25)",
        border: "1px solid #228B22",
        borderRadius: 12,
        boxShadow: "0 2px 12px rgba(34,139,34,0.15)",
        backdropFilter: "blur(8px)",
        color: "#228B22",
        padding: "8px 16px",
        display: "flex",
        alignItems: "center",
        fontWeight: 600,
        fontSize: 18
      },
      onClick: () => navigate("/")
    },
    /* @__PURE__ */ React$4.createElement(CannabisLeafIcon, { style: { marginRight: 8, height: 24 } }),
    "Home"
  ), onBack && /* @__PURE__ */ React$4.createElement(Button, { onClick: onBack, size: "small", variant: "contained", sx: { bgcolor: "#7CB342", color: "white", textTransform: "none", fontWeight: 700, borderRadius: 999, mb: 2, "&:hover": { bgcolor: "#689f38" } } }, " Back to Garden"), /* @__PURE__ */ React$4.createElement(Typography, { variant: "h4", gutterBottom: true, sx: { color: "white" } }, "Seeds & Genetics"), loading && /* @__PURE__ */ React$4.createElement(Box, { sx: { display: "flex", justifyContent: "center", py: 4 } }, /* @__PURE__ */ React$4.createElement(CircularProgress, null)), error && /* @__PURE__ */ React$4.createElement(Alert, { severity: "error", sx: { mb: 2 } }, error), !loading && !error && showPlaceholder && /* @__PURE__ */ React$4.createElement(Alert, { severity: "info", sx: { mb: 2 } }, "Our seed catalog is being populated. In the meantime, browse strains to research genetics or check back soon for sellers and breeders."), !loading && !error && !showPlaceholder && /* @__PURE__ */ React$4.createElement(Grid, { container: true, spacing: 2 }, seeds.map((seed) => /* @__PURE__ */ React$4.createElement(Grid, { item: true, size: { xs: 12, sm: 6, md: 4 }, key: seed.id }, /* @__PURE__ */ React$4.createElement(Card, null, /* @__PURE__ */ React$4.createElement(CardContent, null, /* @__PURE__ */ React$4.createElement(Typography, { variant: "h6" }, seed.name), /* @__PURE__ */ React$4.createElement(Typography, { variant: "body2" }, seed.breeder), /* @__PURE__ */ React$4.createElement(Typography, { variant: "body2" }, "Type: ", seed.type), /* @__PURE__ */ React$4.createElement(Typography, { variant: "body2" }, "THC: ", seed.thc || "N/A", "%"), /* @__PURE__ */ React$4.createElement(Typography, { variant: "body2" }, "CBD: ", seed.cbd || "N/A", "%"), seed.description && /* @__PURE__ */ React$4.createElement(Typography, { variant: "body2", sx: { mt: 1 } }, seed.description), seed.url && /* @__PURE__ */ React$4.createElement(Stack, { direction: "row", sx: { mt: 1 } }, /* @__PURE__ */ React$4.createElement(
    Button,
    {
      size: "small",
      variant: "contained",
      color: "primary",
      href: seed.url,
      target: "_blank",
      rel: "noopener noreferrer"
    },
    "View Seller"
  ))))))));
}
const React$3 = window["React"];
const useEffect$a = window["React"].useEffect;
const useState$a = window["React"].useState;
function Dispensaries({ onBack }) {
  const navigate = useNavigate();
  const [dispensaries, setDispensaries] = useState$a([]);
  const [loading, setLoading] = useState$a(true);
  const [error, setError] = useState$a(null);
  const [userLocation, setUserLocation] = useState$a(null);
  const [locationError, setLocationError] = useState$a(null);
  useEffect$a(() => {
    if ("geolocation" in navigator) {
      navigator.geolocation.getCurrentPosition(
        (position2) => {
          console.log("[Dispensaries] Location obtained successfully");
          setUserLocation({
            lat: position2.coords.latitude,
            lng: position2.coords.longitude
          });
        },
        (err) => {
          console.warn("[Dispensaries] Location access denied:", err.message);
          setLocationError("Location access denied. Showing all dispensaries.");
          setUserLocation({ lat: 37.7749, lng: -122.4194 });
        },
        {
          timeout: 5e3,
          maximumAge: 3e5,
          // 5 min cache
          enableHighAccuracy: false
        }
      );
    } else {
      console.log("[Dispensaries] Geolocation not supported");
      setLocationError("Geolocation not supported. Showing all dispensaries.");
      setUserLocation({ lat: 37.7749, lng: -122.4194 });
    }
  }, []);
  useEffect$a(() => {
    const params = new URLSearchParams();
    if (userLocation) {
      params.set("lat", userLocation.lat);
      params.set("lng", userLocation.lng);
      params.set("radius", "50");
    }
    const url = `${API_BASE}/api/dispensaries?${params}`;
    console.log("[Dispensaries] Fetching from:", url);
    fetch(url).then((res) => {
      console.log("[Dispensaries] Response status:", res.status, res.statusText);
      if (!res.ok) throw new Error("Failed to load dispensaries");
      return res.json();
    }).then((data) => {
      console.log("[Dispensaries] Received dispensaries:", (data == null ? void 0 : data.length) || 0);
      if (userLocation && Array.isArray(data)) {
        data.sort((a, b) => (a.distance || Infinity) - (b.distance || Infinity));
      }
      setDispensaries(data);
    }).catch((e) => {
      console.error("[Dispensaries] Error:", e);
      setDispensaries([
        {
          id: "sample-green-leaf",
          name: "Green Leaf Dispensary",
          address: "123 Main St",
          city: "San Francisco",
          state: "CA",
          phone: "(415) 555-0123",
          description: "Friendly staff  Curbside pickup  Daily deals"
        },
        {
          id: "sample-sunset-wellness",
          name: "Sunset Wellness",
          address: "456 Sunset Blvd",
          city: "Los Angeles",
          state: "CA",
          phone: "(323) 555-0456",
          description: "Verified lab-tested products  Rewards program"
        }
      ]);
      setError(null);
    }).finally(() => setLoading(false));
  }, [userLocation]);
  if (loading) {
    return /* @__PURE__ */ React$3.createElement(Box, { sx: { display: "flex", flexDirection: "column", alignItems: "center", gap: 2, m: 4 } }, /* @__PURE__ */ React$3.createElement(CircularProgress, null), /* @__PURE__ */ React$3.createElement(Typography, { variant: "body2", color: "text.secondary" }, userLocation ? "Finding dispensaries near you..." : "Getting your location..."));
  }
  if (error) return /* @__PURE__ */ React$3.createElement(Alert, { severity: "error", sx: { m: 2 } }, error);
  return /* @__PURE__ */ React$3.createElement(Box, { sx: { p: 3 } }, /* @__PURE__ */ React$3.createElement(
    "button",
    {
      style: {
        position: "absolute",
        top: 16,
        left: 16,
        zIndex: 100,
        background: "rgba(34, 139, 34, 0.25)",
        border: "1px solid #228B22",
        borderRadius: 12,
        boxShadow: "0 2px 12px rgba(34,139,34,0.15)",
        backdropFilter: "blur(8px)",
        color: "#228B22",
        padding: "8px 16px",
        display: "flex",
        alignItems: "center",
        fontWeight: 600,
        fontSize: 18
      },
      onClick: () => navigate("/")
    },
    /* @__PURE__ */ React$3.createElement(CannabisLeafIcon, { style: { marginRight: 8, height: 24 } }),
    "Home"
  ), onBack && /* @__PURE__ */ React$3.createElement(Box, { sx: { mb: 2 } }, /* @__PURE__ */ React$3.createElement(Button, { onClick: onBack, size: "small", variant: "contained", sx: { bgcolor: "#7CB342", color: "white", textTransform: "none", fontWeight: 700, borderRadius: 999, "&:hover": { bgcolor: "#689f38" } } }, " Back to Garden")), /* @__PURE__ */ React$3.createElement(Stack, { direction: "row", alignItems: "center", spacing: 2, sx: { mb: 3 } }, /* @__PURE__ */ React$3.createElement(Typography, { variant: "h4", sx: { fontWeight: 700 } }, "Dispensaries Near You"), userLocation && /* @__PURE__ */ React$3.createElement(
    Chip,
    {
      icon: /* @__PURE__ */ React$3.createElement(MyLocationIcon, null),
      label: "Location enabled",
      color: "success",
      size: "small"
    }
  )), /* @__PURE__ */ React$3.createElement(Box, { sx: { mb: 4 } }, /* @__PURE__ */ React$3.createElement(Typography, { variant: "h6", sx: { mb: 1 } }, "Google Maps Results"), /* @__PURE__ */ React$3.createElement(
    Button,
    {
      variant: "outlined",
      color: "primary",
      startIcon: /* @__PURE__ */ React$3.createElement(OpenInNewIcon, null),
      href: userLocation ? `https://www.google.com/maps/search/dispensary/@${userLocation.lat},${userLocation.lng},13z` : `https://www.google.com/maps/search/dispensary/`,
      target: "_blank",
      rel: "noopener noreferrer",
      sx: { mb: 2 }
    },
    "View Dispensaries on Google Maps"
  )), locationError && /* @__PURE__ */ React$3.createElement(Alert, { severity: "info", sx: { mb: 2 } }, locationError), dispensaries.length === 0 ? /* @__PURE__ */ React$3.createElement(Alert, { severity: "info" }, "No dispensaries found nearby. Try expanding your search radius or check back later.") : /* @__PURE__ */ React$3.createElement(Grid, { container: true, spacing: 3 }, dispensaries.map((d, idx) => /* @__PURE__ */ React$3.createElement(Grid, { item: true, size: { xs: 12, sm: 6, md: 4 }, key: `${d.id}-${idx}` }, /* @__PURE__ */ React$3.createElement(Card, { sx: { mb: 2, background: "rgba(255,255,255,0.10)", backdropFilter: "blur(12px)", border: "2px solid black", boxShadow: "none" } }, /* @__PURE__ */ React$3.createElement(CardContent, { sx: { flex: 1 } }, /* @__PURE__ */ React$3.createElement(Typography, { variant: "h6", gutterBottom: true, sx: { fontWeight: 600 } }, d.name), d.distance && /* @__PURE__ */ React$3.createElement(
    Chip,
    {
      label: `${d.distance.toFixed(1)} mi away`,
      size: "small",
      color: "primary",
      sx: { mb: 1 }
    }
  ), /* @__PURE__ */ React$3.createElement(Stack, { spacing: 0.5, sx: { mt: 1 } }, /* @__PURE__ */ React$3.createElement(Typography, { variant: "body2", sx: { color: "black", fontSize: "1.08rem" } }, d.address), /* @__PURE__ */ React$3.createElement(Typography, { variant: "body2", color: "text.secondary" }, d.city, ", ", d.state, " ", d.zip || ""), d.description && /* @__PURE__ */ React$3.createElement(Typography, { variant: "body2", sx: { mt: 1 } }, d.description))), /* @__PURE__ */ React$3.createElement(Box, { sx: { p: 2, pt: 0 } }, /* @__PURE__ */ React$3.createElement(ButtonGroup, { fullWidth: true, orientation: "vertical", variant: "contained" }, d.phone && /* @__PURE__ */ React$3.createElement(
    Button,
    {
      startIcon: /* @__PURE__ */ React$3.createElement(PhoneIcon, null),
      href: `tel:${d.phone.replace(/[^0-9+]/g, "")}`,
      sx: {
        background: "linear-gradient(45deg, #4caf50 30%, #66bb6a 90%)",
        "&:hover": {
          background: "linear-gradient(45deg, #388e3c 30%, #4caf50 90%)"
        }
      }
    },
    "Call ",
    d.phone
  ), d.lat && d.lng || d.address && d.city && d.state ? /* @__PURE__ */ React$3.createElement(
    Button,
    {
      startIcon: /* @__PURE__ */ React$3.createElement(DirectionsIcon, null),
      onClick: () => {
        const destination = d.lat && d.lng ? `${d.lat},${d.lng}` : `${d.address}, ${d.city}, ${d.state} ${d.zip || ""}`.trim();
        const mapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${encodeURIComponent(destination)}`;
        window.open(mapsUrl, "_blank");
      },
      sx: {
        background: "linear-gradient(45deg, #2196f3 30%, #42a5f5 90%)",
        "&:hover": {
          background: "linear-gradient(45deg, #1976d2 30%, #2196f3 90%)"
        }
      }
    },
    "Get Directions"
  ) : null, d.website && /* @__PURE__ */ React$3.createElement(
    Button,
    {
      startIcon: /* @__PURE__ */ React$3.createElement(OpenInNewIcon, null),
      href: d.website,
      target: "_blank",
      rel: "noopener noreferrer",
      sx: {
        background: "linear-gradient(45deg, #ff9800 30%, #ffa726 90%)",
        "&:hover": {
          background: "linear-gradient(45deg, #f57c00 30%, #ff9800 90%)"
        }
      }
    },
    "Visit Website"
  ))))))));
}
function Help({ onNavigate, onBack }) {
  const tiles = [
    { key: "scanner", title: "Scanner", emoji: "", blurb: "Snap bud or label for AI match" },
    { key: "history", title: "Scan History", emoji: "", blurb: "Revisit past scans & results" },
    { key: "strains", title: "Strain Browser", emoji: "hero", blurb: "Explore 35k+ strains" },
    { key: "dispensaries", title: "Dispensaries", emoji: "", blurb: "Find nearby shops" },
    { key: "seeds", title: "Seeds", emoji: "", blurb: "Where to buy seed packs" },
    { key: "grow-coach", title: "Grow Coach", emoji: "", blurb: "Stepbystep grow guide" },
    { key: "groups", title: "Groups & Chat", emoji: "", blurb: "Talk with the community" },
    { key: "friends", title: "Friends", emoji: "", blurb: "Add friends and connect" },
    { key: "growers", title: "Grower Directory", emoji: "", blurb: "Discover local growers" },
    { key: "membership", nav: "membership-join", title: "Membership", emoji: "", blurb: "Unlimited scans & more" },
    { key: "feedback", title: "Feedback", emoji: "", blurb: "Send us ideas & issues" }
  ];
  const GlassTile = ({ title, emoji, onClick }) => /* @__PURE__ */ React.createElement(
    ButtonBase,
    {
      disableRipple: true,
      onClick,
      sx: {
        position: "relative",
        borderRadius: 3,
        p: 0.5,
        // Little buttons
        minHeight: { xs: 72, sm: 84 },
        aspectRatio: "1 / 1",
        width: "100%",
        textAlign: "center",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        gap: 1,
        // Single-layer, highly see-through glass
        background: "rgba(20, 40, 30, 0.10)",
        border: "1px solid rgba(124,179,66,0.14)",
        backdropFilter: "blur(3px)",
        boxShadow: "0 1px 8px rgba(0,0,0,0.10)",
        color: "white",
        transition: "all 200ms cubic-bezier(0.4, 0, 0.2, 1)",
        outline: "none",
        "&:focus-visible": { outline: "none", boxShadow: "none" },
        "&:hover": {
          transform: "none",
          background: "rgba(24, 52, 38, 0.12)",
          borderColor: "rgba(124,179,66,0.18)",
          boxShadow: "0 2px 10px rgba(0,0,0,0.12)"
        }
      }
    },
    emoji === "hero" ? /* @__PURE__ */ React.createElement(Box, { component: "img", src: "/hero.png?v=13", alt: "", sx: {
      width: { xs: 20, sm: 22 },
      height: { xs: 20, sm: 22 },
      filter: "drop-shadow(0 2px 4px rgba(0,0,0,0.2)) drop-shadow(0 0 4px rgba(124, 179, 66, 0.6))"
    } }) : /* @__PURE__ */ React.createElement(Box, { sx: {
      fontSize: { xs: 20, sm: 22 },
      lineHeight: 1,
      filter: "drop-shadow(0 2px 4px rgba(0,0,0,0.2))"
    }, "aria-hidden": true }, emoji),
    /* @__PURE__ */ React.createElement(
      Typography,
      {
        variant: "subtitle2",
        sx: {
          fontWeight: 700,
          lineHeight: 1.3,
          fontSize: { xs: "0.70rem", sm: "0.80rem" },
          textShadow: "0 1px 2px rgba(0,0,0,0.25), 0 0 12px rgba(124,179,66,0.15)",
          maxWidth: "90%"
        }
      },
      title
    ),
    /* @__PURE__ */ React.createElement(Box, { sx: { position: "absolute", bottom: 8, left: 8, opacity: 0.08 }, "aria-hidden": true }, /* @__PURE__ */ React.createElement(CannabisLeafIcon, null))
  );
  return /* @__PURE__ */ React.createElement(Box, { sx: { minHeight: "100vh" } }, /* @__PURE__ */ React.createElement(Container, { maxWidth: "lg", sx: { py: 4 } }, /* @__PURE__ */ React.createElement(Stack, { spacing: 3 }, onBack && /* @__PURE__ */ React.createElement(Button, { onClick: onBack, size: "small", variant: "contained", sx: { bgcolor: "white", color: "black", textTransform: "none", fontWeight: 700, alignSelf: "flex-start", borderRadius: 999, "&:hover": { bgcolor: "grey.100" } } }, "Home"), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1, alignItems: "center" }, /* @__PURE__ */ React.createElement(CannabisLeafIcon, null), /* @__PURE__ */ React.createElement(Typography, { variant: "h4", fontWeight: "bold", color: "primary.light" }, "Help & How-To")), /* @__PURE__ */ React.createElement(
    Box,
    {
      sx: {
        display: "grid",
        gap: 2,
        gridTemplateColumns: {
          xs: "repeat(2, minmax(0, 1fr))",
          sm: "repeat(3, minmax(0, 1fr))",
          md: "repeat(4, minmax(0, 1fr))"
        }
      }
    },
    tiles.map((t) => /* @__PURE__ */ React.createElement(
      GlassTile,
      {
        key: t.key,
        title: t.title,
        emoji: t.emoji,
        onClick: () => onNavigate == null ? void 0 : onNavigate(t.nav || t.key)
      }
    ))
  ), /* @__PURE__ */ React.createElement(Card, { sx: { background: "rgba(255,255,255,0.05)", border: "1px solid rgba(255,255,255,0.15)", backdropFilter: "blur(6px)" } }, /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", gutterBottom: true }, "Getting Started"), /* @__PURE__ */ React.createElement(Stack, { spacing: 1 }, /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, /* @__PURE__ */ React.createElement("strong", null, "1. Create an Account:"), " Tap the Account tile to sign up with email and password."), /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, /* @__PURE__ */ React.createElement("strong", null, "2. Enable Location:"), " Allow location access for nearby dispensaries and grower directory."), /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, /* @__PURE__ */ React.createElement("strong", null, "3. Start Scanning:"), " Tap the Scanner tile and take a photo of your cannabis to identify the strain."), /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, /* @__PURE__ */ React.createElement("strong", null, "4. Join the Community:"), " Use Groups & Chat to connect with other cannabis enthusiasts."), /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, /* @__PURE__ */ React.createElement("strong", null, "5. Upgrade to Premium:"), " Get unlimited scans, exclusive features, and support the app.")))), /* @__PURE__ */ React.createElement(Card, { sx: { background: "rgba(255,255,255,0.05)", border: "1px solid rgba(255,255,255,0.15)", backdropFilter: "blur(6px)" } }, /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", gutterBottom: true }, "Scanning tips"), /* @__PURE__ */ React.createElement(Stack, { spacing: 1 }, /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, " Frame the whole bud inside the guide. Avoid extreme macro."), /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, " Even lighting. Avoid glare and deep shadows."), /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, " Include the label or strain name when possible."), /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, " Try 23 angles of the same bud for richer features.")))), /* @__PURE__ */ React.createElement(Card, { sx: { background: "rgba(255,255,255,0.05)", border: "1px solid rgba(255,255,255,0.15)", backdropFilter: "blur(6px)" } }, /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", gutterBottom: true }, "Common issues"), /* @__PURE__ */ React.createElement(Stack, { spacing: 1 }, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2" }, "No match or low confidence"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, "Retake with better lighting and framing; include text if available."), /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", sx: { mt: 1 } }, "Upload error"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, "Check connectivity and retry. Service may be briefly busy."), /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", sx: { mt: 1 } }, "Stuck on processing"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, "Close and retry the scan. If repeated, wait a minute and try again.")))), /* @__PURE__ */ React.createElement(Alert, { severity: "info" }, "Questions or suggestions? Use the Feedback tile to send us a message."), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", color: "text.secondary" }, "For privacy, login isnt required. Select scans may be used to improve the service."))));
}
const useState$9 = window["React"].useState;
const useEffect$9 = window["React"].useEffect;
const useCallback$1 = window["React"].useCallback;
function Friends({ userId = "demo-user", onBack }) {
  const [tab, setTab] = useState$9(0);
  const [friends, setFriends] = useState$9([]);
  const [sent, setSent] = useState$9([]);
  const [received, setReceived] = useState$9([]);
  const [loading, setLoading] = useState$9(true);
  const [error, setError] = useState$9(null);
  const [friendUsername, setFriendUsername] = useState$9("");
  const fetchFriends = useCallback$1(() => __async(null, null, function* () {
    setLoading(true);
    setError(null);
    try {
      const res = yield fetch(`${API_BASE}/api/friends?user_id=${userId}`);
      if (!res.ok) {
        const errData = yield res.json().catch(() => ({}));
        throw new Error(errData.error || "Failed to load friends");
      }
      const data = yield res.json();
      setFriends(data.friends || []);
      setSent(data.sent || []);
      setReceived(data.received || []);
      setError(null);
    } catch (e) {
      console.error("Friends fetch error:", e);
      setError(e.message);
      setFriends([]);
      setSent([]);
      setReceived([]);
    } finally {
      setLoading(false);
    }
  }), [userId]);
  useEffect$9(() => {
    fetchFriends();
  }, [fetchFriends]);
  const sendRequest = () => __async(null, null, function* () {
    if (!friendUsername.trim()) return;
    try {
      const res = yield fetch(`${API_BASE}/api/friends/request`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ user_id: userId, friend_id: "friend-user-id" })
        // Replace with actual lookup
      });
      if (!res.ok) {
        const err = yield res.json();
        throw new Error(err.error || "Failed to send request");
      }
      setFriendUsername("");
      fetchFriends();
    } catch (e) {
      setError(e.message);
    }
  });
  const acceptRequest = (friendshipId) => __async(null, null, function* () {
    try {
      const res = yield fetch(`${API_BASE}/api/friends/accept`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ friendship_id: friendshipId })
      });
      if (!res.ok) throw new Error("Failed to accept");
      fetchFriends();
    } catch (e) {
      setError(e.message);
    }
  });
  const rejectRequest = (friendshipId) => __async(null, null, function* () {
    try {
      const res = yield fetch(`${API_BASE}/api/friends/reject`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ friendship_id: friendshipId })
      });
      if (!res.ok) throw new Error("Failed to reject");
      fetchFriends();
    } catch (e) {
      setError(e.message);
    }
  });
  const removeFriend = (friendshipId) => __async(null, null, function* () {
    try {
      const res = yield fetch(`${API_BASE}/api/friends/${friendshipId}`, { method: "DELETE" });
      if (!res.ok) throw new Error("Failed to remove");
      fetchFriends();
    } catch (e) {
      setError(e.message);
    }
  });
  return /* @__PURE__ */ React.createElement(Box, { sx: { minHeight: "100vh" } }, /* @__PURE__ */ React.createElement(Container, { maxWidth: "md", sx: { py: 4 } }, onBack && /* @__PURE__ */ React.createElement(Button, { onClick: onBack, size: "small", variant: "contained", sx: { bgcolor: "white", color: "black", textTransform: "none", fontWeight: 700, borderRadius: 999, mb: 1, "&:hover": { bgcolor: "grey.100" } } }, "Home"), /* @__PURE__ */ React.createElement(Typography, { variant: "h4", gutterBottom: true }, "Friends"), error && /* @__PURE__ */ React.createElement(Alert, { severity: "error", sx: { mb: 2 } }, error), /* @__PURE__ */ React.createElement(Card, { sx: { mb: 3 } }, /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", gutterBottom: true }, "Add Friend"), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 2 }, /* @__PURE__ */ React.createElement(
    TextField,
    {
      placeholder: "Enter username",
      value: friendUsername,
      onChange: (e) => setFriendUsername(e.target.value),
      fullWidth: true
    }
  ), /* @__PURE__ */ React.createElement(Button, { variant: "contained", onClick: sendRequest }, "Send Request")))), /* @__PURE__ */ React.createElement(Tabs, { value: tab, onChange: (_, v) => setTab(v), sx: { mb: 2 } }, /* @__PURE__ */ React.createElement(Tab, { label: `Friends (${friends.length})` }), /* @__PURE__ */ React.createElement(Tab, { label: `Requests (${received.length})` }), /* @__PURE__ */ React.createElement(Tab, { label: `Sent (${sent.length})` })), loading ? /* @__PURE__ */ React.createElement(CircularProgress, null) : /* @__PURE__ */ React.createElement(React.Fragment, null, tab === 0 && /* @__PURE__ */ React.createElement(List$1, null, friends.length === 0 ? /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, "No friends yet") : friends.map((f) => {
    var _a2;
    const friend = f.user_id === userId ? f.friend : f.users;
    return /* @__PURE__ */ React.createElement(ListItem, { key: f.id }, /* @__PURE__ */ React.createElement(ListItemAvatar, null, /* @__PURE__ */ React.createElement(Avatar$1, { src: friend == null ? void 0 : friend.avatar_url }, ((_a2 = friend == null ? void 0 : friend.username) == null ? void 0 : _a2[0]) || "?")), /* @__PURE__ */ React.createElement(ListItemText, { primary: (friend == null ? void 0 : friend.username) || "Unknown", secondary: `Friends since ${new Date(f.accepted_at).toLocaleDateString()}` }), /* @__PURE__ */ React.createElement(Button, { size: "small", color: "error", onClick: () => removeFriend(f.id) }, "Remove"));
  })), tab === 1 && /* @__PURE__ */ React.createElement(List$1, null, received.length === 0 ? /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, "No pending requests") : received.map((r2) => {
    var _a2, _b, _c, _d;
    return /* @__PURE__ */ React.createElement(ListItem, { key: r2.id }, /* @__PURE__ */ React.createElement(ListItemAvatar, null, /* @__PURE__ */ React.createElement(Avatar$1, { src: (_a2 = r2.users) == null ? void 0 : _a2.avatar_url }, ((_c = (_b = r2.users) == null ? void 0 : _b.username) == null ? void 0 : _c[0]) || "?")), /* @__PURE__ */ React.createElement(ListItemText, { primary: ((_d = r2.users) == null ? void 0 : _d.username) || "Unknown", secondary: `Requested ${new Date(r2.requested_at).toLocaleDateString()}` }), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1 }, /* @__PURE__ */ React.createElement(Button, { size: "small", variant: "contained", onClick: () => acceptRequest(r2.id) }, "Accept"), /* @__PURE__ */ React.createElement(Button, { size: "small", variant: "outlined", onClick: () => rejectRequest(r2.id) }, "Reject")));
  })), tab === 2 && /* @__PURE__ */ React.createElement(List$1, null, sent.length === 0 ? /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, "No sent requests") : sent.map((s) => {
    var _a2, _b, _c, _d;
    return /* @__PURE__ */ React.createElement(ListItem, { key: s.id }, /* @__PURE__ */ React.createElement(ListItemAvatar, null, /* @__PURE__ */ React.createElement(Avatar$1, { src: (_a2 = s.friend) == null ? void 0 : _a2.avatar_url }, ((_c = (_b = s.friend) == null ? void 0 : _b.username) == null ? void 0 : _c[0]) || "?")), /* @__PURE__ */ React.createElement(ListItemText, { primary: ((_d = s.friend) == null ? void 0 : _d.username) || "Unknown", secondary: `Sent ${new Date(s.requested_at).toLocaleDateString()}` }), /* @__PURE__ */ React.createElement(Chip, { label: "Pending", size: "small" }));
  })))));
}
const useState$8 = window["React"].useState;
const useEffect$8 = window["React"].useEffect;
const useCallback = window["React"].useCallback;
function MembershipJoin() {
  const [strainStats, setStrainStats] = useState$8({ count: null, lastUpdated: null });
  useEffect$8(() => {
    (() => __async(null, null, function* () {
      try {
        const [countRes, updatedRes] = yield Promise.all([
          fetch(`${API_BASE}/api/strains/count`),
          fetch(`${API_BASE}/api/strains/last-updated`)
        ]);
        const countData = yield countRes.json();
        const updatedData = yield updatedRes.json();
        setStrainStats({
          count: countData.count,
          lastUpdated: updatedData.lastUpdated ? new Date(updatedData.lastUpdated) : null
        });
      } catch (e) {
      }
    }))();
  }, []);
  const [showLogin, setShowLogin] = useState$8(false);
  const [loginEmail, setLoginEmail] = useState$8("");
  const [loginPassword, setLoginPassword] = useState$8("");
  const [loginError, setLoginError] = useState$8(null);
  const [user, setUser] = useState$8(null);
  const [status, setStatus] = useState$8(null);
  const [loading, setLoading] = useState$8(true);
  const [applying, setApplying] = useState$8(false);
  const [showForm, setShowForm] = useState$8(false);
  const [formData, setFormData] = useState$8({
    email: "",
    full_name: "",
    phone: "",
    message: ""
  });
  const [error, setError] = useState$8(null);
  const [success, setSuccess] = useState$8(null);
  const getSessionId = useCallback(() => {
    let sid = localStorage.getItem("ss-session-id");
    if (!sid) {
      sid = `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      localStorage.setItem("ss-session-id", sid);
    }
    return sid;
  }, []);
  const loadStatus = useCallback(() => __async(null, null, function* () {
    try {
      const res = yield fetch(`${API_BASE}/api/membership/status`, {
        headers: { "x-session-id": getSessionId() }
      });
      if (res.ok) {
        setStatus(yield res.json());
      }
    } catch (e) {
      console.error("Failed to load status:", e);
    } finally {
      setLoading(false);
    }
  }), [getSessionId]);
  useEffect$8(() => {
    loadStatus();
  }, [loadStatus]);
  const handleLogin = () => __async(null, null, function* () {
    setLoginError(null);
    if (!loginEmail || !loginPassword) {
      setLoginError("Please enter both email and password.");
      return;
    }
    try {
      const { error: error2 } = yield supabase.auth.signInWithPassword({ email: loginEmail, password: loginPassword });
      if (error2) {
        setLoginError(error2.message);
        return;
      }
      setShowLogin(false);
    } catch (error2) {
      console.error("Supabase login failed:", error2);
      setLoginError("Login failed. Please try again.");
    }
  });
  useEffect$8(() => {
    let listener;
    const getSession = () => __async(null, null, function* () {
      var _a2, _b, _c, _d;
      const sessionObj = yield (_b = (_a2 = supabase.auth).getSession) == null ? void 0 : _b.call(_a2);
      if ((_d = (_c = sessionObj == null ? void 0 : sessionObj.data) == null ? void 0 : _c.session) == null ? void 0 : _d.user) setUser(sessionObj.data.session.user);
    });
    getSession();
    listener = supabase.auth.onAuthStateChange((_event, session) => {
      setUser((session == null ? void 0 : session.user) || null);
    });
    return () => {
      var _a2;
      ((_a2 = listener == null ? void 0 : listener.data) == null ? void 0 : _a2.unsubscribe) && listener.data.unsubscribe();
    };
  }, []);
  if (user) {
    return /* @__PURE__ */ React.createElement(Container, { maxWidth: "md", sx: { py: 4 } }, /* @__PURE__ */ React.createElement(
      Button,
      {
        onClick: () => window.location.href = "/",
        variant: "contained",
        sx: { position: "absolute", top: 16, left: 16, bgcolor: "#388e3c", color: "white", fontWeight: 700, borderRadius: 999, boxShadow: "0 2px 8px 0 rgba(46,125,50,0.18)", zIndex: 10, textTransform: "none", px: 3, py: 1 }
      },
      "Home"
    ), /* @__PURE__ */ React.createElement(Box, { sx: { mt: 8, textAlign: "center" } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h4", sx: { fontWeight: 700, color: "#2e7d32", mb: 2 } }, "Welcome, ", user.email, "!"), /* @__PURE__ */ React.createElement(Typography, { variant: "body1", sx: { color: "#388e3c", mb: 2 } }, "You are now logged in and have full access to all features."), /* @__PURE__ */ React.createElement(Button, { variant: "contained", color: "error", sx: { borderRadius: 999, px: 4, py: 1, fontWeight: 600 }, onClick: () => __async(null, null, function* () {
      yield supabase.auth.signOut();
      setUser(null);
    }) }, "Logout")));
  }
  const handleSubmit = (e) => __async(null, null, function* () {
    e.preventDefault();
    setError(null);
    setSuccess(null);
    setApplying(true);
    try {
      const res = yield fetch(`${API_BASE}/api/membership/apply`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData)
      });
      const data = yield res.json();
      if (!res.ok) {
        setError(data.error || "Application failed");
        return;
      }
      setSuccess("Application submitted! We will review and be in touch via email within 24-48 hours. Thank you!");
      setShowForm(false);
      setFormData({ email: "", full_name: "", phone: "", message: "" });
    } catch (e2) {
      console.error("Membership apply error:", e2);
      setError("Network error. Please check your connection and try again.");
    } finally {
      setApplying(false);
    }
  });
  if (loading) {
    return /* @__PURE__ */ React.createElement(Container, { maxWidth: "md", sx: { py: 4 } }, /* @__PURE__ */ React.createElement(LinearProgress, null));
  }
  return /* @__PURE__ */ React.createElement(Container, { maxWidth: "md", sx: { py: 4, position: "relative" } }, /* @__PURE__ */ React.createElement(
    Button,
    {
      onClick: () => window.location.href = "/",
      variant: "contained",
      sx: {
        position: "absolute",
        top: 16,
        left: 16,
        bgcolor: "#388e3c",
        color: "white",
        fontWeight: 700,
        borderRadius: 999,
        boxShadow: "0 2px 8px 0 rgba(46,125,50,0.18)",
        zIndex: 10,
        textTransform: "none",
        px: 3,
        py: 1
      }
    },
    "Home"
  ), /* @__PURE__ */ React.createElement(Box, { sx: { mb: 2, display: "flex", justifyContent: "center", alignItems: "center", flexDirection: "column", opacity: 0.95 } }, strainStats.count !== null && /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { fontWeight: 600, color: "#388e3c", textAlign: "center", fontSize: "1rem", mb: 0.5 } }, "Over ", /* @__PURE__ */ React.createElement("span", { style: { fontWeight: 800 } }, strainStats.count.toLocaleString()), " strains in our database"), strainStats.lastUpdated && /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "#388e3c", textAlign: "center" } }, "Updated ", strainStats.lastUpdated.toLocaleDateString(void 0, { month: "short", day: "numeric", year: "numeric" }))), /* @__PURE__ */ React.createElement(Typography, { variant: "h4", sx: { mb: 3, fontWeight: 700, color: "#2e7d32", textShadow: "0 2px 12px rgba(46,125,50,0.2)" } }, "Welcome to StrainSpotter Membership"), (status == null ? void 0 : status.isMember) ? /* @__PURE__ */ React.createElement(Box, { sx: {
    mt: 3,
    p: 4,
    borderRadius: 4,
    background: "rgba(255,255,255,0.15)",
    boxShadow: "0 8px 32px 0 rgba(46,125,50,0.25)",
    backdropFilter: "blur(12px)",
    border: "1px solid rgba(56,142,60,0.25)",
    color: "#2e7d32",
    fontWeight: 600
  } }, "You're an active member! Enjoy unlimited access to all features.") : /* @__PURE__ */ React.createElement(Card, { sx: {
    mb: 3,
    borderRadius: 4,
    background: "rgba(255,255,255,0.10)",
    boxShadow: "0 8px 32px 0 rgba(46,125,50,0.18)",
    backdropFilter: "blur(10px)",
    border: "1px solid rgba(56,142,60,0.18)",
    color: "#388e3c"
  } }, /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { mb: 2, color: "#388e3c" } }, "Basic Access"), /* @__PURE__ */ React.createElement(Box, { sx: {
    background: "rgba(255,255,255,0.10)",
    borderRadius: 2,
    p: 2,
    color: "#388e3c",
    fontWeight: 500,
    boxShadow: "0 2px 8px 0 rgba(46,125,50,0.10)",
    border: "1px solid rgba(56,142,60,0.10)"
  } }, "You have access to the scanner and results.", /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("strong", null, "Unlock Full Access:"), " ", /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("ul", { style: { margin: "8px 0 0 16px", color: "#388e3c" } }, /* @__PURE__ */ React.createElement("li", null, "Sign up for membership to enjoy exclusive strain data, grow guides, chat/groups, dispensary/grower access, and more.")), /* @__PURE__ */ React.createElement(Button, { variant: "contained", sx: { mt: 2, bgcolor: "#388e3c", color: "white", fontWeight: 700, borderRadius: 2, boxShadow: "0 2px 8px 0 rgba(46,125,50,0.18)" }, onClick: () => setShowForm(true) }, "Join Now"), /* @__PURE__ */ React.createElement(Button, { variant: "outlined", sx: { mt: 2, ml: 2, borderRadius: 2, fontWeight: 700 }, onClick: () => setShowLogin(true) }, "Login to Unlock Full Access")))), /* @__PURE__ */ React.createElement(Dialog, { open: showLogin, onClose: () => setShowLogin(false) }, /* @__PURE__ */ React.createElement(DialogTitle, null, "Login"), /* @__PURE__ */ React.createElement(DialogContent, null, /* @__PURE__ */ React.createElement(Stack, { spacing: 2, sx: { pt: 1 } }, /* @__PURE__ */ React.createElement(Button, { variant: "contained", color: "primary", sx: { borderRadius: 999, px: 4, py: 1, fontWeight: 600 }, onClick: () => __async(null, null, function* () {
    const { error: error2 } = yield supabase.auth.signInWithOAuth({ provider: "google" });
    if (error2) setLoginError("Google login failed: " + error2.message);
  }) }, "Login with Google"), /* @__PURE__ */ React.createElement(Button, { variant: "contained", color: "secondary", sx: { borderRadius: 999, px: 4, py: 1, fontWeight: 600 }, onClick: () => __async(null, null, function* () {
    const { error: error2 } = yield supabase.auth.signInWithOAuth({ provider: "apple" });
    if (error2) setLoginError("Apple login failed: " + error2.message);
  }) }, "Login with Apple"), /* @__PURE__ */ React.createElement("form", { onSubmit: (e) => {
    e.preventDefault();
    handleLogin();
  } }, /* @__PURE__ */ React.createElement(
    TextField,
    {
      label: "Email",
      type: "email",
      value: loginEmail,
      onChange: (e) => setLoginEmail(e.target.value),
      fullWidth: true,
      autoFocus: true,
      sx: { mt: 1 },
      required: true
    }
  ), /* @__PURE__ */ React.createElement(
    TextField,
    {
      label: "Password",
      type: "password",
      value: loginPassword,
      onChange: (e) => setLoginPassword(e.target.value),
      fullWidth: true,
      sx: { mt: 2 },
      required: true
    }
  ), /* @__PURE__ */ React.createElement(Button, { type: "submit", variant: "outlined", sx: { mt: 2, borderRadius: 999, px: 3, py: 1, fontWeight: 600 } }, "Login with Email")), loginError && /* @__PURE__ */ React.createElement(Alert, { severity: "error", sx: { mt: 2 } }, loginError))), /* @__PURE__ */ React.createElement(DialogActions, null, /* @__PURE__ */ React.createElement(Button, { onClick: () => setShowLogin(false) }, "Cancel"))), error && /* @__PURE__ */ React.createElement(Alert, { severity: "error", sx: { mt: 2 }, onClose: () => setError(null) }, error), success && /* @__PURE__ */ React.createElement(Alert, { severity: "success", sx: { mt: 2 }, onClose: () => setSuccess(null) }, success), /* @__PURE__ */ React.createElement(Dialog, { open: showForm, onClose: () => setShowForm(false), maxWidth: "sm", fullWidth: true }, /* @__PURE__ */ React.createElement("form", { onSubmit: handleSubmit }, /* @__PURE__ */ React.createElement(DialogTitle, null, "Membership Application"), /* @__PURE__ */ React.createElement(DialogContent, null, /* @__PURE__ */ React.createElement(Stack, { spacing: 2, sx: { pt: 1 } }, /* @__PURE__ */ React.createElement(
    TextField,
    {
      label: "Email",
      type: "email",
      required: true,
      fullWidth: true,
      value: formData.email,
      onChange: (e) => setFormData(__spreadProps(__spreadValues({}, formData), { email: e.target.value }))
    }
  ), /* @__PURE__ */ React.createElement(
    TextField,
    {
      label: "Full Name",
      required: true,
      fullWidth: true,
      value: formData.full_name,
      onChange: (e) => setFormData(__spreadProps(__spreadValues({}, formData), { full_name: e.target.value }))
    }
  ), /* @__PURE__ */ React.createElement(
    TextField,
    {
      label: "Phone (optional)",
      fullWidth: true,
      value: formData.phone,
      onChange: (e) => setFormData(__spreadProps(__spreadValues({}, formData), { phone: e.target.value }))
    }
  ), /* @__PURE__ */ React.createElement(
    TextField,
    {
      label: "Message (optional)",
      multiline: true,
      rows: 3,
      fullWidth: true,
      value: formData.message,
      onChange: (e) => setFormData(__spreadProps(__spreadValues({}, formData), { message: e.target.value })),
      placeholder: "Tell us why you want to join..."
    }
  ), /* @__PURE__ */ React.createElement(Alert, { severity: "info" }, "After submitting, our team will review your application and contact you with payment instructions."))), /* @__PURE__ */ React.createElement(DialogActions, null, /* @__PURE__ */ React.createElement(Button, { onClick: () => setShowForm(false), disabled: applying }, "Cancel"), /* @__PURE__ */ React.createElement(Button, { type: "submit", variant: "contained", disabled: applying }, applying ? "Submitting..." : "Submit Application")))));
}
const useState$7 = window["React"].useState;
function MembershipAdmin({ onBack }) {
  const [tab, setTab] = useState$7(0);
  const [applications, setApplications] = useState$7([]);
  const [members, setMembers] = useState$7([]);
  const [loading, setLoading] = useState$7(true);
  const [selectedApp, setSelectedApp] = useState$7(null);
  const [approveDialog, setApproveDialog] = useState$7(false);
  const [approveData, setApproveData] = useState$7({
    payment_received: false,
    payment_amount: "",
    payment_reference: "",
    tier: "full",
    expires_at: ""
  });
  const loadData = () => __async(null, null, function* () {
    setLoading(true);
    try {
      if (tab === 0) {
        const res = yield fetch(`${API_BASE}/api/membership/applications`);
        if (res.ok) setApplications(yield res.json().then((d) => d.applications));
      } else {
        const res = yield fetch(`${API_BASE}/api/membership/members`);
        if (res.ok) setMembers(yield res.json().then((d) => d.members));
      }
    } catch (e) {
      console.error("Failed to load:", e);
    } finally {
      setLoading(false);
    }
  });
  const handleApprove = () => __async(null, null, function* () {
    if (!selectedApp) return;
    try {
      const res = yield fetch(`${API_BASE}/api/membership/applications/${selectedApp.id}/approve`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(approveData)
      });
      if (res.ok) {
        setApproveDialog(false);
        setSelectedApp(null);
        loadData();
      }
    } catch (e) {
      console.error("Failed to approve:", e);
    }
  });
  const getStatusColor = (status) => {
    switch (status) {
      case "pending":
        return "warning";
      case "active":
        return "success";
      case "approved":
        return "success";
      case "rejected":
        return "error";
      case "expired":
        return "default";
      case "cancelled":
        return "error";
      default:
        return "default";
    }
  };
  return /* @__PURE__ */ React.createElement(Container, { maxWidth: "lg", sx: { py: 4 } }, onBack && /* @__PURE__ */ React.createElement(Button, { onClick: onBack, size: "small", variant: "contained", sx: { bgcolor: "white", color: "black", textTransform: "none", fontWeight: 700, borderRadius: 999, mb: 1, "&:hover": { bgcolor: "grey.100" } } }, "Home"), /* @__PURE__ */ React.createElement(Typography, { variant: "h4", sx: { mb: 3, fontWeight: 700 } }, "Membership Management"), /* @__PURE__ */ React.createElement(Tabs, { value: tab, onChange: (e, v) => setTab(v), sx: { mb: 3 } }, /* @__PURE__ */ React.createElement(Tab, { label: "Applications" }), /* @__PURE__ */ React.createElement(Tab, { label: "Members" })), tab === 0 && /* @__PURE__ */ React.createElement(Card, null, /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { mb: 2 } }, "Membership Applications (", applications.length, ")"), loading ? /* @__PURE__ */ React.createElement(Typography, null, "Loading...") : applications.length === 0 ? /* @__PURE__ */ React.createElement(Alert, { severity: "info" }, "No applications yet") : /* @__PURE__ */ React.createElement(Table, null, /* @__PURE__ */ React.createElement(TableHead, null, /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, "Name"), /* @__PURE__ */ React.createElement(TableCell, null, "Email"), /* @__PURE__ */ React.createElement(TableCell, null, "Phone"), /* @__PURE__ */ React.createElement(TableCell, null, "Status"), /* @__PURE__ */ React.createElement(TableCell, null, "Submitted"), /* @__PURE__ */ React.createElement(TableCell, null, "Actions"))), /* @__PURE__ */ React.createElement(TableBody, null, applications.map((app) => /* @__PURE__ */ React.createElement(TableRow, { key: app.id }, /* @__PURE__ */ React.createElement(TableCell, null, app.full_name), /* @__PURE__ */ React.createElement(TableCell, null, app.email), /* @__PURE__ */ React.createElement(TableCell, null, app.phone || "-"), /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Chip, { label: app.status, color: getStatusColor(app.status), size: "small" })), /* @__PURE__ */ React.createElement(TableCell, null, new Date(app.created_at).toLocaleDateString()), /* @__PURE__ */ React.createElement(TableCell, null, app.status === "pending" && /* @__PURE__ */ React.createElement(
    Button,
    {
      size: "small",
      variant: "contained",
      onClick: () => {
        setSelectedApp(app);
        setApproveDialog(true);
      }
    },
    "Approve"
  )))))))), tab === 1 && /* @__PURE__ */ React.createElement(Card, null, /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { mb: 2 } }, "Active Members (", members.length, ")"), loading ? /* @__PURE__ */ React.createElement(Typography, null, "Loading...") : members.length === 0 ? /* @__PURE__ */ React.createElement(Alert, { severity: "info" }, "No members yet") : /* @__PURE__ */ React.createElement(Table, null, /* @__PURE__ */ React.createElement(TableHead, null, /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, "Name"), /* @__PURE__ */ React.createElement(TableCell, null, "Email"), /* @__PURE__ */ React.createElement(TableCell, null, "Tier"), /* @__PURE__ */ React.createElement(TableCell, null, "Status"), /* @__PURE__ */ React.createElement(TableCell, null, "Joined"), /* @__PURE__ */ React.createElement(TableCell, null, "Expires"))), /* @__PURE__ */ React.createElement(TableBody, null, members.map((member) => /* @__PURE__ */ React.createElement(TableRow, { key: member.id }, /* @__PURE__ */ React.createElement(TableCell, null, member.full_name), /* @__PURE__ */ React.createElement(TableCell, null, member.email), /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Chip, { label: member.tier, color: "primary", size: "small" })), /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Chip, { label: member.status, color: getStatusColor(member.status), size: "small" })), /* @__PURE__ */ React.createElement(TableCell, null, new Date(member.joined_at).toLocaleDateString()), /* @__PURE__ */ React.createElement(TableCell, null, member.expires_at ? new Date(member.expires_at).toLocaleDateString() : "Never"))))))), /* @__PURE__ */ React.createElement(Dialog, { open: approveDialog, onClose: () => setApproveDialog(false), maxWidth: "sm", fullWidth: true }, /* @__PURE__ */ React.createElement(DialogTitle, null, "Approve Membership"), /* @__PURE__ */ React.createElement(DialogContent, null, selectedApp && /* @__PURE__ */ React.createElement(Stack, { spacing: 2, sx: { pt: 1 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, /* @__PURE__ */ React.createElement("strong", null, "Applicant:"), " ", selectedApp.full_name, " (", selectedApp.email, ")"), /* @__PURE__ */ React.createElement(
    TextField,
    {
      label: "Payment Amount",
      type: "number",
      fullWidth: true,
      value: approveData.payment_amount,
      onChange: (e) => setApproveData(__spreadProps(__spreadValues({}, approveData), { payment_amount: e.target.value }))
    }
  ), /* @__PURE__ */ React.createElement(
    TextField,
    {
      label: "Payment Reference",
      fullWidth: true,
      value: approveData.payment_reference,
      onChange: (e) => setApproveData(__spreadProps(__spreadValues({}, approveData), { payment_reference: e.target.value }))
    }
  ), /* @__PURE__ */ React.createElement(
    TextField,
    {
      label: "Tier",
      select: true,
      fullWidth: true,
      value: approveData.tier,
      onChange: (e) => setApproveData(__spreadProps(__spreadValues({}, approveData), { tier: e.target.value })),
      SelectProps: { native: true }
    },
    /* @__PURE__ */ React.createElement("option", { value: "full" }, "Full"),
    /* @__PURE__ */ React.createElement("option", { value: "premium" }, "Premium")
  ), /* @__PURE__ */ React.createElement(
    TextField,
    {
      label: "Expires At (optional)",
      type: "date",
      fullWidth: true,
      value: approveData.expires_at,
      onChange: (e) => setApproveData(__spreadProps(__spreadValues({}, approveData), { expires_at: e.target.value })),
      InputLabelProps: { shrink: true }
    }
  ))), /* @__PURE__ */ React.createElement(DialogActions, null, /* @__PURE__ */ React.createElement(Button, { onClick: () => setApproveDialog(false) }, "Cancel"), /* @__PURE__ */ React.createElement(Button, { onClick: handleApprove, variant: "contained" }, "Approve & Create Membership"))));
}
const useEffect$7 = window["React"].useEffect;
const useState$6 = window["React"].useState;
function PipelineStatus({ onBack }) {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
  const [latest, setLatest] = useState$6(null);
  const [history2, setHistory] = useState$6([]);
  const [loading, setLoading] = useState$6(true);
  const [error, setError] = useState$6(null);
  useEffect$7(() => {
    const load = () => __async(null, null, function* () {
      try {
        setLoading(true);
        const [l, h] = yield Promise.all([
          fetch(`${API_BASE}/api/pipeline/latest`).then((r2) => r2.json()),
          fetch(`${API_BASE}/api/pipeline/history`).then((r2) => r2.json())
        ]);
        setLatest(l);
        setHistory(Array.isArray(h) ? h : [h].filter(Boolean));
      } catch (e) {
        console.error("[Pipeline] load error", e);
        setError("Could not load pipeline status");
      } finally {
        setLoading(false);
      }
    });
    load();
  }, []);
  return /* @__PURE__ */ React.createElement(Box, { sx: { maxWidth: 1e3, mx: "auto", p: 2 } }, onBack && /* @__PURE__ */ React.createElement(Button, { onClick: onBack, size: "small", variant: "contained", sx: { bgcolor: "white", color: "black", textTransform: "none", fontWeight: 700, borderRadius: 999, mb: 1, "&:hover": { bgcolor: "grey.100" } } }, "Home"), /* @__PURE__ */ React.createElement(Typography, { variant: "h4", sx: { fontWeight: 800, mb: 1 } }, "Data Pipeline"), /* @__PURE__ */ React.createElement(Typography, { variant: "body1", sx: { color: "text.secondary", mb: 2 } }, "Schedule: Daily at 3:00 AM UTC via GitHub Actions."), loading && /* @__PURE__ */ React.createElement(LinearProgress, null), error && /* @__PURE__ */ React.createElement(Typography, { color: "error", sx: { mb: 2 } }, error), latest && /* @__PURE__ */ React.createElement(Card, { sx: { mb: 3 } }, /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Stack, { direction: { xs: "column", sm: "row" }, spacing: 2, justifyContent: "space-between", alignItems: { xs: "flex-start", sm: "center" } }, /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { fontWeight: 700 } }, "Latest Run"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "text.secondary" } }, "Date: ", new Date(latest.date || latest.when || Date.now()).toLocaleString())), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1 }, /* @__PURE__ */ React.createElement(Chip, { label: `Strains (main): ${(_b = (_a2 = latest.totals) == null ? void 0 : _a2.strainsMain) != null ? _b : ""}`, color: "success", variant: "outlined" }), /* @__PURE__ */ React.createElement(Chip, { label: `Strains (enhanced): ${(_d = (_c = latest.totals) == null ? void 0 : _c.strainsEnhanced) != null ? _d : ""}`, color: "success", variant: "outlined" }))), /* @__PURE__ */ React.createElement(Divider, { sx: { my: 2 } }), /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle1", sx: { fontWeight: 700, mb: 1 } }, "Import Report"), /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 2, flexWrap: "wrap" }, /* @__PURE__ */ React.createElement(Chip, { label: `Attributes: ${(_g = (_f = (_e = latest.report) == null ? void 0 : _e.counts) == null ? void 0 : _f.attributes) != null ? _g : ""}` }), /* @__PURE__ */ React.createElement(Chip, { label: `CSV Rows: ${(_j = (_i = (_h = latest.report) == null ? void 0 : _h.counts) == null ? void 0 : _i.csvRows) != null ? _j : ""}` }), /* @__PURE__ */ React.createElement(Chip, { label: `Matched: ${(_m = (_l = (_k = latest.report) == null ? void 0 : _k.counts) == null ? void 0 : _l.matched) != null ? _m : ""}`, color: "primary" }), /* @__PURE__ */ React.createElement(Chip, { label: `Unmatched: ${(_p = (_o = (_n = latest.report) == null ? void 0 : _n.counts) == null ? void 0 : _o.unmatched) != null ? _p : ""}`, color: "warning" })))), /* @__PURE__ */ React.createElement(Card, null, /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { fontWeight: 700, mb: 1 } }, "Run History"), /* @__PURE__ */ React.createElement(Table, { size: "small" }, /* @__PURE__ */ React.createElement(TableHead, null, /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, "Date (UTC)"), /* @__PURE__ */ React.createElement(TableCell, { align: "right" }, "Strains (main)"), /* @__PURE__ */ React.createElement(TableCell, { align: "right" }, "Strains (enhanced)"), /* @__PURE__ */ React.createElement(TableCell, { align: "right" }, "Matched"), /* @__PURE__ */ React.createElement(TableCell, { align: "right" }, "Unmatched"))), /* @__PURE__ */ React.createElement(TableBody, null, history2.map((h, idx) => {
    var _a3, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2;
    return /* @__PURE__ */ React.createElement(TableRow, { key: idx, hover: true }, /* @__PURE__ */ React.createElement(TableCell, null, h.date_utc || (h.date ? new Date(h.date).toISOString().slice(0, 10) : "")), /* @__PURE__ */ React.createElement(TableCell, { align: "right" }, (_b2 = (_a3 = h.totals) == null ? void 0 : _a3.strainsMain) != null ? _b2 : ""), /* @__PURE__ */ React.createElement(TableCell, { align: "right" }, (_d2 = (_c2 = h.totals) == null ? void 0 : _c2.strainsEnhanced) != null ? _d2 : ""), /* @__PURE__ */ React.createElement(TableCell, { align: "right" }, (_g2 = (_f2 = (_e2 = h.report) == null ? void 0 : _e2.counts) == null ? void 0 : _f2.matched) != null ? _g2 : ""), /* @__PURE__ */ React.createElement(TableCell, { align: "right" }, (_j2 = (_i2 = (_h2 = h.report) == null ? void 0 : _h2.counts) == null ? void 0 : _i2.unmatched) != null ? _j2 : ""));
  }))))));
}
const useState$5 = window["React"].useState;
const useEffect$6 = window["React"].useEffect;
function ModerationDashboard({ onBack }) {
  var _a2;
  const [reports, setReports] = useState$5([]);
  const [stats, setStats] = useState$5(null);
  const [loading, setLoading] = useState$5(true);
  const [selectedReport, setSelectedReport] = useState$5(null);
  const [resolveDialogOpen, setResolveDialogOpen] = useState$5(false);
  const [moderatorNotes, setModeratorNotes] = useState$5("");
  const [actionType, setActionType] = useState$5("approve");
  const [error, setError] = useState$5(null);
  useEffect$6(() => {
    loadData();
  }, []);
  const loadData = () => __async(null, null, function* () {
    try {
      setLoading(true);
      const [reportsRes, statsRes] = yield Promise.all([
        fetch(`${API_BASE}/api/moderation/reports?status=pending`),
        fetch(`${API_BASE}/api/moderation/stats`)
      ]);
      if (reportsRes.ok) {
        const reportsData = yield reportsRes.json();
        setReports(reportsData.reports || []);
      }
      if (statsRes.ok) {
        const statsData = yield statsRes.json();
        setStats(statsData);
      }
    } catch (e) {
      console.error("[Moderation] Load error:", e);
      setError("Failed to load moderation data");
    } finally {
      setLoading(false);
    }
  });
  const handleResolve = () => __async(null, null, function* () {
    if (!selectedReport) return;
    try {
      setError(null);
      const res = yield fetch(`${API_BASE}/api/moderation/reports/${selectedReport.id}/resolve`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          action: actionType,
          moderator_notes: moderatorNotes
        })
      });
      if (!res.ok) {
        const errData = yield res.json();
        throw new Error(errData.error || "Failed to resolve report");
      }
      setResolveDialogOpen(false);
      setSelectedReport(null);
      setModeratorNotes("");
      loadData();
    } catch (e) {
      setError(e.message);
    }
  });
  const openResolveDialog = (report, action) => {
    setSelectedReport(report);
    setActionType(action);
    setResolveDialogOpen(true);
  };
  if (loading) {
    return /* @__PURE__ */ React.createElement(Container, { maxWidth: "lg", sx: { py: 4 } }, /* @__PURE__ */ React.createElement(LinearProgress, null));
  }
  return /* @__PURE__ */ React.createElement(Container, { maxWidth: "lg", sx: { py: 4 } }, onBack && /* @__PURE__ */ React.createElement(Button, { onClick: onBack, size: "small", variant: "contained", sx: { bgcolor: "white", color: "black", textTransform: "none", fontWeight: 700, borderRadius: 999, mb: 1, "&:hover": { bgcolor: "grey.100" } } }, "Home"), /* @__PURE__ */ React.createElement(Typography, { variant: "h4", sx: { fontWeight: 800, mb: 3 } }, "Moderation Dashboard"), error && /* @__PURE__ */ React.createElement(Alert, { severity: "error", sx: { mb: 3 }, onClose: () => setError(null) }, error), stats && /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 2, sx: { mb: 4 } }, /* @__PURE__ */ React.createElement(Card, { sx: { flex: 1 } }, /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h3", color: "warning.main", sx: { fontWeight: 700 } }, stats.pendingReports), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, "Pending Reports"))), /* @__PURE__ */ React.createElement(Card, { sx: { flex: 1 } }, /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h3", color: "success.main", sx: { fontWeight: 700 } }, stats.resolvedReports), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, "Resolved Reports"))), /* @__PURE__ */ React.createElement(Card, { sx: { flex: 1 } }, /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h3", color: "primary.main", sx: { fontWeight: 700 } }, stats.totalMessages), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, "Total Messages")))), /* @__PURE__ */ React.createElement(Card, null, /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { mb: 2, fontWeight: 700 } }, "Pending Reports"), reports.length === 0 ? /* @__PURE__ */ React.createElement(Alert, { severity: "info" }, "No pending reports. Great job!") : /* @__PURE__ */ React.createElement(TableContainer, { component: Paper, variant: "outlined" }, /* @__PURE__ */ React.createElement(Table, null, /* @__PURE__ */ React.createElement(TableHead, null, /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, "Report ID"), /* @__PURE__ */ React.createElement(TableCell, null, "Reason"), /* @__PURE__ */ React.createElement(TableCell, null, "Message Content"), /* @__PURE__ */ React.createElement(TableCell, null, "Reported"), /* @__PURE__ */ React.createElement(TableCell, { align: "right" }, "Actions"))), /* @__PURE__ */ React.createElement(TableBody, null, reports.map((report) => {
    var _a3;
    return /* @__PURE__ */ React.createElement(TableRow, { key: report.id, hover: true }, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { fontFamily: "monospace" } }, report.id.slice(0, 8), "...")), /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(
      Chip,
      {
        label: report.reason,
        size: "small",
        color: report.reason === "harassment" ? "error" : "warning"
      }
    )), /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { maxWidth: 300 }, noWrap: true }, ((_a3 = report.messages) == null ? void 0 : _a3.content) || "(message deleted)"), report.details && /* @__PURE__ */ React.createElement(Typography, { variant: "caption", color: "text.secondary", sx: { display: "block", mt: 0.5 } }, "Details: ", report.details)), /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Typography, { variant: "caption", color: "text.secondary" }, new Date(report.created_at).toLocaleString())), /* @__PURE__ */ React.createElement(TableCell, { align: "right" }, /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 1, justifyContent: "flex-end" }, /* @__PURE__ */ React.createElement(Tooltip, { title: "Approve (false positive)" }, /* @__PURE__ */ React.createElement(
      IconButton,
      {
        size: "small",
        color: "success",
        onClick: () => openResolveDialog(report, "approve")
      },
      /* @__PURE__ */ React.createElement(CheckCircleIcon, null)
    )), /* @__PURE__ */ React.createElement(Tooltip, { title: "Warn user" }, /* @__PURE__ */ React.createElement(
      IconButton,
      {
        size: "small",
        color: "warning",
        onClick: () => openResolveDialog(report, "warn")
      },
      /* @__PURE__ */ React.createElement(WarningIcon, null)
    )), /* @__PURE__ */ React.createElement(Tooltip, { title: "Remove message" }, /* @__PURE__ */ React.createElement(
      IconButton,
      {
        size: "small",
        color: "error",
        onClick: () => openResolveDialog(report, "remove")
      },
      /* @__PURE__ */ React.createElement(DeleteIcon, null)
    )))));
  })))))), /* @__PURE__ */ React.createElement(Dialog, { open: resolveDialogOpen, onClose: () => setResolveDialogOpen(false), maxWidth: "sm", fullWidth: true }, /* @__PURE__ */ React.createElement(DialogTitle, null, "Resolve Report: ", actionType === "approve" ? "Approve" : actionType === "warn" ? "Warn User" : "Remove Message"), /* @__PURE__ */ React.createElement(DialogContent, null, selectedReport && /* @__PURE__ */ React.createElement(Box, { sx: { mb: 2 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", color: "text.secondary" }, "Message Content:"), /* @__PURE__ */ React.createElement(Typography, { variant: "body1", sx: { mb: 2, p: 1, bgcolor: "grey.100", borderRadius: 1 } }, ((_a2 = selectedReport.messages) == null ? void 0 : _a2.content) || "(message deleted)"), /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", color: "text.secondary" }, "Reason: ", selectedReport.reason), selectedReport.details && /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary", sx: { mt: 1 } }, "Details: ", selectedReport.details)), /* @__PURE__ */ React.createElement(
    TextField,
    {
      label: "Moderator Notes (optional)",
      multiline: true,
      rows: 3,
      fullWidth: true,
      value: moderatorNotes,
      onChange: (e) => setModeratorNotes(e.target.value),
      placeholder: "Add any notes about this decision..."
    }
  ), actionType === "remove" && /* @__PURE__ */ React.createElement(Alert, { severity: "warning", sx: { mt: 2 } }, "This will permanently delete the message from the database.")), /* @__PURE__ */ React.createElement(DialogActions, null, /* @__PURE__ */ React.createElement(Button, { onClick: () => setResolveDialogOpen(false) }, "Cancel"), /* @__PURE__ */ React.createElement(
    Button,
    {
      onClick: handleResolve,
      variant: "contained",
      color: actionType === "remove" ? "error" : actionType === "warn" ? "warning" : "success"
    },
    actionType === "approve" ? "Approve" : actionType === "warn" ? "Warn User" : "Remove Message"
  ))));
}
function Guidelines({ onBack }) {
  return /* @__PURE__ */ React.createElement(Container, { maxWidth: "md", sx: { py: 4 } }, onBack && /* @__PURE__ */ React.createElement(Button, { onClick: onBack, size: "small", variant: "contained", sx: { bgcolor: "white", color: "black", textTransform: "none", fontWeight: 700, borderRadius: 999, mb: 1, "&:hover": { bgcolor: "grey.100" } } }, "Home"), /* @__PURE__ */ React.createElement(Typography, { variant: "h4", sx: { mb: 2, fontWeight: 700 } }, "Community Guidelines"), /* @__PURE__ */ React.createElement(Typography, { variant: "body1", sx: { mb: 3 } }, "These rules keep conversations helpful, safe, and legal. By participating in Groups & Chat, you agree to follow them."), /* @__PURE__ */ React.createElement(Stack, { spacing: 3 }, /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { fontWeight: 700, mb: 1 } }, "Be respectful"), /* @__PURE__ */ React.createElement(List$1, { dense: true }, /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(ListItemText, { primary: "No harassment, bullying, slurs, hate speech, or threats." })), /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(ListItemText, { primary: "Debate ideas, not people. No personal attacks." })))), /* @__PURE__ */ React.createElement(Divider, null), /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { fontWeight: 700, mb: 1 } }, "Keep it legal and safe"), /* @__PURE__ */ React.createElement(List$1, { dense: true }, /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(ListItemText, { primary: "No buying, selling, trading, or soliciting cannabis, products, or services." })), /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(ListItemText, { primary: "No arranging meetups, deliveries, or shipping; dont share contact details to transact." })), /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(ListItemText, { primary: "Avoid dangerous instructions or dosing advice. Follow local laws and age rules." })))), /* @__PURE__ */ React.createElement(Divider, null), /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { fontWeight: 700, mb: 1 } }, "No spam or scams"), /* @__PURE__ */ React.createElement(List$1, { dense: true }, /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(ListItemText, { primary: "No promos, giveaways, referral/affiliate links unless approved by admins." })), /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(ListItemText, { primary: "No link shorteners or off-platform sales groups (Telegram/WhatsApp/Discord)." })), /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(ListItemText, { primary: "No repetitive, deceptive, or irrelevant content." })))), /* @__PURE__ */ React.createElement(Divider, null), /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { fontWeight: 700, mb: 1 } }, "Privacy first"), /* @__PURE__ */ React.createElement(List$1, { dense: true }, /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(ListItemText, { primary: "Dont share personal information (phone numbers, emails, addresses, IDs)." })), /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(ListItemText, { primary: "Dont pressure others to move off-platform or share private info." })))), /* @__PURE__ */ React.createElement(Divider, null), /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { fontWeight: 700, mb: 1 } }, "Quality over quantity"), /* @__PURE__ */ React.createElement(List$1, { dense: true }, /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(ListItemText, { primary: "Share real experiences and helpful questions. Be specific and honest." })), /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(ListItemText, { primary: "No medical diagnoses or claims; consult a professional." })), /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(ListItemText, { primary: "Respect copyrights; dont post content you dont own rights to." })))), /* @__PURE__ */ React.createElement(Divider, null), /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", sx: { fontWeight: 700, mb: 1 } }, "Moderation and enforcement"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { mb: 1 } }, "We use automated filtering plus community reports. Depending on severity and history, actions may include content removal, warnings, temporary timeouts, or permanent bans."), /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, "You can report content via the flag button on messages. Appeals are available by replying to moderation notices with context.")), /* @__PURE__ */ React.createElement(Divider, null), /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "caption", color: "text.secondary" }, "Health & legal: This is not medical advice. Always comply with your local laws and age requirements."))));
}
const useState$4 = window["React"].useState;
const useEffect$5 = window["React"].useEffect;
const GUIDELINES_KEY = "ss_guidelines_accepted";
function GuidelinesGate({ children }) {
  const [userId, setUserId] = useState$4(null);
  const [open, setOpen] = useState$4(false);
  const [checked, setChecked] = useState$4(false);
  const [loading, setLoading] = useState$4(true);
  useEffect$5(() => {
    var _a2;
    let sub;
    (() => __async(null, null, function* () {
      var _a3;
      try {
        if (!supabase) {
          setLoading(false);
          return;
        }
        const { data } = yield supabase.auth.getSession();
        const user = (_a3 = data == null ? void 0 : data.session) == null ? void 0 : _a3.user;
        setUserId((user == null ? void 0 : user.id) || null);
        if (user) {
          const key = `${GUIDELINES_KEY}_${user.id}`;
          const accepted = localStorage.getItem(key);
          if (accepted !== "true") {
            setOpen(true);
          }
        }
      } catch (e) {
        console.debug("GuidelinesGate: getSession failed", e);
      } finally {
        setLoading(false);
      }
    }))();
    if (supabase) {
      const listener = supabase.auth.onAuthStateChange((_e, session) => {
        const user = session == null ? void 0 : session.user;
        setUserId((user == null ? void 0 : user.id) || null);
        if (user) {
          const key = `${GUIDELINES_KEY}_${user.id}`;
          const accepted = localStorage.getItem(key);
          if (accepted !== "true") {
            setOpen(true);
          }
        } else {
          setOpen(false);
        }
      });
      sub = (_a2 = listener == null ? void 0 : listener.data) == null ? void 0 : _a2.subscription;
    }
    return () => {
      var _a3;
      return (_a3 = sub == null ? void 0 : sub.unsubscribe) == null ? void 0 : _a3.call(sub);
    };
  }, []);
  const handleAccept = () => {
    if (userId) {
      const key = `${GUIDELINES_KEY}_${userId}`;
      localStorage.setItem(key, "true");
      setOpen(false);
    }
  };
  if (loading) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, children, /* @__PURE__ */ React.createElement(
    Dialog,
    {
      open,
      disableEscapeKeyDown: true,
      maxWidth: "sm",
      fullWidth: true
    },
    /* @__PURE__ */ React.createElement(DialogTitle, { sx: { fontWeight: 700 } }, "Welcome to StrainSpotter"),
    /* @__PURE__ */ React.createElement(DialogContent, null, /* @__PURE__ */ React.createElement(Stack, { spacing: 3, sx: { mt: 1 } }, /* @__PURE__ */ React.createElement(Alert, { severity: "info" }, "Before you start, please review and accept our Community Guidelines."), /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", gutterBottom: true, sx: { fontWeight: 600 } }, "Community Guidelines"), /* @__PURE__ */ React.createElement(Stack, { spacing: 2, sx: { mt: 2 } }, /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", color: "primary.light", sx: { fontWeight: 600 } }, " Be Respectful"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, "Treat everyone with respect. No harassment, hate speech, or personal attacks.")), /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", color: "primary.light", sx: { fontWeight: 600 } }, " No Solicitations"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, "Do not sell, buy, trade, or solicit cannabis or any products. StrainSpotter is for information and community only.")), /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", color: "primary.light", sx: { fontWeight: 600 } }, " Privacy Matters"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, "Never share personal contact information (phone numbers, addresses, social media) in public spaces.")), /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", color: "primary.light", sx: { fontWeight: 600 } }, " Follow Local Laws"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, "You are responsible for knowing and following all local, state, and federal laws regarding cannabis.")), /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2", color: "primary.light", sx: { fontWeight: 600 } }, " Report Issues"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", color: "text.secondary" }, "Use the report feature if you see content that violates these guidelines.")))), /* @__PURE__ */ React.createElement(
      FormControlLabel,
      {
        control: /* @__PURE__ */ React.createElement(
          Checkbox,
          {
            checked,
            onChange: (e) => setChecked(e.target.checked),
            color: "primary"
          }
        ),
        label: /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, "I have read and agree to follow the Community Guidelines")
      }
    ))),
    /* @__PURE__ */ React.createElement(DialogActions, { sx: { p: 2 } }, /* @__PURE__ */ React.createElement(
      Button,
      {
        onClick: handleAccept,
        variant: "contained",
        disabled: !checked,
        fullWidth: true,
        size: "large"
      },
      "Accept & Continue"
    ))
  ));
}
const useState$3 = window["React"].useState;
const useEffect$4 = window["React"].useEffect;
function ErrorViewer({ onBack }) {
  const [errors, setErrors] = useState$3([]);
  const [loading, setLoading] = useState$3(true);
  const [message, setMessage] = useState$3("");
  const loadErrors = () => __async(null, null, function* () {
    setLoading(true);
    try {
      const resp = yield fetch(`${API_BASE}/api/errors/recent`);
      if (!resp.ok) {
        const text = yield resp.text();
        setMessage(text || "Failed to load errors");
        setErrors([]);
        return;
      }
      const data = yield resp.json();
      setErrors(data.errors || []);
      setMessage(data.message || "");
    } catch (e) {
      setMessage(`Connection error: ${e.message}`);
      setErrors([]);
    } finally {
      setLoading(false);
    }
  });
  useEffect$4(() => {
    loadErrors();
  }, []);
  const getStatusColor = (status) => {
    if (status >= 500) return "error";
    if (status >= 400) return "warning";
    return "default";
  };
  return /* @__PURE__ */ React.createElement(Container, { maxWidth: "lg", sx: { py: 4 } }, onBack && /* @__PURE__ */ React.createElement(Button, { onClick: onBack, size: "small", variant: "contained", sx: { bgcolor: "white", color: "black", textTransform: "none", fontWeight: 700, borderRadius: 999, mb: 1, "&:hover": { bgcolor: "grey.100" } } }, "Home"), /* @__PURE__ */ React.createElement(Stack, { direction: "row", justifyContent: "space-between", alignItems: "center", sx: { mb: 3 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "h4", fontWeight: "bold" }, " Error Logs"), /* @__PURE__ */ React.createElement(Button, { variant: "contained", onClick: loadErrors, disabled: loading }, "Refresh")), message && /* @__PURE__ */ React.createElement(Alert, { severity: "info", sx: { mb: 3 } }, message), loading ? /* @__PURE__ */ React.createElement(Typography, null, "Loading...") : errors.length === 0 ? /* @__PURE__ */ React.createElement(Alert, { severity: "success" }, " No recent errors! Everything is running smoothly.") : /* @__PURE__ */ React.createElement(Stack, { spacing: 2 }, errors.map((err, idx) => /* @__PURE__ */ React.createElement(
    Card,
    {
      key: idx,
      sx: {
        bgcolor: err.status >= 500 ? "rgba(211, 47, 47, 0.05)" : "rgba(255, 152, 0, 0.05)",
        border: `1px solid ${err.status >= 500 ? "#d32f2f44" : "#ff980044"}`
      }
    },
    /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Stack, { direction: "row", spacing: 2, alignItems: "center", sx: { mb: 2 } }, /* @__PURE__ */ React.createElement(
      Chip,
      {
        label: `${err.status}`,
        color: getStatusColor(err.status),
        size: "small"
      }
    ), /* @__PURE__ */ React.createElement(
      Chip,
      {
        label: err.method,
        variant: "outlined",
        size: "small"
      }
    ), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", color: "text.secondary" }, new Date(err.timestamp).toLocaleString()), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", color: "text.secondary", sx: { ml: "auto" } }, "User: ", err.userId)), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", fontWeight: "bold", sx: { mb: 1 } }, "Endpoint: ", /* @__PURE__ */ React.createElement("code", null, err.url)), /* @__PURE__ */ React.createElement(Typography, { variant: "body1", color: "error.main", sx: { mb: 2 } }, " ", err.error), err.stack && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Divider, { sx: { my: 2 } }), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", color: "text.secondary", sx: { mb: 1, display: "block" } }, "Stack Trace:"), /* @__PURE__ */ React.createElement(
      Box,
      {
        component: "pre",
        sx: {
          bgcolor: "rgba(0,0,0,0.05)",
          p: 2,
          borderRadius: 1,
          fontSize: "0.75rem",
          overflow: "auto",
          maxHeight: 200
        }
      },
      err.stack
    )))
  ))), /* @__PURE__ */ React.createElement(Alert, { severity: "info", sx: { mt: 4 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", fontWeight: "bold", sx: { mb: 1 } }, " How to view full logs:"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", component: "div" }, " ", /* @__PURE__ */ React.createElement("strong", null, "PM2 logs:"), " ", /* @__PURE__ */ React.createElement("code", null, "pm2 logs strainspotter-backend")), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", component: "div" }, " ", /* @__PURE__ */ React.createElement("strong", null, "PM2 errors only:"), " ", /* @__PURE__ */ React.createElement("code", null, "pm2 logs strainspotter-backend --err")), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", component: "div" }, " ", /* @__PURE__ */ React.createElement("strong", null, "PM2 flush logs:"), " ", /* @__PURE__ */ React.createElement("code", null, "pm2 flush")), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", component: "div", sx: { mt: 1 } }, " ", /* @__PURE__ */ React.createElement("strong", null, "Browser console:"), " Open DevTools (F12)  Console tab to see frontend errors")));
}
const useState$2 = window["React"].useState;
function EmergencyLogout() {
  const [loading, setLoading] = useState$2(false);
  const [message, setMessage] = useState$2("");
  const handleEmergencyLogout = () => __async(null, null, function* () {
    setLoading(true);
    setMessage("Logging out...");
    try {
      yield supabase.auth.signOut();
      setMessage(" Logged out successfully!");
      setTimeout(() => {
        window.location.href = "/";
      }, 1e3);
    } catch (error) {
      console.error("Emergency logout error:", error);
      setMessage(" Logout failed: " + error.message);
    } finally {
      setLoading(false);
    }
  });
  const handleFullReset = () => __async(null, null, function* () {
    setLoading(true);
    setMessage("Performing full reset...");
    try {
      yield supabase.auth.signOut();
      localStorage.clear();
      sessionStorage.clear();
      setMessage(" Full reset complete! Redirecting...");
      setTimeout(() => {
        window.location.href = "/";
      }, 1e3);
    } catch (error) {
      console.error("Full reset error:", error);
      setMessage(" Reset failed: " + error.message);
    } finally {
      setLoading(false);
    }
  });
  return /* @__PURE__ */ React.createElement(
    Box,
    {
      sx: {
        minHeight: "100vh",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        background: "linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%)",
        p: 2
      }
    },
    /* @__PURE__ */ React.createElement(
      Paper,
      {
        elevation: 8,
        sx: {
          p: 4,
          maxWidth: 500,
          width: "100%",
          background: "linear-gradient(135deg, rgba(255, 82, 82, 0.1) 0%, rgba(255, 107, 107, 0.1) 100%)",
          border: "2px solid #ff5252",
          borderRadius: 3
        }
      },
      /* @__PURE__ */ React.createElement(Box, { sx: { textAlign: "center", mb: 3 } }, /* @__PURE__ */ React.createElement(LogoutIcon, { sx: { fontSize: 64, color: "#ff5252", mb: 2 } }), /* @__PURE__ */ React.createElement(Typography, { variant: "h4", sx: { color: "#fff", fontWeight: 700, mb: 1 } }, "Emergency Logout"), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { color: "rgba(255, 255, 255, 0.7)", mb: 2 } }, "This will log you out immediately, bypassing all membership checks."), /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "rgba(255, 255, 255, 0.5)" } }, 'Use "Full Reset" to also clear age verification and see the age gate again.')),
      /* @__PURE__ */ React.createElement(
        Button,
        {
          variant: "contained",
          fullWidth: true,
          size: "large",
          onClick: handleEmergencyLogout,
          disabled: loading,
          startIcon: /* @__PURE__ */ React.createElement(LogoutIcon, null),
          sx: {
            bgcolor: "#ff5252",
            color: "#fff",
            fontWeight: 700,
            fontSize: "1.1rem",
            py: 1.5,
            mb: 2,
            "&:hover": {
              bgcolor: "#ff1744"
            },
            "&:disabled": {
              bgcolor: "#666",
              color: "#999"
            }
          }
        },
        loading ? "Logging Out..." : "Force Logout Now"
      ),
      /* @__PURE__ */ React.createElement(
        Button,
        {
          variant: "outlined",
          fullWidth: true,
          size: "large",
          onClick: handleFullReset,
          disabled: loading,
          sx: {
            borderColor: "#ff9800",
            color: "#ff9800",
            fontWeight: 700,
            fontSize: "1rem",
            py: 1.5,
            "&:hover": {
              borderColor: "#f57c00",
              bgcolor: "rgba(255, 152, 0, 0.1)"
            },
            "&:disabled": {
              borderColor: "#666",
              color: "#999"
            }
          }
        },
        loading ? "Resetting..." : "Full Reset (Clear Age Gate Too)"
      ),
      message && /* @__PURE__ */ React.createElement(
        Typography,
        {
          variant: "body1",
          sx: {
            mt: 3,
            p: 2,
            bgcolor: "rgba(0, 0, 0, 0.3)",
            borderRadius: 2,
            color: "#fff",
            textAlign: "center",
            fontWeight: 600
          }
        },
        message
      ),
      /* @__PURE__ */ React.createElement(Box, { sx: { mt: 3, textAlign: "center" } }, /* @__PURE__ */ React.createElement(Typography, { variant: "caption", sx: { color: "rgba(255, 255, 255, 0.5)" } }, "This is a developer tool for emergency logout situations."))
    )
  );
}
const useEffect$3 = window["React"].useEffect;
const useState$1 = window["React"].useState;
function PasswordReset({ onBack }) {
  const [newPassword, setNewPassword] = useState$1("");
  const [confirm2, setConfirm] = useState$1("");
  const [loading, setLoading] = useState$1(false);
  const [error, setError] = useState$1(null);
  const [info, setInfo] = useState$1("");
  const [ready, setReady] = useState$1(false);
  const [showPassword, setShowPassword] = useState$1(false);
  useEffect$3(() => {
    let timeout;
    let cleanup = false;
    timeout = setTimeout(() => __async(null, null, function* () {
      var _a2, _b;
      try {
        if (!supabase || !supabase.auth) {
          setError("Supabase client not initialized. Please reload the page.");
          return;
        }
        const { data, error: sessionError } = yield supabase.auth.getSession();
        console.log("[PasswordReset] Session check:", ((_b = (_a2 = data == null ? void 0 : data.session) == null ? void 0 : _a2.user) == null ? void 0 : _b.email) || "none");
        if (data == null ? void 0 : data.session) {
          setReady(true);
          setInfo("Enter a new password below to complete the reset.");
          if (!cleanup && typeof window !== "undefined") {
            setTimeout(() => {
              history.replaceState(null, "", window.location.pathname + window.location.search);
            }, 500);
          }
        } else {
          console.error("[PasswordReset] No session found:", sessionError);
          setError("Recovery link is invalid or expired. Please request a new reset email from the Sign In screen.");
        }
      } catch (err) {
        console.error("[PasswordReset] Session error:", err);
        setError("Unable to validate session. Please request a new reset link.");
      }
    }), 1500);
    return () => {
      cleanup = true;
      clearTimeout(timeout);
    };
  }, []);
  function updatePassword() {
    return __async(this, null, function* () {
      var _a2;
      if (newPassword.length < 6) {
        setError("Password must be at least 6 characters.");
        return;
      }
      if (newPassword !== confirm2) {
        setError("Passwords do not match.");
        return;
      }
      setLoading(true);
      setError(null);
      setInfo(null);
      try {
        console.log("[PasswordReset] Updating password");
        const { data, error: error2 } = yield supabase.auth.updateUser({ password: newPassword });
        if (error2) {
          console.error("[PasswordReset] Error:", error2);
          setError(error2.message);
        } else {
          console.log("[PasswordReset] Password updated successfully");
          if ((_a2 = data == null ? void 0 : data.user) == null ? void 0 : _a2.id) {
            try {
              yield fetch(`${"https://strainspotter.onrender.com"}/api/users/ensure`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ user_id: data.user.id })
              });
            } catch (err) {
              console.warn("[PasswordReset] Failed to ensure user record:", err);
            }
          }
          setInfo(" Password updated! You are now signed in. Redirecting to home...");
          setTimeout(() => {
            if (onBack) {
              onBack();
            } else {
              window.location.hash = "#/";
            }
          }, 2e3);
        }
      } catch (err) {
        console.error("[PasswordReset] Catch error:", err);
        setError("Failed to update password. Please try again.");
      } finally {
        setLoading(false);
      }
    });
  }
  function goToLogin() {
    if (onBack) {
      onBack();
      setTimeout(() => {
        window.location.hash = "#/login";
      }, 100);
    } else {
      window.location.hash = "#/login";
    }
  }
  function goHome() {
    if (onBack) {
      onBack();
    } else {
      window.location.hash = "#/";
    }
  }
  return /* @__PURE__ */ React.createElement(Box, { sx: { maxWidth: 420, mx: "auto", py: 4 } }, /* @__PURE__ */ React.createElement(
    Button,
    {
      onClick: goHome,
      size: "small",
      variant: "contained",
      sx: {
        mb: 2,
        bgcolor: "#7CB342",
        color: "white",
        textTransform: "none",
        fontWeight: 700,
        borderRadius: 999,
        "&:hover": { bgcolor: "#689f38" }
      }
    },
    " Home"
  ), /* @__PURE__ */ React.createElement(Card, null, /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Stack, { spacing: 2 }, /* @__PURE__ */ React.createElement(Typography, { variant: "h5" }, "Reset Password"), info && /* @__PURE__ */ React.createElement(Alert, { severity: "success" }, info), error && /* @__PURE__ */ React.createElement(Alert, { severity: "error" }, error), ready ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    TextField,
    {
      label: "New Password",
      type: showPassword ? "text" : "password",
      value: newPassword,
      onChange: (e) => setNewPassword(e.target.value),
      fullWidth: true,
      autoComplete: "new-password",
      helperText: /* @__PURE__ */ React.createElement(
        Button,
        {
          size: "small",
          onClick: () => setShowPassword(!showPassword),
          sx: { textTransform: "none", p: 0, minWidth: 0 }
        },
        showPassword ? "Hide" : "Show",
        " password"
      )
    }
  ), /* @__PURE__ */ React.createElement(
    TextField,
    {
      label: "Confirm Password",
      type: showPassword ? "text" : "password",
      value: confirm2,
      onChange: (e) => setConfirm(e.target.value),
      fullWidth: true,
      autoComplete: "new-password"
    }
  ), /* @__PURE__ */ React.createElement(Button, { variant: "contained", onClick: updatePassword, disabled: loading, fullWidth: true }, loading ? /* @__PURE__ */ React.createElement(CircularProgress, { size: 20 }) : "Update Password & Sign In")) : /* @__PURE__ */ React.createElement(React.Fragment, null, !error ? /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, "Verifying recovery link") : /* @__PURE__ */ React.createElement(Alert, { severity: "warning", sx: { mt: 1 } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { mb: 1 } }, /* @__PURE__ */ React.createElement("strong", null, "Link Expired")), /* @__PURE__ */ React.createElement(Typography, { variant: "body2", sx: { mb: 2 } }, 'Password reset links expire after 1 hour. Please request a new one from the Sign In page using the "Forgot Password?" button.'), /* @__PURE__ */ React.createElement(Stack, { spacing: 1 }, /* @__PURE__ */ React.createElement(Button, { variant: "contained", onClick: goToLogin, fullWidth: true }, "Go to Sign In & Request New Link"), /* @__PURE__ */ React.createElement(Button, { variant: "outlined", onClick: goHome, fullWidth: true }, "Back to Home"))))))));
}
const useState = window["React"].useState;
const useEffect$2 = window["React"].useEffect;
const theme = createTheme(muiThemeOverrides);
function App() {
  const [ageVerified, setAgeVerified] = useState(false);
  const [currentView, setCurrentView] = useState("home");
  useEffect$2(() => {
    const verified = localStorage.getItem("strainspotter_age_verified");
    if (verified === "true") {
      setAgeVerified(true);
    }
    if (typeof window !== "undefined" && window.location.hash) {
      const hash2 = window.location.hash;
      if (hash2 === "#/emergency-logout") {
        setCurrentView("emergency-logout");
      } else if (/type=recovery/.test(hash2)) {
        setCurrentView("reset");
      } else if (/access_token=/.test(hash2)) {
        setCurrentView("home");
        (() => __async(null, null, function* () {
          var _a2;
          try {
            const { data } = yield supabase.auth.getSession();
            const user = (_a2 = data == null ? void 0 : data.session) == null ? void 0 : _a2.user;
            if (user == null ? void 0 : user.id) {
              const email = user.email || void 0;
              const username = email ? email.split("@")[0] : void 0;
              yield fetch(`${API_BASE}/api/users/ensure`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ user_id: user.id, email, username })
              });
            }
          } catch (e) {
            console.warn("[onboard] ensure user after magic link failed:", e);
          }
        }))();
        setTimeout(() => {
          history.replaceState(null, "", window.location.pathname + window.location.search);
        }, 1e3);
      }
    }
  }, []);
  const handleAgeVerify = () => {
    localStorage.setItem("strainspotter_age_verified", "true");
    setAgeVerified(true);
  };
  if (!ageVerified) {
    return /* @__PURE__ */ React.createElement(ThemeProvider, { theme }, /* @__PURE__ */ React.createElement(CssBaseline, null), /* @__PURE__ */ React.createElement(AgeGate, { onVerify: handleAgeVerify }));
  }
  return /* @__PURE__ */ React.createElement(ThemeProvider, { theme }, /* @__PURE__ */ React.createElement(CssBaseline, null), /* @__PURE__ */ React.createElement(AuthProvider, null, /* @__PURE__ */ React.createElement(MobileOnlyGuard, null, /* @__PURE__ */ React.createElement("div", { style: {
    position: "fixed",
    inset: 0,
    zIndex: 0,
    backgroundImage: "url(/strainspotter-bg.jpg)",
    backgroundSize: "cover",
    backgroundPosition: "center"
  } }), /* @__PURE__ */ React.createElement(ErrorBoundary$1, null, /* @__PURE__ */ React.createElement(GuidelinesGate, null, typeof window !== "undefined" && !/localhost|127\.0\.0\.1/.test(window.location.host) && /localhost:5181/.test("https://strainspotter.onrender.com") && /* @__PURE__ */ React.createElement("div", { style: { background: "#ff5555", color: "#fff", padding: "6px 12px", textAlign: "center", fontWeight: 700 } }, "Warning: Frontend is calling localhost API_BASE. Update VITE_API_BASE or config.js."), /* @__PURE__ */ React.createElement("div", { style: { position: "relative", zIndex: 10 } }, currentView === "home" && /* @__PURE__ */ React.createElement(Home, { onNavigate: setCurrentView }), currentView === "scanner" && /* @__PURE__ */ React.createElement(Scanner, { onViewHistory: () => setCurrentView("history"), onBack: () => setCurrentView("home") }), currentView === "guest-scan" && /* @__PURE__ */ React.createElement(Scanner, { onViewHistory: () => setCurrentView("history"), onBack: () => setCurrentView("home") }), currentView === "wizard" && /* @__PURE__ */ React.createElement(ScanWizard, { onBack: () => setCurrentView("home") }), currentView === "history" && /* @__PURE__ */ React.createElement(ScanHistory, { onBack: () => setCurrentView("home") }), currentView === "feedback" && /* @__PURE__ */ React.createElement(FeedbackChat, { onBack: () => setCurrentView("home") }), currentView === "growers" && /* @__PURE__ */ React.createElement(GrowerDirectory, { onNavigate: setCurrentView, onBack: () => setCurrentView("home") }), currentView === "seeds" && /* @__PURE__ */ React.createElement(Seeds, { onBack: () => setCurrentView("home") }), currentView === "dispensaries" && /* @__PURE__ */ React.createElement(Dispensaries, { onBack: () => setCurrentView("home") }), currentView === "register" && /* @__PURE__ */ React.createElement(GrowerRegistration, { onBack: () => setCurrentView("home") }), currentView === "groups" && /* @__PURE__ */ React.createElement(Groups, { onNavigate: setCurrentView, onBack: () => setCurrentView("home") }), currentView === "grow-coach" && /* @__PURE__ */ React.createElement(GrowCoach, { onBack: () => setCurrentView("home") }), currentView === "membership-join" && /* @__PURE__ */ React.createElement(MembershipJoin, { onBack: () => setCurrentView("home") }), currentView === "help" && /* @__PURE__ */ React.createElement(Help, { onNavigate: setCurrentView, onBack: () => setCurrentView("home") }), currentView === "login" && /* @__PURE__ */ React.createElement(Auth, { onBack: () => setCurrentView("home") }), currentView === "friends" && /* @__PURE__ */ React.createElement(Friends, { onBack: () => setCurrentView("home") }), currentView === "strains" && /* @__PURE__ */ React.createElement(StrainBrowser, { onNavigate: setCurrentView }), currentView === "membership-admin" && /* @__PURE__ */ React.createElement(MembershipAdmin, { onBack: () => setCurrentView("home") }), currentView === "pipeline" && /* @__PURE__ */ React.createElement(PipelineStatus, { onBack: () => setCurrentView("home") }), currentView === "moderation" && /* @__PURE__ */ React.createElement(ModerationDashboard, { onBack: () => setCurrentView("home") }), currentView === "guidelines" && /* @__PURE__ */ React.createElement(Guidelines, { onBack: () => setCurrentView("home") }), currentView === "reset" && /* @__PURE__ */ React.createElement(PasswordReset, { onBack: () => setCurrentView("home") }), currentView === "errors" && /* @__PURE__ */ React.createElement(ErrorViewer, { onBack: () => setCurrentView("home") }), currentView === "emergency-logout" && /* @__PURE__ */ React.createElement(EmergencyLogout, null)))))));
}
const React$2 = window["React"];
class ErrorBoundary2 extends React$2.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  componentDidCatch(error, errorInfo) {
    console.error("ErrorBoundary caught:", error, errorInfo);
  }
  render() {
    var _a2;
    if (this.state.hasError) {
      return /* @__PURE__ */ React$2.createElement("div", { style: {
        color: "white",
        backgroundColor: "red",
        padding: 32,
        minHeight: "100vh",
        fontSize: "16px"
      } }, /* @__PURE__ */ React$2.createElement("h2", null, "Something went wrong."), /* @__PURE__ */ React$2.createElement("pre", { style: { whiteSpace: "pre-wrap", wordBreak: "break-word" } }, String(this.state.error), (_a2 = this.state.error) == null ? void 0 : _a2.stack));
    }
    return this.props.children;
  }
}
var define_process_env_default$1 = {};
const useEffect$1 = window["React"].useEffect;
const useRef = window["React"].useRef;
var name$1 = "@vercel/speed-insights";
var version$1 = "1.2.0";
var initQueue$1 = () => {
  if (window.si) return;
  window.si = function a(...params) {
    (window.siq = window.siq || []).push(params);
  };
};
function isBrowser$1() {
  return typeof window !== "undefined";
}
function detectEnvironment$1() {
  try {
    const env = "production";
    if (env === "development" || env === "test") ;
  } catch (e) {
  }
  return "production";
}
function isDevelopment$1() {
  return detectEnvironment$1() === "development";
}
function getScriptSrc$1(props) {
  if (props.scriptSrc) {
    return props.scriptSrc;
  }
  if (isDevelopment$1()) {
    return "https://va.vercel-scripts.com/v1/speed-insights/script.debug.js";
  }
  if (props.dsn) {
    return "https://va.vercel-scripts.com/v1/speed-insights/script.js";
  }
  if (props.basePath) {
    return `${props.basePath}/speed-insights/script.js`;
  }
  return "/_vercel/speed-insights/script.js";
}
function injectSpeedInsights(props = {}) {
  var _a2;
  if (!isBrowser$1() || props.route === null) return null;
  initQueue$1();
  const src = getScriptSrc$1(props);
  if (document.head.querySelector(`script[src*="${src}"]`)) return null;
  if (props.beforeSend) {
    (_a2 = window.si) == null ? void 0 : _a2.call(window, "beforeSend", props.beforeSend);
  }
  const script = document.createElement("script");
  script.src = src;
  script.defer = true;
  script.dataset.sdkn = name$1 + (props.framework ? `/${props.framework}` : "");
  script.dataset.sdkv = version$1;
  if (props.sampleRate) {
    script.dataset.sampleRate = props.sampleRate.toString();
  }
  if (props.route) {
    script.dataset.route = props.route;
  }
  if (props.endpoint) {
    script.dataset.endpoint = props.endpoint;
  } else if (props.basePath) {
    script.dataset.endpoint = `${props.basePath}/speed-insights/vitals`;
  }
  if (props.dsn) {
    script.dataset.dsn = props.dsn;
  }
  if (isDevelopment$1() && props.debug === false) {
    script.dataset.debug = "false";
  }
  script.onerror = () => {
    console.log(
      `[Vercel Speed Insights] Failed to load script from ${src}. Please check if any content blockers are enabled and try again.`
    );
  };
  document.head.appendChild(script);
  return {
    setRoute: (route) => {
      script.dataset.route = route != null ? route : void 0;
    }
  };
}
function getBasePath$1() {
  if (typeof process === "undefined" || typeof define_process_env_default$1 === "undefined") {
    return void 0;
  }
  return define_process_env_default$1.REACT_APP_VERCEL_OBSERVABILITY_BASEPATH;
}
function SpeedInsights(props) {
  useEffect$1(() => {
    var _a2;
    if (props.beforeSend) {
      (_a2 = window.si) == null ? void 0 : _a2.call(window, "beforeSend", props.beforeSend);
    }
  }, [props.beforeSend]);
  const setScriptRoute = useRef(null);
  useEffect$1(() => {
    var _a2, _b;
    if (!setScriptRoute.current) {
      const script = injectSpeedInsights(__spreadValues({
        framework: (_a2 = props.framework) != null ? _a2 : "react",
        basePath: (_b = props.basePath) != null ? _b : getBasePath$1()
      }, props));
      if (script) {
        setScriptRoute.current = script.setRoute;
      }
    } else if (props.route) {
      setScriptRoute.current(props.route);
    }
  }, [props.route]);
  return null;
}
var define_process_env_default = {};
const useEffect = window["React"].useEffect;
var name = "@vercel/analytics";
var version = "1.5.0";
var initQueue = () => {
  if (window.va) return;
  window.va = function a(...params) {
    (window.vaq = window.vaq || []).push(params);
  };
};
function isBrowser() {
  return typeof window !== "undefined";
}
function detectEnvironment() {
  try {
    const env = "production";
    if (env === "development" || env === "test") ;
  } catch (e) {
  }
  return "production";
}
function setMode(mode = "auto") {
  if (mode === "auto") {
    window.vam = detectEnvironment();
    return;
  }
  window.vam = mode;
}
function getMode() {
  const mode = isBrowser() ? window.vam : detectEnvironment();
  return mode || "production";
}
function isDevelopment() {
  return getMode() === "development";
}
function getScriptSrc(props) {
  if (props.scriptSrc) {
    return props.scriptSrc;
  }
  if (isDevelopment()) {
    return "https://va.vercel-scripts.com/v1/script.debug.js";
  }
  if (props.basePath) {
    return `${props.basePath}/insights/script.js`;
  }
  return "/_vercel/insights/script.js";
}
function inject(props = {
  debug: true
}) {
  var _a2;
  if (!isBrowser()) return;
  setMode(props.mode);
  initQueue();
  if (props.beforeSend) {
    (_a2 = window.va) == null ? void 0 : _a2.call(window, "beforeSend", props.beforeSend);
  }
  const src = getScriptSrc(props);
  if (document.head.querySelector(`script[src*="${src}"]`)) return;
  const script = document.createElement("script");
  script.src = src;
  script.defer = true;
  script.dataset.sdkn = name + (props.framework ? `/${props.framework}` : "");
  script.dataset.sdkv = version;
  if (props.disableAutoTrack) {
    script.dataset.disableAutoTrack = "1";
  }
  if (props.endpoint) {
    script.dataset.endpoint = props.endpoint;
  } else if (props.basePath) {
    script.dataset.endpoint = `${props.basePath}/insights`;
  }
  if (props.dsn) {
    script.dataset.dsn = props.dsn;
  }
  script.onerror = () => {
    const errorMessage = isDevelopment() ? "Please check if any ad blockers are enabled and try again." : "Be sure to enable Web Analytics for your project and deploy again. See https://vercel.com/docs/analytics/quickstart for more information.";
    console.log(
      `[Vercel Web Analytics] Failed to load script from ${src}. ${errorMessage}`
    );
  };
  if (isDevelopment() && props.debug === false) {
    script.dataset.debug = "false";
  }
  document.head.appendChild(script);
}
function pageview({
  route,
  path
}) {
  var _a2;
  (_a2 = window.va) == null ? void 0 : _a2.call(window, "pageview", { route, path });
}
function getBasePath() {
  if (typeof process === "undefined" || typeof define_process_env_default === "undefined") {
    return void 0;
  }
  return define_process_env_default.REACT_APP_VERCEL_OBSERVABILITY_BASEPATH;
}
function Analytics(props) {
  useEffect(() => {
    var _a2;
    if (props.beforeSend) {
      (_a2 = window.va) == null ? void 0 : _a2.call(window, "beforeSend", props.beforeSend);
    }
  }, [props.beforeSend]);
  useEffect(() => {
    var _a2;
    inject(__spreadValues(__spreadValues({
      framework: props.framework || "react",
      basePath: (_a2 = props.basePath) != null ? _a2 : getBasePath()
    }, props.route !== void 0 && { disableAutoTrack: true }), props));
  }, []);
  useEffect(() => {
    if (props.route && props.path) {
      pageview({ route: props.route, path: props.path });
    }
  }, [props.route, props.path]);
  return null;
}
const React$1 = window["React"];
const StrictMode = window["React"].StrictMode;
const ReactDOM = window["ReactDOM"];
const createRoot = window["ReactDOM"].createRoot;
window.React = React$1;
window.ReactDOM = ReactDOM;
console.log("StrainSpotter main.jsx loading...");
console.log("Protocol:", window.location.protocol);
console.log("Hostname:", window.location.hostname);
createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ React$1.createElement(StrictMode, null, /* @__PURE__ */ React$1.createElement(ErrorBoundary2, null, /* @__PURE__ */ React$1.createElement(App, null)), /* @__PURE__ */ React$1.createElement(SpeedInsights, null), /* @__PURE__ */ React$1.createElement(Analytics, null))
);
console.log("StrainSpotter rendered!");
//# sourceMappingURL=index-BrfZ5GmZ.js.map
