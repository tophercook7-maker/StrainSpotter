var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __restKey = (key) => typeof key === "symbol" ? key : key + "";
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e = m[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n)) {
          const d = Object.getOwnPropertyDescriptor(e, k);
          if (d) {
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: () => e[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) return;
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) processPreload(link);
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") continue;
      for (const node2 of mutation.addedNodes) if (node2.tagName === "LINK" && node2.rel === "modulepreload") processPreload(node2);
    }
  }).observe(document, {
    childList: true,
    subtree: true
  });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep) return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
const scriptRel = "modulepreload";
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    let allSettled = function(promises$2) {
      return Promise.all(promises$2.map((p) => Promise.resolve(p).then((value$1) => ({
        status: "fulfilled",
        value: value$1
      }), (reason) => ({
        status: "rejected",
        reason
      }))));
    };
    const links = document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
    const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
    promise = allSettled(deps.map((dep) => {
      dep = assetsURL(dep, importerUrl);
      if (dep in seen) return;
      seen[dep] = true;
      const isCss = dep.endsWith(".css");
      const cssSelector = isCss ? '[rel="stylesheet"]' : "";
      if (!!importerUrl) for (let i$1 = links.length - 1; i$1 >= 0; i$1--) {
        const link$1 = links[i$1];
        if (link$1.href === dep && (!isCss || link$1.rel === "stylesheet")) return;
      }
      else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) return;
      const link = document.createElement("link");
      link.rel = isCss ? "stylesheet" : scriptRel;
      if (!isCss) link.as = "script";
      link.crossOrigin = "";
      link.href = dep;
      if (cspNonce) link.setAttribute("nonce", cspNonce);
      document.head.appendChild(link);
      if (isCss) return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(/* @__PURE__ */ new Error(`Unable to preload CSS for ${dep}`)));
      });
    }));
  }
  function handlePreloadError(err$2) {
    const e$1 = new Event("vite:preloadError", { cancelable: true });
    e$1.payload = err$2;
    window.dispatchEvent(e$1);
    if (!e$1.defaultPrevented) throw err$2;
  }
  return promise.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      var isInstance = false;
      try {
        isInstance = this instanceof a2;
      } catch (e) {
      }
      if (isInstance) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReact_production_min;
function requireReact_production_min() {
  if (hasRequiredReact_production_min) return react_production_min;
  hasRequiredReact_production_min = 1;
  var l = Symbol.for("react.element"), n = Symbol.for("react.portal"), p = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r2 = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z = Symbol.iterator;
  function A(a) {
    if (null === a || "object" !== typeof a) return null;
    a = z && a[z] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }
  var B = { isMounted: function() {
    return false;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, C = Object.assign, D = {};
  function E(a, b, e) {
    this.props = a;
    this.context = b;
    this.refs = D;
    this.updater = e || B;
  }
  E.prototype.isReactComponent = {};
  E.prototype.setState = function(a, b) {
    if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, a, b, "setState");
  };
  E.prototype.forceUpdate = function(a) {
    this.updater.enqueueForceUpdate(this, a, "forceUpdate");
  };
  function F() {
  }
  F.prototype = E.prototype;
  function G(a, b, e) {
    this.props = a;
    this.context = b;
    this.refs = D;
    this.updater = e || B;
  }
  var H = G.prototype = new F();
  H.constructor = G;
  C(H, E.prototype);
  H.isPureReactComponent = true;
  var I = Array.isArray, J = Object.prototype.hasOwnProperty, K = { current: null }, L = { key: true, ref: true, __self: true, __source: true };
  function M(a, b, e) {
    var d, c = {}, k = null, h = null;
    if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
    var g = arguments.length - 2;
    if (1 === g) c.children = e;
    else if (1 < g) {
      for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
      c.children = f;
    }
    if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
    return { $$typeof: l, type: a, key: k, ref: h, props: c, _owner: K.current };
  }
  function N(a, b) {
    return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
  }
  function O(a) {
    return "object" === typeof a && null !== a && a.$$typeof === l;
  }
  function escape(a) {
    var b = { "=": "=0", ":": "=2" };
    return "$" + a.replace(/[=:]/g, function(a2) {
      return b[a2];
    });
  }
  var P = /\/+/g;
  function Q(a, b) {
    return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
  }
  function R(a, b, e, d, c) {
    var k = typeof a;
    if ("undefined" === k || "boolean" === k) a = null;
    var h = false;
    if (null === a) h = true;
    else switch (k) {
      case "string":
      case "number":
        h = true;
        break;
      case "object":
        switch (a.$$typeof) {
          case l:
          case n:
            h = true;
        }
    }
    if (h) return h = a, c = c(h), a = "" === d ? "." + Q(h, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function(a2) {
      return a2;
    })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
    h = 0;
    d = "" === d ? "." : d + ":";
    if (I(a)) for (var g = 0; g < a.length; g++) {
      k = a[g];
      var f = d + Q(k, g);
      h += R(k, b, e, f, c);
    }
    else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done; ) k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);
    else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
    return h;
  }
  function S(a, b, e) {
    if (null == a) return a;
    var d = [], c = 0;
    R(a, d, "", "", function(a2) {
      return b.call(e, a2, c++);
    });
    return d;
  }
  function T(a) {
    if (-1 === a._status) {
      var b = a._result;
      b = b();
      b.then(function(b2) {
        if (0 === a._status || -1 === a._status) a._status = 1, a._result = b2;
      }, function(b2) {
        if (0 === a._status || -1 === a._status) a._status = 2, a._result = b2;
      });
      -1 === a._status && (a._status = 0, a._result = b);
    }
    if (1 === a._status) return a._result.default;
    throw a._result;
  }
  var U = { current: null }, V = { transition: null }, W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
  function X() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  react_production_min.Children = { map: S, forEach: function(a, b, e) {
    S(a, function() {
      b.apply(this, arguments);
    }, e);
  }, count: function(a) {
    var b = 0;
    S(a, function() {
      b++;
    });
    return b;
  }, toArray: function(a) {
    return S(a, function(a2) {
      return a2;
    }) || [];
  }, only: function(a) {
    if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
    return a;
  } };
  react_production_min.Component = E;
  react_production_min.Fragment = p;
  react_production_min.Profiler = r2;
  react_production_min.PureComponent = G;
  react_production_min.StrictMode = q;
  react_production_min.Suspense = w;
  react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
  react_production_min.act = X;
  react_production_min.cloneElement = function(a, b, e) {
    if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
    var d = C({}, a.props), c = a.key, k = a.ref, h = a._owner;
    if (null != b) {
      void 0 !== b.ref && (k = b.ref, h = K.current);
      void 0 !== b.key && (c = "" + b.key);
      if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
      for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
    }
    var f = arguments.length - 2;
    if (1 === f) d.children = e;
    else if (1 < f) {
      g = Array(f);
      for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
      d.children = g;
    }
    return { $$typeof: l, type: a.type, key: c, ref: k, props: d, _owner: h };
  };
  react_production_min.createContext = function(a) {
    a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
    a.Provider = { $$typeof: t, _context: a };
    return a.Consumer = a;
  };
  react_production_min.createElement = M;
  react_production_min.createFactory = function(a) {
    var b = M.bind(null, a);
    b.type = a;
    return b;
  };
  react_production_min.createRef = function() {
    return { current: null };
  };
  react_production_min.forwardRef = function(a) {
    return { $$typeof: v, render: a };
  };
  react_production_min.isValidElement = O;
  react_production_min.lazy = function(a) {
    return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
  };
  react_production_min.memo = function(a, b) {
    return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
  };
  react_production_min.startTransition = function(a) {
    var b = V.transition;
    V.transition = {};
    try {
      a();
    } finally {
      V.transition = b;
    }
  };
  react_production_min.unstable_act = X;
  react_production_min.useCallback = function(a, b) {
    return U.current.useCallback(a, b);
  };
  react_production_min.useContext = function(a) {
    return U.current.useContext(a);
  };
  react_production_min.useDebugValue = function() {
  };
  react_production_min.useDeferredValue = function(a) {
    return U.current.useDeferredValue(a);
  };
  react_production_min.useEffect = function(a, b) {
    return U.current.useEffect(a, b);
  };
  react_production_min.useId = function() {
    return U.current.useId();
  };
  react_production_min.useImperativeHandle = function(a, b, e) {
    return U.current.useImperativeHandle(a, b, e);
  };
  react_production_min.useInsertionEffect = function(a, b) {
    return U.current.useInsertionEffect(a, b);
  };
  react_production_min.useLayoutEffect = function(a, b) {
    return U.current.useLayoutEffect(a, b);
  };
  react_production_min.useMemo = function(a, b) {
    return U.current.useMemo(a, b);
  };
  react_production_min.useReducer = function(a, b, e) {
    return U.current.useReducer(a, b, e);
  };
  react_production_min.useRef = function(a) {
    return U.current.useRef(a);
  };
  react_production_min.useState = function(a) {
    return U.current.useState(a);
  };
  react_production_min.useSyncExternalStore = function(a, b, e) {
    return U.current.useSyncExternalStore(a, b, e);
  };
  react_production_min.useTransition = function() {
    return U.current.useTransition();
  };
  react_production_min.version = "18.3.1";
  return react_production_min;
}
var hasRequiredReact;
function requireReact() {
  if (hasRequiredReact) return react.exports;
  hasRequiredReact = 1;
  {
    react.exports = requireReact_production_min();
  }
  return react.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f = requireReact(), k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
  function q(c, a, g) {
    var b, d = {}, e = null, h = null;
    void 0 !== g && (e = "" + g);
    void 0 !== a.key && (e = "" + a.key);
    void 0 !== a.ref && (h = a.ref);
    for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
    if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
    return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
  }
  reactJsxRuntime_production_min.Fragment = l;
  reactJsxRuntime_production_min.jsx = q;
  reactJsxRuntime_production_min.jsxs = q;
  return reactJsxRuntime_production_min;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  {
    jsxRuntime.exports = requireReactJsxRuntime_production_min();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
var reactExports = requireReact();
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredScheduler_production_min;
function requireScheduler_production_min() {
  if (hasRequiredScheduler_production_min) return scheduler_production_min;
  hasRequiredScheduler_production_min = 1;
  (function(exports) {
    function f(a, b) {
      var c = a.length;
      a.push(b);
      a: for (; 0 < c; ) {
        var d = c - 1 >>> 1, e = a[d];
        if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;
        else break a;
      }
    }
    function h(a) {
      return 0 === a.length ? null : a[0];
    }
    function k(a) {
      if (0 === a.length) return null;
      var b = a[0], c = a.pop();
      if (c !== b) {
        a[0] = c;
        a: for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
          var m = 2 * (d + 1) - 1, C = a[m], n = m + 1, x = a[n];
          if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);
          else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;
          else break a;
        }
      }
      return b;
    }
    function g(a, b) {
      var c = a.sortIndex - b.sortIndex;
      return 0 !== c ? c : a.id - b.id;
    }
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var l = performance;
      exports.unstable_now = function() {
        return l.now();
      };
    } else {
      var p = Date, q = p.now();
      exports.unstable_now = function() {
        return p.now() - q;
      };
    }
    var r2 = [], t = [], u = 1, v = null, y = 3, z = false, A = false, B = false, D = "function" === typeof setTimeout ? setTimeout : null, E = "function" === typeof clearTimeout ? clearTimeout : null, F = "undefined" !== typeof setImmediate ? setImmediate : null;
    "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G(a) {
      for (var b = h(t); null !== b; ) {
        if (null === b.callback) k(t);
        else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r2, b);
        else break;
        b = h(t);
      }
    }
    function H(a) {
      B = false;
      G(a);
      if (!A) if (null !== h(r2)) A = true, I(J);
      else {
        var b = h(t);
        null !== b && K(H, b.startTime - a);
      }
    }
    function J(a, b) {
      A = false;
      B && (B = false, E(L), L = -1);
      z = true;
      var c = y;
      try {
        G(b);
        for (v = h(r2); null !== v && (!(v.expirationTime > b) || a && !M()); ) {
          var d = v.callback;
          if ("function" === typeof d) {
            v.callback = null;
            y = v.priorityLevel;
            var e = d(v.expirationTime <= b);
            b = exports.unstable_now();
            "function" === typeof e ? v.callback = e : v === h(r2) && k(r2);
            G(b);
          } else k(r2);
          v = h(r2);
        }
        if (null !== v) var w = true;
        else {
          var m = h(t);
          null !== m && K(H, m.startTime - b);
          w = false;
        }
        return w;
      } finally {
        v = null, y = c, z = false;
      }
    }
    var N = false, O = null, L = -1, P = 5, Q = -1;
    function M() {
      return exports.unstable_now() - Q < P ? false : true;
    }
    function R() {
      if (null !== O) {
        var a = exports.unstable_now();
        Q = a;
        var b = true;
        try {
          b = O(true, a);
        } finally {
          b ? S() : (N = false, O = null);
        }
      } else N = false;
    }
    var S;
    if ("function" === typeof F) S = function() {
      F(R);
    };
    else if ("undefined" !== typeof MessageChannel) {
      var T = new MessageChannel(), U = T.port2;
      T.port1.onmessage = R;
      S = function() {
        U.postMessage(null);
      };
    } else S = function() {
      D(R, 0);
    };
    function I(a) {
      O = a;
      N || (N = true, S());
    }
    function K(a, b) {
      L = D(function() {
        a(exports.unstable_now());
      }, b);
    }
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(a) {
      a.callback = null;
    };
    exports.unstable_continueExecution = function() {
      A || z || (A = true, I(J));
    };
    exports.unstable_forceFrameRate = function(a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1e3 / a) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return y;
    };
    exports.unstable_getFirstCallbackNode = function() {
      return h(r2);
    };
    exports.unstable_next = function(a) {
      switch (y) {
        case 1:
        case 2:
        case 3:
          var b = 3;
          break;
        default:
          b = y;
      }
      var c = y;
      y = b;
      try {
        return a();
      } finally {
        y = c;
      }
    };
    exports.unstable_pauseExecution = function() {
    };
    exports.unstable_requestPaint = function() {
    };
    exports.unstable_runWithPriority = function(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a = 3;
      }
      var c = y;
      y = a;
      try {
        return b();
      } finally {
        y = c;
      }
    };
    exports.unstable_scheduleCallback = function(a, b, c) {
      var d = exports.unstable_now();
      "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
      switch (a) {
        case 1:
          var e = -1;
          break;
        case 2:
          e = 250;
          break;
        case 5:
          e = 1073741823;
          break;
        case 4:
          e = 1e4;
          break;
        default:
          e = 5e3;
      }
      e = c + e;
      a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
      c > d ? (a.sortIndex = c, f(t, a), null === h(r2) && a === h(t) && (B ? (E(L), L = -1) : B = true, K(H, c - d))) : (a.sortIndex = e, f(r2, a), A || z || (A = true, I(J)));
      return a;
    };
    exports.unstable_shouldYield = M;
    exports.unstable_wrapCallback = function(a) {
      var b = y;
      return function() {
        var c = y;
        y = b;
        try {
          return a.apply(this, arguments);
        } finally {
          y = c;
        }
      };
    };
  })(scheduler_production_min);
  return scheduler_production_min;
}
var hasRequiredScheduler;
function requireScheduler() {
  if (hasRequiredScheduler) return scheduler.exports;
  hasRequiredScheduler = 1;
  {
    scheduler.exports = requireScheduler_production_min();
  }
  return scheduler.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDom_production_min;
function requireReactDom_production_min() {
  if (hasRequiredReactDom_production_min) return reactDom_production_min;
  hasRequiredReactDom_production_min = 1;
  var aa = requireReact(), ca = requireScheduler();
  function p(a) {
    for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
    return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var da = /* @__PURE__ */ new Set(), ea = {};
  function fa(a, b) {
    ha(a, b);
    ha(a + "Capture", b);
  }
  function ha(a, b) {
    ea[a] = b;
    for (a = 0; a < b.length; a++) da.add(b[a]);
  }
  var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
  function oa(a) {
    if (ja.call(ma, a)) return true;
    if (ja.call(la, a)) return false;
    if (ka.test(a)) return ma[a] = true;
    la[a] = true;
    return false;
  }
  function pa(a, b, c, d) {
    if (null !== c && 0 === c.type) return false;
    switch (typeof b) {
      case "function":
      case "symbol":
        return true;
      case "boolean":
        if (d) return false;
        if (null !== c) return !c.acceptsBooleans;
        a = a.toLowerCase().slice(0, 5);
        return "data-" !== a && "aria-" !== a;
      default:
        return false;
    }
  }
  function qa(a, b, c, d) {
    if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return true;
    if (d) return false;
    if (null !== c) switch (c.type) {
      case 3:
        return !b;
      case 4:
        return false === b;
      case 5:
        return isNaN(b);
      case 6:
        return isNaN(b) || 1 > b;
    }
    return false;
  }
  function v(a, b, c, d, e, f, g) {
    this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
    this.attributeName = d;
    this.attributeNamespace = e;
    this.mustUseProperty = c;
    this.propertyName = a;
    this.type = b;
    this.sanitizeURL = f;
    this.removeEmptyString = g;
  }
  var z = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
    z[a] = new v(a, 0, false, a, null, false, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
    var b = a[0];
    z[b] = new v(b, 1, false, a[1], null, false, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
    z[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
    z[a] = new v(a, 2, false, a, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
    z[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(a) {
    z[a] = new v(a, 3, true, a, null, false, false);
  });
  ["capture", "download"].forEach(function(a) {
    z[a] = new v(a, 4, false, a, null, false, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(a) {
    z[a] = new v(a, 6, false, a, null, false, false);
  });
  ["rowSpan", "start"].forEach(function(a) {
    z[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
  });
  var ra = /[\-:]([a-z])/g;
  function sa(a) {
    return a[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
    var b = a.replace(
      ra,
      sa
    );
    z[b] = new v(b, 1, false, a, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
    var b = a.replace(ra, sa);
    z[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
    var b = a.replace(ra, sa);
    z[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(a) {
    z[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
  });
  z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  ["src", "href", "action", "formAction"].forEach(function(a) {
    z[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
  });
  function ta(a, b, c, d) {
    var e = z.hasOwnProperty(b) ? z[b] : null;
    if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
  }
  var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
  var Ia = Symbol.for("react.offscreen");
  var Ja = Symbol.iterator;
  function Ka(a) {
    if (null === a || "object" !== typeof a) return null;
    a = Ja && a[Ja] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }
  var A = Object.assign, La;
  function Ma(a) {
    if (void 0 === La) try {
      throw Error();
    } catch (c) {
      var b = c.stack.trim().match(/\n( *(at )?)/);
      La = b && b[1] || "";
    }
    return "\n" + La + a;
  }
  var Na = false;
  function Oa(a, b) {
    if (!a || Na) return "";
    Na = true;
    var c = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (b) if (b = function() {
        throw Error();
      }, Object.defineProperty(b.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b, []);
        } catch (l) {
          var d = l;
        }
        Reflect.construct(a, [], b);
      } else {
        try {
          b.call();
        } catch (l) {
          d = l;
        }
        a.call(b.prototype);
      }
      else {
        try {
          throw Error();
        } catch (l) {
          d = l;
        }
        a();
      }
    } catch (l) {
      if (l && d && "string" === typeof l.stack) {
        for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; ) h--;
        for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
          if (1 !== g || 1 !== h) {
            do
              if (g--, h--, 0 > h || e[g] !== f[h]) {
                var k = "\n" + e[g].replace(" at new ", " at ");
                a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                return k;
              }
            while (1 <= g && 0 <= h);
          }
          break;
        }
      }
    } finally {
      Na = false, Error.prepareStackTrace = c;
    }
    return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
  }
  function Pa(a) {
    switch (a.tag) {
      case 5:
        return Ma(a.type);
      case 16:
        return Ma("Lazy");
      case 13:
        return Ma("Suspense");
      case 19:
        return Ma("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a = Oa(a.type, false), a;
      case 11:
        return a = Oa(a.type.render, false), a;
      case 1:
        return a = Oa(a.type, true), a;
      default:
        return "";
    }
  }
  function Qa(a) {
    if (null == a) return null;
    if ("function" === typeof a) return a.displayName || a.name || null;
    if ("string" === typeof a) return a;
    switch (a) {
      case ya:
        return "Fragment";
      case wa:
        return "Portal";
      case Aa:
        return "Profiler";
      case za:
        return "StrictMode";
      case Ea:
        return "Suspense";
      case Fa:
        return "SuspenseList";
    }
    if ("object" === typeof a) switch (a.$$typeof) {
      case Ca:
        return (a.displayName || "Context") + ".Consumer";
      case Ba:
        return (a._context.displayName || "Context") + ".Provider";
      case Da:
        var b = a.render;
        a = a.displayName;
        a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        return a;
      case Ga:
        return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
      case Ha:
        b = a._payload;
        a = a._init;
        try {
          return Qa(a(b));
        } catch (c) {
        }
    }
    return null;
  }
  function Ra(a) {
    var b = a.type;
    switch (a.tag) {
      case 24:
        return "Cache";
      case 9:
        return (b.displayName || "Context") + ".Consumer";
      case 10:
        return (b._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return b;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Qa(b);
      case 8:
        return b === za ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if ("function" === typeof b) return b.displayName || b.name || null;
        if ("string" === typeof b) return b;
    }
    return null;
  }
  function Sa(a) {
    switch (typeof a) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a;
      case "object":
        return a;
      default:
        return "";
    }
  }
  function Ta(a) {
    var b = a.type;
    return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
  }
  function Ua(a) {
    var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
    if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
      var e = c.get, f = c.set;
      Object.defineProperty(a, b, { configurable: true, get: function() {
        return e.call(this);
      }, set: function(a2) {
        d = "" + a2;
        f.call(this, a2);
      } });
      Object.defineProperty(a, b, { enumerable: c.enumerable });
      return { getValue: function() {
        return d;
      }, setValue: function(a2) {
        d = "" + a2;
      }, stopTracking: function() {
        a._valueTracker = null;
        delete a[b];
      } };
    }
  }
  function Va(a) {
    a._valueTracker || (a._valueTracker = Ua(a));
  }
  function Wa(a) {
    if (!a) return false;
    var b = a._valueTracker;
    if (!b) return true;
    var c = b.getValue();
    var d = "";
    a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
    a = d;
    return a !== c ? (b.setValue(a), true) : false;
  }
  function Xa(a) {
    a = a || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof a) return null;
    try {
      return a.activeElement || a.body;
    } catch (b) {
      return a.body;
    }
  }
  function Ya(a, b) {
    var c = b.checked;
    return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
  }
  function Za(a, b) {
    var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
    c = Sa(null != b.value ? b.value : c);
    a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
  }
  function ab(a, b) {
    b = b.checked;
    null != b && ta(a, "checked", b, false);
  }
  function bb(a, b) {
    ab(a, b);
    var c = Sa(b.value), d = b.type;
    if (null != c) if ("number" === d) {
      if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
    } else a.value !== "" + c && (a.value = "" + c);
    else if ("submit" === d || "reset" === d) {
      a.removeAttribute("value");
      return;
    }
    b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
    null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
  }
  function db(a, b, c) {
    if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
      var d = b.type;
      if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
      b = "" + a._wrapperState.initialValue;
      c || b === a.value || (a.value = b);
      a.defaultValue = b;
    }
    c = a.name;
    "" !== c && (a.name = "");
    a.defaultChecked = !!a._wrapperState.initialChecked;
    "" !== c && (a.name = c);
  }
  function cb(a, b, c) {
    if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
  }
  var eb = Array.isArray;
  function fb(a, b, c, d) {
    a = a.options;
    if (b) {
      b = {};
      for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
      for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
    } else {
      c = "" + Sa(c);
      b = null;
      for (e = 0; e < a.length; e++) {
        if (a[e].value === c) {
          a[e].selected = true;
          d && (a[e].defaultSelected = true);
          return;
        }
        null !== b || a[e].disabled || (b = a[e]);
      }
      null !== b && (b.selected = true);
    }
  }
  function gb(a, b) {
    if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
    return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
  }
  function hb(a, b) {
    var c = b.value;
    if (null == c) {
      c = b.children;
      b = b.defaultValue;
      if (null != c) {
        if (null != b) throw Error(p(92));
        if (eb(c)) {
          if (1 < c.length) throw Error(p(93));
          c = c[0];
        }
        b = c;
      }
      null == b && (b = "");
      c = b;
    }
    a._wrapperState = { initialValue: Sa(c) };
  }
  function ib(a, b) {
    var c = Sa(b.value), d = Sa(b.defaultValue);
    null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
    null != d && (a.defaultValue = "" + d);
  }
  function jb(a) {
    var b = a.textContent;
    b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
  }
  function kb(a) {
    switch (a) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function lb(a, b) {
    return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
  }
  var mb, nb = (function(a) {
    return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
      MSApp.execUnsafeLocalFunction(function() {
        return a(b, c, d, e);
      });
    } : a;
  })(function(a, b) {
    if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;
    else {
      mb = mb || document.createElement("div");
      mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
      for (b = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
      for (; b.firstChild; ) a.appendChild(b.firstChild);
    }
  });
  function ob(a, b) {
    if (b) {
      var c = a.firstChild;
      if (c && c === a.lastChild && 3 === c.nodeType) {
        c.nodeValue = b;
        return;
      }
    }
    a.textContent = b;
  }
  var pb = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, qb = ["Webkit", "ms", "Moz", "O"];
  Object.keys(pb).forEach(function(a) {
    qb.forEach(function(b) {
      b = b + a.charAt(0).toUpperCase() + a.substring(1);
      pb[b] = pb[a];
    });
  });
  function rb(a, b, c) {
    return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
  }
  function sb(a, b) {
    a = a.style;
    for (var c in b) if (b.hasOwnProperty(c)) {
      var d = 0 === c.indexOf("--"), e = rb(c, b[c], d);
      "float" === c && (c = "cssFloat");
      d ? a.setProperty(c, e) : a[c] = e;
    }
  }
  var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
  function ub(a, b) {
    if (b) {
      if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));
      if (null != b.dangerouslySetInnerHTML) {
        if (null != b.children) throw Error(p(60));
        if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
      }
      if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
    }
  }
  function vb(a, b) {
    if (-1 === a.indexOf("-")) return "string" === typeof b.is;
    switch (a) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var wb = null;
  function xb(a) {
    a = a.target || a.srcElement || window;
    a.correspondingUseElement && (a = a.correspondingUseElement);
    return 3 === a.nodeType ? a.parentNode : a;
  }
  var yb = null, zb = null, Ab = null;
  function Bb(a) {
    if (a = Cb(a)) {
      if ("function" !== typeof yb) throw Error(p(280));
      var b = a.stateNode;
      b && (b = Db(b), yb(a.stateNode, a.type, b));
    }
  }
  function Eb(a) {
    zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
  }
  function Fb() {
    if (zb) {
      var a = zb, b = Ab;
      Ab = zb = null;
      Bb(a);
      if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
    }
  }
  function Gb(a, b) {
    return a(b);
  }
  function Hb() {
  }
  var Ib = false;
  function Jb(a, b, c) {
    if (Ib) return a(b, c);
    Ib = true;
    try {
      return Gb(a, b, c);
    } finally {
      if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
    }
  }
  function Kb(a, b) {
    var c = a.stateNode;
    if (null === c) return null;
    var d = Db(c);
    if (null === d) return null;
    c = d[b];
    a: switch (b) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
        a = !d;
        break a;
      default:
        a = false;
    }
    if (a) return null;
    if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
    return c;
  }
  var Lb = false;
  if (ia) try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a) {
    Lb = false;
  }
  function Nb(a, b, c, d, e, f, g, h, k) {
    var l = Array.prototype.slice.call(arguments, 3);
    try {
      b.apply(c, l);
    } catch (m) {
      this.onError(m);
    }
  }
  var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
    Ob = true;
    Pb = a;
  } };
  function Tb(a, b, c, d, e, f, g, h, k) {
    Ob = false;
    Pb = null;
    Nb.apply(Sb, arguments);
  }
  function Ub(a, b, c, d, e, f, g, h, k) {
    Tb.apply(this, arguments);
    if (Ob) {
      if (Ob) {
        var l = Pb;
        Ob = false;
        Pb = null;
      } else throw Error(p(198));
      Qb || (Qb = true, Rb = l);
    }
  }
  function Vb(a) {
    var b = a, c = a;
    if (a.alternate) for (; b.return; ) b = b.return;
    else {
      a = b;
      do
        b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
      while (a);
    }
    return 3 === b.tag ? c : null;
  }
  function Wb(a) {
    if (13 === a.tag) {
      var b = a.memoizedState;
      null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
      if (null !== b) return b.dehydrated;
    }
    return null;
  }
  function Xb(a) {
    if (Vb(a) !== a) throw Error(p(188));
  }
  function Yb(a) {
    var b = a.alternate;
    if (!b) {
      b = Vb(a);
      if (null === b) throw Error(p(188));
      return b !== a ? null : a;
    }
    for (var c = a, d = b; ; ) {
      var e = c.return;
      if (null === e) break;
      var f = e.alternate;
      if (null === f) {
        d = e.return;
        if (null !== d) {
          c = d;
          continue;
        }
        break;
      }
      if (e.child === f.child) {
        for (f = e.child; f; ) {
          if (f === c) return Xb(e), a;
          if (f === d) return Xb(e), b;
          f = f.sibling;
        }
        throw Error(p(188));
      }
      if (c.return !== d.return) c = e, d = f;
      else {
        for (var g = false, h = e.child; h; ) {
          if (h === c) {
            g = true;
            c = e;
            d = f;
            break;
          }
          if (h === d) {
            g = true;
            d = e;
            c = f;
            break;
          }
          h = h.sibling;
        }
        if (!g) {
          for (h = f.child; h; ) {
            if (h === c) {
              g = true;
              c = f;
              d = e;
              break;
            }
            if (h === d) {
              g = true;
              d = f;
              c = e;
              break;
            }
            h = h.sibling;
          }
          if (!g) throw Error(p(189));
        }
      }
      if (c.alternate !== d) throw Error(p(190));
    }
    if (3 !== c.tag) throw Error(p(188));
    return c.stateNode.current === c ? a : b;
  }
  function Zb(a) {
    a = Yb(a);
    return null !== a ? $b(a) : null;
  }
  function $b(a) {
    if (5 === a.tag || 6 === a.tag) return a;
    for (a = a.child; null !== a; ) {
      var b = $b(a);
      if (null !== b) return b;
      a = a.sibling;
    }
    return null;
  }
  var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
  function mc(a) {
    if (lc && "function" === typeof lc.onCommitFiberRoot) try {
      lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
    } catch (b) {
    }
  }
  var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
  function nc(a) {
    a >>>= 0;
    return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
  }
  var rc = 64, sc = 4194304;
  function tc(a) {
    switch (a & -a) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a;
    }
  }
  function uc(a, b) {
    var c = a.pendingLanes;
    if (0 === c) return 0;
    var d = 0, e = a.suspendedLanes, f = a.pingedLanes, g = c & 268435455;
    if (0 !== g) {
      var h = g & ~e;
      0 !== h ? d = tc(h) : (f &= g, 0 !== f && (d = tc(f)));
    } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f && (d = tc(f));
    if (0 === d) return 0;
    if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
    0 !== (d & 4) && (d |= c & 16);
    b = a.entangledLanes;
    if (0 !== b) for (a = a.entanglements, b &= d; 0 < b; ) c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
    return d;
  }
  function vc(a, b) {
    switch (a) {
      case 1:
      case 2:
      case 4:
        return b + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return b + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function wc(a, b) {
    for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f; ) {
      var g = 31 - oc(f), h = 1 << g, k = e[g];
      if (-1 === k) {
        if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
      } else k <= b && (a.expiredLanes |= h);
      f &= ~h;
    }
  }
  function xc(a) {
    a = a.pendingLanes & -1073741825;
    return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
  }
  function yc() {
    var a = rc;
    rc <<= 1;
    0 === (rc & 4194240) && (rc = 64);
    return a;
  }
  function zc(a) {
    for (var b = [], c = 0; 31 > c; c++) b.push(a);
    return b;
  }
  function Ac(a, b, c) {
    a.pendingLanes |= b;
    536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
    a = a.eventTimes;
    b = 31 - oc(b);
    a[b] = c;
  }
  function Bc(a, b) {
    var c = a.pendingLanes & ~b;
    a.pendingLanes = b;
    a.suspendedLanes = 0;
    a.pingedLanes = 0;
    a.expiredLanes &= b;
    a.mutableReadLanes &= b;
    a.entangledLanes &= b;
    b = a.entanglements;
    var d = a.eventTimes;
    for (a = a.expirationTimes; 0 < c; ) {
      var e = 31 - oc(c), f = 1 << e;
      b[e] = 0;
      d[e] = -1;
      a[e] = -1;
      c &= ~f;
    }
  }
  function Cc(a, b) {
    var c = a.entangledLanes |= b;
    for (a = a.entanglements; c; ) {
      var d = 31 - oc(c), e = 1 << d;
      e & b | a[d] & b && (a[d] |= b);
      c &= ~e;
    }
  }
  var C = 0;
  function Dc(a) {
    a &= -a;
    return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
  }
  var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Sc(a, b) {
    switch (a) {
      case "focusin":
      case "focusout":
        Lc = null;
        break;
      case "dragenter":
      case "dragleave":
        Mc = null;
        break;
      case "mouseover":
      case "mouseout":
        Nc = null;
        break;
      case "pointerover":
      case "pointerout":
        Oc.delete(b.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Pc.delete(b.pointerId);
    }
  }
  function Tc(a, b, c, d, e, f) {
    if (null === a || a.nativeEvent !== f) return a = { blockedOn: b, domEventName: c, eventSystemFlags: d, nativeEvent: f, targetContainers: [e] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
    a.eventSystemFlags |= d;
    b = a.targetContainers;
    null !== e && -1 === b.indexOf(e) && b.push(e);
    return a;
  }
  function Uc(a, b, c, d, e) {
    switch (b) {
      case "focusin":
        return Lc = Tc(Lc, a, b, c, d, e), true;
      case "dragenter":
        return Mc = Tc(Mc, a, b, c, d, e), true;
      case "mouseover":
        return Nc = Tc(Nc, a, b, c, d, e), true;
      case "pointerover":
        var f = e.pointerId;
        Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e));
        return true;
      case "gotpointercapture":
        return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)), true;
    }
    return false;
  }
  function Vc(a) {
    var b = Wc(a.target);
    if (null !== b) {
      var c = Vb(b);
      if (null !== c) {
        if (b = c.tag, 13 === b) {
          if (b = Wb(c), null !== b) {
            a.blockedOn = b;
            Ic(a.priority, function() {
              Gc(c);
            });
            return;
          }
        } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
          a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a.blockedOn = null;
  }
  function Xc(a) {
    if (null !== a.blockedOn) return false;
    for (var b = a.targetContainers; 0 < b.length; ) {
      var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
      if (null === c) {
        c = a.nativeEvent;
        var d = new c.constructor(c.type, c);
        wb = d;
        c.target.dispatchEvent(d);
        wb = null;
      } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
      b.shift();
    }
    return true;
  }
  function Zc(a, b, c) {
    Xc(a) && c.delete(b);
  }
  function $c() {
    Jc = false;
    null !== Lc && Xc(Lc) && (Lc = null);
    null !== Mc && Xc(Mc) && (Mc = null);
    null !== Nc && Xc(Nc) && (Nc = null);
    Oc.forEach(Zc);
    Pc.forEach(Zc);
  }
  function ad(a, b) {
    a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
  }
  function bd(a) {
    function b(b2) {
      return ad(b2, a);
    }
    if (0 < Kc.length) {
      ad(Kc[0], a);
      for (var c = 1; c < Kc.length; c++) {
        var d = Kc[c];
        d.blockedOn === a && (d.blockedOn = null);
      }
    }
    null !== Lc && ad(Lc, a);
    null !== Mc && ad(Mc, a);
    null !== Nc && ad(Nc, a);
    Oc.forEach(b);
    Pc.forEach(b);
    for (c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
    for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); ) Vc(c), null === c.blockedOn && Qc.shift();
  }
  var cd = ua.ReactCurrentBatchConfig, dd = true;
  function ed(a, b, c, d) {
    var e = C, f = cd.transition;
    cd.transition = null;
    try {
      C = 1, fd(a, b, c, d);
    } finally {
      C = e, cd.transition = f;
    }
  }
  function gd(a, b, c, d) {
    var e = C, f = cd.transition;
    cd.transition = null;
    try {
      C = 4, fd(a, b, c, d);
    } finally {
      C = e, cd.transition = f;
    }
  }
  function fd(a, b, c, d) {
    if (dd) {
      var e = Yc(a, b, c, d);
      if (null === e) hd(a, b, d, id, c), Sc(a, d);
      else if (Uc(e, a, b, c, d)) d.stopPropagation();
      else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
        for (; null !== e; ) {
          var f = Cb(e);
          null !== f && Ec(f);
          f = Yc(a, b, c, d);
          null === f && hd(a, b, d, id, c);
          if (f === e) break;
          e = f;
        }
        null !== e && d.stopPropagation();
      } else hd(a, b, d, null, c);
    }
  }
  var id = null;
  function Yc(a, b, c, d) {
    id = null;
    a = xb(d);
    a = Wc(a);
    if (null !== a) if (b = Vb(a), null === b) a = null;
    else if (c = b.tag, 13 === c) {
      a = Wb(b);
      if (null !== a) return a;
      a = null;
    } else if (3 === c) {
      if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
      a = null;
    } else b !== a && (a = null);
    id = a;
    return null;
  }
  function jd(a) {
    switch (a) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (ec()) {
          case fc:
            return 1;
          case gc:
            return 4;
          case hc:
          case ic:
            return 16;
          case jc:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var kd = null, ld = null, md = null;
  function nd() {
    if (md) return md;
    var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
    for (a = 0; a < c && b[a] === e[a]; a++) ;
    var g = c - a;
    for (d = 1; d <= g && b[c - d] === e[f - d]; d++) ;
    return md = e.slice(a, 1 < d ? 1 - d : void 0);
  }
  function od(a) {
    var b = a.keyCode;
    "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
    10 === a && (a = 13);
    return 32 <= a || 13 === a ? a : 0;
  }
  function pd() {
    return true;
  }
  function qd() {
    return false;
  }
  function rd(a) {
    function b(b2, d, e, f, g) {
      this._reactName = b2;
      this._targetInst = e;
      this.type = d;
      this.nativeEvent = f;
      this.target = g;
      this.currentTarget = null;
      for (var c in a) a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
      this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
      this.isPropagationStopped = qd;
      return this;
    }
    A(b.prototype, { preventDefault: function() {
      this.defaultPrevented = true;
      var a2 = this.nativeEvent;
      a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
    }, stopPropagation: function() {
      var a2 = this.nativeEvent;
      a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
    }, persist: function() {
    }, isPersistent: pd });
    return b;
  }
  var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
    return a.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
    return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
  }, movementX: function(a) {
    if ("movementX" in a) return a.movementX;
    a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
    return wd;
  }, movementY: function(a) {
    return "movementY" in a ? a.movementY : xd;
  } }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A({}, sd, { clipboardData: function(a) {
    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
  } }), Jd = rd(Id), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Pd(a) {
    var b = this.nativeEvent;
    return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
  }
  function zd() {
    return Pd;
  }
  var Qd = A({}, ud, { key: function(a) {
    if (a.key) {
      var b = Md[a.key] || a.key;
      if ("Unidentified" !== b) return b;
    }
    return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
    return "keypress" === a.type ? od(a) : 0;
  }, keyCode: function(a) {
    return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  }, which: function(a) {
    return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  } }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
    deltaX: function(a) {
      return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
    },
    deltaY: function(a) {
      return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
  ia && "documentMode" in document && (be = document.documentMode);
  var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
  function ge(a, b) {
    switch (a) {
      case "keyup":
        return -1 !== $d.indexOf(b.keyCode);
      case "keydown":
        return 229 !== b.keyCode;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function he(a) {
    a = a.detail;
    return "object" === typeof a && "data" in a ? a.data : null;
  }
  var ie = false;
  function je(a, b) {
    switch (a) {
      case "compositionend":
        return he(b);
      case "keypress":
        if (32 !== b.which) return null;
        fe = true;
        return ee;
      case "textInput":
        return a = b.data, a === ee && fe ? null : a;
      default:
        return null;
    }
  }
  function ke(a, b) {
    if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
    switch (a) {
      case "paste":
        return null;
      case "keypress":
        if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
          if (b.char && 1 < b.char.length) return b.char;
          if (b.which) return String.fromCharCode(b.which);
        }
        return null;
      case "compositionend":
        return de && "ko" !== b.locale ? null : b.data;
      default:
        return null;
    }
  }
  var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
  function me(a) {
    var b = a && a.nodeName && a.nodeName.toLowerCase();
    return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
  }
  function ne(a, b, c, d) {
    Eb(d);
    b = oe(b, "onChange");
    0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
  }
  var pe = null, qe = null;
  function re(a) {
    se(a, 0);
  }
  function te(a) {
    var b = ue(a);
    if (Wa(b)) return a;
  }
  function ve(a, b) {
    if ("change" === a) return b;
  }
  var we = false;
  if (ia) {
    var xe;
    if (ia) {
      var ye = "oninput" in document;
      if (!ye) {
        var ze = document.createElement("div");
        ze.setAttribute("oninput", "return;");
        ye = "function" === typeof ze.oninput;
      }
      xe = ye;
    } else xe = false;
    we = xe && (!document.documentMode || 9 < document.documentMode);
  }
  function Ae() {
    pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
  }
  function Be(a) {
    if ("value" === a.propertyName && te(qe)) {
      var b = [];
      ne(b, qe, a, xb(a));
      Jb(re, b);
    }
  }
  function Ce(a, b, c) {
    "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
  }
  function De(a) {
    if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
  }
  function Ee(a, b) {
    if ("click" === a) return te(b);
  }
  function Fe(a, b) {
    if ("input" === a || "change" === a) return te(b);
  }
  function Ge(a, b) {
    return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
  }
  var He = "function" === typeof Object.is ? Object.is : Ge;
  function Ie(a, b) {
    if (He(a, b)) return true;
    if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return false;
    var c = Object.keys(a), d = Object.keys(b);
    if (c.length !== d.length) return false;
    for (d = 0; d < c.length; d++) {
      var e = c[d];
      if (!ja.call(b, e) || !He(a[e], b[e])) return false;
    }
    return true;
  }
  function Je(a) {
    for (; a && a.firstChild; ) a = a.firstChild;
    return a;
  }
  function Ke(a, b) {
    var c = Je(a);
    a = 0;
    for (var d; c; ) {
      if (3 === c.nodeType) {
        d = a + c.textContent.length;
        if (a <= b && d >= b) return { node: c, offset: b - a };
        a = d;
      }
      a: {
        for (; c; ) {
          if (c.nextSibling) {
            c = c.nextSibling;
            break a;
          }
          c = c.parentNode;
        }
        c = void 0;
      }
      c = Je(c);
    }
  }
  function Le(a, b) {
    return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
  }
  function Me() {
    for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
      try {
        var c = "string" === typeof b.contentWindow.location.href;
      } catch (d) {
        c = false;
      }
      if (c) a = b.contentWindow;
      else break;
      b = Xa(a.document);
    }
    return b;
  }
  function Ne(a) {
    var b = a && a.nodeName && a.nodeName.toLowerCase();
    return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
  }
  function Oe(a) {
    var b = Me(), c = a.focusedElem, d = a.selectionRange;
    if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
      if (null !== d && Ne(c)) {
        if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
        else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
          a = a.getSelection();
          var e = c.textContent.length, f = Math.min(d.start, e);
          d = void 0 === d.end ? f : Math.min(d.end, e);
          !a.extend && f > d && (e = d, d = f, f = e);
          e = Ke(c, f);
          var g = Ke(
            c,
            d
          );
          e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
        }
      }
      b = [];
      for (a = c; a = a.parentNode; ) 1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
      "function" === typeof c.focus && c.focus();
      for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
    }
  }
  var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
  function Ue(a, b, c) {
    var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
    Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
  }
  function Ve(a, b) {
    var c = {};
    c[a.toLowerCase()] = b.toLowerCase();
    c["Webkit" + a] = "webkit" + b;
    c["Moz" + a] = "moz" + b;
    return c;
  }
  var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
  ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
  function Ze(a) {
    if (Xe[a]) return Xe[a];
    if (!We[a]) return a;
    var b = We[a], c;
    for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
    return a;
  }
  var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ff(a, b) {
    df.set(a, b);
    fa(b, [a]);
  }
  for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf);
  }
  ff($e, "onAnimationEnd");
  ff(af, "onAnimationIteration");
  ff(bf, "onAnimationStart");
  ff("dblclick", "onDoubleClick");
  ff("focusin", "onFocus");
  ff("focusout", "onBlur");
  ff(cf, "onTransitionEnd");
  ha("onMouseEnter", ["mouseout", "mouseover"]);
  ha("onMouseLeave", ["mouseout", "mouseover"]);
  ha("onPointerEnter", ["pointerout", "pointerover"]);
  ha("onPointerLeave", ["pointerout", "pointerover"]);
  fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
  fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
  function nf(a, b, c) {
    var d = a.type || "unknown-event";
    a.currentTarget = c;
    Ub(d, b, void 0, a);
    a.currentTarget = null;
  }
  function se(a, b) {
    b = 0 !== (b & 4);
    for (var c = 0; c < a.length; c++) {
      var d = a[c], e = d.event;
      d = d.listeners;
      a: {
        var f = void 0;
        if (b) for (var g = d.length - 1; 0 <= g; g--) {
          var h = d[g], k = h.instance, l = h.currentTarget;
          h = h.listener;
          if (k !== f && e.isPropagationStopped()) break a;
          nf(e, h, l);
          f = k;
        }
        else for (g = 0; g < d.length; g++) {
          h = d[g];
          k = h.instance;
          l = h.currentTarget;
          h = h.listener;
          if (k !== f && e.isPropagationStopped()) break a;
          nf(e, h, l);
          f = k;
        }
      }
    }
    if (Qb) throw a = Rb, Qb = false, Rb = null, a;
  }
  function D(a, b) {
    var c = b[of];
    void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
    var d = a + "__bubble";
    c.has(d) || (pf(b, a, 2, false), c.add(d));
  }
  function qf(a, b, c) {
    var d = 0;
    b && (d |= 4);
    pf(c, a, d, b);
  }
  var rf = "_reactListening" + Math.random().toString(36).slice(2);
  function sf(a) {
    if (!a[rf]) {
      a[rf] = true;
      da.forEach(function(b2) {
        "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
      });
      var b = 9 === a.nodeType ? a : a.ownerDocument;
      null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
    }
  }
  function pf(a, b, c, d) {
    switch (jd(b)) {
      case 1:
        var e = ed;
        break;
      case 4:
        e = gd;
        break;
      default:
        e = fd;
    }
    c = e.bind(null, b, c, a);
    e = void 0;
    !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
    d ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
  }
  function hd(a, b, c, d, e) {
    var f = d;
    if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (; ; ) {
      if (null === d) return;
      var g = d.tag;
      if (3 === g || 4 === g) {
        var h = d.stateNode.containerInfo;
        if (h === e || 8 === h.nodeType && h.parentNode === e) break;
        if (4 === g) for (g = d.return; null !== g; ) {
          var k = g.tag;
          if (3 === k || 4 === k) {
            if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
          }
          g = g.return;
        }
        for (; null !== h; ) {
          g = Wc(h);
          if (null === g) return;
          k = g.tag;
          if (5 === k || 6 === k) {
            d = f = g;
            continue a;
          }
          h = h.parentNode;
        }
      }
      d = d.return;
    }
    Jb(function() {
      var d2 = f, e2 = xb(c), g2 = [];
      a: {
        var h2 = df.get(a);
        if (void 0 !== h2) {
          var k2 = td, n = a;
          switch (a) {
            case "keypress":
              if (0 === od(c)) break a;
            case "keydown":
            case "keyup":
              k2 = Rd;
              break;
            case "focusin":
              n = "focus";
              k2 = Fd;
              break;
            case "focusout":
              n = "blur";
              k2 = Fd;
              break;
            case "beforeblur":
            case "afterblur":
              k2 = Fd;
              break;
            case "click":
              if (2 === c.button) break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              k2 = Bd;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              k2 = Dd;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              k2 = Vd;
              break;
            case $e:
            case af:
            case bf:
              k2 = Hd;
              break;
            case cf:
              k2 = Xd;
              break;
            case "scroll":
              k2 = vd;
              break;
            case "wheel":
              k2 = Zd;
              break;
            case "copy":
            case "cut":
            case "paste":
              k2 = Jd;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              k2 = Td;
          }
          var t = 0 !== (b & 4), J = !t && "scroll" === a, x = t ? null !== h2 ? h2 + "Capture" : null : h2;
          t = [];
          for (var w = d2, u; null !== w; ) {
            u = w;
            var F = u.stateNode;
            5 === u.tag && null !== F && (u = F, null !== x && (F = Kb(w, x), null != F && t.push(tf(w, F, u))));
            if (J) break;
            w = w.return;
          }
          0 < t.length && (h2 = new k2(h2, n, null, c, e2), g2.push({ event: h2, listeners: t }));
        }
      }
      if (0 === (b & 7)) {
        a: {
          h2 = "mouseover" === a || "pointerover" === a;
          k2 = "mouseout" === a || "pointerout" === a;
          if (h2 && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
          if (k2 || h2) {
            h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
            if (k2) {
              if (n = c.relatedTarget || c.toElement, k2 = d2, n = n ? Wc(n) : null, null !== n && (J = Vb(n), n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
            } else k2 = null, n = d2;
            if (k2 !== n) {
              t = Bd;
              F = "onMouseLeave";
              x = "onMouseEnter";
              w = "mouse";
              if ("pointerout" === a || "pointerover" === a) t = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer";
              J = null == k2 ? h2 : ue(k2);
              u = null == n ? h2 : ue(n);
              h2 = new t(F, w + "leave", k2, c, e2);
              h2.target = J;
              h2.relatedTarget = u;
              F = null;
              Wc(e2) === d2 && (t = new t(x, w + "enter", n, c, e2), t.target = u, t.relatedTarget = J, F = t);
              J = F;
              if (k2 && n) b: {
                t = k2;
                x = n;
                w = 0;
                for (u = t; u; u = vf(u)) w++;
                u = 0;
                for (F = x; F; F = vf(F)) u++;
                for (; 0 < w - u; ) t = vf(t), w--;
                for (; 0 < u - w; ) x = vf(x), u--;
                for (; w--; ) {
                  if (t === x || null !== x && t === x.alternate) break b;
                  t = vf(t);
                  x = vf(x);
                }
                t = null;
              }
              else t = null;
              null !== k2 && wf(g2, h2, k2, t, false);
              null !== n && null !== J && wf(g2, J, n, t, true);
            }
          }
        }
        a: {
          h2 = d2 ? ue(d2) : window;
          k2 = h2.nodeName && h2.nodeName.toLowerCase();
          if ("select" === k2 || "input" === k2 && "file" === h2.type) var na = ve;
          else if (me(h2)) if (we) na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
          else (k2 = h2.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (na = Ee);
          if (na && (na = na(a, d2))) {
            ne(g2, na, c, e2);
            break a;
          }
          xa && xa(a, h2, d2);
          "focusout" === a && (xa = h2._wrapperState) && xa.controlled && "number" === h2.type && cb(h2, "number", h2.value);
        }
        xa = d2 ? ue(d2) : window;
        switch (a) {
          case "focusin":
            if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d2, Se = null;
            break;
          case "focusout":
            Se = Re = Qe = null;
            break;
          case "mousedown":
            Te = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Te = false;
            Ue(g2, c, e2);
            break;
          case "selectionchange":
            if (Pe) break;
          case "keydown":
          case "keyup":
            Ue(g2, c, e2);
        }
        var $a;
        if (ae) b: {
          switch (a) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
        else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
        ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
        if ($a = ce ? je(a, c) : ke(a, c)) d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = $a);
      }
      se(g2, b);
    });
  }
  function tf(a, b, c) {
    return { instance: a, listener: b, currentTarget: c };
  }
  function oe(a, b) {
    for (var c = b + "Capture", d = []; null !== a; ) {
      var e = a, f = e.stateNode;
      5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d.unshift(tf(a, f, e)), f = Kb(a, b), null != f && d.push(tf(a, f, e)));
      a = a.return;
    }
    return d;
  }
  function vf(a) {
    if (null === a) return null;
    do
      a = a.return;
    while (a && 5 !== a.tag);
    return a ? a : null;
  }
  function wf(a, b, c, d, e) {
    for (var f = b._reactName, g = []; null !== c && c !== d; ) {
      var h = c, k = h.alternate, l = h.stateNode;
      if (null !== k && k === d) break;
      5 === h.tag && null !== l && (h = l, e ? (k = Kb(c, f), null != k && g.unshift(tf(c, k, h))) : e || (k = Kb(c, f), null != k && g.push(tf(c, k, h))));
      c = c.return;
    }
    0 !== g.length && a.push({ event: b, listeners: g });
  }
  var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
  function zf(a) {
    return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
  }
  function Af(a, b, c) {
    b = zf(b);
    if (zf(a) !== b && c) throw Error(p(425));
  }
  function Bf() {
  }
  var Cf = null, Df = null;
  function Ef(a, b) {
    return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
  }
  var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
    return Hf.resolve(null).then(a).catch(If);
  } : Ff;
  function If(a) {
    setTimeout(function() {
      throw a;
    });
  }
  function Kf(a, b) {
    var c = b, d = 0;
    do {
      var e = c.nextSibling;
      a.removeChild(c);
      if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
        if (0 === d) {
          a.removeChild(e);
          bd(b);
          return;
        }
        d--;
      } else "$" !== c && "$?" !== c && "$!" !== c || d++;
      c = e;
    } while (c);
    bd(b);
  }
  function Lf(a) {
    for (; null != a; a = a.nextSibling) {
      var b = a.nodeType;
      if (1 === b || 3 === b) break;
      if (8 === b) {
        b = a.data;
        if ("$" === b || "$!" === b || "$?" === b) break;
        if ("/$" === b) return null;
      }
    }
    return a;
  }
  function Mf(a) {
    a = a.previousSibling;
    for (var b = 0; a; ) {
      if (8 === a.nodeType) {
        var c = a.data;
        if ("$" === c || "$!" === c || "$?" === c) {
          if (0 === b) return a;
          b--;
        } else "/$" === c && b++;
      }
      a = a.previousSibling;
    }
    return null;
  }
  var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
  function Wc(a) {
    var b = a[Of];
    if (b) return b;
    for (var c = a.parentNode; c; ) {
      if (b = c[uf] || c[Of]) {
        c = b.alternate;
        if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a; ) {
          if (c = a[Of]) return c;
          a = Mf(a);
        }
        return b;
      }
      a = c;
      c = a.parentNode;
    }
    return null;
  }
  function Cb(a) {
    a = a[Of] || a[uf];
    return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
  }
  function ue(a) {
    if (5 === a.tag || 6 === a.tag) return a.stateNode;
    throw Error(p(33));
  }
  function Db(a) {
    return a[Pf] || null;
  }
  var Sf = [], Tf = -1;
  function Uf(a) {
    return { current: a };
  }
  function E(a) {
    0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
  }
  function G(a, b) {
    Tf++;
    Sf[Tf] = a.current;
    a.current = b;
  }
  var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
  function Yf(a, b) {
    var c = a.type.contextTypes;
    if (!c) return Vf;
    var d = a.stateNode;
    if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
    var e = {}, f;
    for (f in c) e[f] = b[f];
    d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
    return e;
  }
  function Zf(a) {
    a = a.childContextTypes;
    return null !== a && void 0 !== a;
  }
  function $f() {
    E(Wf);
    E(H);
  }
  function ag(a, b, c) {
    if (H.current !== Vf) throw Error(p(168));
    G(H, b);
    G(Wf, c);
  }
  function bg(a, b, c) {
    var d = a.stateNode;
    b = b.childContextTypes;
    if ("function" !== typeof d.getChildContext) return c;
    d = d.getChildContext();
    for (var e in d) if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
    return A({}, c, d);
  }
  function cg(a) {
    a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
    Xf = H.current;
    G(H, a);
    G(Wf, Wf.current);
    return true;
  }
  function dg(a, b, c) {
    var d = a.stateNode;
    if (!d) throw Error(p(169));
    c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
    G(Wf, c);
  }
  var eg = null, fg = false, gg = false;
  function hg(a) {
    null === eg ? eg = [a] : eg.push(a);
  }
  function ig(a) {
    fg = true;
    hg(a);
  }
  function jg() {
    if (!gg && null !== eg) {
      gg = true;
      var a = 0, b = C;
      try {
        var c = eg;
        for (C = 1; a < c.length; a++) {
          var d = c[a];
          do
            d = d(true);
          while (null !== d);
        }
        eg = null;
        fg = false;
      } catch (e) {
        throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
      } finally {
        C = b, gg = false;
      }
    }
    return null;
  }
  var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
  function tg(a, b) {
    kg[lg++] = ng;
    kg[lg++] = mg;
    mg = a;
    ng = b;
  }
  function ug(a, b, c) {
    og[pg++] = rg;
    og[pg++] = sg;
    og[pg++] = qg;
    qg = a;
    var d = rg;
    a = sg;
    var e = 32 - oc(d) - 1;
    d &= ~(1 << e);
    c += 1;
    var f = 32 - oc(b) + e;
    if (30 < f) {
      var g = e - e % 5;
      f = (d & (1 << g) - 1).toString(32);
      d >>= g;
      e -= g;
      rg = 1 << 32 - oc(b) + e | c << e | d;
      sg = f + a;
    } else rg = 1 << f | c << e | d, sg = a;
  }
  function vg(a) {
    null !== a.return && (tg(a, 1), ug(a, 1, 0));
  }
  function wg(a) {
    for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
    for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
  }
  var xg = null, yg = null, I = false, zg = null;
  function Ag(a, b) {
    var c = Bg(5, null, null, 0);
    c.elementType = "DELETED";
    c.stateNode = b;
    c.return = a;
    b = a.deletions;
    null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
  }
  function Cg(a, b) {
    switch (a.tag) {
      case 5:
        var c = a.type;
        b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
        return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
      case 6:
        return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
      case 13:
        return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
      default:
        return false;
    }
  }
  function Dg(a) {
    return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
  }
  function Eg(a) {
    if (I) {
      var b = yg;
      if (b) {
        var c = b;
        if (!Cg(a, b)) {
          if (Dg(a)) throw Error(p(418));
          b = Lf(c.nextSibling);
          var d = xg;
          b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
        }
      } else {
        if (Dg(a)) throw Error(p(418));
        a.flags = a.flags & -4097 | 2;
        I = false;
        xg = a;
      }
    }
  }
  function Fg(a) {
    for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
    xg = a;
  }
  function Gg(a) {
    if (a !== xg) return false;
    if (!I) return Fg(a), I = true, false;
    var b;
    (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
    if (b && (b = yg)) {
      if (Dg(a)) throw Hg(), Error(p(418));
      for (; b; ) Ag(a, b), b = Lf(b.nextSibling);
    }
    Fg(a);
    if (13 === a.tag) {
      a = a.memoizedState;
      a = null !== a ? a.dehydrated : null;
      if (!a) throw Error(p(317));
      a: {
        a = a.nextSibling;
        for (b = 0; a; ) {
          if (8 === a.nodeType) {
            var c = a.data;
            if ("/$" === c) {
              if (0 === b) {
                yg = Lf(a.nextSibling);
                break a;
              }
              b--;
            } else "$" !== c && "$!" !== c && "$?" !== c || b++;
          }
          a = a.nextSibling;
        }
        yg = null;
      }
    } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
    return true;
  }
  function Hg() {
    for (var a = yg; a; ) a = Lf(a.nextSibling);
  }
  function Ig() {
    yg = xg = null;
    I = false;
  }
  function Jg(a) {
    null === zg ? zg = [a] : zg.push(a);
  }
  var Kg = ua.ReactCurrentBatchConfig;
  function Lg(a, b, c) {
    a = c.ref;
    if (null !== a && "function" !== typeof a && "object" !== typeof a) {
      if (c._owner) {
        c = c._owner;
        if (c) {
          if (1 !== c.tag) throw Error(p(309));
          var d = c.stateNode;
        }
        if (!d) throw Error(p(147, a));
        var e = d, f = "" + a;
        if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
        b = function(a2) {
          var b2 = e.refs;
          null === a2 ? delete b2[f] : b2[f] = a2;
        };
        b._stringRef = f;
        return b;
      }
      if ("string" !== typeof a) throw Error(p(284));
      if (!c._owner) throw Error(p(290, a));
    }
    return a;
  }
  function Mg(a, b) {
    a = Object.prototype.toString.call(b);
    throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
  }
  function Ng(a) {
    var b = a._init;
    return b(a._payload);
  }
  function Og(a) {
    function b(b2, c2) {
      if (a) {
        var d2 = b2.deletions;
        null === d2 ? (b2.deletions = [c2], b2.flags |= 16) : d2.push(c2);
      }
    }
    function c(c2, d2) {
      if (!a) return null;
      for (; null !== d2; ) b(c2, d2), d2 = d2.sibling;
      return null;
    }
    function d(a2, b2) {
      for (a2 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
      return a2;
    }
    function e(a2, b2) {
      a2 = Pg(a2, b2);
      a2.index = 0;
      a2.sibling = null;
      return a2;
    }
    function f(b2, c2, d2) {
      b2.index = d2;
      if (!a) return b2.flags |= 1048576, c2;
      d2 = b2.alternate;
      if (null !== d2) return d2 = d2.index, d2 < c2 ? (b2.flags |= 2, c2) : d2;
      b2.flags |= 2;
      return c2;
    }
    function g(b2) {
      a && null === b2.alternate && (b2.flags |= 2);
      return b2;
    }
    function h(a2, b2, c2, d2) {
      if (null === b2 || 6 !== b2.tag) return b2 = Qg(c2, a2.mode, d2), b2.return = a2, b2;
      b2 = e(b2, c2);
      b2.return = a2;
      return b2;
    }
    function k(a2, b2, c2, d2) {
      var f2 = c2.type;
      if (f2 === ya) return m(a2, b2, c2.props.children, d2, c2.key);
      if (null !== b2 && (b2.elementType === f2 || "object" === typeof f2 && null !== f2 && f2.$$typeof === Ha && Ng(f2) === b2.type)) return d2 = e(b2, c2.props), d2.ref = Lg(a2, b2, c2), d2.return = a2, d2;
      d2 = Rg(c2.type, c2.key, c2.props, null, a2.mode, d2);
      d2.ref = Lg(a2, b2, c2);
      d2.return = a2;
      return d2;
    }
    function l(a2, b2, c2, d2) {
      if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation) return b2 = Sg(c2, a2.mode, d2), b2.return = a2, b2;
      b2 = e(b2, c2.children || []);
      b2.return = a2;
      return b2;
    }
    function m(a2, b2, c2, d2, f2) {
      if (null === b2 || 7 !== b2.tag) return b2 = Tg(c2, a2.mode, d2, f2), b2.return = a2, b2;
      b2 = e(b2, c2);
      b2.return = a2;
      return b2;
    }
    function q(a2, b2, c2) {
      if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = Qg("" + b2, a2.mode, c2), b2.return = a2, b2;
      if ("object" === typeof b2 && null !== b2) {
        switch (b2.$$typeof) {
          case va:
            return c2 = Rg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Lg(a2, null, b2), c2.return = a2, c2;
          case wa:
            return b2 = Sg(b2, a2.mode, c2), b2.return = a2, b2;
          case Ha:
            var d2 = b2._init;
            return q(a2, d2(b2._payload), c2);
        }
        if (eb(b2) || Ka(b2)) return b2 = Tg(b2, a2.mode, c2, null), b2.return = a2, b2;
        Mg(a2, b2);
      }
      return null;
    }
    function r2(a2, b2, c2, d2) {
      var e2 = null !== b2 ? b2.key : null;
      if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2) return null !== e2 ? null : h(a2, b2, "" + c2, d2);
      if ("object" === typeof c2 && null !== c2) {
        switch (c2.$$typeof) {
          case va:
            return c2.key === e2 ? k(a2, b2, c2, d2) : null;
          case wa:
            return c2.key === e2 ? l(a2, b2, c2, d2) : null;
          case Ha:
            return e2 = c2._init, r2(
              a2,
              b2,
              e2(c2._payload),
              d2
            );
        }
        if (eb(c2) || Ka(c2)) return null !== e2 ? null : m(a2, b2, c2, d2, null);
        Mg(a2, c2);
      }
      return null;
    }
    function y(a2, b2, c2, d2, e2) {
      if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2) return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
      if ("object" === typeof d2 && null !== d2) {
        switch (d2.$$typeof) {
          case va:
            return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, k(b2, a2, d2, e2);
          case wa:
            return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l(b2, a2, d2, e2);
          case Ha:
            var f2 = d2._init;
            return y(a2, b2, c2, f2(d2._payload), e2);
        }
        if (eb(d2) || Ka(d2)) return a2 = a2.get(c2) || null, m(b2, a2, d2, e2, null);
        Mg(b2, d2);
      }
      return null;
    }
    function n(e2, g2, h2, k2) {
      for (var l2 = null, m2 = null, u = g2, w = g2 = 0, x = null; null !== u && w < h2.length; w++) {
        u.index > w ? (x = u, u = null) : x = u.sibling;
        var n2 = r2(e2, u, h2[w], k2);
        if (null === n2) {
          null === u && (u = x);
          break;
        }
        a && u && null === n2.alternate && b(e2, u);
        g2 = f(n2, g2, w);
        null === m2 ? l2 = n2 : m2.sibling = n2;
        m2 = n2;
        u = x;
      }
      if (w === h2.length) return c(e2, u), I && tg(e2, w), l2;
      if (null === u) {
        for (; w < h2.length; w++) u = q(e2, h2[w], k2), null !== u && (g2 = f(u, g2, w), null === m2 ? l2 = u : m2.sibling = u, m2 = u);
        I && tg(e2, w);
        return l2;
      }
      for (u = d(e2, u); w < h2.length; w++) x = y(u, e2, w, h2[w], k2), null !== x && (a && null !== x.alternate && u.delete(null === x.key ? w : x.key), g2 = f(x, g2, w), null === m2 ? l2 = x : m2.sibling = x, m2 = x);
      a && u.forEach(function(a2) {
        return b(e2, a2);
      });
      I && tg(e2, w);
      return l2;
    }
    function t(e2, g2, h2, k2) {
      var l2 = Ka(h2);
      if ("function" !== typeof l2) throw Error(p(150));
      h2 = l2.call(h2);
      if (null == h2) throw Error(p(151));
      for (var u = l2 = null, m2 = g2, w = g2 = 0, x = null, n2 = h2.next(); null !== m2 && !n2.done; w++, n2 = h2.next()) {
        m2.index > w ? (x = m2, m2 = null) : x = m2.sibling;
        var t2 = r2(e2, m2, n2.value, k2);
        if (null === t2) {
          null === m2 && (m2 = x);
          break;
        }
        a && m2 && null === t2.alternate && b(e2, m2);
        g2 = f(t2, g2, w);
        null === u ? l2 = t2 : u.sibling = t2;
        u = t2;
        m2 = x;
      }
      if (n2.done) return c(
        e2,
        m2
      ), I && tg(e2, w), l2;
      if (null === m2) {
        for (; !n2.done; w++, n2 = h2.next()) n2 = q(e2, n2.value, k2), null !== n2 && (g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
        I && tg(e2, w);
        return l2;
      }
      for (m2 = d(e2, m2); !n2.done; w++, n2 = h2.next()) n2 = y(m2, e2, w, n2.value, k2), null !== n2 && (a && null !== n2.alternate && m2.delete(null === n2.key ? w : n2.key), g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
      a && m2.forEach(function(a2) {
        return b(e2, a2);
      });
      I && tg(e2, w);
      return l2;
    }
    function J(a2, d2, f2, h2) {
      "object" === typeof f2 && null !== f2 && f2.type === ya && null === f2.key && (f2 = f2.props.children);
      if ("object" === typeof f2 && null !== f2) {
        switch (f2.$$typeof) {
          case va:
            a: {
              for (var k2 = f2.key, l2 = d2; null !== l2; ) {
                if (l2.key === k2) {
                  k2 = f2.type;
                  if (k2 === ya) {
                    if (7 === l2.tag) {
                      c(a2, l2.sibling);
                      d2 = e(l2, f2.props.children);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    }
                  } else if (l2.elementType === k2 || "object" === typeof k2 && null !== k2 && k2.$$typeof === Ha && Ng(k2) === l2.type) {
                    c(a2, l2.sibling);
                    d2 = e(l2, f2.props);
                    d2.ref = Lg(a2, l2, f2);
                    d2.return = a2;
                    a2 = d2;
                    break a;
                  }
                  c(a2, l2);
                  break;
                } else b(a2, l2);
                l2 = l2.sibling;
              }
              f2.type === ya ? (d2 = Tg(f2.props.children, a2.mode, h2, f2.key), d2.return = a2, a2 = d2) : (h2 = Rg(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = Lg(a2, d2, f2), h2.return = a2, a2 = h2);
            }
            return g(a2);
          case wa:
            a: {
              for (l2 = f2.key; null !== d2; ) {
                if (d2.key === l2) if (4 === d2.tag && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                  c(a2, d2.sibling);
                  d2 = e(d2, f2.children || []);
                  d2.return = a2;
                  a2 = d2;
                  break a;
                } else {
                  c(a2, d2);
                  break;
                }
                else b(a2, d2);
                d2 = d2.sibling;
              }
              d2 = Sg(f2, a2.mode, h2);
              d2.return = a2;
              a2 = d2;
            }
            return g(a2);
          case Ha:
            return l2 = f2._init, J(a2, d2, l2(f2._payload), h2);
        }
        if (eb(f2)) return n(a2, d2, f2, h2);
        if (Ka(f2)) return t(a2, d2, f2, h2);
        Mg(a2, f2);
      }
      return "string" === typeof f2 && "" !== f2 || "number" === typeof f2 ? (f2 = "" + f2, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Qg(f2, a2.mode, h2), d2.return = a2, a2 = d2), g(a2)) : c(a2, d2);
    }
    return J;
  }
  var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
  function $g() {
    Zg = Yg = Xg = null;
  }
  function ah(a) {
    var b = Wg.current;
    E(Wg);
    a._currentValue = b;
  }
  function bh(a, b, c) {
    for (; null !== a; ) {
      var d = a.alternate;
      (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
      if (a === c) break;
      a = a.return;
    }
  }
  function ch(a, b) {
    Xg = a;
    Zg = Yg = null;
    a = a.dependencies;
    null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (dh = true), a.firstContext = null);
  }
  function eh(a) {
    var b = a._currentValue;
    if (Zg !== a) if (a = { context: a, memoizedValue: b, next: null }, null === Yg) {
      if (null === Xg) throw Error(p(308));
      Yg = a;
      Xg.dependencies = { lanes: 0, firstContext: a };
    } else Yg = Yg.next = a;
    return b;
  }
  var fh = null;
  function gh(a) {
    null === fh ? fh = [a] : fh.push(a);
  }
  function hh(a, b, c, d) {
    var e = b.interleaved;
    null === e ? (c.next = c, gh(b)) : (c.next = e.next, e.next = c);
    b.interleaved = c;
    return ih(a, d);
  }
  function ih(a, b) {
    a.lanes |= b;
    var c = a.alternate;
    null !== c && (c.lanes |= b);
    c = a;
    for (a = a.return; null !== a; ) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
    return 3 === c.tag ? c.stateNode : null;
  }
  var jh = false;
  function kh(a) {
    a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function lh(a, b) {
    a = a.updateQueue;
    b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
  }
  function mh(a, b) {
    return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
  }
  function nh(a, b, c) {
    var d = a.updateQueue;
    if (null === d) return null;
    d = d.shared;
    if (0 !== (K & 2)) {
      var e = d.pending;
      null === e ? b.next = b : (b.next = e.next, e.next = b);
      d.pending = b;
      return ih(a, c);
    }
    e = d.interleaved;
    null === e ? (b.next = b, gh(d)) : (b.next = e.next, e.next = b);
    d.interleaved = b;
    return ih(a, c);
  }
  function oh(a, b, c) {
    b = b.updateQueue;
    if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
      var d = b.lanes;
      d &= a.pendingLanes;
      c |= d;
      b.lanes = c;
      Cc(a, c);
    }
  }
  function ph(a, b) {
    var c = a.updateQueue, d = a.alternate;
    if (null !== d && (d = d.updateQueue, c === d)) {
      var e = null, f = null;
      c = c.firstBaseUpdate;
      if (null !== c) {
        do {
          var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
          null === f ? e = f = g : f = f.next = g;
          c = c.next;
        } while (null !== c);
        null === f ? e = f = b : f = f.next = b;
      } else e = f = b;
      c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };
      a.updateQueue = c;
      return;
    }
    a = c.lastBaseUpdate;
    null === a ? c.firstBaseUpdate = b : a.next = b;
    c.lastBaseUpdate = b;
  }
  function qh(a, b, c, d) {
    var e = a.updateQueue;
    jh = false;
    var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
    if (null !== h) {
      e.shared.pending = null;
      var k = h, l = k.next;
      k.next = null;
      null === g ? f = l : g.next = l;
      g = k;
      var m = a.alternate;
      null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
    }
    if (null !== f) {
      var q = e.baseState;
      g = 0;
      m = l = k = null;
      h = f;
      do {
        var r2 = h.lane, y = h.eventTime;
        if ((d & r2) === r2) {
          null !== m && (m = m.next = {
            eventTime: y,
            lane: 0,
            tag: h.tag,
            payload: h.payload,
            callback: h.callback,
            next: null
          });
          a: {
            var n = a, t = h;
            r2 = b;
            y = c;
            switch (t.tag) {
              case 1:
                n = t.payload;
                if ("function" === typeof n) {
                  q = n.call(y, q, r2);
                  break a;
                }
                q = n;
                break a;
              case 3:
                n.flags = n.flags & -65537 | 128;
              case 0:
                n = t.payload;
                r2 = "function" === typeof n ? n.call(y, q, r2) : n;
                if (null === r2 || void 0 === r2) break a;
                q = A({}, q, r2);
                break a;
              case 2:
                jh = true;
            }
          }
          null !== h.callback && 0 !== h.lane && (a.flags |= 64, r2 = e.effects, null === r2 ? e.effects = [h] : r2.push(h));
        } else y = { eventTime: y, lane: r2, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, null === m ? (l = m = y, k = q) : m = m.next = y, g |= r2;
        h = h.next;
        if (null === h) if (h = e.shared.pending, null === h) break;
        else r2 = h, h = r2.next, r2.next = null, e.lastBaseUpdate = r2, e.shared.pending = null;
      } while (1);
      null === m && (k = q);
      e.baseState = k;
      e.firstBaseUpdate = l;
      e.lastBaseUpdate = m;
      b = e.shared.interleaved;
      if (null !== b) {
        e = b;
        do
          g |= e.lane, e = e.next;
        while (e !== b);
      } else null === f && (e.shared.lanes = 0);
      rh |= g;
      a.lanes = g;
      a.memoizedState = q;
    }
  }
  function sh(a, b, c) {
    a = b.effects;
    b.effects = null;
    if (null !== a) for (b = 0; b < a.length; b++) {
      var d = a[b], e = d.callback;
      if (null !== e) {
        d.callback = null;
        d = c;
        if ("function" !== typeof e) throw Error(p(191, e));
        e.call(d);
      }
    }
  }
  var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
  function xh(a) {
    if (a === th) throw Error(p(174));
    return a;
  }
  function yh(a, b) {
    G(wh, b);
    G(vh, a);
    G(uh, th);
    a = b.nodeType;
    switch (a) {
      case 9:
      case 11:
        b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
        break;
      default:
        a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
    }
    E(uh);
    G(uh, b);
  }
  function zh() {
    E(uh);
    E(vh);
    E(wh);
  }
  function Ah(a) {
    xh(wh.current);
    var b = xh(uh.current);
    var c = lb(b, a.type);
    b !== c && (G(vh, a), G(uh, c));
  }
  function Bh(a) {
    vh.current === a && (E(uh), E(vh));
  }
  var L = Uf(0);
  function Ch(a) {
    for (var b = a; null !== b; ) {
      if (13 === b.tag) {
        var c = b.memoizedState;
        if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
      } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
        if (0 !== (b.flags & 128)) return b;
      } else if (null !== b.child) {
        b.child.return = b;
        b = b.child;
        continue;
      }
      if (b === a) break;
      for (; null === b.sibling; ) {
        if (null === b.return || b.return === a) return null;
        b = b.return;
      }
      b.sibling.return = b.return;
      b = b.sibling;
    }
    return null;
  }
  var Dh = [];
  function Eh() {
    for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
    Dh.length = 0;
  }
  var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
  function P() {
    throw Error(p(321));
  }
  function Mh(a, b) {
    if (null === b) return false;
    for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return false;
    return true;
  }
  function Nh(a, b, c, d, e, f) {
    Hh = f;
    M = b;
    b.memoizedState = null;
    b.updateQueue = null;
    b.lanes = 0;
    Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
    a = c(d, e);
    if (Jh) {
      f = 0;
      do {
        Jh = false;
        Kh = 0;
        if (25 <= f) throw Error(p(301));
        f += 1;
        O = N = null;
        b.updateQueue = null;
        Fh.current = Qh;
        a = c(d, e);
      } while (Jh);
    }
    Fh.current = Rh;
    b = null !== N && null !== N.next;
    Hh = 0;
    O = N = M = null;
    Ih = false;
    if (b) throw Error(p(300));
    return a;
  }
  function Sh() {
    var a = 0 !== Kh;
    Kh = 0;
    return a;
  }
  function Th() {
    var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    null === O ? M.memoizedState = O = a : O = O.next = a;
    return O;
  }
  function Uh() {
    if (null === N) {
      var a = M.alternate;
      a = null !== a ? a.memoizedState : null;
    } else a = N.next;
    var b = null === O ? M.memoizedState : O.next;
    if (null !== b) O = b, N = a;
    else {
      if (null === a) throw Error(p(310));
      N = a;
      a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
      null === O ? M.memoizedState = O = a : O = O.next = a;
    }
    return O;
  }
  function Vh(a, b) {
    return "function" === typeof b ? b(a) : b;
  }
  function Wh(a) {
    var b = Uh(), c = b.queue;
    if (null === c) throw Error(p(311));
    c.lastRenderedReducer = a;
    var d = N, e = d.baseQueue, f = c.pending;
    if (null !== f) {
      if (null !== e) {
        var g = e.next;
        e.next = f.next;
        f.next = g;
      }
      d.baseQueue = e = f;
      c.pending = null;
    }
    if (null !== e) {
      f = e.next;
      d = d.baseState;
      var h = g = null, k = null, l = f;
      do {
        var m = l.lane;
        if ((Hh & m) === m) null !== k && (k = k.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), d = l.hasEagerState ? l.eagerState : a(d, l.action);
        else {
          var q = {
            lane: m,
            action: l.action,
            hasEagerState: l.hasEagerState,
            eagerState: l.eagerState,
            next: null
          };
          null === k ? (h = k = q, g = d) : k = k.next = q;
          M.lanes |= m;
          rh |= m;
        }
        l = l.next;
      } while (null !== l && l !== f);
      null === k ? g = d : k.next = h;
      He(d, b.memoizedState) || (dh = true);
      b.memoizedState = d;
      b.baseState = g;
      b.baseQueue = k;
      c.lastRenderedState = d;
    }
    a = c.interleaved;
    if (null !== a) {
      e = a;
      do
        f = e.lane, M.lanes |= f, rh |= f, e = e.next;
      while (e !== a);
    } else null === e && (c.lanes = 0);
    return [b.memoizedState, c.dispatch];
  }
  function Xh(a) {
    var b = Uh(), c = b.queue;
    if (null === c) throw Error(p(311));
    c.lastRenderedReducer = a;
    var d = c.dispatch, e = c.pending, f = b.memoizedState;
    if (null !== e) {
      c.pending = null;
      var g = e = e.next;
      do
        f = a(f, g.action), g = g.next;
      while (g !== e);
      He(f, b.memoizedState) || (dh = true);
      b.memoizedState = f;
      null === b.baseQueue && (b.baseState = f);
      c.lastRenderedState = f;
    }
    return [f, d];
  }
  function Yh() {
  }
  function Zh(a, b) {
    var c = M, d = Uh(), e = b(), f = !He(d.memoizedState, e);
    f && (d.memoizedState = e, dh = true);
    d = d.queue;
    $h(ai.bind(null, c, d, a), [a]);
    if (d.getSnapshot !== b || f || null !== O && O.memoizedState.tag & 1) {
      c.flags |= 2048;
      bi(9, ci.bind(null, c, d, e, b), void 0, null);
      if (null === Q) throw Error(p(349));
      0 !== (Hh & 30) || di(c, b, e);
    }
    return e;
  }
  function di(a, b, c) {
    a.flags |= 16384;
    a = { getSnapshot: b, value: c };
    b = M.updateQueue;
    null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
  }
  function ci(a, b, c, d) {
    b.value = c;
    b.getSnapshot = d;
    ei(b) && fi(a);
  }
  function ai(a, b, c) {
    return c(function() {
      ei(b) && fi(a);
    });
  }
  function ei(a) {
    var b = a.getSnapshot;
    a = a.value;
    try {
      var c = b();
      return !He(a, c);
    } catch (d) {
      return true;
    }
  }
  function fi(a) {
    var b = ih(a, 1);
    null !== b && gi(b, a, 1, -1);
  }
  function hi(a) {
    var b = Th();
    "function" === typeof a && (a = a());
    b.memoizedState = b.baseState = a;
    a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a };
    b.queue = a;
    a = a.dispatch = ii.bind(null, M, a);
    return [b.memoizedState, a];
  }
  function bi(a, b, c, d) {
    a = { tag: a, create: b, destroy: c, deps: d, next: null };
    b = M.updateQueue;
    null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
    return a;
  }
  function ji() {
    return Uh().memoizedState;
  }
  function ki(a, b, c, d) {
    var e = Th();
    M.flags |= a;
    e.memoizedState = bi(1 | b, c, void 0, void 0 === d ? null : d);
  }
  function li(a, b, c, d) {
    var e = Uh();
    d = void 0 === d ? null : d;
    var f = void 0;
    if (null !== N) {
      var g = N.memoizedState;
      f = g.destroy;
      if (null !== d && Mh(d, g.deps)) {
        e.memoizedState = bi(b, c, f, d);
        return;
      }
    }
    M.flags |= a;
    e.memoizedState = bi(1 | b, c, f, d);
  }
  function mi(a, b) {
    return ki(8390656, 8, a, b);
  }
  function $h(a, b) {
    return li(2048, 8, a, b);
  }
  function ni(a, b) {
    return li(4, 2, a, b);
  }
  function oi(a, b) {
    return li(4, 4, a, b);
  }
  function pi(a, b) {
    if ("function" === typeof b) return a = a(), b(a), function() {
      b(null);
    };
    if (null !== b && void 0 !== b) return a = a(), b.current = a, function() {
      b.current = null;
    };
  }
  function qi(a, b, c) {
    c = null !== c && void 0 !== c ? c.concat([a]) : null;
    return li(4, 4, pi.bind(null, b, a), c);
  }
  function ri() {
  }
  function si(a, b) {
    var c = Uh();
    b = void 0 === b ? null : b;
    var d = c.memoizedState;
    if (null !== d && null !== b && Mh(b, d[1])) return d[0];
    c.memoizedState = [a, b];
    return a;
  }
  function ti(a, b) {
    var c = Uh();
    b = void 0 === b ? null : b;
    var d = c.memoizedState;
    if (null !== d && null !== b && Mh(b, d[1])) return d[0];
    a = a();
    c.memoizedState = [a, b];
    return a;
  }
  function ui(a, b, c) {
    if (0 === (Hh & 21)) return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c;
    He(c, b) || (c = yc(), M.lanes |= c, rh |= c, a.baseState = true);
    return b;
  }
  function vi(a, b) {
    var c = C;
    C = 0 !== c && 4 > c ? c : 4;
    a(true);
    var d = Gh.transition;
    Gh.transition = {};
    try {
      a(false), b();
    } finally {
      C = c, Gh.transition = d;
    }
  }
  function wi() {
    return Uh().memoizedState;
  }
  function xi(a, b, c) {
    var d = yi(a);
    c = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
    if (zi(a)) Ai(b, c);
    else if (c = hh(a, b, c, d), null !== c) {
      var e = R();
      gi(c, a, d, e);
      Bi(c, b, d);
    }
  }
  function ii(a, b, c) {
    var d = yi(a), e = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
    if (zi(a)) Ai(b, e);
    else {
      var f = a.alternate;
      if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
        var g = b.lastRenderedState, h = f(g, c);
        e.hasEagerState = true;
        e.eagerState = h;
        if (He(h, g)) {
          var k = b.interleaved;
          null === k ? (e.next = e, gh(b)) : (e.next = k.next, k.next = e);
          b.interleaved = e;
          return;
        }
      } catch (l) {
      } finally {
      }
      c = hh(a, b, e, d);
      null !== c && (e = R(), gi(c, a, d, e), Bi(c, b, d));
    }
  }
  function zi(a) {
    var b = a.alternate;
    return a === M || null !== b && b === M;
  }
  function Ai(a, b) {
    Jh = Ih = true;
    var c = a.pending;
    null === c ? b.next = b : (b.next = c.next, c.next = b);
    a.pending = b;
  }
  function Bi(a, b, c) {
    if (0 !== (c & 4194240)) {
      var d = b.lanes;
      d &= a.pendingLanes;
      c |= d;
      b.lanes = c;
      Cc(a, c);
    }
  }
  var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a, b) {
    Th().memoizedState = [a, void 0 === b ? null : b];
    return a;
  }, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b, c) {
    c = null !== c && void 0 !== c ? c.concat([a]) : null;
    return ki(
      4194308,
      4,
      pi.bind(null, b, a),
      c
    );
  }, useLayoutEffect: function(a, b) {
    return ki(4194308, 4, a, b);
  }, useInsertionEffect: function(a, b) {
    return ki(4, 2, a, b);
  }, useMemo: function(a, b) {
    var c = Th();
    b = void 0 === b ? null : b;
    a = a();
    c.memoizedState = [a, b];
    return a;
  }, useReducer: function(a, b, c) {
    var d = Th();
    b = void 0 !== c ? c(b) : b;
    d.memoizedState = d.baseState = b;
    a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
    d.queue = a;
    a = a.dispatch = xi.bind(null, M, a);
    return [d.memoizedState, a];
  }, useRef: function(a) {
    var b = Th();
    a = { current: a };
    return b.memoizedState = a;
  }, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
    return Th().memoizedState = a;
  }, useTransition: function() {
    var a = hi(false), b = a[0];
    a = vi.bind(null, a[1]);
    Th().memoizedState = a;
    return [b, a];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(a, b, c) {
    var d = M, e = Th();
    if (I) {
      if (void 0 === c) throw Error(p(407));
      c = c();
    } else {
      c = b();
      if (null === Q) throw Error(p(349));
      0 !== (Hh & 30) || di(d, b, c);
    }
    e.memoizedState = c;
    var f = { value: c, getSnapshot: b };
    e.queue = f;
    mi(ai.bind(
      null,
      d,
      f,
      a
    ), [a]);
    d.flags |= 2048;
    bi(9, ci.bind(null, d, f, c, b), void 0, null);
    return c;
  }, useId: function() {
    var a = Th(), b = Q.identifierPrefix;
    if (I) {
      var c = sg;
      var d = rg;
      c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
      b = ":" + b + "R" + c;
      c = Kh++;
      0 < c && (b += "H" + c.toString(32));
      b += ":";
    } else c = Lh++, b = ":" + b + "r" + c.toString(32) + ":";
    return a.memoizedState = b;
  }, unstable_isNewReconciler: false }, Ph = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Wh,
    useRef: ji,
    useState: function() {
      return Wh(Vh);
    },
    useDebugValue: ri,
    useDeferredValue: function(a) {
      var b = Uh();
      return ui(b, N.memoizedState, a);
    },
    useTransition: function() {
      var a = Wh(Vh)[0], b = Uh().memoizedState;
      return [a, b];
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: false
  }, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
    return Xh(Vh);
  }, useDebugValue: ri, useDeferredValue: function(a) {
    var b = Uh();
    return null === N ? b.memoizedState = a : ui(b, N.memoizedState, a);
  }, useTransition: function() {
    var a = Xh(Vh)[0], b = Uh().memoizedState;
    return [a, b];
  }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
  function Ci(a, b) {
    if (a && a.defaultProps) {
      b = A({}, b);
      a = a.defaultProps;
      for (var c in a) void 0 === b[c] && (b[c] = a[c]);
      return b;
    }
    return b;
  }
  function Di(a, b, c, d) {
    b = a.memoizedState;
    c = c(d, b);
    c = null === c || void 0 === c ? b : A({}, b, c);
    a.memoizedState = c;
    0 === a.lanes && (a.updateQueue.baseState = c);
  }
  var Ei = { isMounted: function(a) {
    return (a = a._reactInternals) ? Vb(a) === a : false;
  }, enqueueSetState: function(a, b, c) {
    a = a._reactInternals;
    var d = R(), e = yi(a), f = mh(d, e);
    f.payload = b;
    void 0 !== c && null !== c && (f.callback = c);
    b = nh(a, f, e);
    null !== b && (gi(b, a, e, d), oh(b, a, e));
  }, enqueueReplaceState: function(a, b, c) {
    a = a._reactInternals;
    var d = R(), e = yi(a), f = mh(d, e);
    f.tag = 1;
    f.payload = b;
    void 0 !== c && null !== c && (f.callback = c);
    b = nh(a, f, e);
    null !== b && (gi(b, a, e, d), oh(b, a, e));
  }, enqueueForceUpdate: function(a, b) {
    a = a._reactInternals;
    var c = R(), d = yi(a), e = mh(c, d);
    e.tag = 2;
    void 0 !== b && null !== b && (e.callback = b);
    b = nh(a, e, d);
    null !== b && (gi(b, a, d, c), oh(b, a, d));
  } };
  function Fi(a, b, c, d, e, f, g) {
    a = a.stateNode;
    return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f) : true;
  }
  function Gi(a, b, c) {
    var d = false, e = Vf;
    var f = b.contextType;
    "object" === typeof f && null !== f ? f = eh(f) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
    b = new b(c, f);
    a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
    b.updater = Ei;
    a.stateNode = b;
    b._reactInternals = a;
    d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
    return b;
  }
  function Hi(a, b, c, d) {
    a = b.state;
    "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
    "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
    b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
  }
  function Ii(a, b, c, d) {
    var e = a.stateNode;
    e.props = c;
    e.state = a.memoizedState;
    e.refs = {};
    kh(a);
    var f = b.contextType;
    "object" === typeof f && null !== f ? e.context = eh(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a, f));
    e.state = a.memoizedState;
    f = b.getDerivedStateFromProps;
    "function" === typeof f && (Di(a, b, f, c), e.state = a.memoizedState);
    "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a, c, e, d), e.state = a.memoizedState);
    "function" === typeof e.componentDidMount && (a.flags |= 4194308);
  }
  function Ji(a, b) {
    try {
      var c = "", d = b;
      do
        c += Pa(d), d = d.return;
      while (d);
      var e = c;
    } catch (f) {
      e = "\nError generating stack: " + f.message + "\n" + f.stack;
    }
    return { value: a, source: b, stack: e, digest: null };
  }
  function Ki(a, b, c) {
    return { value: a, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
  }
  function Li(a, b) {
    try {
      console.error(b.value);
    } catch (c) {
      setTimeout(function() {
        throw c;
      });
    }
  }
  var Mi = "function" === typeof WeakMap ? WeakMap : Map;
  function Ni(a, b, c) {
    c = mh(-1, c);
    c.tag = 3;
    c.payload = { element: null };
    var d = b.value;
    c.callback = function() {
      Oi || (Oi = true, Pi = d);
      Li(a, b);
    };
    return c;
  }
  function Qi(a, b, c) {
    c = mh(-1, c);
    c.tag = 3;
    var d = a.type.getDerivedStateFromError;
    if ("function" === typeof d) {
      var e = b.value;
      c.payload = function() {
        return d(e);
      };
      c.callback = function() {
        Li(a, b);
      };
    }
    var f = a.stateNode;
    null !== f && "function" === typeof f.componentDidCatch && (c.callback = function() {
      Li(a, b);
      "function" !== typeof d && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
      var c2 = b.stack;
      this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
    });
    return c;
  }
  function Si(a, b, c) {
    var d = a.pingCache;
    if (null === d) {
      d = a.pingCache = new Mi();
      var e = /* @__PURE__ */ new Set();
      d.set(b, e);
    } else e = d.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d.set(b, e));
    e.has(c) || (e.add(c), a = Ti.bind(null, a, b, c), b.then(a, a));
  }
  function Ui(a) {
    do {
      var b;
      if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
      if (b) return a;
      a = a.return;
    } while (null !== a);
    return null;
  }
  function Vi(a, b, c, d, e) {
    if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c, b, 1))), c.lanes |= 1), a;
    a.flags |= 65536;
    a.lanes = e;
    return a;
  }
  var Wi = ua.ReactCurrentOwner, dh = false;
  function Xi(a, b, c, d) {
    b.child = null === a ? Vg(b, null, c, d) : Ug(b, a.child, c, d);
  }
  function Yi(a, b, c, d, e) {
    c = c.render;
    var f = b.ref;
    ch(b, e);
    d = Nh(a, b, c, d, f, e);
    c = Sh();
    if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
    I && c && vg(b);
    b.flags |= 1;
    Xi(a, b, d, e);
    return b.child;
  }
  function $i(a, b, c, d, e) {
    if (null === a) {
      var f = c.type;
      if ("function" === typeof f && !aj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, bj(a, b, f, d, e);
      a = Rg(c.type, null, d, b, b.mode, e);
      a.ref = b.ref;
      a.return = b;
      return b.child = a;
    }
    f = a.child;
    if (0 === (a.lanes & e)) {
      var g = f.memoizedProps;
      c = c.compare;
      c = null !== c ? c : Ie;
      if (c(g, d) && a.ref === b.ref) return Zi(a, b, e);
    }
    b.flags |= 1;
    a = Pg(f, d);
    a.ref = b.ref;
    a.return = b;
    return b.child = a;
  }
  function bj(a, b, c, d, e) {
    if (null !== a) {
      var f = a.memoizedProps;
      if (Ie(f, d) && a.ref === b.ref) if (dh = false, b.pendingProps = d = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (dh = true);
      else return b.lanes = a.lanes, Zi(a, b, e);
    }
    return cj(a, b, c, d, e);
  }
  function dj(a, b, c) {
    var d = b.pendingProps, e = d.children, f = null !== a ? a.memoizedState : null;
    if ("hidden" === d.mode) if (0 === (b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c;
    else {
      if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(ej, fj), fj |= a, null;
      b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d = null !== f ? f.baseLanes : c;
      G(ej, fj);
      fj |= d;
    }
    else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G(ej, fj), fj |= d;
    Xi(a, b, e, c);
    return b.child;
  }
  function gj(a, b) {
    var c = b.ref;
    if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
  }
  function cj(a, b, c, d, e) {
    var f = Zf(c) ? Xf : H.current;
    f = Yf(b, f);
    ch(b, e);
    c = Nh(a, b, c, d, f, e);
    d = Sh();
    if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
    I && d && vg(b);
    b.flags |= 1;
    Xi(a, b, c, e);
    return b.child;
  }
  function hj(a, b, c, d, e) {
    if (Zf(c)) {
      var f = true;
      cg(b);
    } else f = false;
    ch(b, e);
    if (null === b.stateNode) ij(a, b), Gi(b, c, d), Ii(b, c, d, e), d = true;
    else if (null === a) {
      var g = b.stateNode, h = b.memoizedProps;
      g.props = h;
      var k = g.context, l = c.contextType;
      "object" === typeof l && null !== l ? l = eh(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
      var m = c.getDerivedStateFromProps, q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
      q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Hi(b, g, d, l);
      jh = false;
      var r2 = b.memoizedState;
      g.state = r2;
      qh(b, d, g, e);
      k = b.memoizedState;
      h !== d || r2 !== k || Wf.current || jh ? ("function" === typeof m && (Di(b, c, m, d), k = b.memoizedState), (h = jh || Fi(b, c, h, d, r2, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
    } else {
      g = b.stateNode;
      lh(a, b);
      h = b.memoizedProps;
      l = b.type === b.elementType ? h : Ci(b.type, h);
      g.props = l;
      q = b.pendingProps;
      r2 = g.context;
      k = c.contextType;
      "object" === typeof k && null !== k ? k = eh(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
      var y = c.getDerivedStateFromProps;
      (m = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r2 !== k) && Hi(b, g, d, k);
      jh = false;
      r2 = b.memoizedState;
      g.state = r2;
      qh(b, d, g, e);
      var n = b.memoizedState;
      h !== q || r2 !== n || Wf.current || jh ? ("function" === typeof y && (Di(b, c, y, d), n = b.memoizedState), (l = jh || Fi(b, c, l, d, r2, n, k) || false) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 1024), d = false);
    }
    return jj(a, b, c, d, f, e);
  }
  function jj(a, b, c, d, e, f) {
    gj(a, b);
    var g = 0 !== (b.flags & 128);
    if (!d && !g) return e && dg(b, c, false), Zi(a, b, f);
    d = b.stateNode;
    Wi.current = b;
    var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
    b.flags |= 1;
    null !== a && g ? (b.child = Ug(b, a.child, null, f), b.child = Ug(b, null, h, f)) : Xi(a, b, h, f);
    b.memoizedState = d.state;
    e && dg(b, c, true);
    return b.child;
  }
  function kj(a) {
    var b = a.stateNode;
    b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
    yh(a, b.containerInfo);
  }
  function lj(a, b, c, d, e) {
    Ig();
    Jg(e);
    b.flags |= 256;
    Xi(a, b, c, d);
    return b.child;
  }
  var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
  function nj(a) {
    return { baseLanes: a, cachePool: null, transitions: null };
  }
  function oj(a, b, c) {
    var d = b.pendingProps, e = L.current, f = false, g = 0 !== (b.flags & 128), h;
    (h = g) || (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
    if (h) f = true, b.flags &= -129;
    else if (null === a || null !== a.memoizedState) e |= 1;
    G(L, e & 1);
    if (null === a) {
      Eg(b);
      a = b.memoizedState;
      if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
      g = d.children;
      a = d.fallback;
      return f ? (d = b.mode, f = b.child, g = { mode: "hidden", children: g }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = pj(g, d, 0, null), a = Tg(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = nj(c), b.memoizedState = mj, a) : qj(b, g);
    }
    e = a.memoizedState;
    if (null !== e && (h = e.dehydrated, null !== h)) return rj(a, b, g, d, h, e, c);
    if (f) {
      f = d.fallback;
      g = b.mode;
      e = a.child;
      h = e.sibling;
      var k = { mode: "hidden", children: d.children };
      0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = Pg(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
      null !== h ? f = Pg(h, f) : (f = Tg(f, g, c, null), f.flags |= 2);
      f.return = b;
      d.return = b;
      d.sibling = f;
      b.child = d;
      d = f;
      f = b.child;
      g = a.child.memoizedState;
      g = null === g ? nj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions };
      f.memoizedState = g;
      f.childLanes = a.childLanes & ~c;
      b.memoizedState = mj;
      return d;
    }
    f = a.child;
    a = f.sibling;
    d = Pg(f, { mode: "visible", children: d.children });
    0 === (b.mode & 1) && (d.lanes = c);
    d.return = b;
    d.sibling = null;
    null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
    b.child = d;
    b.memoizedState = null;
    return d;
  }
  function qj(a, b) {
    b = pj({ mode: "visible", children: b }, a.mode, 0, null);
    b.return = a;
    return a.child = b;
  }
  function sj(a, b, c, d) {
    null !== d && Jg(d);
    Ug(b, a.child, null, c);
    a = qj(b, b.pendingProps.children);
    a.flags |= 2;
    b.memoizedState = null;
    return a;
  }
  function rj(a, b, c, d, e, f, g) {
    if (c) {
      if (b.flags & 256) return b.flags &= -257, d = Ki(Error(p(422))), sj(a, b, g, d);
      if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
      f = d.fallback;
      e = b.mode;
      d = pj({ mode: "visible", children: d.children }, e, 0, null);
      f = Tg(f, e, g, null);
      f.flags |= 2;
      d.return = b;
      f.return = b;
      d.sibling = f;
      b.child = d;
      0 !== (b.mode & 1) && Ug(b, a.child, null, g);
      b.child.memoizedState = nj(g);
      b.memoizedState = mj;
      return f;
    }
    if (0 === (b.mode & 1)) return sj(a, b, g, null);
    if ("$!" === e.data) {
      d = e.nextSibling && e.nextSibling.dataset;
      if (d) var h = d.dgst;
      d = h;
      f = Error(p(419));
      d = Ki(f, d, void 0);
      return sj(a, b, g, d);
    }
    h = 0 !== (g & a.childLanes);
    if (dh || h) {
      d = Q;
      if (null !== d) {
        switch (g & -g) {
          case 4:
            e = 2;
            break;
          case 16:
            e = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            e = 32;
            break;
          case 536870912:
            e = 268435456;
            break;
          default:
            e = 0;
        }
        e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
        0 !== e && e !== f.retryLane && (f.retryLane = e, ih(a, e), gi(d, a, e, -1));
      }
      tj();
      d = Ki(Error(p(421)));
      return sj(a, b, g, d);
    }
    if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = uj.bind(null, a), e._reactRetry = b, null;
    a = f.treeContext;
    yg = Lf(e.nextSibling);
    xg = b;
    I = true;
    zg = null;
    null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
    b = qj(b, d.children);
    b.flags |= 4096;
    return b;
  }
  function vj(a, b, c) {
    a.lanes |= b;
    var d = a.alternate;
    null !== d && (d.lanes |= b);
    bh(a.return, b, c);
  }
  function wj(a, b, c, d, e) {
    var f = a.memoizedState;
    null === f ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
  }
  function xj(a, b, c) {
    var d = b.pendingProps, e = d.revealOrder, f = d.tail;
    Xi(a, b, d.children, c);
    d = L.current;
    if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;
    else {
      if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a; ) {
        if (13 === a.tag) null !== a.memoizedState && vj(a, c, b);
        else if (19 === a.tag) vj(a, c, b);
        else if (null !== a.child) {
          a.child.return = a;
          a = a.child;
          continue;
        }
        if (a === b) break a;
        for (; null === a.sibling; ) {
          if (null === a.return || a.return === b) break a;
          a = a.return;
        }
        a.sibling.return = a.return;
        a = a.sibling;
      }
      d &= 1;
    }
    G(L, d);
    if (0 === (b.mode & 1)) b.memoizedState = null;
    else switch (e) {
      case "forwards":
        c = b.child;
        for (e = null; null !== c; ) a = c.alternate, null !== a && null === Ch(a) && (e = c), c = c.sibling;
        c = e;
        null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
        wj(b, false, e, c, f);
        break;
      case "backwards":
        c = null;
        e = b.child;
        for (b.child = null; null !== e; ) {
          a = e.alternate;
          if (null !== a && null === Ch(a)) {
            b.child = e;
            break;
          }
          a = e.sibling;
          e.sibling = c;
          c = e;
          e = a;
        }
        wj(b, true, c, null, f);
        break;
      case "together":
        wj(b, false, null, null, void 0);
        break;
      default:
        b.memoizedState = null;
    }
    return b.child;
  }
  function ij(a, b) {
    0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
  }
  function Zi(a, b, c) {
    null !== a && (b.dependencies = a.dependencies);
    rh |= b.lanes;
    if (0 === (c & b.childLanes)) return null;
    if (null !== a && b.child !== a.child) throw Error(p(153));
    if (null !== b.child) {
      a = b.child;
      c = Pg(a, a.pendingProps);
      b.child = c;
      for (c.return = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = Pg(a, a.pendingProps), c.return = b;
      c.sibling = null;
    }
    return b.child;
  }
  function yj(a, b, c) {
    switch (b.tag) {
      case 3:
        kj(b);
        Ig();
        break;
      case 5:
        Ah(b);
        break;
      case 1:
        Zf(b.type) && cg(b);
        break;
      case 4:
        yh(b, b.stateNode.containerInfo);
        break;
      case 10:
        var d = b.type._context, e = b.memoizedProps.value;
        G(Wg, d._currentValue);
        d._currentValue = e;
        break;
      case 13:
        d = b.memoizedState;
        if (null !== d) {
          if (null !== d.dehydrated) return G(L, L.current & 1), b.flags |= 128, null;
          if (0 !== (c & b.child.childLanes)) return oj(a, b, c);
          G(L, L.current & 1);
          a = Zi(a, b, c);
          return null !== a ? a.sibling : null;
        }
        G(L, L.current & 1);
        break;
      case 19:
        d = 0 !== (c & b.childLanes);
        if (0 !== (a.flags & 128)) {
          if (d) return xj(a, b, c);
          b.flags |= 128;
        }
        e = b.memoizedState;
        null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
        G(L, L.current);
        if (d) break;
        else return null;
      case 22:
      case 23:
        return b.lanes = 0, dj(a, b, c);
    }
    return Zi(a, b, c);
  }
  var zj, Aj, Bj, Cj;
  zj = function(a, b) {
    for (var c = b.child; null !== c; ) {
      if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
      else if (4 !== c.tag && null !== c.child) {
        c.child.return = c;
        c = c.child;
        continue;
      }
      if (c === b) break;
      for (; null === c.sibling; ) {
        if (null === c.return || c.return === b) return;
        c = c.return;
      }
      c.sibling.return = c.return;
      c = c.sibling;
    }
  };
  Aj = function() {
  };
  Bj = function(a, b, c, d) {
    var e = a.memoizedProps;
    if (e !== d) {
      a = b.stateNode;
      xh(uh.current);
      var f = null;
      switch (c) {
        case "input":
          e = Ya(a, e);
          d = Ya(a, d);
          f = [];
          break;
        case "select":
          e = A({}, e, { value: void 0 });
          d = A({}, d, { value: void 0 });
          f = [];
          break;
        case "textarea":
          e = gb(a, e);
          d = gb(a, d);
          f = [];
          break;
        default:
          "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
      }
      ub(c, d);
      var g;
      c = null;
      for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
        var h = e[l];
        for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
      } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
      for (l in d) {
        var k = d[l];
        h = null != e ? e[l] : void 0;
        if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) if (h) {
          for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
          for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
        } else c || (f || (f = []), f.push(
          l,
          c
        )), c = k;
        else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
      }
      c && (f = f || []).push("style", c);
      var l = f;
      if (b.updateQueue = l) b.flags |= 4;
    }
  };
  Cj = function(a, b, c, d) {
    c !== d && (b.flags |= 4);
  };
  function Dj(a, b) {
    if (!I) switch (a.tailMode) {
      case "hidden":
        b = a.tail;
        for (var c = null; null !== b; ) null !== b.alternate && (c = b), b = b.sibling;
        null === c ? a.tail = null : c.sibling = null;
        break;
      case "collapsed":
        c = a.tail;
        for (var d = null; null !== c; ) null !== c.alternate && (d = c), c = c.sibling;
        null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
    }
  }
  function S(a) {
    var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
    if (b) for (var e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
    else for (e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
    a.subtreeFlags |= d;
    a.childLanes = c;
    return b;
  }
  function Ej(a, b, c) {
    var d = b.pendingProps;
    wg(b);
    switch (b.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return S(b), null;
      case 1:
        return Zf(b.type) && $f(), S(b), null;
      case 3:
        d = b.stateNode;
        zh();
        E(Wf);
        E(H);
        Eh();
        d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
        if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Fj(zg), zg = null));
        Aj(a, b);
        S(b);
        return null;
      case 5:
        Bh(b);
        var e = xh(wh.current);
        c = b.type;
        if (null !== a && null != b.stateNode) Bj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
        else {
          if (!d) {
            if (null === b.stateNode) throw Error(p(166));
            S(b);
            return null;
          }
          a = xh(uh.current);
          if (Gg(b)) {
            d = b.stateNode;
            c = b.type;
            var f = b.memoizedProps;
            d[Of] = b;
            d[Pf] = f;
            a = 0 !== (b.mode & 1);
            switch (c) {
              case "dialog":
                D("cancel", d);
                D("close", d);
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", d);
                break;
              case "video":
              case "audio":
                for (e = 0; e < lf.length; e++) D(lf[e], d);
                break;
              case "source":
                D("error", d);
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  d
                );
                D("load", d);
                break;
              case "details":
                D("toggle", d);
                break;
              case "input":
                Za(d, f);
                D("invalid", d);
                break;
              case "select":
                d._wrapperState = { wasMultiple: !!f.multiple };
                D("invalid", d);
                break;
              case "textarea":
                hb(d, f), D("invalid", d);
            }
            ub(c, f);
            e = null;
            for (var g in f) if (f.hasOwnProperty(g)) {
              var h = f[g];
              "children" === g ? "string" === typeof h ? d.textContent !== h && (true !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (true !== f.suppressHydrationWarning && Af(
                d.textContent,
                h,
                a
              ), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
            }
            switch (c) {
              case "input":
                Va(d);
                db(d, f, true);
                break;
              case "textarea":
                Va(d);
                jb(d);
                break;
              case "select":
              case "option":
                break;
              default:
                "function" === typeof f.onClick && (d.onclick = Bf);
            }
            d = e;
            b.updateQueue = d;
            null !== d && (b.flags |= 4);
          } else {
            g = 9 === e.nodeType ? e : e.ownerDocument;
            "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
            "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
            a[Of] = b;
            a[Pf] = d;
            zj(a, b, false, false);
            b.stateNode = a;
            a: {
              g = vb(c, d);
              switch (c) {
                case "dialog":
                  D("cancel", a);
                  D("close", a);
                  e = d;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", a);
                  e = d;
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < lf.length; e++) D(lf[e], a);
                  e = d;
                  break;
                case "source":
                  D("error", a);
                  e = d;
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    a
                  );
                  D("load", a);
                  e = d;
                  break;
                case "details":
                  D("toggle", a);
                  e = d;
                  break;
                case "input":
                  Za(a, d);
                  e = Ya(a, d);
                  D("invalid", a);
                  break;
                case "option":
                  e = d;
                  break;
                case "select":
                  a._wrapperState = { wasMultiple: !!d.multiple };
                  e = A({}, d, { value: void 0 });
                  D("invalid", a);
                  break;
                case "textarea":
                  hb(a, d);
                  e = gb(a, d);
                  D("invalid", a);
                  break;
                default:
                  e = d;
              }
              ub(c, e);
              h = e;
              for (f in h) if (h.hasOwnProperty(f)) {
                var k = h[f];
                "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a) : null != k && ta(a, f, k, g));
              }
              switch (c) {
                case "input":
                  Va(a);
                  db(a, d, false);
                  break;
                case "textarea":
                  Va(a);
                  jb(a);
                  break;
                case "option":
                  null != d.value && a.setAttribute("value", "" + Sa(d.value));
                  break;
                case "select":
                  a.multiple = !!d.multiple;
                  f = d.value;
                  null != f ? fb(a, !!d.multiple, f, false) : null != d.defaultValue && fb(
                    a,
                    !!d.multiple,
                    d.defaultValue,
                    true
                  );
                  break;
                default:
                  "function" === typeof e.onClick && (a.onclick = Bf);
              }
              switch (c) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  d = !!d.autoFocus;
                  break a;
                case "img":
                  d = true;
                  break a;
                default:
                  d = false;
              }
            }
            d && (b.flags |= 4);
          }
          null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
        }
        S(b);
        return null;
      case 6:
        if (a && null != b.stateNode) Cj(a, b, a.memoizedProps, d);
        else {
          if ("string" !== typeof d && null === b.stateNode) throw Error(p(166));
          c = xh(wh.current);
          xh(uh.current);
          if (Gg(b)) {
            d = b.stateNode;
            c = b.memoizedProps;
            d[Of] = b;
            if (f = d.nodeValue !== c) {
              if (a = xg, null !== a) switch (a.tag) {
                case 3:
                  Af(d.nodeValue, c, 0 !== (a.mode & 1));
                  break;
                case 5:
                  true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
              }
            }
            f && (b.flags |= 4);
          } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
        }
        S(b);
        return null;
      case 13:
        E(L);
        d = b.memoizedState;
        if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
          if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = false;
          else if (f = Gg(b), null !== d && null !== d.dehydrated) {
            if (null === a) {
              if (!f) throw Error(p(318));
              f = b.memoizedState;
              f = null !== f ? f.dehydrated : null;
              if (!f) throw Error(p(317));
              f[Of] = b;
            } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
            S(b);
            f = false;
          } else null !== zg && (Fj(zg), zg = null), f = true;
          if (!f) return b.flags & 65536 ? b : null;
        }
        if (0 !== (b.flags & 128)) return b.lanes = c, b;
        d = null !== d;
        d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
        null !== b.updateQueue && (b.flags |= 4);
        S(b);
        return null;
      case 4:
        return zh(), Aj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
      case 10:
        return ah(b.type._context), S(b), null;
      case 17:
        return Zf(b.type) && $f(), S(b), null;
      case 19:
        E(L);
        f = b.memoizedState;
        if (null === f) return S(b), null;
        d = 0 !== (b.flags & 128);
        g = f.rendering;
        if (null === g) if (d) Dj(f, false);
        else {
          if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a; ) {
            g = Ch(a);
            if (null !== g) {
              b.flags |= 128;
              Dj(f, false);
              d = g.updateQueue;
              null !== d && (b.updateQueue = d, b.flags |= 4);
              b.subtreeFlags = 0;
              d = c;
              for (c = b.child; null !== c; ) f = c, a = d, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
              G(L, L.current & 1 | 2);
              return b.child;
            }
            a = a.sibling;
          }
          null !== f.tail && B() > Gj && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
        }
        else {
          if (!d) if (a = Ch(g), null !== a) {
            if (b.flags |= 128, d = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Dj(f, true), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), null;
          } else 2 * B() - f.renderingStartTime > Gj && 1073741824 !== c && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
          f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
        }
        if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = L.current, G(L, d ? c & 1 | 2 : c & 1), b;
        S(b);
        return null;
      case 22:
      case 23:
        return Hj(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(p(156, b.tag));
  }
  function Ij(a, b) {
    wg(b);
    switch (b.tag) {
      case 1:
        return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
      case 3:
        return zh(), E(Wf), E(H), Eh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
      case 5:
        return Bh(b), null;
      case 13:
        E(L);
        a = b.memoizedState;
        if (null !== a && null !== a.dehydrated) {
          if (null === b.alternate) throw Error(p(340));
          Ig();
        }
        a = b.flags;
        return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
      case 19:
        return E(L), null;
      case 4:
        return zh(), null;
      case 10:
        return ah(b.type._context), null;
      case 22:
      case 23:
        return Hj(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
  function Lj(a, b) {
    var c = a.ref;
    if (null !== c) if ("function" === typeof c) try {
      c(null);
    } catch (d) {
      W(a, b, d);
    }
    else c.current = null;
  }
  function Mj(a, b, c) {
    try {
      c();
    } catch (d) {
      W(a, b, d);
    }
  }
  var Nj = false;
  function Oj(a, b) {
    Cf = dd;
    a = Me();
    if (Ne(a)) {
      if ("selectionStart" in a) var c = { start: a.selectionStart, end: a.selectionEnd };
      else a: {
        c = (c = a.ownerDocument) && c.defaultView || window;
        var d = c.getSelection && c.getSelection();
        if (d && 0 !== d.rangeCount) {
          c = d.anchorNode;
          var e = d.anchorOffset, f = d.focusNode;
          d = d.focusOffset;
          try {
            c.nodeType, f.nodeType;
          } catch (F) {
            c = null;
            break a;
          }
          var g = 0, h = -1, k = -1, l = 0, m = 0, q = a, r2 = null;
          b: for (; ; ) {
            for (var y; ; ) {
              q !== c || 0 !== e && 3 !== q.nodeType || (h = g + e);
              q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
              3 === q.nodeType && (g += q.nodeValue.length);
              if (null === (y = q.firstChild)) break;
              r2 = q;
              q = y;
            }
            for (; ; ) {
              if (q === a) break b;
              r2 === c && ++l === e && (h = g);
              r2 === f && ++m === d && (k = g);
              if (null !== (y = q.nextSibling)) break;
              q = r2;
              r2 = q.parentNode;
            }
            q = y;
          }
          c = -1 === h || -1 === k ? null : { start: h, end: k };
        } else c = null;
      }
      c = c || { start: 0, end: 0 };
    } else c = null;
    Df = { focusedElem: a, selectionRange: c };
    dd = false;
    for (V = b; null !== V; ) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;
    else for (; null !== V; ) {
      b = V;
      try {
        var n = b.alternate;
        if (0 !== (b.flags & 1024)) switch (b.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (null !== n) {
              var t = n.memoizedProps, J = n.memoizedState, x = b.stateNode, w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Ci(b.type, t), J);
              x.__reactInternalSnapshotBeforeUpdate = w;
            }
            break;
          case 3:
            var u = b.stateNode.containerInfo;
            1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(p(163));
        }
      } catch (F) {
        W(b, b.return, F);
      }
      a = b.sibling;
      if (null !== a) {
        a.return = b.return;
        V = a;
        break;
      }
      V = b.return;
    }
    n = Nj;
    Nj = false;
    return n;
  }
  function Pj(a, b, c) {
    var d = b.updateQueue;
    d = null !== d ? d.lastEffect : null;
    if (null !== d) {
      var e = d = d.next;
      do {
        if ((e.tag & a) === a) {
          var f = e.destroy;
          e.destroy = void 0;
          void 0 !== f && Mj(b, c, f);
        }
        e = e.next;
      } while (e !== d);
    }
  }
  function Qj(a, b) {
    b = b.updateQueue;
    b = null !== b ? b.lastEffect : null;
    if (null !== b) {
      var c = b = b.next;
      do {
        if ((c.tag & a) === a) {
          var d = c.create;
          c.destroy = d();
        }
        c = c.next;
      } while (c !== b);
    }
  }
  function Rj(a) {
    var b = a.ref;
    if (null !== b) {
      var c = a.stateNode;
      switch (a.tag) {
        case 5:
          a = c;
          break;
        default:
          a = c;
      }
      "function" === typeof b ? b(a) : b.current = a;
    }
  }
  function Sj(a) {
    var b = a.alternate;
    null !== b && (a.alternate = null, Sj(b));
    a.child = null;
    a.deletions = null;
    a.sibling = null;
    5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
    a.stateNode = null;
    a.return = null;
    a.dependencies = null;
    a.memoizedProps = null;
    a.memoizedState = null;
    a.pendingProps = null;
    a.stateNode = null;
    a.updateQueue = null;
  }
  function Tj(a) {
    return 5 === a.tag || 3 === a.tag || 4 === a.tag;
  }
  function Uj(a) {
    a: for (; ; ) {
      for (; null === a.sibling; ) {
        if (null === a.return || Tj(a.return)) return null;
        a = a.return;
      }
      a.sibling.return = a.return;
      for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
        if (a.flags & 2) continue a;
        if (null === a.child || 4 === a.tag) continue a;
        else a.child.return = a, a = a.child;
      }
      if (!(a.flags & 2)) return a.stateNode;
    }
  }
  function Vj(a, b, c) {
    var d = a.tag;
    if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));
    else if (4 !== d && (a = a.child, null !== a)) for (Vj(a, b, c), a = a.sibling; null !== a; ) Vj(a, b, c), a = a.sibling;
  }
  function Wj(a, b, c) {
    var d = a.tag;
    if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
    else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a; ) Wj(a, b, c), a = a.sibling;
  }
  var X = null, Xj = false;
  function Yj(a, b, c) {
    for (c = c.child; null !== c; ) Zj(a, b, c), c = c.sibling;
  }
  function Zj(a, b, c) {
    if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
      lc.onCommitFiberUnmount(kc, c);
    } catch (h) {
    }
    switch (c.tag) {
      case 5:
        U || Lj(c, b);
      case 6:
        var d = X, e = Xj;
        X = null;
        Yj(a, b, c);
        X = d;
        Xj = e;
        null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
        break;
      case 18:
        null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
        break;
      case 4:
        d = X;
        e = Xj;
        X = c.stateNode.containerInfo;
        Xj = true;
        Yj(a, b, c);
        X = d;
        Xj = e;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
          e = d = d.next;
          do {
            var f = e, g = f.destroy;
            f = f.tag;
            void 0 !== g && (0 !== (f & 2) ? Mj(c, b, g) : 0 !== (f & 4) && Mj(c, b, g));
            e = e.next;
          } while (e !== d);
        }
        Yj(a, b, c);
        break;
      case 1:
        if (!U && (Lj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
          d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
        } catch (h) {
          W(c, b, h);
        }
        Yj(a, b, c);
        break;
      case 21:
        Yj(a, b, c);
        break;
      case 22:
        c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Yj(a, b, c), U = d) : Yj(a, b, c);
        break;
      default:
        Yj(a, b, c);
    }
  }
  function ak(a) {
    var b = a.updateQueue;
    if (null !== b) {
      a.updateQueue = null;
      var c = a.stateNode;
      null === c && (c = a.stateNode = new Kj());
      b.forEach(function(b2) {
        var d = bk.bind(null, a, b2);
        c.has(b2) || (c.add(b2), b2.then(d, d));
      });
    }
  }
  function ck(a, b) {
    var c = b.deletions;
    if (null !== c) for (var d = 0; d < c.length; d++) {
      var e = c[d];
      try {
        var f = a, g = b, h = g;
        a: for (; null !== h; ) {
          switch (h.tag) {
            case 5:
              X = h.stateNode;
              Xj = false;
              break a;
            case 3:
              X = h.stateNode.containerInfo;
              Xj = true;
              break a;
            case 4:
              X = h.stateNode.containerInfo;
              Xj = true;
              break a;
          }
          h = h.return;
        }
        if (null === X) throw Error(p(160));
        Zj(f, g, e);
        X = null;
        Xj = false;
        var k = e.alternate;
        null !== k && (k.return = null);
        e.return = null;
      } catch (l) {
        W(e, b, l);
      }
    }
    if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) dk(b, a), b = b.sibling;
  }
  function dk(a, b) {
    var c = a.alternate, d = a.flags;
    switch (a.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        ck(b, a);
        ek(a);
        if (d & 4) {
          try {
            Pj(3, a, a.return), Qj(3, a);
          } catch (t) {
            W(a, a.return, t);
          }
          try {
            Pj(5, a, a.return);
          } catch (t) {
            W(a, a.return, t);
          }
        }
        break;
      case 1:
        ck(b, a);
        ek(a);
        d & 512 && null !== c && Lj(c, c.return);
        break;
      case 5:
        ck(b, a);
        ek(a);
        d & 512 && null !== c && Lj(c, c.return);
        if (a.flags & 32) {
          var e = a.stateNode;
          try {
            ob(e, "");
          } catch (t) {
            W(a, a.return, t);
          }
        }
        if (d & 4 && (e = a.stateNode, null != e)) {
          var f = a.memoizedProps, g = null !== c ? c.memoizedProps : f, h = a.type, k = a.updateQueue;
          a.updateQueue = null;
          if (null !== k) try {
            "input" === h && "radio" === f.type && null != f.name && ab(e, f);
            vb(h, g);
            var l = vb(h, f);
            for (g = 0; g < k.length; g += 2) {
              var m = k[g], q = k[g + 1];
              "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta(e, m, q, l);
            }
            switch (h) {
              case "input":
                bb(e, f);
                break;
              case "textarea":
                ib(e, f);
                break;
              case "select":
                var r2 = e._wrapperState.wasMultiple;
                e._wrapperState.wasMultiple = !!f.multiple;
                var y = f.value;
                null != y ? fb(e, !!f.multiple, y, false) : r2 !== !!f.multiple && (null != f.defaultValue ? fb(
                  e,
                  !!f.multiple,
                  f.defaultValue,
                  true
                ) : fb(e, !!f.multiple, f.multiple ? [] : "", false));
            }
            e[Pf] = f;
          } catch (t) {
            W(a, a.return, t);
          }
        }
        break;
      case 6:
        ck(b, a);
        ek(a);
        if (d & 4) {
          if (null === a.stateNode) throw Error(p(162));
          e = a.stateNode;
          f = a.memoizedProps;
          try {
            e.nodeValue = f;
          } catch (t) {
            W(a, a.return, t);
          }
        }
        break;
      case 3:
        ck(b, a);
        ek(a);
        if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
          bd(b.containerInfo);
        } catch (t) {
          W(a, a.return, t);
        }
        break;
      case 4:
        ck(b, a);
        ek(a);
        break;
      case 13:
        ck(b, a);
        ek(a);
        e = a.child;
        e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (fk = B()));
        d & 4 && ak(a);
        break;
      case 22:
        m = null !== c && null !== c.memoizedState;
        a.mode & 1 ? (U = (l = U) || m, ck(b, a), U = l) : ck(b, a);
        ek(a);
        if (d & 8192) {
          l = null !== a.memoizedState;
          if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1)) for (V = a, m = a.child; null !== m; ) {
            for (q = V = m; null !== V; ) {
              r2 = V;
              y = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Pj(4, r2, r2.return);
                  break;
                case 1:
                  Lj(r2, r2.return);
                  var n = r2.stateNode;
                  if ("function" === typeof n.componentWillUnmount) {
                    d = r2;
                    c = r2.return;
                    try {
                      b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                    } catch (t) {
                      W(d, c, t);
                    }
                  }
                  break;
                case 5:
                  Lj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    gk(q);
                    continue;
                  }
              }
              null !== y ? (y.return = r2, V = y) : gk(q);
            }
            m = m.sibling;
          }
          a: for (m = null, q = a; ; ) {
            if (5 === q.tag) {
              if (null === m) {
                m = q;
                try {
                  e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
                } catch (t) {
                  W(a, a.return, t);
                }
              }
            } else if (6 === q.tag) {
              if (null === m) try {
                q.stateNode.nodeValue = l ? "" : q.memoizedProps;
              } catch (t) {
                W(a, a.return, t);
              }
            } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
              q.child.return = q;
              q = q.child;
              continue;
            }
            if (q === a) break a;
            for (; null === q.sibling; ) {
              if (null === q.return || q.return === a) break a;
              m === q && (m = null);
              q = q.return;
            }
            m === q && (m = null);
            q.sibling.return = q.return;
            q = q.sibling;
          }
        }
        break;
      case 19:
        ck(b, a);
        ek(a);
        d & 4 && ak(a);
        break;
      case 21:
        break;
      default:
        ck(
          b,
          a
        ), ek(a);
    }
  }
  function ek(a) {
    var b = a.flags;
    if (b & 2) {
      try {
        a: {
          for (var c = a.return; null !== c; ) {
            if (Tj(c)) {
              var d = c;
              break a;
            }
            c = c.return;
          }
          throw Error(p(160));
        }
        switch (d.tag) {
          case 5:
            var e = d.stateNode;
            d.flags & 32 && (ob(e, ""), d.flags &= -33);
            var f = Uj(a);
            Wj(a, f, e);
            break;
          case 3:
          case 4:
            var g = d.stateNode.containerInfo, h = Uj(a);
            Vj(a, h, g);
            break;
          default:
            throw Error(p(161));
        }
      } catch (k) {
        W(a, a.return, k);
      }
      a.flags &= -3;
    }
    b & 4096 && (a.flags &= -4097);
  }
  function hk(a, b, c) {
    V = a;
    ik(a);
  }
  function ik(a, b, c) {
    for (var d = 0 !== (a.mode & 1); null !== V; ) {
      var e = V, f = e.child;
      if (22 === e.tag && d) {
        var g = null !== e.memoizedState || Jj;
        if (!g) {
          var h = e.alternate, k = null !== h && null !== h.memoizedState || U;
          h = Jj;
          var l = U;
          Jj = g;
          if ((U = k) && !l) for (V = e; null !== V; ) g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? jk(e) : null !== k ? (k.return = g, V = k) : jk(e);
          for (; null !== f; ) V = f, ik(f), f = f.sibling;
          V = e;
          Jj = h;
          U = l;
        }
        kk(a);
      } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V = f) : kk(a);
    }
  }
  function kk(a) {
    for (; null !== V; ) {
      var b = V;
      if (0 !== (b.flags & 8772)) {
        var c = b.alternate;
        try {
          if (0 !== (b.flags & 8772)) switch (b.tag) {
            case 0:
            case 11:
            case 15:
              U || Qj(5, b);
              break;
            case 1:
              var d = b.stateNode;
              if (b.flags & 4 && !U) if (null === c) d.componentDidMount();
              else {
                var e = b.elementType === b.type ? c.memoizedProps : Ci(b.type, c.memoizedProps);
                d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
              }
              var f = b.updateQueue;
              null !== f && sh(b, f, d);
              break;
            case 3:
              var g = b.updateQueue;
              if (null !== g) {
                c = null;
                if (null !== b.child) switch (b.child.tag) {
                  case 5:
                    c = b.child.stateNode;
                    break;
                  case 1:
                    c = b.child.stateNode;
                }
                sh(b, g, c);
              }
              break;
            case 5:
              var h = b.stateNode;
              if (null === c && b.flags & 4) {
                c = h;
                var k = b.memoizedProps;
                switch (b.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k.autoFocus && c.focus();
                    break;
                  case "img":
                    k.src && (c.src = k.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b.memoizedState) {
                var l = b.alternate;
                if (null !== l) {
                  var m = l.memoizedState;
                  if (null !== m) {
                    var q = m.dehydrated;
                    null !== q && bd(q);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p(163));
          }
          U || b.flags & 512 && Rj(b);
        } catch (r2) {
          W(b, b.return, r2);
        }
      }
      if (b === a) {
        V = null;
        break;
      }
      c = b.sibling;
      if (null !== c) {
        c.return = b.return;
        V = c;
        break;
      }
      V = b.return;
    }
  }
  function gk(a) {
    for (; null !== V; ) {
      var b = V;
      if (b === a) {
        V = null;
        break;
      }
      var c = b.sibling;
      if (null !== c) {
        c.return = b.return;
        V = c;
        break;
      }
      V = b.return;
    }
  }
  function jk(a) {
    for (; null !== V; ) {
      var b = V;
      try {
        switch (b.tag) {
          case 0:
          case 11:
          case 15:
            var c = b.return;
            try {
              Qj(4, b);
            } catch (k) {
              W(b, c, k);
            }
            break;
          case 1:
            var d = b.stateNode;
            if ("function" === typeof d.componentDidMount) {
              var e = b.return;
              try {
                d.componentDidMount();
              } catch (k) {
                W(b, e, k);
              }
            }
            var f = b.return;
            try {
              Rj(b);
            } catch (k) {
              W(b, f, k);
            }
            break;
          case 5:
            var g = b.return;
            try {
              Rj(b);
            } catch (k) {
              W(b, g, k);
            }
        }
      } catch (k) {
        W(b, b.return, k);
      }
      if (b === a) {
        V = null;
        break;
      }
      var h = b.sibling;
      if (null !== h) {
        h.return = b.return;
        V = h;
        break;
      }
      V = b.return;
    }
  }
  var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
  function R() {
    return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
  }
  function yi(a) {
    if (0 === (a.mode & 1)) return 1;
    if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
    if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
    a = C;
    if (0 !== a) return a;
    a = window.event;
    a = void 0 === a ? 16 : jd(a.type);
    return a;
  }
  function gi(a, b, c, d) {
    if (50 < yk) throw yk = 0, zk = null, Error(p(185));
    Ac(a, c, d);
    if (0 === (K & 2) || a !== Q) a === Q && (0 === (K & 2) && (qk |= c), 4 === T && Ck(a, Z)), Dk(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Gj = B() + 500, fg && jg());
  }
  function Dk(a, b) {
    var c = a.callbackNode;
    wc(a, b);
    var d = uc(a, a === Q ? Z : 0);
    if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
    else if (b = d & -d, a.callbackPriority !== b) {
      null != c && bc(c);
      if (1 === b) 0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
        0 === (K & 6) && jg();
      }), c = null;
      else {
        switch (Dc(d)) {
          case 1:
            c = fc;
            break;
          case 4:
            c = gc;
            break;
          case 16:
            c = hc;
            break;
          case 536870912:
            c = jc;
            break;
          default:
            c = hc;
        }
        c = Fk(c, Gk.bind(null, a));
      }
      a.callbackPriority = b;
      a.callbackNode = c;
    }
  }
  function Gk(a, b) {
    Ak = -1;
    Bk = 0;
    if (0 !== (K & 6)) throw Error(p(327));
    var c = a.callbackNode;
    if (Hk() && a.callbackNode !== c) return null;
    var d = uc(a, a === Q ? Z : 0);
    if (0 === d) return null;
    if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Ik(a, d);
    else {
      b = d;
      var e = K;
      K |= 2;
      var f = Jk();
      if (Q !== a || Z !== b) uk = null, Gj = B() + 500, Kk(a, b);
      do
        try {
          Lk();
          break;
        } catch (h) {
          Mk(a, h);
        }
      while (1);
      $g();
      mk.current = f;
      K = e;
      null !== Y ? b = 0 : (Q = null, Z = 0, b = T);
    }
    if (0 !== b) {
      2 === b && (e = xc(a), 0 !== e && (d = e, b = Nk(a, e)));
      if (1 === b) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
      if (6 === b) Ck(a, d);
      else {
        e = a.current.alternate;
        if (0 === (d & 30) && !Ok(e) && (b = Ik(a, d), 2 === b && (f = xc(a), 0 !== f && (d = f, b = Nk(a, f))), 1 === b)) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
        a.finishedWork = e;
        a.finishedLanes = d;
        switch (b) {
          case 0:
          case 1:
            throw Error(p(345));
          case 2:
            Pk(a, tk, uk);
            break;
          case 3:
            Ck(a, d);
            if ((d & 130023424) === d && (b = fk + 500 - B(), 10 < b)) {
              if (0 !== uc(a, 0)) break;
              e = a.suspendedLanes;
              if ((e & d) !== d) {
                R();
                a.pingedLanes |= a.suspendedLanes & e;
                break;
              }
              a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b);
              break;
            }
            Pk(a, tk, uk);
            break;
          case 4:
            Ck(a, d);
            if ((d & 4194240) === d) break;
            b = a.eventTimes;
            for (e = -1; 0 < d; ) {
              var g = 31 - oc(d);
              f = 1 << g;
              g = b[g];
              g > e && (e = g);
              d &= ~f;
            }
            d = e;
            d = B() - d;
            d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
            if (10 < d) {
              a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d);
              break;
            }
            Pk(a, tk, uk);
            break;
          case 5:
            Pk(a, tk, uk);
            break;
          default:
            throw Error(p(329));
        }
      }
    }
    Dk(a, B());
    return a.callbackNode === c ? Gk.bind(null, a) : null;
  }
  function Nk(a, b) {
    var c = sk;
    a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256);
    a = Ik(a, b);
    2 !== a && (b = tk, tk = c, null !== b && Fj(b));
    return a;
  }
  function Fj(a) {
    null === tk ? tk = a : tk.push.apply(tk, a);
  }
  function Ok(a) {
    for (var b = a; ; ) {
      if (b.flags & 16384) {
        var c = b.updateQueue;
        if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
          var e = c[d], f = e.getSnapshot;
          e = e.value;
          try {
            if (!He(f(), e)) return false;
          } catch (g) {
            return false;
          }
        }
      }
      c = b.child;
      if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;
      else {
        if (b === a) break;
        for (; null === b.sibling; ) {
          if (null === b.return || b.return === a) return true;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
    }
    return true;
  }
  function Ck(a, b) {
    b &= ~rk;
    b &= ~qk;
    a.suspendedLanes |= b;
    a.pingedLanes &= ~b;
    for (a = a.expirationTimes; 0 < b; ) {
      var c = 31 - oc(b), d = 1 << c;
      a[c] = -1;
      b &= ~d;
    }
  }
  function Ek(a) {
    if (0 !== (K & 6)) throw Error(p(327));
    Hk();
    var b = uc(a, 0);
    if (0 === (b & 1)) return Dk(a, B()), null;
    var c = Ik(a, b);
    if (0 !== a.tag && 2 === c) {
      var d = xc(a);
      0 !== d && (b = d, c = Nk(a, d));
    }
    if (1 === c) throw c = pk, Kk(a, 0), Ck(a, b), Dk(a, B()), c;
    if (6 === c) throw Error(p(345));
    a.finishedWork = a.current.alternate;
    a.finishedLanes = b;
    Pk(a, tk, uk);
    Dk(a, B());
    return null;
  }
  function Qk(a, b) {
    var c = K;
    K |= 1;
    try {
      return a(b);
    } finally {
      K = c, 0 === K && (Gj = B() + 500, fg && jg());
    }
  }
  function Rk(a) {
    null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
    var b = K;
    K |= 1;
    var c = ok.transition, d = C;
    try {
      if (ok.transition = null, C = 1, a) return a();
    } finally {
      C = d, ok.transition = c, K = b, 0 === (K & 6) && jg();
    }
  }
  function Hj() {
    fj = ej.current;
    E(ej);
  }
  function Kk(a, b) {
    a.finishedWork = null;
    a.finishedLanes = 0;
    var c = a.timeoutHandle;
    -1 !== c && (a.timeoutHandle = -1, Gf(c));
    if (null !== Y) for (c = Y.return; null !== c; ) {
      var d = c;
      wg(d);
      switch (d.tag) {
        case 1:
          d = d.type.childContextTypes;
          null !== d && void 0 !== d && $f();
          break;
        case 3:
          zh();
          E(Wf);
          E(H);
          Eh();
          break;
        case 5:
          Bh(d);
          break;
        case 4:
          zh();
          break;
        case 13:
          E(L);
          break;
        case 19:
          E(L);
          break;
        case 10:
          ah(d.type._context);
          break;
        case 22:
        case 23:
          Hj();
      }
      c = c.return;
    }
    Q = a;
    Y = a = Pg(a.current, null);
    Z = fj = b;
    T = 0;
    pk = null;
    rk = qk = rh = 0;
    tk = sk = null;
    if (null !== fh) {
      for (b = 0; b < fh.length; b++) if (c = fh[b], d = c.interleaved, null !== d) {
        c.interleaved = null;
        var e = d.next, f = c.pending;
        if (null !== f) {
          var g = f.next;
          f.next = e;
          d.next = g;
        }
        c.pending = d;
      }
      fh = null;
    }
    return a;
  }
  function Mk(a, b) {
    do {
      var c = Y;
      try {
        $g();
        Fh.current = Rh;
        if (Ih) {
          for (var d = M.memoizedState; null !== d; ) {
            var e = d.queue;
            null !== e && (e.pending = null);
            d = d.next;
          }
          Ih = false;
        }
        Hh = 0;
        O = N = M = null;
        Jh = false;
        Kh = 0;
        nk.current = null;
        if (null === c || null === c.return) {
          T = 1;
          pk = b;
          Y = null;
          break;
        }
        a: {
          var f = a, g = c.return, h = c, k = b;
          b = Z;
          h.flags |= 32768;
          if (null !== k && "object" === typeof k && "function" === typeof k.then) {
            var l = k, m = h, q = m.tag;
            if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
              var r2 = m.alternate;
              r2 ? (m.updateQueue = r2.updateQueue, m.memoizedState = r2.memoizedState, m.lanes = r2.lanes) : (m.updateQueue = null, m.memoizedState = null);
            }
            var y = Ui(g);
            if (null !== y) {
              y.flags &= -257;
              Vi(y, g, h, f, b);
              y.mode & 1 && Si(f, l, b);
              b = y;
              k = l;
              var n = b.updateQueue;
              if (null === n) {
                var t = /* @__PURE__ */ new Set();
                t.add(k);
                b.updateQueue = t;
              } else n.add(k);
              break a;
            } else {
              if (0 === (b & 1)) {
                Si(f, l, b);
                tj();
                break a;
              }
              k = Error(p(426));
            }
          } else if (I && h.mode & 1) {
            var J = Ui(g);
            if (null !== J) {
              0 === (J.flags & 65536) && (J.flags |= 256);
              Vi(J, g, h, f, b);
              Jg(Ji(k, h));
              break a;
            }
          }
          f = k = Ji(k, h);
          4 !== T && (T = 2);
          null === sk ? sk = [f] : sk.push(f);
          f = g;
          do {
            switch (f.tag) {
              case 3:
                f.flags |= 65536;
                b &= -b;
                f.lanes |= b;
                var x = Ni(f, k, b);
                ph(f, x);
                break a;
              case 1:
                h = k;
                var w = f.type, u = f.stateNode;
                if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Ri || !Ri.has(u)))) {
                  f.flags |= 65536;
                  b &= -b;
                  f.lanes |= b;
                  var F = Qi(f, h, b);
                  ph(f, F);
                  break a;
                }
            }
            f = f.return;
          } while (null !== f);
        }
        Sk(c);
      } catch (na) {
        b = na;
        Y === c && null !== c && (Y = c = c.return);
        continue;
      }
      break;
    } while (1);
  }
  function Jk() {
    var a = mk.current;
    mk.current = Rh;
    return null === a ? Rh : a;
  }
  function tj() {
    if (0 === T || 3 === T || 2 === T) T = 4;
    null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
  }
  function Ik(a, b) {
    var c = K;
    K |= 2;
    var d = Jk();
    if (Q !== a || Z !== b) uk = null, Kk(a, b);
    do
      try {
        Tk();
        break;
      } catch (e) {
        Mk(a, e);
      }
    while (1);
    $g();
    K = c;
    mk.current = d;
    if (null !== Y) throw Error(p(261));
    Q = null;
    Z = 0;
    return T;
  }
  function Tk() {
    for (; null !== Y; ) Uk(Y);
  }
  function Lk() {
    for (; null !== Y && !cc(); ) Uk(Y);
  }
  function Uk(a) {
    var b = Vk(a.alternate, a, fj);
    a.memoizedProps = a.pendingProps;
    null === b ? Sk(a) : Y = b;
    nk.current = null;
  }
  function Sk(a) {
    var b = a;
    do {
      var c = b.alternate;
      a = b.return;
      if (0 === (b.flags & 32768)) {
        if (c = Ej(c, b, fj), null !== c) {
          Y = c;
          return;
        }
      } else {
        c = Ij(c, b);
        if (null !== c) {
          c.flags &= 32767;
          Y = c;
          return;
        }
        if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
        else {
          T = 6;
          Y = null;
          return;
        }
      }
      b = b.sibling;
      if (null !== b) {
        Y = b;
        return;
      }
      Y = b = a;
    } while (null !== b);
    0 === T && (T = 5);
  }
  function Pk(a, b, c) {
    var d = C, e = ok.transition;
    try {
      ok.transition = null, C = 1, Wk(a, b, c, d);
    } finally {
      ok.transition = e, C = d;
    }
    return null;
  }
  function Wk(a, b, c, d) {
    do
      Hk();
    while (null !== wk);
    if (0 !== (K & 6)) throw Error(p(327));
    c = a.finishedWork;
    var e = a.finishedLanes;
    if (null === c) return null;
    a.finishedWork = null;
    a.finishedLanes = 0;
    if (c === a.current) throw Error(p(177));
    a.callbackNode = null;
    a.callbackPriority = 0;
    var f = c.lanes | c.childLanes;
    Bc(a, f);
    a === Q && (Y = Q = null, Z = 0);
    0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || vk || (vk = true, Fk(hc, function() {
      Hk();
      return null;
    }));
    f = 0 !== (c.flags & 15990);
    if (0 !== (c.subtreeFlags & 15990) || f) {
      f = ok.transition;
      ok.transition = null;
      var g = C;
      C = 1;
      var h = K;
      K |= 4;
      nk.current = null;
      Oj(a, c);
      dk(c, a);
      Oe(Df);
      dd = !!Cf;
      Df = Cf = null;
      a.current = c;
      hk(c);
      dc();
      K = h;
      C = g;
      ok.transition = f;
    } else a.current = c;
    vk && (vk = false, wk = a, xk = e);
    f = a.pendingLanes;
    0 === f && (Ri = null);
    mc(c.stateNode);
    Dk(a, B());
    if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, { componentStack: e.stack, digest: e.digest });
    if (Oi) throw Oi = false, a = Pi, Pi = null, a;
    0 !== (xk & 1) && 0 !== a.tag && Hk();
    f = a.pendingLanes;
    0 !== (f & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
    jg();
    return null;
  }
  function Hk() {
    if (null !== wk) {
      var a = Dc(xk), b = ok.transition, c = C;
      try {
        ok.transition = null;
        C = 16 > a ? 16 : a;
        if (null === wk) var d = false;
        else {
          a = wk;
          wk = null;
          xk = 0;
          if (0 !== (K & 6)) throw Error(p(331));
          var e = K;
          K |= 4;
          for (V = a.current; null !== V; ) {
            var f = V, g = f.child;
            if (0 !== (V.flags & 16)) {
              var h = f.deletions;
              if (null !== h) {
                for (var k = 0; k < h.length; k++) {
                  var l = h[k];
                  for (V = l; null !== V; ) {
                    var m = V;
                    switch (m.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pj(8, m, f);
                    }
                    var q = m.child;
                    if (null !== q) q.return = m, V = q;
                    else for (; null !== V; ) {
                      m = V;
                      var r2 = m.sibling, y = m.return;
                      Sj(m);
                      if (m === l) {
                        V = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y;
                        V = r2;
                        break;
                      }
                      V = y;
                    }
                  }
                }
                var n = f.alternate;
                if (null !== n) {
                  var t = n.child;
                  if (null !== t) {
                    n.child = null;
                    do {
                      var J = t.sibling;
                      t.sibling = null;
                      t = J;
                    } while (null !== t);
                  }
                }
                V = f;
              }
            }
            if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V = g;
            else b: for (; null !== V; ) {
              f = V;
              if (0 !== (f.flags & 2048)) switch (f.tag) {
                case 0:
                case 11:
                case 15:
                  Pj(9, f, f.return);
              }
              var x = f.sibling;
              if (null !== x) {
                x.return = f.return;
                V = x;
                break b;
              }
              V = f.return;
            }
          }
          var w = a.current;
          for (V = w; null !== V; ) {
            g = V;
            var u = g.child;
            if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V = u;
            else b: for (g = w; null !== V; ) {
              h = V;
              if (0 !== (h.flags & 2048)) try {
                switch (h.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Qj(9, h);
                }
              } catch (na) {
                W(h, h.return, na);
              }
              if (h === g) {
                V = null;
                break b;
              }
              var F = h.sibling;
              if (null !== F) {
                F.return = h.return;
                V = F;
                break b;
              }
              V = h.return;
            }
          }
          K = e;
          jg();
          if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
            lc.onPostCommitFiberRoot(kc, a);
          } catch (na) {
          }
          d = true;
        }
        return d;
      } finally {
        C = c, ok.transition = b;
      }
    }
    return false;
  }
  function Xk(a, b, c) {
    b = Ji(c, b);
    b = Ni(a, b, 1);
    a = nh(a, b, 1);
    b = R();
    null !== a && (Ac(a, 1, b), Dk(a, b));
  }
  function W(a, b, c) {
    if (3 === a.tag) Xk(a, a, c);
    else for (; null !== b; ) {
      if (3 === b.tag) {
        Xk(b, a, c);
        break;
      } else if (1 === b.tag) {
        var d = b.stateNode;
        if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri || !Ri.has(d))) {
          a = Ji(c, a);
          a = Qi(b, a, 1);
          b = nh(b, a, 1);
          a = R();
          null !== b && (Ac(b, 1, a), Dk(b, a));
          break;
        }
      }
      b = b.return;
    }
  }
  function Ti(a, b, c) {
    var d = a.pingCache;
    null !== d && d.delete(b);
    b = R();
    a.pingedLanes |= a.suspendedLanes & c;
    Q === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c);
    Dk(a, b);
  }
  function Yk(a, b) {
    0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
    var c = R();
    a = ih(a, b);
    null !== a && (Ac(a, b, c), Dk(a, c));
  }
  function uj(a) {
    var b = a.memoizedState, c = 0;
    null !== b && (c = b.retryLane);
    Yk(a, c);
  }
  function bk(a, b) {
    var c = 0;
    switch (a.tag) {
      case 13:
        var d = a.stateNode;
        var e = a.memoizedState;
        null !== e && (c = e.retryLane);
        break;
      case 19:
        d = a.stateNode;
        break;
      default:
        throw Error(p(314));
    }
    null !== d && d.delete(b);
    Yk(a, c);
  }
  var Vk;
  Vk = function(a, b, c) {
    if (null !== a) if (a.memoizedProps !== b.pendingProps || Wf.current) dh = true;
    else {
      if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return dh = false, yj(a, b, c);
      dh = 0 !== (a.flags & 131072) ? true : false;
    }
    else dh = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
    b.lanes = 0;
    switch (b.tag) {
      case 2:
        var d = b.type;
        ij(a, b);
        a = b.pendingProps;
        var e = Yf(b, H.current);
        ch(b, c);
        e = Nh(null, b, d, a, e, c);
        var f = Sh();
        b.flags |= 1;
        "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = true, cg(b)) : f = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, kh(b), e.updater = Ei, b.stateNode = e, e._reactInternals = b, Ii(b, d, a, c), b = jj(null, b, d, true, f, c)) : (b.tag = 0, I && f && vg(b), Xi(null, b, e, c), b = b.child);
        return b;
      case 16:
        d = b.elementType;
        a: {
          ij(a, b);
          a = b.pendingProps;
          e = d._init;
          d = e(d._payload);
          b.type = d;
          e = b.tag = Zk(d);
          a = Ci(d, a);
          switch (e) {
            case 0:
              b = cj(null, b, d, a, c);
              break a;
            case 1:
              b = hj(null, b, d, a, c);
              break a;
            case 11:
              b = Yi(null, b, d, a, c);
              break a;
            case 14:
              b = $i(null, b, d, Ci(d.type, a), c);
              break a;
          }
          throw Error(p(
            306,
            d,
            ""
          ));
        }
        return b;
      case 0:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), cj(a, b, d, e, c);
      case 1:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), hj(a, b, d, e, c);
      case 3:
        a: {
          kj(b);
          if (null === a) throw Error(p(387));
          d = b.pendingProps;
          f = b.memoizedState;
          e = f.element;
          lh(a, b);
          qh(b, d, null, c);
          var g = b.memoizedState;
          d = g.element;
          if (f.isDehydrated) if (f = { element: d, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
            e = Ji(Error(p(423)), b);
            b = lj(a, b, d, c, e);
            break a;
          } else if (d !== e) {
            e = Ji(Error(p(424)), b);
            b = lj(a, b, d, c, e);
            break a;
          } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Vg(b, null, d, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
          else {
            Ig();
            if (d === e) {
              b = Zi(a, b, c);
              break a;
            }
            Xi(a, b, d, c);
          }
          b = b.child;
        }
        return b;
      case 5:
        return Ah(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), gj(a, b), Xi(a, b, g, c), b.child;
      case 6:
        return null === a && Eg(b), null;
      case 13:
        return oj(a, b, c);
      case 4:
        return yh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Ug(b, null, d, c) : Xi(a, b, d, c), b.child;
      case 11:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), Yi(a, b, d, e, c);
      case 7:
        return Xi(a, b, b.pendingProps, c), b.child;
      case 8:
        return Xi(a, b, b.pendingProps.children, c), b.child;
      case 12:
        return Xi(a, b, b.pendingProps.children, c), b.child;
      case 10:
        a: {
          d = b.type._context;
          e = b.pendingProps;
          f = b.memoizedProps;
          g = e.value;
          G(Wg, d._currentValue);
          d._currentValue = g;
          if (null !== f) if (He(f.value, g)) {
            if (f.children === e.children && !Wf.current) {
              b = Zi(a, b, c);
              break a;
            }
          } else for (f = b.child, null !== f && (f.return = b); null !== f; ) {
            var h = f.dependencies;
            if (null !== h) {
              g = f.child;
              for (var k = h.firstContext; null !== k; ) {
                if (k.context === d) {
                  if (1 === f.tag) {
                    k = mh(-1, c & -c);
                    k.tag = 2;
                    var l = f.updateQueue;
                    if (null !== l) {
                      l = l.shared;
                      var m = l.pending;
                      null === m ? k.next = k : (k.next = m.next, m.next = k);
                      l.pending = k;
                    }
                  }
                  f.lanes |= c;
                  k = f.alternate;
                  null !== k && (k.lanes |= c);
                  bh(
                    f.return,
                    c,
                    b
                  );
                  h.lanes |= c;
                  break;
                }
                k = k.next;
              }
            } else if (10 === f.tag) g = f.type === b.type ? null : f.child;
            else if (18 === f.tag) {
              g = f.return;
              if (null === g) throw Error(p(341));
              g.lanes |= c;
              h = g.alternate;
              null !== h && (h.lanes |= c);
              bh(g, c, b);
              g = f.sibling;
            } else g = f.child;
            if (null !== g) g.return = f;
            else for (g = f; null !== g; ) {
              if (g === b) {
                g = null;
                break;
              }
              f = g.sibling;
              if (null !== f) {
                f.return = g.return;
                g = f;
                break;
              }
              g = g.return;
            }
            f = g;
          }
          Xi(a, b, e.children, c);
          b = b.child;
        }
        return b;
      case 9:
        return e = b.type, d = b.pendingProps.children, ch(b, c), e = eh(e), d = d(e), b.flags |= 1, Xi(a, b, d, c), b.child;
      case 14:
        return d = b.type, e = Ci(d, b.pendingProps), e = Ci(d.type, e), $i(a, b, d, e, c);
      case 15:
        return bj(a, b, b.type, b.pendingProps, c);
      case 17:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), ij(a, b), b.tag = 1, Zf(d) ? (a = true, cg(b)) : a = false, ch(b, c), Gi(b, d, e), Ii(b, d, e, c), jj(null, b, d, true, a, c);
      case 19:
        return xj(a, b, c);
      case 22:
        return dj(a, b, c);
    }
    throw Error(p(156, b.tag));
  };
  function Fk(a, b) {
    return ac(a, b);
  }
  function $k(a, b, c, d) {
    this.tag = a;
    this.key = c;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = b;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = d;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }
  function Bg(a, b, c, d) {
    return new $k(a, b, c, d);
  }
  function aj(a) {
    a = a.prototype;
    return !(!a || !a.isReactComponent);
  }
  function Zk(a) {
    if ("function" === typeof a) return aj(a) ? 1 : 0;
    if (void 0 !== a && null !== a) {
      a = a.$$typeof;
      if (a === Da) return 11;
      if (a === Ga) return 14;
    }
    return 2;
  }
  function Pg(a, b) {
    var c = a.alternate;
    null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
    c.flags = a.flags & 14680064;
    c.childLanes = a.childLanes;
    c.lanes = a.lanes;
    c.child = a.child;
    c.memoizedProps = a.memoizedProps;
    c.memoizedState = a.memoizedState;
    c.updateQueue = a.updateQueue;
    b = a.dependencies;
    c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
    c.sibling = a.sibling;
    c.index = a.index;
    c.ref = a.ref;
    return c;
  }
  function Rg(a, b, c, d, e, f) {
    var g = 2;
    d = a;
    if ("function" === typeof a) aj(a) && (g = 1);
    else if ("string" === typeof a) g = 5;
    else a: switch (a) {
      case ya:
        return Tg(c.children, e, f, b);
      case za:
        g = 8;
        e |= 8;
        break;
      case Aa:
        return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
      case Ea:
        return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
      case Fa:
        return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;
      case Ia:
        return pj(c, e, f, b);
      default:
        if ("object" === typeof a && null !== a) switch (a.$$typeof) {
          case Ba:
            g = 10;
            break a;
          case Ca:
            g = 9;
            break a;
          case Da:
            g = 11;
            break a;
          case Ga:
            g = 14;
            break a;
          case Ha:
            g = 16;
            d = null;
            break a;
        }
        throw Error(p(130, null == a ? a : typeof a, ""));
    }
    b = Bg(g, c, b, e);
    b.elementType = a;
    b.type = d;
    b.lanes = f;
    return b;
  }
  function Tg(a, b, c, d) {
    a = Bg(7, a, d, b);
    a.lanes = c;
    return a;
  }
  function pj(a, b, c, d) {
    a = Bg(22, a, d, b);
    a.elementType = Ia;
    a.lanes = c;
    a.stateNode = { isHidden: false };
    return a;
  }
  function Qg(a, b, c) {
    a = Bg(6, a, null, b);
    a.lanes = c;
    return a;
  }
  function Sg(a, b, c) {
    b = Bg(4, null !== a.children ? a.children : [], a.key, b);
    b.lanes = c;
    b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
    return b;
  }
  function al(a, b, c, d, e) {
    this.tag = b;
    this.containerInfo = a;
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.callbackNode = this.pendingContext = this.context = null;
    this.callbackPriority = 0;
    this.eventTimes = zc(0);
    this.expirationTimes = zc(-1);
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = zc(0);
    this.identifierPrefix = d;
    this.onRecoverableError = e;
    this.mutableSourceEagerHydrationData = null;
  }
  function bl(a, b, c, d, e, f, g, h, k) {
    a = new al(a, b, c, h, k);
    1 === b ? (b = 1, true === f && (b |= 8)) : b = 0;
    f = Bg(3, null, null, b);
    a.current = f;
    f.stateNode = a;
    f.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
    kh(f);
    return a;
  }
  function cl(a, b, c) {
    var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return { $$typeof: wa, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
  }
  function dl(a) {
    if (!a) return Vf;
    a = a._reactInternals;
    a: {
      if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
      var b = a;
      do {
        switch (b.tag) {
          case 3:
            b = b.stateNode.context;
            break a;
          case 1:
            if (Zf(b.type)) {
              b = b.stateNode.__reactInternalMemoizedMergedChildContext;
              break a;
            }
        }
        b = b.return;
      } while (null !== b);
      throw Error(p(171));
    }
    if (1 === a.tag) {
      var c = a.type;
      if (Zf(c)) return bg(a, c, b);
    }
    return b;
  }
  function el(a, b, c, d, e, f, g, h, k) {
    a = bl(c, d, true, a, e, f, g, h, k);
    a.context = dl(null);
    c = a.current;
    d = R();
    e = yi(c);
    f = mh(d, e);
    f.callback = void 0 !== b && null !== b ? b : null;
    nh(c, f, e);
    a.current.lanes = e;
    Ac(a, e, d);
    Dk(a, d);
    return a;
  }
  function fl(a, b, c, d) {
    var e = b.current, f = R(), g = yi(e);
    c = dl(c);
    null === b.context ? b.context = c : b.pendingContext = c;
    b = mh(f, g);
    b.payload = { element: a };
    d = void 0 === d ? null : d;
    null !== d && (b.callback = d);
    a = nh(e, b, g);
    null !== a && (gi(a, e, g, f), oh(a, e, g));
    return g;
  }
  function gl(a) {
    a = a.current;
    if (!a.child) return null;
    switch (a.child.tag) {
      case 5:
        return a.child.stateNode;
      default:
        return a.child.stateNode;
    }
  }
  function hl(a, b) {
    a = a.memoizedState;
    if (null !== a && null !== a.dehydrated) {
      var c = a.retryLane;
      a.retryLane = 0 !== c && c < b ? c : b;
    }
  }
  function il(a, b) {
    hl(a, b);
    (a = a.alternate) && hl(a, b);
  }
  function jl() {
    return null;
  }
  var kl = "function" === typeof reportError ? reportError : function(a) {
    console.error(a);
  };
  function ll(a) {
    this._internalRoot = a;
  }
  ml.prototype.render = ll.prototype.render = function(a) {
    var b = this._internalRoot;
    if (null === b) throw Error(p(409));
    fl(a, b, null, null);
  };
  ml.prototype.unmount = ll.prototype.unmount = function() {
    var a = this._internalRoot;
    if (null !== a) {
      this._internalRoot = null;
      var b = a.containerInfo;
      Rk(function() {
        fl(null, a, null, null);
      });
      b[uf] = null;
    }
  };
  function ml(a) {
    this._internalRoot = a;
  }
  ml.prototype.unstable_scheduleHydration = function(a) {
    if (a) {
      var b = Hc();
      a = { blockedOn: null, target: a, priority: b };
      for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++) ;
      Qc.splice(c, 0, a);
      0 === c && Vc(a);
    }
  };
  function nl(a) {
    return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
  }
  function ol(a) {
    return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
  }
  function pl() {
  }
  function ql(a, b, c, d, e) {
    if (e) {
      if ("function" === typeof d) {
        var f = d;
        d = function() {
          var a2 = gl(g);
          f.call(a2);
        };
      }
      var g = el(b, d, a, 0, null, false, false, "", pl);
      a._reactRootContainer = g;
      a[uf] = g.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      Rk();
      return g;
    }
    for (; e = a.lastChild; ) a.removeChild(e);
    if ("function" === typeof d) {
      var h = d;
      d = function() {
        var a2 = gl(k);
        h.call(a2);
      };
    }
    var k = bl(a, 0, false, null, null, false, false, "", pl);
    a._reactRootContainer = k;
    a[uf] = k.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Rk(function() {
      fl(b, k, c, d);
    });
    return k;
  }
  function rl(a, b, c, d, e) {
    var f = c._reactRootContainer;
    if (f) {
      var g = f;
      if ("function" === typeof e) {
        var h = e;
        e = function() {
          var a2 = gl(g);
          h.call(a2);
        };
      }
      fl(b, g, a, e);
    } else g = ql(c, b, a, e, d);
    return gl(g);
  }
  Ec = function(a) {
    switch (a.tag) {
      case 3:
        var b = a.stateNode;
        if (b.current.memoizedState.isDehydrated) {
          var c = tc(b.pendingLanes);
          0 !== c && (Cc(b, c | 1), Dk(b, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
        }
        break;
      case 13:
        Rk(function() {
          var b2 = ih(a, 1);
          if (null !== b2) {
            var c2 = R();
            gi(b2, a, 1, c2);
          }
        }), il(a, 1);
    }
  };
  Fc = function(a) {
    if (13 === a.tag) {
      var b = ih(a, 134217728);
      if (null !== b) {
        var c = R();
        gi(b, a, 134217728, c);
      }
      il(a, 134217728);
    }
  };
  Gc = function(a) {
    if (13 === a.tag) {
      var b = yi(a), c = ih(a, b);
      if (null !== c) {
        var d = R();
        gi(c, a, b, d);
      }
      il(a, b);
    }
  };
  Hc = function() {
    return C;
  };
  Ic = function(a, b) {
    var c = C;
    try {
      return C = a, b();
    } finally {
      C = c;
    }
  };
  yb = function(a, b, c) {
    switch (b) {
      case "input":
        bb(a, c);
        b = c.name;
        if ("radio" === c.type && null != b) {
          for (c = a; c.parentNode; ) c = c.parentNode;
          c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
          for (b = 0; b < c.length; b++) {
            var d = c[b];
            if (d !== a && d.form === a.form) {
              var e = Db(d);
              if (!e) throw Error(p(90));
              Wa(d);
              bb(d, e);
            }
          }
        }
        break;
      case "textarea":
        ib(a, c);
        break;
      case "select":
        b = c.value, null != b && fb(a, !!c.multiple, b, false);
    }
  };
  Gb = Qk;
  Hb = Rk;
  var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
  var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
    a = Zb(a);
    return null === a ? null : a.stateNode;
  }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vl.isDisabled && vl.supportsFiber) try {
      kc = vl.inject(ul), lc = vl;
    } catch (a) {
    }
  }
  reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
  reactDom_production_min.createPortal = function(a, b) {
    var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!nl(b)) throw Error(p(200));
    return cl(a, b, null, c);
  };
  reactDom_production_min.createRoot = function(a, b) {
    if (!nl(a)) throw Error(p(299));
    var c = false, d = "", e = kl;
    null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
    b = bl(a, 1, false, null, null, c, false, d, e);
    a[uf] = b.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    return new ll(b);
  };
  reactDom_production_min.findDOMNode = function(a) {
    if (null == a) return null;
    if (1 === a.nodeType) return a;
    var b = a._reactInternals;
    if (void 0 === b) {
      if ("function" === typeof a.render) throw Error(p(188));
      a = Object.keys(a).join(",");
      throw Error(p(268, a));
    }
    a = Zb(b);
    a = null === a ? null : a.stateNode;
    return a;
  };
  reactDom_production_min.flushSync = function(a) {
    return Rk(a);
  };
  reactDom_production_min.hydrate = function(a, b, c) {
    if (!ol(b)) throw Error(p(200));
    return rl(null, a, b, true, c);
  };
  reactDom_production_min.hydrateRoot = function(a, b, c) {
    if (!nl(a)) throw Error(p(405));
    var d = null != c && c.hydratedSources || null, e = false, f = "", g = kl;
    null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
    b = el(b, null, a, 1, null != c ? c : null, e, false, f, g);
    a[uf] = b.current;
    sf(a);
    if (d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
      c,
      e
    );
    return new ml(b);
  };
  reactDom_production_min.render = function(a, b, c) {
    if (!ol(b)) throw Error(p(200));
    return rl(null, a, b, false, c);
  };
  reactDom_production_min.unmountComponentAtNode = function(a) {
    if (!ol(a)) throw Error(p(40));
    return a._reactRootContainer ? (Rk(function() {
      rl(null, null, a, false, function() {
        a._reactRootContainer = null;
        a[uf] = null;
      });
    }), true) : false;
  };
  reactDom_production_min.unstable_batchedUpdates = Qk;
  reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
    if (!ol(c)) throw Error(p(200));
    if (null == a || void 0 === a._reactInternals) throw Error(p(38));
    return rl(a, b, c, false, d);
  };
  reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
  return reactDom_production_min;
}
var hasRequiredReactDom;
function requireReactDom() {
  if (hasRequiredReactDom) return reactDom.exports;
  hasRequiredReactDom = 1;
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    reactDom.exports = requireReactDom_production_min();
  }
  return reactDom.exports;
}
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client;
  hasRequiredClient = 1;
  var m = requireReactDom();
  {
    client.createRoot = m.createRoot;
    client.hydrateRoot = m.hydrateRoot;
  }
  return client;
}
var clientExports = requireClient();
const ReactDOM$1 = /* @__PURE__ */ getDefaultExportFromCjs(clientExports);
/**
 * react-router v7.9.4
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
var PopStateEventType = "popstate";
function createBrowserHistory(options = {}) {
  function createBrowserLocation(window2, globalHistory) {
    let { pathname, search, hash: hash2 } = window2.location;
    return createLocation(
      "",
      { pathname, search, hash: hash2 },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(
    createBrowserLocation,
    createBrowserHref,
    null,
    options
  );
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined") console.warn(message);
    try {
      throw new Error(message);
    } catch (e) {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substring(2, 10);
}
function getHistoryState(location, index2) {
  return {
    usr: location.state,
    key: location.key,
    idx: index2
  };
}
function createLocation(current, to, state = null, key) {
  let location = __spreadProps(__spreadValues({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to), {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
  return location;
}
function createPath({
  pathname = "/",
  search = "",
  hash: hash2 = ""
}) {
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash2 && hash2 !== "#")
    pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substring(hashIndex);
      path = path.substring(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substring(searchIndex);
      path = path.substring(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref2, validateLocation, options = {}) {
  let { window: window2 = document.defaultView, v5Compat = false } = options;
  let globalHistory = window2.history;
  let action = "POP";
  let listener = null;
  let index2 = getIndex();
  if (index2 == null) {
    index2 = 0;
    globalHistory.replaceState(__spreadProps(__spreadValues({}, globalHistory.state), { idx: index2 }), "");
  }
  function getIndex() {
    let state = globalHistory.state || { idx: null };
    return state.idx;
  }
  function handlePop() {
    action = "POP";
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index2;
    index2 = nextIndex;
    if (listener) {
      listener({ action, location: history2.location, delta });
    }
  }
  function push(to, state) {
    action = "PUSH";
    let location = createLocation(history2.location, to, state);
    index2 = getIndex() + 1;
    let historyState = getHistoryState(location, index2);
    let url = history2.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error2) {
      if (error2 instanceof DOMException && error2.name === "DataCloneError") {
        throw error2;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({ action, location: history2.location, delta: 1 });
    }
  }
  function replace2(to, state) {
    action = "REPLACE";
    let location = createLocation(history2.location, to, state);
    index2 = getIndex();
    let historyState = getHistoryState(location, index2);
    let url = history2.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({ action, location: history2.location, delta: 0 });
    }
  }
  function createURL(to) {
    return createBrowserURLImpl(to);
  }
  let history2 = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn2) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn2;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref2(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace: replace2,
    go(n) {
      return globalHistory.go(n);
    }
  };
  return history2;
}
function createBrowserURLImpl(to, isAbsolute = false) {
  let base = "http://localhost";
  if (typeof window !== "undefined") {
    base = window.location.origin !== "null" ? window.location.origin : window.location.href;
  }
  invariant(base, "No window.location.(origin|href) available to create URL");
  let href = typeof to === "string" ? to : createPath(to);
  href = href.replace(/ $/, "%20");
  if (!isAbsolute && href.startsWith("//")) {
    href = base + href;
  }
  return new URL(href, base);
}
function matchRoutes(routes, locationArg, basename = "/") {
  return matchRoutesImpl(routes, locationArg, basename, false);
}
function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    let decoded = decodePath(pathname);
    matches = matchRouteBranch(
      branches[i],
      decoded,
      allowPartial
    );
  }
  return matches;
}
function flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = "", _hasParentOptionalSegments = false) {
  let flattenRoute = (route, index2, hasParentOptionalSegments = _hasParentOptionalSegments, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index2,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      if (!meta.relativePath.startsWith(parentPath) && hasParentOptionalSegments) {
        return;
      }
      invariant(
        meta.relativePath.startsWith(parentPath),
        `Absolute route path "${meta.relativePath}" nested under path "${parentPath}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
      );
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        `Index routes must not have child routes. Please remove all child routes from route path "${path}".`
      );
      flattenRoutes(
        route.children,
        branches,
        routesMeta,
        path,
        hasParentOptionalSegments
      );
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index2) => {
    var _a2;
    if (route.path === "" || !((_a2 = route.path) == null ? void 0 : _a2.includes("?"))) {
      flattenRoute(route, index2);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index2, true, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0) return [];
  let [first, ...rest] = segments;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(
    ...restExploded.map(
      (subpath) => subpath === "" ? required : [required, subpath].join("/")
    )
  );
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map(
    (exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded
  );
}
function rankRouteBranches(branches) {
  branches.sort(
    (a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(
      a.routesMeta.map((meta) => meta.childrenIndex),
      b.routesMeta.map((meta) => meta.childrenIndex)
    )
  );
}
var paramRe = /^:[\w-]+$/;
var dynamicSegmentValue = 3;
var indexRouteValue = 2;
var emptySegmentValue = 1;
var staticSegmentValue = 10;
var splatPenalty = -2;
var isSplat = (s) => s === "*";
function computeScore(path, index2) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index2) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s) => !isSplat(s)).reduce(
    (score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue),
    initialScore
  );
}
function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a[a.length - 1] - b[b.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname, allowPartial = false) {
  let { routesMeta } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end2 = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match2 = matchPath(
      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end: end2 },
      remainingPathname
    );
    let route = meta.route;
    if (!match2 && end2 && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
      match2 = matchPath(
        {
          path: meta.relativePath,
          caseSensitive: meta.caseSensitive,
          end: false
        },
        remainingPathname
      );
    }
    if (!match2) {
      return null;
    }
    Object.assign(matchedParams, match2.params);
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match2.pathname]),
      pathnameBase: normalizePathname(
        joinPaths([matchedPathname, match2.pathnameBase])
      ),
      route
    });
    if (match2.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = { path: pattern, caseSensitive: false, end: true };
  }
  let [matcher, compiledParams] = compilePath(
    pattern.path,
    pattern.caseSensitive,
    pattern.end
  );
  let match2 = pathname.match(matcher);
  if (!match2) return null;
  let matchedPathname = match2[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match2.slice(1);
  let params = compiledParams.reduce(
    (memo2, { paramName, isOptional }, index2) => {
      if (paramName === "*") {
        let splatValue = captureGroups[index2] || "";
        pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
      }
      const value = captureGroups[index2];
      if (isOptional && !value) {
        memo2[paramName] = void 0;
      } else {
        memo2[paramName] = (value || "").replace(/%2F/g, "/");
      }
      return memo2;
    },
    {}
  );
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive = false, end2 = true) {
  warning(
    path === "*" || !path.endsWith("*") || path.endsWith("/*"),
    `Route path "${path}" will be treated as if it were "${path.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${path.replace(/\*$/, "/*")}".`
  );
  let params = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
    /\/:([\w-]+)(\?)?/g,
    (_, paramName, isOptional) => {
      params.push({ paramName, isOptional: isOptional != null });
      return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
    }
  ).replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2");
  if (path.endsWith("*")) {
    params.push({ paramName: "*" });
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end2) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, params];
}
function decodePath(value) {
  try {
    return value.split("/").map((v) => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
  } catch (error2) {
    warning(
      false,
      `The URL path "${value}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error2}).`
    );
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function resolvePath(to, fromPathname = "/") {
  let {
    pathname: toPathname,
    search = "",
    hash: hash2 = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash2)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char2, field, dest, path) {
  return `Cannot include a '${char2}' character in a manually specified \`to.${field}\` field [${JSON.stringify(
    path
  )}].  Please separate it out to the \`to.${dest}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function getPathContributingMatches(matches) {
  return matches.filter(
    (match2, index2) => index2 === 0 || match2.route.path && match2.route.path.length > 0
  );
}
function getResolveToMatches(matches) {
  let pathMatches = getPathContributingMatches(matches);
  return pathMatches.map(
    (match2, idx) => idx === pathMatches.length - 1 ? match2.pathname : match2.pathnameBase
  );
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = __spreadValues({}, toArg);
    invariant(
      !to.pathname || !to.pathname.includes("?"),
      getInvalidPathError("?", "pathname", "search", to)
    );
    invariant(
      !to.pathname || !to.pathname.includes("#"),
      getInvalidPathError("#", "pathname", "hash", to)
    );
    invariant(
      !to.search || !to.search.includes("#"),
      getInvalidPathError("#", "search", "hash", to)
    );
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from2;
  if (toPathname == null) {
    from2 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from2);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
var normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
var normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
function isRouteErrorResponse(error2) {
  return error2 != null && typeof error2.status === "number" && typeof error2.statusText === "string" && typeof error2.internal === "boolean" && "data" in error2;
}
var validMutationMethodsArr = [
  "POST",
  "PUT",
  "PATCH",
  "DELETE"
];
new Set(
  validMutationMethodsArr
);
var validRequestMethodsArr = [
  "GET",
  ...validMutationMethodsArr
];
new Set(validRequestMethodsArr);
var DataRouterContext = reactExports.createContext(null);
DataRouterContext.displayName = "DataRouter";
var DataRouterStateContext = reactExports.createContext(null);
DataRouterStateContext.displayName = "DataRouterState";
reactExports.createContext(false);
var ViewTransitionContext = reactExports.createContext({
  isTransitioning: false
});
ViewTransitionContext.displayName = "ViewTransition";
var FetchersContext = reactExports.createContext(
  /* @__PURE__ */ new Map()
);
FetchersContext.displayName = "Fetchers";
var AwaitContext = reactExports.createContext(null);
AwaitContext.displayName = "Await";
var NavigationContext = reactExports.createContext(
  null
);
NavigationContext.displayName = "Navigation";
var LocationContext = reactExports.createContext(
  null
);
LocationContext.displayName = "Location";
var RouteContext = reactExports.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
RouteContext.displayName = "Route";
var RouteErrorContext = reactExports.createContext(null);
RouteErrorContext.displayName = "RouteError";
function useHref(to, { relative } = {}) {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useHref() may be used only in the context of a <Router> component.`
  );
  let { basename, navigator: navigator2 } = reactExports.useContext(NavigationContext);
  let { hash: hash2, pathname, search } = useResolvedPath(to, { relative });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({ pathname: joinedPathname, search, hash: hash2 });
}
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
function useLocation() {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useLocation() may be used only in the context of a <Router> component.`
  );
  return reactExports.useContext(LocationContext).location;
}
var navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;
function useIsomorphicLayoutEffect(cb) {
  let isStatic = reactExports.useContext(NavigationContext).static;
  if (!isStatic) {
    reactExports.useLayoutEffect(cb);
  }
}
function useNavigate() {
  let { isDataRoute } = reactExports.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useNavigate() may be used only in the context of a <Router> component.`
  );
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  let { basename, navigator: navigator2 } = reactExports.useContext(NavigationContext);
  let { matches } = reactExports.useContext(RouteContext);
  let { pathname: locationPathname } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(
    (to, options = {}) => {
      warning(activeRef.current, navigateEffectWarning);
      if (!activeRef.current) return;
      if (typeof to === "number") {
        navigator2.go(to);
        return;
      }
      let path = resolveTo(
        to,
        JSON.parse(routePathnamesJson),
        locationPathname,
        options.relative === "path"
      );
      if (dataRouterContext == null && basename !== "/") {
        path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
      }
      (!!options.replace ? navigator2.replace : navigator2.push)(
        path,
        options.state,
        options
      );
    },
    [
      basename,
      navigator2,
      routePathnamesJson,
      locationPathname,
      dataRouterContext
    ]
  );
  return navigate;
}
reactExports.createContext(null);
function useResolvedPath(to, { relative } = {}) {
  let { matches } = reactExports.useContext(RouteContext);
  let { pathname: locationPathname } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
  return reactExports.useMemo(
    () => resolveTo(
      to,
      JSON.parse(routePathnamesJson),
      locationPathname,
      relative === "path"
    ),
    [to, routePathnamesJson, locationPathname, relative]
  );
}
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}
function useRoutesImpl(routes, locationArg, dataRouterState, unstable_onError, future) {
  var _a2;
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useRoutes() may be used only in the context of a <Router> component.`
  );
  let { navigator: navigator2 } = reactExports.useContext(NavigationContext);
  let { matches: parentMatches } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  {
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(
      parentPathname,
      !parentRoute || parentPath.endsWith("*") || parentPath.endsWith("*?"),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${parentPathname}" (under <Route path="${parentPath}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${parentPath}"> to <Route path="${parentPath === "/" ? "*" : `${parentPath}/*`}">.`
    );
  }
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    invariant(
      parentPathnameBase === "/" || ((_a2 = parsedLocationArg.pathname) == null ? void 0 : _a2.startsWith(parentPathnameBase)),
      `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${parentPathnameBase}" but pathname "${parsedLocationArg.pathname}" was given in the \`location\` prop.`
    );
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = pathname;
  if (parentPathnameBase !== "/") {
    let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
    let segments = pathname.replace(/^\//, "").split("/");
    remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
  }
  let matches = matchRoutes(routes, { pathname: remainingPathname });
  {
    warning(
      parentRoute || matches != null,
      `No routes matched location "${location.pathname}${location.search}${location.hash}" `
    );
    warning(
      matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0,
      `Matched leaf route at location "${location.pathname}${location.search}${location.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
    );
  }
  let renderedMatches = _renderMatches(
    matches && matches.map(
      (match2) => Object.assign({}, match2, {
        params: Object.assign({}, parentParams, match2.params),
        pathname: joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes.
          // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
          // `new URL()` internally and we need to prevent it from treating
          // them as separators
          navigator2.encodeLocation ? navigator2.encodeLocation(
            match2.pathname.replace(/\?/g, "%3F").replace(/#/g, "%23")
          ).pathname : match2.pathname
        ]),
        pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
          // `new URL()` internally and we need to prevent it from treating
          // them as separators
          navigator2.encodeLocation ? navigator2.encodeLocation(
            match2.pathnameBase.replace(/\?/g, "%3F").replace(/#/g, "%23")
          ).pathname : match2.pathnameBase
        ])
      })
    ),
    parentMatches,
    dataRouterState,
    unstable_onError,
    future
  );
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ reactExports.createElement(
      LocationContext.Provider,
      {
        value: {
          location: __spreadValues({
            pathname: "/",
            search: "",
            hash: "",
            state: null,
            key: "default"
          }, location),
          navigationType: "POP"
          /* Pop */
        }
      },
      renderedMatches
    );
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error2 = useRouteError();
  let message = isRouteErrorResponse(error2) ? `${error2.status} ${error2.statusText}` : error2 instanceof Error ? error2.message : JSON.stringify(error2);
  let stack = error2 instanceof Error ? error2.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = { padding: "0.5rem", backgroundColor: lightgrey };
  let codeStyles = { padding: "2px 4px", backgroundColor: lightgrey };
  let devInfo = null;
  {
    console.error(
      "Error handled by React Router default ErrorBoundary:",
      error2
    );
    devInfo = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("p", null, " Hey developer "), /* @__PURE__ */ reactExports.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ reactExports.createElement("code", { style: codeStyles }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ reactExports.createElement("code", { style: codeStyles }, "errorElement"), " prop on your route."));
  }
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", { style: { fontStyle: "italic" } }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", { style: preStyles }, stack) : null, devInfo);
}
var defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
var RenderErrorBoundary = class extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error2) {
    return { error: error2 };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error !== void 0 ? props.error : state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error2, errorInfo) {
    if (this.props.unstable_onError) {
      this.props.unstable_onError(error2, errorInfo);
    } else {
      console.error(
        "React Router caught the following error during render",
        error2
      );
    }
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, { value: this.props.routeContext }, /* @__PURE__ */ reactExports.createElement(
      RouteErrorContext.Provider,
      {
        value: this.state.error,
        children: this.props.component
      }
    )) : this.props.children;
  }
};
function RenderedRoute({ routeContext, match: match2, children }) {
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match2.route.errorElement || match2.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match2.route.id;
  }
  return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, { value: routeContext }, children);
}
function _renderMatches(matches, parentMatches = [], dataRouterState = null, unstable_onError = null, future = null) {
  if (matches == null) {
    if (!dataRouterState) {
      return null;
    }
    if (dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = dataRouterState == null ? void 0 : dataRouterState.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex(
      (m) => m.route.id && (errors == null ? void 0 : errors[m.route.id]) !== void 0
    );
    invariant(
      errorIndex >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(
        errors
      ).join(",")}`
    );
    renderedMatches = renderedMatches.slice(
      0,
      Math.min(renderedMatches.length, errorIndex + 1)
    );
  }
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState) {
    for (let i = 0; i < renderedMatches.length; i++) {
      let match2 = renderedMatches[i];
      if (match2.route.HydrateFallback || match2.route.hydrateFallbackElement) {
        fallbackIndex = i;
      }
      if (match2.route.id) {
        let { loaderData, errors: errors2 } = dataRouterState;
        let needsToRunLoader = match2.route.loader && !loaderData.hasOwnProperty(match2.route.id) && (!errors2 || errors2[match2.route.id] === void 0);
        if (match2.route.lazy || needsToRunLoader) {
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  return renderedMatches.reduceRight(
    (outlet, match2, index2) => {
      let error2;
      let shouldRenderHydrateFallback = false;
      let errorElement = null;
      let hydrateFallbackElement = null;
      if (dataRouterState) {
        error2 = errors && match2.route.id ? errors[match2.route.id] : void 0;
        errorElement = match2.route.errorElement || defaultErrorElement;
        if (renderFallback) {
          if (fallbackIndex < 0 && index2 === 0) {
            warningOnce(
              "route-fallback",
              false,
              "No `HydrateFallback` element provided to render during initial hydration"
            );
            shouldRenderHydrateFallback = true;
            hydrateFallbackElement = null;
          } else if (fallbackIndex === index2) {
            shouldRenderHydrateFallback = true;
            hydrateFallbackElement = match2.route.hydrateFallbackElement || null;
          }
        }
      }
      let matches2 = parentMatches.concat(renderedMatches.slice(0, index2 + 1));
      let getChildren = () => {
        let children;
        if (error2) {
          children = errorElement;
        } else if (shouldRenderHydrateFallback) {
          children = hydrateFallbackElement;
        } else if (match2.route.Component) {
          children = /* @__PURE__ */ reactExports.createElement(match2.route.Component, null);
        } else if (match2.route.element) {
          children = match2.route.element;
        } else {
          children = outlet;
        }
        return /* @__PURE__ */ reactExports.createElement(
          RenderedRoute,
          {
            match: match2,
            routeContext: {
              outlet,
              matches: matches2,
              isDataRoute: dataRouterState != null
            },
            children
          }
        );
      };
      return dataRouterState && (match2.route.ErrorBoundary || match2.route.errorElement || index2 === 0) ? /* @__PURE__ */ reactExports.createElement(
        RenderErrorBoundary,
        {
          location: dataRouterState.location,
          revalidation: dataRouterState.revalidation,
          component: errorElement,
          error: error2,
          children: getChildren(),
          routeContext: { outlet: null, matches: matches2, isDataRoute: true },
          unstable_onError
        }
      ) : getChildren();
    },
    null
  );
}
function getDataRouterConsoleError(hookName) {
  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function useDataRouterContext(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  invariant(ctx, getDataRouterConsoleError(hookName));
  return ctx;
}
function useDataRouterState(hookName) {
  let state = reactExports.useContext(DataRouterStateContext);
  invariant(state, getDataRouterConsoleError(hookName));
  return state;
}
function useRouteContext(hookName) {
  let route = reactExports.useContext(RouteContext);
  invariant(route, getDataRouterConsoleError(hookName));
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext(hookName);
  let thisRoute = route.matches[route.matches.length - 1];
  invariant(
    thisRoute.route.id,
    `${hookName} can only be used on routes that contain a unique "id"`
  );
  return thisRoute.route.id;
}
function useRouteId() {
  return useCurrentRouteId(
    "useRouteId"
    /* UseRouteId */
  );
}
function useRouteError() {
  var _a2;
  let error2 = reactExports.useContext(RouteErrorContext);
  let state = useDataRouterState(
    "useRouteError"
    /* UseRouteError */
  );
  let routeId = useCurrentRouteId(
    "useRouteError"
    /* UseRouteError */
  );
  if (error2 !== void 0) {
    return error2;
  }
  return (_a2 = state.errors) == null ? void 0 : _a2[routeId];
}
function useNavigateStable() {
  let { router } = useDataRouterContext(
    "useNavigate"
    /* UseNavigateStable */
  );
  let id = useCurrentRouteId(
    "useNavigate"
    /* UseNavigateStable */
  );
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(
    (_0, ..._1) => __async(null, [_0, ..._1], function* (to, options = {}) {
      warning(activeRef.current, navigateEffectWarning);
      if (!activeRef.current) return;
      if (typeof to === "number") {
        router.navigate(to);
      } else {
        yield router.navigate(to, __spreadValues({ fromRouteId: id }, options));
      }
    }),
    [router, id]
  );
  return navigate;
}
var alreadyWarned = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
    warning(false, message);
  }
}
reactExports.memo(DataRoutes);
function DataRoutes({
  routes,
  future,
  state,
  unstable_onError
}) {
  return useRoutesImpl(routes, void 0, state, unstable_onError, future);
}
function Route(props) {
  invariant(
    false,
    `A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.`
  );
}
function Router({
  basename: basenameProp = "/",
  children = null,
  location: locationProp,
  navigationType = "POP",
  navigator: navigator2,
  static: staticProp = false
}) {
  invariant(
    !useInRouterContext(),
    `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`
  );
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(
    () => ({
      basename,
      navigator: navigator2,
      static: staticProp,
      future: {}
    }),
    [basename, navigator2, staticProp]
  );
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash: hash2 = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash: hash2,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash2, state, key, navigationType]);
  warning(
    locationContext != null,
    `<Router basename="${basename}"> is not able to match the URL "${pathname}${search}${hash2}" because it does not start with the basename, so the <Router> won't render anything.`
  );
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, { value: navigationContext }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, { children, value: locationContext }));
}
function Routes({
  children,
  location
}) {
  return useRoutes(createRoutesFromChildren(children), location);
}
function createRoutesFromChildren(children, parentPath = []) {
  let routes = [];
  reactExports.Children.forEach(children, (element, index2) => {
    if (!reactExports.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index2];
    if (element.type === reactExports.Fragment) {
      routes.push.apply(
        routes,
        createRoutesFromChildren(element.props.children, treePath)
      );
      return;
    }
    invariant(
      element.type === Route,
      `[${typeof element.type === "string" ? element.type : element.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`
    );
    invariant(
      !element.props.index || !element.props.children,
      "An index route cannot have child routes."
    );
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      middleware: element.props.middleware,
      loader: element.props.loader,
      action: element.props.action,
      hydrateFallbackElement: element.props.hydrateFallbackElement,
      HydrateFallback: element.props.HydrateFallback,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.hasErrorBoundary === true || element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(
        element.props.children,
        treePath
      );
    }
    routes.push(route);
  });
  return routes;
}
var defaultMethod = "get";
var defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement(object) {
  return object != null && typeof object.tagName === "string";
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
var _formDataSupportsSubmitter = null;
function isFormDataSubmitterSupported() {
  if (_formDataSupportsSubmitter === null) {
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      );
      _formDataSupportsSubmitter = false;
    } catch (e) {
      _formDataSupportsSubmitter = true;
    }
  }
  return _formDataSupportsSubmitter;
}
var supportedFormEncTypes = /* @__PURE__ */ new Set([
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain"
]);
function getFormEncType(encType) {
  if (encType != null && !supportedFormEncTypes.has(encType)) {
    warning(
      false,
      `"${encType}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${defaultEncType}"`
    );
    return null;
  }
  return encType;
}
function getFormSubmissionInfo(target, basename) {
  let method;
  let action;
  let encType;
  let formData;
  let body2;
  if (isFormElement(target)) {
    let attr = target.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(target);
  } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
    let form = target.form;
    if (form == null) {
      throw new Error(
        `Cannot submit a <button> or <input type="submit"> without a <form>`
      );
    }
    let attr = target.getAttribute("formaction") || form.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(form, target);
    if (!isFormDataSubmitterSupported()) {
      let { name: name2, type, value } = target;
      if (type === "image") {
        let prefix2 = name2 ? `${name2}.` : "";
        formData.append(`${prefix2}x`, "0");
        formData.append(`${prefix2}y`, "0");
      } else if (name2) {
        formData.append(name2, value);
      }
    }
  } else if (isHtmlElement(target)) {
    throw new Error(
      `Cannot submit element that is not <form>, <button>, or <input type="submit|image">`
    );
  } else {
    method = defaultMethod;
    action = null;
    encType = defaultEncType;
    body2 = target;
  }
  if (formData && encType === "text/plain") {
    body2 = formData;
    formData = void 0;
  }
  return { action, method: method.toLowerCase(), encType, formData, body: body2 };
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function invariant2(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function singleFetchUrl(reqUrl, basename, extension) {
  let url = typeof reqUrl === "string" ? new URL(
    reqUrl,
    // This can be called during the SSR flow via PrefetchPageLinksImpl so
    // don't assume window is available
    typeof window === "undefined" ? "server://singlefetch/" : window.location.origin
  ) : reqUrl;
  if (url.pathname === "/") {
    url.pathname = `_root.${extension}`;
  } else if (basename && stripBasename(url.pathname, basename) === "/") {
    url.pathname = `${basename.replace(/\/$/, "")}/_root.${extension}`;
  } else {
    url.pathname = `${url.pathname.replace(/\/$/, "")}.${extension}`;
  }
  return url;
}
function loadRouteModule(route, routeModulesCache) {
  return __async(this, null, function* () {
    if (route.id in routeModulesCache) {
      return routeModulesCache[route.id];
    }
    try {
      let routeModule = yield import(
        /* @vite-ignore */
        /* webpackIgnore: true */
        route.module
      );
      routeModulesCache[route.id] = routeModule;
      return routeModule;
    } catch (error2) {
      console.error(
        `Error loading route module \`${route.module}\`, reloading page...`
      );
      console.error(error2);
      if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode && // @ts-expect-error
      void 0) ;
      window.location.reload();
      return new Promise(() => {
      });
    }
  });
}
function isHtmlLinkDescriptor(object) {
  if (object == null) {
    return false;
  }
  if (object.href == null) {
    return object.rel === "preload" && typeof object.imageSrcSet === "string" && typeof object.imageSizes === "string";
  }
  return typeof object.rel === "string" && typeof object.href === "string";
}
function getKeyedPrefetchLinks(matches, manifest, routeModules) {
  return __async(this, null, function* () {
    let links = yield Promise.all(
      matches.map((match2) => __async(null, null, function* () {
        let route = manifest.routes[match2.route.id];
        if (route) {
          let mod = yield loadRouteModule(route, routeModules);
          return mod.links ? mod.links() : [];
        }
        return [];
      }))
    );
    return dedupeLinkDescriptors(
      links.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map(
        (link) => link.rel === "stylesheet" ? __spreadProps(__spreadValues({}, link), { rel: "prefetch", as: "style" }) : __spreadProps(__spreadValues({}, link), { rel: "prefetch" })
      )
    );
  });
}
function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {
  let isNew = (match2, index2) => {
    if (!currentMatches[index2]) return true;
    return match2.route.id !== currentMatches[index2].route.id;
  };
  let matchPathChanged = (match2, index2) => {
    var _a2;
    return (
      // param change, /users/123 -> /users/456
      currentMatches[index2].pathname !== match2.pathname || // splat param changed, which is not present in match.path
      // e.g. /files/images/avatar.jpg -> files/finances.xls
      ((_a2 = currentMatches[index2].route.path) == null ? void 0 : _a2.endsWith("*")) && currentMatches[index2].params["*"] !== match2.params["*"]
    );
  };
  if (mode === "assets") {
    return nextMatches.filter(
      (match2, index2) => isNew(match2, index2) || matchPathChanged(match2, index2)
    );
  }
  if (mode === "data") {
    return nextMatches.filter((match2, index2) => {
      var _a2;
      let manifestRoute = manifest.routes[match2.route.id];
      if (!manifestRoute || !manifestRoute.hasLoader) {
        return false;
      }
      if (isNew(match2, index2) || matchPathChanged(match2, index2)) {
        return true;
      }
      if (match2.route.shouldRevalidate) {
        let routeChoice = match2.route.shouldRevalidate({
          currentUrl: new URL(
            location.pathname + location.search + location.hash,
            window.origin
          ),
          currentParams: ((_a2 = currentMatches[0]) == null ? void 0 : _a2.params) || {},
          nextUrl: new URL(page, window.origin),
          nextParams: match2.params,
          defaultShouldRevalidate: true
        });
        if (typeof routeChoice === "boolean") {
          return routeChoice;
        }
      }
      return true;
    });
  }
  return [];
}
function getModuleLinkHrefs(matches, manifest, { includeHydrateFallback } = {}) {
  return dedupeHrefs(
    matches.map((match2) => {
      let route = manifest.routes[match2.route.id];
      if (!route) return [];
      let hrefs = [route.module];
      if (route.clientActionModule) {
        hrefs = hrefs.concat(route.clientActionModule);
      }
      if (route.clientLoaderModule) {
        hrefs = hrefs.concat(route.clientLoaderModule);
      }
      if (includeHydrateFallback && route.hydrateFallbackModule) {
        hrefs = hrefs.concat(route.hydrateFallbackModule);
      }
      if (route.imports) {
        hrefs = hrefs.concat(route.imports);
      }
      return hrefs;
    }).flat(1)
  );
}
function dedupeHrefs(hrefs) {
  return [...new Set(hrefs)];
}
function sortKeys(obj) {
  let sorted = {};
  let keys = Object.keys(obj).sort();
  for (let key of keys) {
    sorted[key] = obj[key];
  }
  return sorted;
}
function dedupeLinkDescriptors(descriptors, preloads) {
  let set = /* @__PURE__ */ new Set();
  new Set(preloads);
  return descriptors.reduce((deduped, descriptor) => {
    let key = JSON.stringify(sortKeys(descriptor));
    if (!set.has(key)) {
      set.add(key);
      deduped.push({ key, link: descriptor });
    }
    return deduped;
  }, []);
}
function useDataRouterContext2() {
  let context = reactExports.useContext(DataRouterContext);
  invariant2(
    context,
    "You must render this element inside a <DataRouterContext.Provider> element"
  );
  return context;
}
function useDataRouterStateContext() {
  let context = reactExports.useContext(DataRouterStateContext);
  invariant2(
    context,
    "You must render this element inside a <DataRouterStateContext.Provider> element"
  );
  return context;
}
var FrameworkContext = reactExports.createContext(void 0);
FrameworkContext.displayName = "FrameworkContext";
function useFrameworkContext() {
  let context = reactExports.useContext(FrameworkContext);
  invariant2(
    context,
    "You must render this element inside a <HydratedRouter> element"
  );
  return context;
}
function usePrefetchBehavior(prefetch, theirElementProps) {
  let frameworkContext = reactExports.useContext(FrameworkContext);
  let [maybePrefetch, setMaybePrefetch] = reactExports.useState(false);
  let [shouldPrefetch, setShouldPrefetch] = reactExports.useState(false);
  let { onFocus, onBlur, onMouseEnter, onMouseLeave, onTouchStart } = theirElementProps;
  let ref = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (prefetch === "render") {
      setShouldPrefetch(true);
    }
    if (prefetch === "viewport") {
      let callback = (entries) => {
        entries.forEach((entry) => {
          setShouldPrefetch(entry.isIntersecting);
        });
      };
      let observer = new IntersectionObserver(callback, { threshold: 0.5 });
      if (ref.current) observer.observe(ref.current);
      return () => {
        observer.disconnect();
      };
    }
  }, [prefetch]);
  reactExports.useEffect(() => {
    if (maybePrefetch) {
      let id = setTimeout(() => {
        setShouldPrefetch(true);
      }, 100);
      return () => {
        clearTimeout(id);
      };
    }
  }, [maybePrefetch]);
  let setIntent = () => {
    setMaybePrefetch(true);
  };
  let cancelIntent = () => {
    setMaybePrefetch(false);
    setShouldPrefetch(false);
  };
  if (!frameworkContext) {
    return [false, ref, {}];
  }
  if (prefetch !== "intent") {
    return [shouldPrefetch, ref, {}];
  }
  return [
    shouldPrefetch,
    ref,
    {
      onFocus: composeEventHandlers(onFocus, setIntent),
      onBlur: composeEventHandlers(onBlur, cancelIntent),
      onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
      onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
      onTouchStart: composeEventHandlers(onTouchStart, setIntent)
    }
  ];
}
function composeEventHandlers(theirHandler, ourHandler) {
  return (event) => {
    theirHandler && theirHandler(event);
    if (!event.defaultPrevented) {
      ourHandler(event);
    }
  };
}
function PrefetchPageLinks(_a2) {
  var _b = _a2, { page } = _b, linkProps = __objRest(_b, ["page"]);
  let { router } = useDataRouterContext2();
  let matches = reactExports.useMemo(
    () => matchRoutes(router.routes, page, router.basename),
    [router.routes, page, router.basename]
  );
  if (!matches) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(PrefetchPageLinksImpl, __spreadValues({ page, matches }, linkProps));
}
function useKeyedPrefetchLinks(matches) {
  let { manifest, routeModules } = useFrameworkContext();
  let [keyedPrefetchLinks, setKeyedPrefetchLinks] = reactExports.useState([]);
  reactExports.useEffect(() => {
    let interrupted = false;
    void getKeyedPrefetchLinks(matches, manifest, routeModules).then(
      (links) => {
        if (!interrupted) {
          setKeyedPrefetchLinks(links);
        }
      }
    );
    return () => {
      interrupted = true;
    };
  }, [matches, manifest, routeModules]);
  return keyedPrefetchLinks;
}
function PrefetchPageLinksImpl(_c) {
  var _d = _c, {
    page,
    matches: nextMatches
  } = _d, linkProps = __objRest(_d, [
    "page",
    "matches"
  ]);
  let location = useLocation();
  let { manifest, routeModules } = useFrameworkContext();
  let { basename } = useDataRouterContext2();
  let { loaderData, matches } = useDataRouterStateContext();
  let newMatchesForData = reactExports.useMemo(
    () => getNewMatchesForLinks(
      page,
      nextMatches,
      matches,
      manifest,
      location,
      "data"
    ),
    [page, nextMatches, matches, manifest, location]
  );
  let newMatchesForAssets = reactExports.useMemo(
    () => getNewMatchesForLinks(
      page,
      nextMatches,
      matches,
      manifest,
      location,
      "assets"
    ),
    [page, nextMatches, matches, manifest, location]
  );
  let dataHrefs = reactExports.useMemo(() => {
    if (page === location.pathname + location.search + location.hash) {
      return [];
    }
    let routesParams = /* @__PURE__ */ new Set();
    let foundOptOutRoute = false;
    nextMatches.forEach((m) => {
      var _a2;
      let manifestRoute = manifest.routes[m.route.id];
      if (!manifestRoute || !manifestRoute.hasLoader) {
        return;
      }
      if (!newMatchesForData.some((m2) => m2.route.id === m.route.id) && m.route.id in loaderData && ((_a2 = routeModules[m.route.id]) == null ? void 0 : _a2.shouldRevalidate)) {
        foundOptOutRoute = true;
      } else if (manifestRoute.hasClientLoader) {
        foundOptOutRoute = true;
      } else {
        routesParams.add(m.route.id);
      }
    });
    if (routesParams.size === 0) {
      return [];
    }
    let url = singleFetchUrl(page, basename, "data");
    if (foundOptOutRoute && routesParams.size > 0) {
      url.searchParams.set(
        "_routes",
        nextMatches.filter((m) => routesParams.has(m.route.id)).map((m) => m.route.id).join(",")
      );
    }
    return [url.pathname + url.search];
  }, [
    basename,
    loaderData,
    location,
    manifest,
    newMatchesForData,
    nextMatches,
    page,
    routeModules
  ]);
  let moduleHrefs = reactExports.useMemo(
    () => getModuleLinkHrefs(newMatchesForAssets, manifest),
    [newMatchesForAssets, manifest]
  );
  let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ reactExports.createElement("link", __spreadValues({ key: href, rel: "prefetch", as: "fetch", href }, linkProps))), moduleHrefs.map((href) => /* @__PURE__ */ reactExports.createElement("link", __spreadValues({ key: href, rel: "modulepreload", href }, linkProps))), keyedPrefetchLinks.map(({ key, link }) => (
    // these don't spread `linkProps` because they are full link descriptors
    // already with their own props
    /* @__PURE__ */ reactExports.createElement("link", __spreadValues({ key, nonce: linkProps.nonce }, link))
  )));
}
function mergeRefs(...refs) {
  return (value) => {
    refs.forEach((ref) => {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
}
var isBrowser$3 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
try {
  if (isBrowser$3) {
    window.__reactRouterVersion = // @ts-expect-error
    "7.9.4";
  }
} catch (e) {
}
function BrowserRouter({
  basename,
  children,
  window: window2
}) {
  let historyRef = reactExports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({ window: window2, v5Compat: true });
  }
  let history2 = historyRef.current;
  let [state, setStateImpl] = reactExports.useState({
    action: history2.action,
    location: history2.location
  });
  let setState = reactExports.useCallback(
    (newState) => {
      reactExports.startTransition(() => setStateImpl(newState));
    },
    [setStateImpl]
  );
  reactExports.useLayoutEffect(() => history2.listen(setState), [history2, setState]);
  return /* @__PURE__ */ reactExports.createElement(
    Router,
    {
      basename,
      children,
      location: state.location,
      navigationType: state.action,
      navigator: history2
    }
  );
}
var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var Link$1 = reactExports.forwardRef(
  function LinkWithRef(_e, forwardedRef) {
    var _f = _e, {
      onClick,
      discover = "render",
      prefetch = "none",
      relative,
      reloadDocument,
      replace: replace2,
      state,
      target,
      to,
      preventScrollReset,
      viewTransition
    } = _f, rest = __objRest(_f, [
      "onClick",
      "discover",
      "prefetch",
      "relative",
      "reloadDocument",
      "replace",
      "state",
      "target",
      "to",
      "preventScrollReset",
      "viewTransition"
    ]);
    let { basename } = reactExports.useContext(NavigationContext);
    let isAbsolute = typeof to === "string" && ABSOLUTE_URL_REGEX2.test(to);
    let absoluteHref;
    let isExternal = false;
    if (typeof to === "string" && isAbsolute) {
      absoluteHref = to;
      if (isBrowser$3) {
        try {
          let currentUrl = new URL(window.location.href);
          let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
          let path = stripBasename(targetUrl.pathname, basename);
          if (targetUrl.origin === currentUrl.origin && path != null) {
            to = path + targetUrl.search + targetUrl.hash;
          } else {
            isExternal = true;
          }
        } catch (e) {
          warning(
            false,
            `<Link to="${to}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
          );
        }
      }
    }
    let href = useHref(to, { relative });
    let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(
      prefetch,
      rest
    );
    let internalOnClick = useLinkClickHandler(to, {
      replace: replace2,
      state,
      target,
      preventScrollReset,
      relative,
      viewTransition
    });
    function handleClick(event) {
      if (onClick) onClick(event);
      if (!event.defaultPrevented) {
        internalOnClick(event);
      }
    }
    let link = (
      // eslint-disable-next-line jsx-a11y/anchor-has-content
      /* @__PURE__ */ reactExports.createElement(
        "a",
        __spreadProps(__spreadValues(__spreadValues({}, rest), prefetchHandlers), {
          href: absoluteHref || href,
          onClick: isExternal || reloadDocument ? onClick : handleClick,
          ref: mergeRefs(forwardedRef, prefetchRef),
          target,
          "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
        })
      )
    );
    return shouldPrefetch && !isAbsolute ? /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, link, /* @__PURE__ */ reactExports.createElement(PrefetchPageLinks, { page: href })) : link;
  }
);
Link$1.displayName = "Link";
var NavLink = reactExports.forwardRef(
  function NavLinkWithRef(_g, ref) {
    var _h = _g, {
      "aria-current": ariaCurrentProp = "page",
      caseSensitive = false,
      className: classNameProp = "",
      end: end2 = false,
      style: styleProp,
      to,
      viewTransition,
      children
    } = _h, rest = __objRest(_h, [
      "aria-current",
      "caseSensitive",
      "className",
      "end",
      "style",
      "to",
      "viewTransition",
      "children"
    ]);
    let path = useResolvedPath(to, { relative: rest.relative });
    let location = useLocation();
    let routerState = reactExports.useContext(DataRouterStateContext);
    let { navigator: navigator2, basename } = reactExports.useContext(NavigationContext);
    let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useViewTransitionState(path) && viewTransition === true;
    let toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path).pathname : path.pathname;
    let locationPathname = location.pathname;
    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
    if (!caseSensitive) {
      locationPathname = locationPathname.toLowerCase();
      nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
      toPathname = toPathname.toLowerCase();
    }
    if (nextLocationPathname && basename) {
      nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
    }
    const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
    let isActive = locationPathname === toPathname || !end2 && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end2 && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
    let renderProps = {
      isActive,
      isPending,
      isTransitioning
    };
    let ariaCurrent = isActive ? ariaCurrentProp : void 0;
    let className;
    if (typeof classNameProp === "function") {
      className = classNameProp(renderProps);
    } else {
      className = [
        classNameProp,
        isActive ? "active" : null,
        isPending ? "pending" : null,
        isTransitioning ? "transitioning" : null
      ].filter(Boolean).join(" ");
    }
    let style2 = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
    return /* @__PURE__ */ reactExports.createElement(
      Link$1,
      __spreadProps(__spreadValues({}, rest), {
        "aria-current": ariaCurrent,
        className,
        ref,
        style: style2,
        to,
        viewTransition
      }),
      typeof children === "function" ? children(renderProps) : children
    );
  }
);
NavLink.displayName = "NavLink";
var Form = reactExports.forwardRef(
  (_i, forwardedRef) => {
    var _j = _i, {
      discover = "render",
      fetcherKey,
      navigate,
      reloadDocument,
      replace: replace2,
      state,
      method = defaultMethod,
      action,
      onSubmit,
      relative,
      preventScrollReset,
      viewTransition
    } = _j, props = __objRest(_j, [
      "discover",
      "fetcherKey",
      "navigate",
      "reloadDocument",
      "replace",
      "state",
      "method",
      "action",
      "onSubmit",
      "relative",
      "preventScrollReset",
      "viewTransition"
    ]);
    let submit = useSubmit();
    let formAction = useFormAction(action, { relative });
    let formMethod = method.toLowerCase() === "get" ? "get" : "post";
    let isAbsolute = typeof action === "string" && ABSOLUTE_URL_REGEX2.test(action);
    let submitHandler = (event) => {
      onSubmit && onSubmit(event);
      if (event.defaultPrevented) return;
      event.preventDefault();
      let submitter = event.nativeEvent.submitter;
      let submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;
      submit(submitter || event.currentTarget, {
        fetcherKey,
        method: submitMethod,
        navigate,
        replace: replace2,
        state,
        relative,
        preventScrollReset,
        viewTransition
      });
    };
    return /* @__PURE__ */ reactExports.createElement(
      "form",
      __spreadProps(__spreadValues({
        ref: forwardedRef,
        method: formMethod,
        action: formAction,
        onSubmit: reloadDocument ? onSubmit : submitHandler
      }, props), {
        "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
      })
    );
  }
);
Form.displayName = "Form";
function getDataRouterConsoleError2(hookName) {
  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function useDataRouterContext3(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  invariant(ctx, getDataRouterConsoleError2(hookName));
  return ctx;
}
function useLinkClickHandler(to, {
  target,
  replace: replaceProp,
  state,
  preventScrollReset,
  relative,
  viewTransition
} = {}) {
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to, { relative });
  return reactExports.useCallback(
    (event) => {
      if (shouldProcessLinkClick(event, target)) {
        event.preventDefault();
        let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
        navigate(to, {
          replace: replace2,
          state,
          preventScrollReset,
          relative,
          viewTransition
        });
      }
    },
    [
      location,
      navigate,
      path,
      replaceProp,
      state,
      target,
      to,
      preventScrollReset,
      relative,
      viewTransition
    ]
  );
}
var fetcherId = 0;
var getUniqueFetcherId = () => `__${String(++fetcherId)}__`;
function useSubmit() {
  let { router } = useDataRouterContext3(
    "useSubmit"
    /* UseSubmit */
  );
  let { basename } = reactExports.useContext(NavigationContext);
  let currentRouteId = useRouteId();
  return reactExports.useCallback(
    (_0, ..._1) => __async(null, [_0, ..._1], function* (target, options = {}) {
      let { action, method, encType, formData, body: body2 } = getFormSubmissionInfo(
        target,
        basename
      );
      if (options.navigate === false) {
        let key = options.fetcherKey || getUniqueFetcherId();
        yield router.fetch(key, currentRouteId, options.action || action, {
          preventScrollReset: options.preventScrollReset,
          formData,
          body: body2,
          formMethod: options.method || method,
          formEncType: options.encType || encType,
          flushSync: options.flushSync
        });
      } else {
        yield router.navigate(options.action || action, {
          preventScrollReset: options.preventScrollReset,
          formData,
          body: body2,
          formMethod: options.method || method,
          formEncType: options.encType || encType,
          replace: options.replace,
          state: options.state,
          fromRouteId: currentRouteId,
          flushSync: options.flushSync,
          viewTransition: options.viewTransition
        });
      }
    }),
    [router, basename, currentRouteId]
  );
}
function useFormAction(action, { relative } = {}) {
  let { basename } = reactExports.useContext(NavigationContext);
  let routeContext = reactExports.useContext(RouteContext);
  invariant(routeContext, "useFormAction must be used inside a RouteContext");
  let [match2] = routeContext.matches.slice(-1);
  let path = __spreadValues({}, useResolvedPath(action ? action : ".", { relative }));
  let location = useLocation();
  if (action == null) {
    path.search = location.search;
    let params = new URLSearchParams(path.search);
    let indexValues = params.getAll("index");
    let hasNakedIndexParam = indexValues.some((v) => v === "");
    if (hasNakedIndexParam) {
      params.delete("index");
      indexValues.filter((v) => v).forEach((v) => params.append("index", v));
      let qs = params.toString();
      path.search = qs ? `?${qs}` : "";
    }
  }
  if ((!action || action === ".") && match2.route.index) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  }
  if (basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
function useViewTransitionState(to, { relative } = {}) {
  let vtContext = reactExports.useContext(ViewTransitionContext);
  invariant(
    vtContext != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
  );
  let { basename } = useDataRouterContext3(
    "useViewTransitionState"
    /* useViewTransitionState */
  );
  let path = useResolvedPath(to, { relative });
  if (!vtContext.isTransitioning) {
    return false;
  }
  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
}
var reactDomExports = requireReactDom();
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
let ErrorBoundary$1 = class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  static getDerivedStateFromError(error2) {
    return { hasError: true, error: error2 };
  }
  componentDidCatch(error2, errorInfo) {
    console.error("ErrorBoundary caught:", error2, errorInfo);
  }
  render() {
    var _a2;
    if (this.state.hasError) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
        color: "white",
        backgroundColor: "red",
        padding: 32,
        minHeight: "100vh",
        fontSize: "16px"
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Something went wrong." }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("pre", { style: { whiteSpace: "pre-wrap", wordBreak: "break-word" }, children: [
          String(this.state.error),
          (_a2 = this.state.error) == null ? void 0 : _a2.stack
        ] })
      ] });
    }
    return this.props.children;
  }
};
var define_process_env_default = {};
var name = "@vercel/speed-insights";
var version$4 = "1.2.0";
var initQueue = () => {
  if (window.si) return;
  window.si = function a(...params) {
    (window.siq = window.siq || []).push(params);
  };
};
function isBrowser$2() {
  return typeof window !== "undefined";
}
function detectEnvironment() {
  try {
    const env = "production";
    if (env === "development" || env === "test") ;
  } catch (e) {
  }
  return "production";
}
function isDevelopment() {
  return detectEnvironment() === "development";
}
function getScriptSrc(props) {
  if (props.scriptSrc) {
    return props.scriptSrc;
  }
  if (isDevelopment()) {
    return "https://va.vercel-scripts.com/v1/speed-insights/script.debug.js";
  }
  if (props.dsn) {
    return "https://va.vercel-scripts.com/v1/speed-insights/script.js";
  }
  if (props.basePath) {
    return `${props.basePath}/speed-insights/script.js`;
  }
  return "/_vercel/speed-insights/script.js";
}
function injectSpeedInsights(props = {}) {
  var _a2;
  if (!isBrowser$2() || props.route === null) return null;
  initQueue();
  const src = getScriptSrc(props);
  if (document.head.querySelector(`script[src*="${src}"]`)) return null;
  if (props.beforeSend) {
    (_a2 = window.si) == null ? void 0 : _a2.call(window, "beforeSend", props.beforeSend);
  }
  const script = document.createElement("script");
  script.src = src;
  script.defer = true;
  script.dataset.sdkn = name + (props.framework ? `/${props.framework}` : "");
  script.dataset.sdkv = version$4;
  if (props.sampleRate) {
    script.dataset.sampleRate = props.sampleRate.toString();
  }
  if (props.route) {
    script.dataset.route = props.route;
  }
  if (props.endpoint) {
    script.dataset.endpoint = props.endpoint;
  } else if (props.basePath) {
    script.dataset.endpoint = `${props.basePath}/speed-insights/vitals`;
  }
  if (props.dsn) {
    script.dataset.dsn = props.dsn;
  }
  if (isDevelopment() && props.debug === false) {
    script.dataset.debug = "false";
  }
  script.onerror = () => {
    console.log(
      `[Vercel Speed Insights] Failed to load script from ${src}. Please check if any content blockers are enabled and try again.`
    );
  };
  document.head.appendChild(script);
  return {
    setRoute: (route) => {
      script.dataset.route = route != null ? route : void 0;
    }
  };
}
function getBasePath() {
  if (typeof process === "undefined" || typeof define_process_env_default === "undefined") {
    return void 0;
  }
  return define_process_env_default.REACT_APP_VERCEL_OBSERVABILITY_BASEPATH;
}
function SpeedInsights(props) {
  reactExports.useEffect(() => {
    var _a2;
    if (props.beforeSend) {
      (_a2 = window.si) == null ? void 0 : _a2.call(window, "beforeSend", props.beforeSend);
    }
  }, [props.beforeSend]);
  const setScriptRoute = reactExports.useRef(null);
  reactExports.useEffect(() => {
    var _a2, _b;
    if (!setScriptRoute.current) {
      const script = injectSpeedInsights(__spreadValues({
        framework: (_a2 = props.framework) != null ? _a2 : "react",
        basePath: (_b = props.basePath) != null ? _b : getBasePath()
      }, props));
      if (script) {
        setScriptRoute.current = script.setRoute;
      }
    } else if (props.route) {
      setScriptRoute.current(props.route);
    }
  }, [props.route]);
  return null;
}
const App$2 = React.lazy(() => __vitePreload(() => Promise.resolve().then(() => App$1), true ? [] : void 0, import.meta.url));
const WebLanding$2 = React.lazy(() => __vitePreload(() => Promise.resolve().then(() => WebLanding$1), true ? void 0 : void 0, import.meta.url));
const WebAppShell$2 = React.lazy(() => __vitePreload(() => Promise.resolve().then(() => WebAppShell$1), true ? void 0 : void 0, import.meta.url));
window.React = React;
window.ReactDOM = ReactDOM$1;
console.log("StrainSpotter main.jsx loading...");
console.log("Protocol:", window.location.protocol);
console.log("Hostname:", window.location.hostname);
const isCapacitor$1 = typeof window !== "undefined" && window.location.protocol === "capacitor:";
const LoadingFallback = () => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    style: {
      width: "100%",
      height: "100vh",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      background: "#050705",
      color: "#C5E1A5",
      fontFamily: "system-ui, -apple-system, BlinkMacSystemFont, sans-serif",
      fontSize: "1rem"
    },
    children: "Loading StrainSpotter"
  }
);
function RootApp() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingFallback, {}), children: /* @__PURE__ */ jsxRuntimeExports.jsx(App$2, {}) });
}
function CapacitorRoot() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RootApp, {});
}
function WebRoot() {
  React.useEffect(() => {
    if (typeof document !== "undefined") {
      document.body.classList.add("web-root");
      return () => {
        document.body.classList.remove("web-root");
      };
    }
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserRouter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingFallback, {}), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/", element: /* @__PURE__ */ jsxRuntimeExports.jsx(WebLanding$2, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/app/*", element: /* @__PURE__ */ jsxRuntimeExports.jsx(WebAppShell$2, {}) })
  ] }) }) });
}
clientExports.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.StrictMode, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary$1, { children: isCapacitor$1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(CapacitorRoot, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(WebRoot, {}) }),
    !isCapacitor$1 && /* @__PURE__ */ jsxRuntimeExports.jsx(SpeedInsights, {})
  ] })
);
const splash = document.getElementById("splash-root");
if (splash && splash.parentNode) {
  splash.parentNode.removeChild(splash);
}
console.log("StrainSpotter rendered!");
const common = {
  black: "#000",
  white: "#fff"
};
const red = {
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  700: "#d32f2f",
  800: "#c62828"
};
const purple = {
  50: "#f3e5f5",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  700: "#7b1fa2"
};
const blue = {
  50: "#e3f2fd",
  200: "#90caf9",
  400: "#42a5f5",
  700: "#1976d2",
  800: "#1565c0"
};
const lightBlue = {
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  700: "#0288d1",
  900: "#01579b"
};
const green = {
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20"
};
const orange = {
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  700: "#f57c00",
  900: "#e65100"
};
const grey = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
};
function formatMuiErrorMessage(code, ...args) {
  const url = new URL(`https://mui.com/production-error/?code=${code}`);
  args.forEach((arg2) => url.searchParams.append("args[]", arg2));
  return `Minified MUI error #${code}; visit ${url} for the full message.`;
}
const THEME_ID = "$$material";
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
  return void 0;
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ (function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      var _tag$parentNode;
      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
})();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash$2(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end2) {
  return value.slice(begin, end2);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type, props, children, length2) {
  return { value, root, parent, type, props, children, line, column, length: length2, return: "" };
}
function copy(root, props) {
  return assign(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end2) {
  return substr(characters, begin, end2);
}
function token(type) {
  switch (type) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      // ] ) " '
      case type:
        return position;
      // " '
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      // (
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      // \
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index2) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice(index2, position);
}
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset2 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference2 = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      // (
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      // \
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      // /
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      // {
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      // } ; \0
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          // \0 }
          case 0:
          case 125:
            scanning = 0;
          // ;
          case 59 + offset2:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          // @ ;
          case 59:
            characters2 += ";";
          // { rule/at-rule
          default:
            append(reference2 = ruleset(characters2, root, parent, index2, offset2, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset2 === 0)
                parse(characters2, root, reference2, reference2, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference2, reference2, rule && append(ruleset(value, reference2, reference2, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                }
        }
        index2 = offset2 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      // :
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          // &
          case 38:
            ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          // ,
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          // @
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset2 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          // -
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index2, offset2, rules, points, type, props, children, length2) {
  var post2 = offset2 - 1;
  var rule = offset2 === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i = 0, j = 0, k = 0; i < index2; ++i)
    for (var x = 0, y = substr(value, post2 + 1, post2 = abs(j = points[i])), z = value; x < size; ++x)
      if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x])))
        props[k++] = z;
  return node(value, root, parent, offset2 === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root, parent) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent, length2) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i = 0; i < length2; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
function stringify(element, index2, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children, callback) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection[i](element, index2, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
function memoize$1(fn2) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg2) {
    if (cache[arg2] === void 0) cache[arg2] = fn2(arg2);
    return cache[arg2];
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      // fallthrough
      default:
        parsed[index2] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value;
  var parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent) return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix(value, length2) {
  switch (hash$2(value, length2)) {
    // color-adjust
    case 5103:
      return WEBKIT + "print-" + value + value;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    // flex, flex-direction
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    // order
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    // align-items
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    // align-self
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    // align-content
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    // flex-shrink
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    // flex-basis
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    // flex-grow
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    // transition
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    // cursor
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    // background, background-image
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    // justify-content
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (charat(value, length2 + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
        // (s)tretch
        case 115:
          return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
      }
      break;
    // position: sticky
    case 4949:
      if (charat(value, length2 + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        // stic(k)y
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        // (inline-)?fl(e)x
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    // writing-mode
    case 5936:
      switch (charat(value, length2 + 11)) {
        // vertical-l(r)
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        // vertical-r(l)
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        // horizontal(-)tb
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index2, children, callback) {
  if (element.length > -1) {
    if (!element["return"]) switch (element.type) {
      case DECLARATION:
        element["return"] = prefix(element.value, element.length);
        break;
      case KEYFRAMES:
        return serialize([copy(element, {
          value: replace(element.value, "@", "@" + WEBKIT)
        })], callback);
      case RULESET:
        if (element.length) return combine(element.props, function(value) {
          switch (match(value, /(::plac\w+|:read-\w+)/)) {
            // :read-(only|write)
            case ":read-only":
            case ":read-write":
              return serialize([copy(element, {
                props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
              })], callback);
            // :placeholder
            case "::placeholder":
              return serialize([copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
              })], callback);
          }
          return "";
        });
    }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize(compile(styles2), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
var reactIs$1 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min) return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r2 = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
  function z(a) {
    if ("object" === typeof a && null !== a) {
      var u = a.$$typeof;
      switch (u) {
        case c:
          switch (a = a.type, a) {
            case l:
            case m:
            case e:
            case g:
            case f:
            case p:
              return a;
            default:
              switch (a = a && a.$$typeof, a) {
                case k:
                case n:
                case t:
                case r2:
                case h:
                  return a;
                default:
                  return u;
              }
          }
        case d:
          return u;
      }
    }
  }
  function A(a) {
    return z(a) === m;
  }
  reactIs_production_min.AsyncMode = l;
  reactIs_production_min.ConcurrentMode = m;
  reactIs_production_min.ContextConsumer = k;
  reactIs_production_min.ContextProvider = h;
  reactIs_production_min.Element = c;
  reactIs_production_min.ForwardRef = n;
  reactIs_production_min.Fragment = e;
  reactIs_production_min.Lazy = t;
  reactIs_production_min.Memo = r2;
  reactIs_production_min.Portal = d;
  reactIs_production_min.Profiler = g;
  reactIs_production_min.StrictMode = f;
  reactIs_production_min.Suspense = p;
  reactIs_production_min.isAsyncMode = function(a) {
    return A(a) || z(a) === l;
  };
  reactIs_production_min.isConcurrentMode = A;
  reactIs_production_min.isContextConsumer = function(a) {
    return z(a) === k;
  };
  reactIs_production_min.isContextProvider = function(a) {
    return z(a) === h;
  };
  reactIs_production_min.isElement = function(a) {
    return "object" === typeof a && null !== a && a.$$typeof === c;
  };
  reactIs_production_min.isForwardRef = function(a) {
    return z(a) === n;
  };
  reactIs_production_min.isFragment = function(a) {
    return z(a) === e;
  };
  reactIs_production_min.isLazy = function(a) {
    return z(a) === t;
  };
  reactIs_production_min.isMemo = function(a) {
    return z(a) === r2;
  };
  reactIs_production_min.isPortal = function(a) {
    return z(a) === d;
  };
  reactIs_production_min.isProfiler = function(a) {
    return z(a) === g;
  };
  reactIs_production_min.isStrictMode = function(a) {
    return z(a) === f;
  };
  reactIs_production_min.isSuspense = function(a) {
    return z(a) === p;
  };
  reactIs_production_min.isValidElementType = function(a) {
    return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r2 || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
  };
  reactIs_production_min.typeOf = z;
  return reactIs_production_min;
}
var hasRequiredReactIs$1;
function requireReactIs$1() {
  if (hasRequiredReactIs$1) return reactIs$1.exports;
  hasRequiredReactIs$1 = 1;
  {
    reactIs$1.exports = requireReactIs_production_min();
  }
  return reactIs$1.exports;
}
var hoistNonReactStatics_cjs;
var hasRequiredHoistNonReactStatics_cjs;
function requireHoistNonReactStatics_cjs() {
  if (hasRequiredHoistNonReactStatics_cjs) return hoistNonReactStatics_cjs;
  hasRequiredHoistNonReactStatics_cjs = 1;
  var reactIs2 = requireReactIs$1();
  var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
  };
  var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
  };
  var FORWARD_REF_STATICS = {
    "$$typeof": true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
  };
  var MEMO_STATICS = {
    "$$typeof": true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
  };
  var TYPE_STATICS = {};
  TYPE_STATICS[reactIs2.ForwardRef] = FORWARD_REF_STATICS;
  TYPE_STATICS[reactIs2.Memo] = MEMO_STATICS;
  function getStatics(component) {
    if (reactIs2.isMemo(component)) {
      return MEMO_STATICS;
    }
    return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
  }
  var defineProperty = Object.defineProperty;
  var getOwnPropertyNames = Object.getOwnPropertyNames;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectPrototype = Object.prototype;
  function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== "string") {
      if (objectPrototype) {
        var inheritedComponent = getPrototypeOf(sourceComponent);
        if (inheritedComponent && inheritedComponent !== objectPrototype) {
          hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
        }
      }
      var keys = getOwnPropertyNames(sourceComponent);
      if (getOwnPropertySymbols) {
        keys = keys.concat(getOwnPropertySymbols(sourceComponent));
      }
      var targetStatics = getStatics(targetComponent);
      var sourceStatics = getStatics(sourceComponent);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
          var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
          try {
            defineProperty(targetComponent, key, descriptor);
          } catch (e) {
          }
        }
      }
    }
    return targetComponent;
  }
  hoistNonReactStatics_cjs = hoistNonReactStatics;
  return hoistNonReactStatics_cjs;
}
requireHoistNonReactStatics_cjs();
var isBrowser$1 = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else if (className) {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag2) {
  var className = cache.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag2 === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser$1 === false) && cache.registered[className] === void 0
  ) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag2) {
  registerStyles(cache, serialized, isStringTag2);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h = 0;
  var k, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
    k ^= /* k >>> r: */
    k >>> 24;
    h = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 255;
      h = /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  h ^= h >>> 13;
  h = /* Math.imul(h, m): */
  (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize$1(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  var componentSelector = interpolation;
  if (componentSelector.__emotion_styles !== void 0) {
    return componentSelector;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      var keyframes2 = interpolation;
      if (keyframes2.anim === 1) {
        cursor = {
          name: keyframes2.name,
          styles: keyframes2.styles,
          next: cursor
        };
        return keyframes2.name;
      }
      var serializedStyles = interpolation;
      if (serializedStyles.styles !== void 0) {
        var next2 = serializedStyles.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = serializedStyles.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  var asString = interpolation;
  if (registered == null) {
    return asString;
  }
  var cached = registered[asString];
  return cached !== void 0 ? cached : asString;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var key in obj) {
      var value = obj[key];
      if (typeof value !== "object") {
        var asString = value;
        if (registered != null && registered[asString] !== void 0) {
          string += key + "{" + registered[asString] + "}";
        } else if (isProcessableValue(asString)) {
          string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
        }
      } else {
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (key) {
            case "animation":
            case "animationName": {
              string += processStyleName(key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string += key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
var cursor;
function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    var asTemplateStringsArr = strings;
    styles2 += asTemplateStringsArr[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      var templateStringsArr = strings;
      styles2 += templateStringsArr[i];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + match2[1];
  }
  var name2 = murmur2(styles2) + identifierName;
  return {
    name: name2,
    styles: styles2,
    next: cursor
  };
}
var syncFallback = function syncFallback2(create) {
  return create();
};
var useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
    var cache = reactExports.useContext(EmotionCacheContext);
    return func(props, cache, ref);
  });
};
var ThemeContext$1 = /* @__PURE__ */ reactExports.createContext({});
var hasOwn = {}.hasOwnProperty;
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type, props) {
  var newProps = {};
  for (var _key in props) {
    if (hasOwn.call(props, _key)) {
      newProps[_key] = props[_key];
    }
  }
  newProps[typePropName] = type;
  return newProps;
};
var Insertion$1 = function Insertion(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag2);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag2);
  });
  return null;
};
var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache, ref) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache.registered[cssProp] !== void 0) {
    cssProp = cache.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, reactExports.useContext(ThemeContext$1));
  className += cache.key + "-" + serialized.name;
  var newProps = {};
  for (var _key2 in props) {
    if (hasOwn.call(props, _key2) && _key2 !== "css" && _key2 !== typePropName && true) {
      newProps[_key2] = props[_key2];
    }
  }
  newProps.className = className;
  if (ref) {
    newProps.ref = ref;
  }
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion$1, {
    cache,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), /* @__PURE__ */ reactExports.createElement(WrappedComponent, newProps));
});
var Emotion$1 = Emotion;
var jsx = function jsx2(type, props) {
  var args = arguments;
  if (props == null || !hasOwn.call(props, "css")) {
    return reactExports.createElement.apply(void 0, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1;
  createElementArgArray[1] = createEmotionProps(type, props);
  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  }
  return reactExports.createElement.apply(null, createElementArgArray);
};
(function(_jsx) {
  var JSX;
  /* @__PURE__ */ (function(_JSX) {
  })(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
})(jsx || (jsx = {}));
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache) {
  var styles2 = props.styles;
  var serialized = serializeStyles([styles2], void 0, reactExports.useContext(ThemeContext$1));
  var sheetRef = reactExports.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache.key + "-global";
    var sheet = new cache.sheet.constructor({
      key,
      nonce: cache.sheet.nonce,
      container: cache.sheet.container,
      speedy: cache.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache.sheet.tags.length) {
      sheet.before = cache.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache.insert("", serialized, sheet, false);
  }, [cache, serialized.name]);
  return null;
});
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
function keyframes() {
  var insertable = css.apply(void 0, arguments);
  var name2 = "animation-" + insertable.name;
  return {
    name: name2,
    styles: "@keyframes " + name2 + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|popover|popoverTarget|popoverTargetAction|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize$1(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
  return key !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
  var shouldForwardProp2;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp2 !== "function" && isReal) {
    shouldForwardProp2 = tag.__emotion_forwardProp;
  }
  return shouldForwardProp2;
};
var Insertion2 = function Insertion3(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag2);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag2);
  });
  return null;
};
var createStyled$1 = function createStyled(tag, options) {
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles2.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles2.push.apply(styles2, args);
    } else {
      var templateStringsArr = args[0];
      styles2.push(templateStringsArr[0]);
      var len = args.length;
      var i = 1;
      for (; i < len; i++) {
        styles2.push(args[i], templateStringsArr[i]);
      }
    }
    var Styled = withEmotionCache(function(props, cache, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key in props) {
          mergedProps[key] = props[key];
        }
        mergedProps.theme = reactExports.useContext(ThemeContext$1);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(styles2.concat(classInterpolations), cache.registered, mergedProps);
      className += cache.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as") continue;
        if (finalShouldForwardProp(_key)) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      if (ref) {
        newProps.ref = ref;
      }
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion2, {
        cache,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ reactExports.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles2;
    Styled.__emotion_forwardProp = shouldForwardProp2;
    Object.defineProperty(Styled, "toString", {
      value: function value() {
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      var newStyled = createStyled(nextTag, _extends({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      }));
      return newStyled.apply(void 0, styles2);
    };
    return Styled;
  };
};
var tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var styled$3 = createStyled$1.bind(null);
tags.forEach(function(tagName) {
  styled$3[tagName] = styled$3(tagName);
});
function isEmpty$2(obj) {
  return obj === void 0 || obj === null || Object.keys(obj).length === 0;
}
function GlobalStyles$3(props) {
  const {
    styles: styles2,
    defaultTheme: defaultTheme2 = {}
  } = props;
  const globalStyles = typeof styles2 === "function" ? (themeInput) => styles2(isEmpty$2(themeInput) ? defaultTheme2 : themeInput) : styles2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Global, {
    styles: globalStyles
  });
}
function styled$2(tag, options) {
  const stylesFactory = styled$3(tag, options);
  return stylesFactory;
}
function internal_mutateStyles(tag, processor) {
  if (Array.isArray(tag.__emotion_styles)) {
    tag.__emotion_styles = processor(tag.__emotion_styles);
  }
}
const wrapper = [];
function internal_serializeStyles(styles2) {
  wrapper[0] = styles2;
  return serializeStyles(wrapper);
}
var reactIs = { exports: {} };
var reactIs_production = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production;
function requireReactIs_production() {
  if (hasRequiredReactIs_production) return reactIs_production;
  hasRequiredReactIs_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
  function typeOf(object) {
    if ("object" === typeof object && null !== object) {
      var $$typeof = object.$$typeof;
      switch ($$typeof) {
        case REACT_ELEMENT_TYPE:
          switch (object = object.type, object) {
            case REACT_FRAGMENT_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_SUSPENSE_TYPE:
            case REACT_SUSPENSE_LIST_TYPE:
            case REACT_VIEW_TRANSITION_TYPE:
              return object;
            default:
              switch (object = object && object.$$typeof, object) {
                case REACT_CONTEXT_TYPE:
                case REACT_FORWARD_REF_TYPE:
                case REACT_LAZY_TYPE:
                case REACT_MEMO_TYPE:
                  return object;
                case REACT_CONSUMER_TYPE:
                  return object;
                default:
                  return $$typeof;
              }
          }
        case REACT_PORTAL_TYPE:
          return $$typeof;
      }
    }
  }
  reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE;
  reactIs_production.ContextProvider = REACT_CONTEXT_TYPE;
  reactIs_production.Element = REACT_ELEMENT_TYPE;
  reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE;
  reactIs_production.Fragment = REACT_FRAGMENT_TYPE;
  reactIs_production.Lazy = REACT_LAZY_TYPE;
  reactIs_production.Memo = REACT_MEMO_TYPE;
  reactIs_production.Portal = REACT_PORTAL_TYPE;
  reactIs_production.Profiler = REACT_PROFILER_TYPE;
  reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE;
  reactIs_production.Suspense = REACT_SUSPENSE_TYPE;
  reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
  reactIs_production.isContextConsumer = function(object) {
    return typeOf(object) === REACT_CONSUMER_TYPE;
  };
  reactIs_production.isContextProvider = function(object) {
    return typeOf(object) === REACT_CONTEXT_TYPE;
  };
  reactIs_production.isElement = function(object) {
    return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
  };
  reactIs_production.isForwardRef = function(object) {
    return typeOf(object) === REACT_FORWARD_REF_TYPE;
  };
  reactIs_production.isFragment = function(object) {
    return typeOf(object) === REACT_FRAGMENT_TYPE;
  };
  reactIs_production.isLazy = function(object) {
    return typeOf(object) === REACT_LAZY_TYPE;
  };
  reactIs_production.isMemo = function(object) {
    return typeOf(object) === REACT_MEMO_TYPE;
  };
  reactIs_production.isPortal = function(object) {
    return typeOf(object) === REACT_PORTAL_TYPE;
  };
  reactIs_production.isProfiler = function(object) {
    return typeOf(object) === REACT_PROFILER_TYPE;
  };
  reactIs_production.isStrictMode = function(object) {
    return typeOf(object) === REACT_STRICT_MODE_TYPE;
  };
  reactIs_production.isSuspense = function(object) {
    return typeOf(object) === REACT_SUSPENSE_TYPE;
  };
  reactIs_production.isSuspenseList = function(object) {
    return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
  };
  reactIs_production.isValidElementType = function(type) {
    return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;
  };
  reactIs_production.typeOf = typeOf;
  return reactIs_production;
}
var hasRequiredReactIs;
function requireReactIs() {
  if (hasRequiredReactIs) return reactIs.exports;
  hasRequiredReactIs = 1;
  {
    reactIs.exports = /* @__PURE__ */ requireReactIs_production();
  }
  return reactIs.exports;
}
var reactIsExports = /* @__PURE__ */ requireReactIs();
function isPlainObject$2(item) {
  if (typeof item !== "object" || item === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(item);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in item) && !(Symbol.iterator in item);
}
function deepClone$1(source) {
  if (/* @__PURE__ */ reactExports.isValidElement(source) || reactIsExports.isValidElementType(source) || !isPlainObject$2(source)) {
    return source;
  }
  const output = {};
  Object.keys(source).forEach((key) => {
    output[key] = deepClone$1(source[key]);
  });
  return output;
}
function deepmerge(target, source, options = {
  clone: true
}) {
  const output = options.clone ? __spreadValues({}, target) : target;
  if (isPlainObject$2(target) && isPlainObject$2(source)) {
    Object.keys(source).forEach((key) => {
      if (/* @__PURE__ */ reactExports.isValidElement(source[key]) || reactIsExports.isValidElementType(source[key])) {
        output[key] = source[key];
      } else if (isPlainObject$2(source[key]) && // Avoid prototype pollution
      Object.prototype.hasOwnProperty.call(target, key) && isPlainObject$2(target[key])) {
        output[key] = deepmerge(target[key], source[key], options);
      } else if (options.clone) {
        output[key] = isPlainObject$2(source[key]) ? deepClone$1(source[key]) : source[key];
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
const sortBreakpointsValues = (values2) => {
  const breakpointsAsArray = Object.keys(values2).map((key) => ({
    key,
    val: values2[key]
  })) || [];
  breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
  return breakpointsAsArray.reduce((acc, obj) => {
    return __spreadProps(__spreadValues({}, acc), {
      [obj.key]: obj.val
    });
  }, {});
};
function createBreakpoints(breakpoints) {
  const _a2 = breakpoints, {
    values: values2 = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit = "px",
    step = 5
  } = _a2, other = __objRest(_a2, [
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    "values",
    "unit",
    "step"
  ]);
  const sortedValues = sortBreakpointsValues(values2);
  const keys = Object.keys(sortedValues);
  function up(key) {
    const value = typeof values2[key] === "number" ? values2[key] : key;
    return `@media (min-width:${value}${unit})`;
  }
  function down(key) {
    const value = typeof values2[key] === "number" ? values2[key] : key;
    return `@media (max-width:${value - step / 100}${unit})`;
  }
  function between(start2, end2) {
    const endIndex = keys.indexOf(end2);
    return `@media (min-width:${typeof values2[start2] === "number" ? values2[start2] : start2}${unit}) and (max-width:${(endIndex !== -1 && typeof values2[keys[endIndex]] === "number" ? values2[keys[endIndex]] : end2) - step / 100}${unit})`;
  }
  function only(key) {
    if (keys.indexOf(key) + 1 < keys.length) {
      return between(key, keys[keys.indexOf(key) + 1]);
    }
    return up(key);
  }
  function not(key) {
    const keyIndex = keys.indexOf(key);
    if (keyIndex === 0) {
      return up(keys[1]);
    }
    if (keyIndex === keys.length - 1) {
      return down(keys[keyIndex]);
    }
    return between(key, keys[keys.indexOf(key) + 1]).replace("@media", "@media not all and");
  }
  return __spreadValues({
    keys,
    values: sortedValues,
    up,
    down,
    between,
    only,
    not,
    unit
  }, other);
}
function sortContainerQueries(theme2, css2) {
  if (!theme2.containerQueries) {
    return css2;
  }
  const sorted = Object.keys(css2).filter((key) => key.startsWith("@container")).sort((a, b) => {
    var _a2, _b;
    const regex = /min-width:\s*([0-9.]+)/;
    return +(((_a2 = a.match(regex)) == null ? void 0 : _a2[1]) || 0) - +(((_b = b.match(regex)) == null ? void 0 : _b[1]) || 0);
  });
  if (!sorted.length) {
    return css2;
  }
  return sorted.reduce((acc, key) => {
    const value = css2[key];
    delete acc[key];
    acc[key] = value;
    return acc;
  }, __spreadValues({}, css2));
}
function isCqShorthand(breakpointKeys, value) {
  return value === "@" || value.startsWith("@") && (breakpointKeys.some((key) => value.startsWith(`@${key}`)) || !!value.match(/^@\d/));
}
function getContainerQuery(theme2, shorthand) {
  const matches = shorthand.match(/^@([^/]+)?\/?(.+)?$/);
  if (!matches) {
    return null;
  }
  const [, containerQuery, containerName] = matches;
  const value = Number.isNaN(+containerQuery) ? containerQuery || 0 : +containerQuery;
  return theme2.containerQueries(containerName).up(value);
}
function cssContainerQueries(themeInput) {
  const toContainerQuery = (mediaQuery, name2) => mediaQuery.replace("@media", name2 ? `@container ${name2}` : "@container");
  function attachCq(node22, name2) {
    node22.up = (...args) => toContainerQuery(themeInput.breakpoints.up(...args), name2);
    node22.down = (...args) => toContainerQuery(themeInput.breakpoints.down(...args), name2);
    node22.between = (...args) => toContainerQuery(themeInput.breakpoints.between(...args), name2);
    node22.only = (...args) => toContainerQuery(themeInput.breakpoints.only(...args), name2);
    node22.not = (...args) => {
      const result = toContainerQuery(themeInput.breakpoints.not(...args), name2);
      if (result.includes("not all and")) {
        return result.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or");
      }
      return result;
    };
  }
  const node2 = {};
  const containerQueries = (name2) => {
    attachCq(node2, name2);
    return node2;
  };
  attachCq(containerQueries);
  return __spreadProps(__spreadValues({}, themeInput), {
    containerQueries
  });
}
const shape = {
  borderRadius: 4
};
function merge(acc, item) {
  if (!item) {
    return acc;
  }
  return deepmerge(acc, item, {
    clone: false
    // No need to clone deep, it's way faster.
  });
}
const values$1 = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
};
const defaultBreakpoints = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (key) => `@media (min-width:${values$1[key]}px)`
};
const defaultContainerQueries = {
  containerQueries: (containerName) => ({
    up: (key) => {
      let result = typeof key === "number" ? key : values$1[key] || key;
      if (typeof result === "number") {
        result = `${result}px`;
      }
      return containerName ? `@container ${containerName} (min-width:${result})` : `@container (min-width:${result})`;
    }
  })
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
  const theme2 = props.theme || {};
  if (Array.isArray(propValue)) {
    const themeBreakpoints = theme2.breakpoints || defaultBreakpoints;
    return propValue.reduce((acc, item, index2) => {
      acc[themeBreakpoints.up(themeBreakpoints.keys[index2])] = styleFromPropValue(propValue[index2]);
      return acc;
    }, {});
  }
  if (typeof propValue === "object") {
    const themeBreakpoints = theme2.breakpoints || defaultBreakpoints;
    return Object.keys(propValue).reduce((acc, breakpoint) => {
      if (isCqShorthand(themeBreakpoints.keys, breakpoint)) {
        const containerKey = getContainerQuery(theme2.containerQueries ? theme2 : defaultContainerQueries, breakpoint);
        if (containerKey) {
          acc[containerKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
        }
      } else if (Object.keys(themeBreakpoints.values || values$1).includes(breakpoint)) {
        const mediaKey = themeBreakpoints.up(breakpoint);
        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
      } else {
        const cssKey = breakpoint;
        acc[cssKey] = propValue[cssKey];
      }
      return acc;
    }, {});
  }
  const output = styleFromPropValue(propValue);
  return output;
}
function createEmptyBreakpointObject(breakpointsInput = {}) {
  var _a2;
  const breakpointsInOrder = (_a2 = breakpointsInput.keys) == null ? void 0 : _a2.reduce((acc, key) => {
    const breakpointStyleKey = breakpointsInput.up(key);
    acc[breakpointStyleKey] = {};
    return acc;
  }, {});
  return breakpointsInOrder || {};
}
function removeUnusedBreakpoints(breakpointKeys, style2) {
  return breakpointKeys.reduce((acc, key) => {
    const breakpointOutput = acc[key];
    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
    if (isBreakpointUnused) {
      delete acc[key];
    }
    return acc;
  }, style2);
}
function mergeBreakpointsInOrder(breakpointsInput, ...styles2) {
  const emptyBreakpoints = createEmptyBreakpointObject(breakpointsInput);
  const mergedOutput = [emptyBreakpoints, ...styles2].reduce((prev2, next2) => deepmerge(prev2, next2), {});
  return removeUnusedBreakpoints(Object.keys(emptyBreakpoints), mergedOutput);
}
function computeBreakpointsBase(breakpointValues, themeBreakpoints) {
  if (typeof breakpointValues !== "object") {
    return {};
  }
  const base = {};
  const breakpointsKeys = Object.keys(themeBreakpoints);
  if (Array.isArray(breakpointValues)) {
    breakpointsKeys.forEach((breakpoint, i) => {
      if (i < breakpointValues.length) {
        base[breakpoint] = true;
      }
    });
  } else {
    breakpointsKeys.forEach((breakpoint) => {
      if (breakpointValues[breakpoint] != null) {
        base[breakpoint] = true;
      }
    });
  }
  return base;
}
function resolveBreakpointValues({
  values: breakpointValues,
  breakpoints: themeBreakpoints,
  base: customBase
}) {
  const base = customBase || computeBreakpointsBase(breakpointValues, themeBreakpoints);
  const keys = Object.keys(base);
  if (keys.length === 0) {
    return breakpointValues;
  }
  let previous;
  return keys.reduce((acc, breakpoint, i) => {
    if (Array.isArray(breakpointValues)) {
      acc[breakpoint] = breakpointValues[i] != null ? breakpointValues[i] : breakpointValues[previous];
      previous = i;
    } else if (typeof breakpointValues === "object") {
      acc[breakpoint] = breakpointValues[breakpoint] != null ? breakpointValues[breakpoint] : breakpointValues[previous];
      previous = breakpoint;
    } else {
      acc[breakpoint] = breakpointValues;
    }
    return acc;
  }, {});
}
function capitalize(string) {
  if (typeof string !== "string") {
    throw new Error(formatMuiErrorMessage(7));
  }
  return string.charAt(0).toUpperCase() + string.slice(1);
}
function getPath(obj, path, checkVars = true) {
  if (!path || typeof path !== "string") {
    return null;
  }
  if (obj && obj.vars && checkVars) {
    const val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
    if (val != null) {
      return val;
    }
  }
  return path.split(".").reduce((acc, item) => {
    if (acc && acc[item] != null) {
      return acc[item];
    }
    return null;
  }, obj);
}
function getStyleValue$1(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
  let value;
  if (typeof themeMapping === "function") {
    value = themeMapping(propValueFinal);
  } else if (Array.isArray(themeMapping)) {
    value = themeMapping[propValueFinal] || userValue;
  } else {
    value = getPath(themeMapping, propValueFinal) || userValue;
  }
  if (transform) {
    value = transform(value, userValue, themeMapping);
  }
  return value;
}
function style$2(options) {
  const {
    prop,
    cssProperty = options.prop,
    themeKey,
    transform
  } = options;
  const fn2 = (props) => {
    if (props[prop] == null) {
      return null;
    }
    const propValue = props[prop];
    const theme2 = props.theme;
    const themeMapping = getPath(theme2, themeKey) || {};
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue$1(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, propValue, styleFromPropValue);
  };
  fn2.propTypes = {};
  fn2.filterProps = [prop];
  return fn2;
}
function memoize(fn2) {
  const cache = {};
  return (arg2) => {
    if (cache[arg2] === void 0) {
      cache[arg2] = fn2(arg2);
    }
    return cache[arg2];
  };
}
const properties = {
  m: "margin",
  p: "padding"
};
const directions = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
};
const aliases = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
};
const getCssProperties = memoize((prop) => {
  if (prop.length > 2) {
    if (aliases[prop]) {
      prop = aliases[prop];
    } else {
      return [prop];
    }
  }
  const [a, b] = prop.split("");
  const property = properties[a];
  const direction = directions[b] || "";
  return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
});
const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...marginKeys, ...paddingKeys];
function createUnaryUnit(theme2, themeKey, defaultValue, propName) {
  var _a2;
  const themeSpacing = (_a2 = getPath(theme2, themeKey, true)) != null ? _a2 : defaultValue;
  if (typeof themeSpacing === "number" || typeof themeSpacing === "string") {
    return (val) => {
      if (typeof val === "string") {
        return val;
      }
      if (typeof themeSpacing === "string") {
        if (themeSpacing.startsWith("var(") && val === 0) {
          return 0;
        }
        if (themeSpacing.startsWith("var(") && val === 1) {
          return themeSpacing;
        }
        return `calc(${val} * ${themeSpacing})`;
      }
      return themeSpacing * val;
    };
  }
  if (Array.isArray(themeSpacing)) {
    return (val) => {
      if (typeof val === "string") {
        return val;
      }
      const abs2 = Math.abs(val);
      const transformed = themeSpacing[abs2];
      if (val >= 0) {
        return transformed;
      }
      if (typeof transformed === "number") {
        return -transformed;
      }
      if (typeof transformed === "string" && transformed.startsWith("var(")) {
        return `calc(-1 * ${transformed})`;
      }
      return `-${transformed}`;
    };
  }
  if (typeof themeSpacing === "function") {
    return themeSpacing;
  }
  return () => void 0;
}
function createUnarySpacing(theme2) {
  return createUnaryUnit(theme2, "spacing", 8);
}
function getValue(transformer, propValue) {
  if (typeof propValue === "string" || propValue == null) {
    return propValue;
  }
  return transformer(propValue);
}
function getStyleFromPropValue(cssProperties, transformer) {
  return (propValue) => cssProperties.reduce((acc, cssProperty) => {
    acc[cssProperty] = getValue(transformer, propValue);
    return acc;
  }, {});
}
function resolveCssProperty(props, keys, prop, transformer) {
  if (!keys.includes(prop)) {
    return null;
  }
  const cssProperties = getCssProperties(prop);
  const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
  const propValue = props[prop];
  return handleBreakpoints(props, propValue, styleFromPropValue);
}
function style$1(props, keys) {
  const transformer = createUnarySpacing(props.theme);
  return Object.keys(props).map((prop) => resolveCssProperty(props, keys, prop, transformer)).reduce(merge, {});
}
function margin(props) {
  return style$1(props, marginKeys);
}
margin.propTypes = {};
margin.filterProps = marginKeys;
function padding(props) {
  return style$1(props, paddingKeys);
}
padding.propTypes = {};
padding.filterProps = paddingKeys;
function createSpacing(spacingInput = 8, transform = createUnarySpacing({
  spacing: spacingInput
})) {
  if (spacingInput.mui) {
    return spacingInput;
  }
  const spacing = (...argsInput) => {
    const args = argsInput.length === 0 ? [1] : argsInput;
    return args.map((argument) => {
      const output = transform(argument);
      return typeof output === "number" ? `${output}px` : output;
    }).join(" ");
  };
  spacing.mui = true;
  return spacing;
}
function compose(...styles2) {
  const handlers = styles2.reduce((acc, style2) => {
    style2.filterProps.forEach((prop) => {
      acc[prop] = style2;
    });
    return acc;
  }, {});
  const fn2 = (props) => {
    return Object.keys(props).reduce((acc, prop) => {
      if (handlers[prop]) {
        return merge(acc, handlers[prop](props));
      }
      return acc;
    }, {});
  };
  fn2.propTypes = {};
  fn2.filterProps = styles2.reduce((acc, style2) => acc.concat(style2.filterProps), []);
  return fn2;
}
function borderTransform(value) {
  if (typeof value !== "number") {
    return value;
  }
  return `${value}px solid`;
}
function createBorderStyle(prop, transform) {
  return style$2({
    prop,
    themeKey: "borders",
    transform
  });
}
const border = createBorderStyle("border", borderTransform);
const borderTop = createBorderStyle("borderTop", borderTransform);
const borderRight = createBorderStyle("borderRight", borderTransform);
const borderBottom = createBorderStyle("borderBottom", borderTransform);
const borderLeft = createBorderStyle("borderLeft", borderTransform);
const borderColor = createBorderStyle("borderColor");
const borderTopColor = createBorderStyle("borderTopColor");
const borderRightColor = createBorderStyle("borderRightColor");
const borderBottomColor = createBorderStyle("borderBottomColor");
const borderLeftColor = createBorderStyle("borderLeftColor");
const outline = createBorderStyle("outline", borderTransform);
const outlineColor = createBorderStyle("outlineColor");
const borderRadius = (props) => {
  if (props.borderRadius !== void 0 && props.borderRadius !== null) {
    const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4);
    const styleFromPropValue = (propValue) => ({
      borderRadius: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
  }
  return null;
};
borderRadius.propTypes = {};
borderRadius.filterProps = ["borderRadius"];
compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);
const gap = (props) => {
  if (props.gap !== void 0 && props.gap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      gap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.gap, styleFromPropValue);
  }
  return null;
};
gap.propTypes = {};
gap.filterProps = ["gap"];
const columnGap = (props) => {
  if (props.columnGap !== void 0 && props.columnGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      columnGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.columnGap, styleFromPropValue);
  }
  return null;
};
columnGap.propTypes = {};
columnGap.filterProps = ["columnGap"];
const rowGap = (props) => {
  if (props.rowGap !== void 0 && props.rowGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      rowGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.rowGap, styleFromPropValue);
  }
  return null;
};
rowGap.propTypes = {};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$2({
  prop: "gridColumn"
});
const gridRow = style$2({
  prop: "gridRow"
});
const gridAutoFlow = style$2({
  prop: "gridAutoFlow"
});
const gridAutoColumns = style$2({
  prop: "gridAutoColumns"
});
const gridAutoRows = style$2({
  prop: "gridAutoRows"
});
const gridTemplateColumns = style$2({
  prop: "gridTemplateColumns"
});
const gridTemplateRows = style$2({
  prop: "gridTemplateRows"
});
const gridTemplateAreas = style$2({
  prop: "gridTemplateAreas"
});
const gridArea = style$2({
  prop: "gridArea"
});
compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
function paletteTransform(value, userValue) {
  if (userValue === "grey") {
    return userValue;
  }
  return value;
}
const color = style$2({
  prop: "color",
  themeKey: "palette",
  transform: paletteTransform
});
const bgcolor = style$2({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
const backgroundColor = style$2({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
compose(color, bgcolor, backgroundColor);
function sizingTransform(value) {
  return value <= 1 && value !== 0 ? `${value * 100}%` : value;
}
const width = style$2({
  prop: "width",
  transform: sizingTransform
});
const maxWidth = (props) => {
  if (props.maxWidth !== void 0 && props.maxWidth !== null) {
    const styleFromPropValue = (propValue) => {
      var _a2, _b, _c, _d, _e;
      const breakpoint = ((_c = (_b = (_a2 = props.theme) == null ? void 0 : _a2.breakpoints) == null ? void 0 : _b.values) == null ? void 0 : _c[propValue]) || values$1[propValue];
      if (!breakpoint) {
        return {
          maxWidth: sizingTransform(propValue)
        };
      }
      if (((_e = (_d = props.theme) == null ? void 0 : _d.breakpoints) == null ? void 0 : _e.unit) !== "px") {
        return {
          maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
        };
      }
      return {
        maxWidth: breakpoint
      };
    };
    return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
  }
  return null;
};
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$2({
  prop: "minWidth",
  transform: sizingTransform
});
const height = style$2({
  prop: "height",
  transform: sizingTransform
});
const maxHeight = style$2({
  prop: "maxHeight",
  transform: sizingTransform
});
const minHeight = style$2({
  prop: "minHeight",
  transform: sizingTransform
});
style$2({
  prop: "size",
  cssProperty: "width",
  transform: sizingTransform
});
style$2({
  prop: "size",
  cssProperty: "height",
  transform: sizingTransform
});
const boxSizing = style$2({
  prop: "boxSizing"
});
compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const defaultSxConfig = {
  // borders
  border: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderTop: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderRight: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderBottom: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderLeft: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: borderTransform
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: borderRadius
  },
  // palette
  color: {
    themeKey: "palette",
    transform: paletteTransform
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: paletteTransform
  },
  backgroundColor: {
    themeKey: "palette",
    transform: paletteTransform
  },
  // spacing
  p: {
    style: padding
  },
  pt: {
    style: padding
  },
  pr: {
    style: padding
  },
  pb: {
    style: padding
  },
  pl: {
    style: padding
  },
  px: {
    style: padding
  },
  py: {
    style: padding
  },
  padding: {
    style: padding
  },
  paddingTop: {
    style: padding
  },
  paddingRight: {
    style: padding
  },
  paddingBottom: {
    style: padding
  },
  paddingLeft: {
    style: padding
  },
  paddingX: {
    style: padding
  },
  paddingY: {
    style: padding
  },
  paddingInline: {
    style: padding
  },
  paddingInlineStart: {
    style: padding
  },
  paddingInlineEnd: {
    style: padding
  },
  paddingBlock: {
    style: padding
  },
  paddingBlockStart: {
    style: padding
  },
  paddingBlockEnd: {
    style: padding
  },
  m: {
    style: margin
  },
  mt: {
    style: margin
  },
  mr: {
    style: margin
  },
  mb: {
    style: margin
  },
  ml: {
    style: margin
  },
  mx: {
    style: margin
  },
  my: {
    style: margin
  },
  margin: {
    style: margin
  },
  marginTop: {
    style: margin
  },
  marginRight: {
    style: margin
  },
  marginBottom: {
    style: margin
  },
  marginLeft: {
    style: margin
  },
  marginX: {
    style: margin
  },
  marginY: {
    style: margin
  },
  marginInline: {
    style: margin
  },
  marginInlineStart: {
    style: margin
  },
  marginInlineEnd: {
    style: margin
  },
  marginBlock: {
    style: margin
  },
  marginBlockStart: {
    style: margin
  },
  marginBlockEnd: {
    style: margin
  },
  // display
  displayPrint: {
    cssProperty: false,
    transform: (value) => ({
      "@media print": {
        display: value
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: gap
  },
  rowGap: {
    style: rowGap
  },
  columnGap: {
    style: columnGap
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: sizingTransform
  },
  maxWidth: {
    style: maxWidth
  },
  minWidth: {
    transform: sizingTransform
  },
  height: {
    transform: sizingTransform
  },
  maxHeight: {
    transform: sizingTransform
  },
  minHeight: {
    transform: sizingTransform
  },
  boxSizing: {},
  // typography
  font: {
    themeKey: "font"
  },
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: false,
    themeKey: "typography"
  }
};
function objectsHaveSameKeys(...objects) {
  const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
  const union = new Set(allKeys);
  return objects.every((object) => union.size === Object.keys(object).length);
}
function callIfFn(maybeFn, arg2) {
  return typeof maybeFn === "function" ? maybeFn(arg2) : maybeFn;
}
function unstable_createStyleFunctionSx() {
  function getThemeValue(prop, val, theme2, config2) {
    const props = {
      [prop]: val,
      theme: theme2
    };
    const options = config2[prop];
    if (!options) {
      return {
        [prop]: val
      };
    }
    const {
      cssProperty = prop,
      themeKey,
      transform,
      style: style2
    } = options;
    if (val == null) {
      return null;
    }
    if (themeKey === "typography" && val === "inherit") {
      return {
        [prop]: val
      };
    }
    const themeMapping = getPath(theme2, themeKey) || {};
    if (style2) {
      return style2(props);
    }
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue$1(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, val, styleFromPropValue);
  }
  function styleFunctionSx2(props) {
    var _a2;
    const {
      sx,
      theme: theme2 = {},
      nested: nested2
    } = props || {};
    if (!sx) {
      return null;
    }
    const config2 = (_a2 = theme2.unstable_sxConfig) != null ? _a2 : defaultSxConfig;
    function traverse(sxInput) {
      let sxObject = sxInput;
      if (typeof sxInput === "function") {
        sxObject = sxInput(theme2);
      } else if (typeof sxInput !== "object") {
        return sxInput;
      }
      if (!sxObject) {
        return null;
      }
      const emptyBreakpoints = createEmptyBreakpointObject(theme2.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css2 = emptyBreakpoints;
      Object.keys(sxObject).forEach((styleKey) => {
        const value = callIfFn(sxObject[styleKey], theme2);
        if (value !== null && value !== void 0) {
          if (typeof value === "object") {
            if (config2[styleKey]) {
              css2 = merge(css2, getThemeValue(styleKey, value, theme2, config2));
            } else {
              const breakpointsValues = handleBreakpoints({
                theme: theme2
              }, value, (x) => ({
                [styleKey]: x
              }));
              if (objectsHaveSameKeys(breakpointsValues, value)) {
                css2[styleKey] = styleFunctionSx2({
                  sx: value,
                  theme: theme2,
                  nested: true
                });
              } else {
                css2 = merge(css2, breakpointsValues);
              }
            }
          } else {
            css2 = merge(css2, getThemeValue(styleKey, value, theme2, config2));
          }
        }
      });
      if (!nested2 && theme2.modularCssLayers) {
        return {
          "@layer sx": sortContainerQueries(theme2, removeUnusedBreakpoints(breakpointsKeys, css2))
        };
      }
      return sortContainerQueries(theme2, removeUnusedBreakpoints(breakpointsKeys, css2));
    }
    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }
  return styleFunctionSx2;
}
const styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ["sx"];
function applyStyles$2(key, styles2) {
  var _a2;
  const theme2 = this;
  if (theme2.vars) {
    if (!((_a2 = theme2.colorSchemes) == null ? void 0 : _a2[key]) || typeof theme2.getColorSchemeSelector !== "function") {
      return {};
    }
    let selector = theme2.getColorSchemeSelector(key);
    if (selector === "&") {
      return styles2;
    }
    if (selector.includes("data-") || selector.includes(".")) {
      selector = `*:where(${selector.replace(/\s*&$/, "")}) &`;
    }
    return {
      [selector]: styles2
    };
  }
  if (theme2.palette.mode === key) {
    return styles2;
  }
  return {};
}
function createTheme$1(options = {}, ...args) {
  const _a2 = options, {
    breakpoints: breakpointsInput = {},
    palette: paletteInput = {},
    spacing: spacingInput,
    shape: shapeInput = {}
  } = _a2, other = __objRest(_a2, [
    "breakpoints",
    "palette",
    "spacing",
    "shape"
  ]);
  const breakpoints = createBreakpoints(breakpointsInput);
  const spacing = createSpacing(spacingInput);
  let muiTheme = deepmerge({
    breakpoints,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: __spreadValues({
      mode: "light"
    }, paletteInput),
    spacing,
    shape: __spreadValues(__spreadValues({}, shape), shapeInput)
  }, other);
  muiTheme = cssContainerQueries(muiTheme);
  muiTheme.applyStyles = applyStyles$2;
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = __spreadValues(__spreadValues({}, defaultSxConfig), other == null ? void 0 : other.unstable_sxConfig);
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}
function isObjectEmpty$2(obj) {
  return Object.keys(obj).length === 0;
}
function useTheme$3(defaultTheme2 = null) {
  const contextTheme = reactExports.useContext(ThemeContext$1);
  return !contextTheme || isObjectEmpty$2(contextTheme) ? defaultTheme2 : contextTheme;
}
const systemDefaultTheme$1 = createTheme$1();
function useTheme$2(defaultTheme2 = systemDefaultTheme$1) {
  return useTheme$3(defaultTheme2);
}
function wrapGlobalLayer(styles2) {
  const serialized = internal_serializeStyles(styles2);
  if (styles2 !== serialized && serialized.styles) {
    if (!serialized.styles.match(/^@layer\s+[^{]*$/)) {
      serialized.styles = `@layer global{${serialized.styles}}`;
    }
    return serialized;
  }
  return styles2;
}
function GlobalStyles$2({
  styles: styles2,
  themeId,
  defaultTheme: defaultTheme2 = {}
}) {
  const upperTheme = useTheme$2(defaultTheme2);
  const resolvedTheme = themeId ? upperTheme[themeId] || upperTheme : upperTheme;
  let globalStyles = typeof styles2 === "function" ? styles2(resolvedTheme) : styles2;
  if (resolvedTheme.modularCssLayers) {
    if (Array.isArray(globalStyles)) {
      globalStyles = globalStyles.map((styleArg) => {
        if (typeof styleArg === "function") {
          return wrapGlobalLayer(styleArg(resolvedTheme));
        }
        return wrapGlobalLayer(styleArg);
      });
    } else {
      globalStyles = wrapGlobalLayer(globalStyles);
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$3, {
    styles: globalStyles
  });
}
const splitProps = (props) => {
  var _a2, _b;
  const result = {
    systemProps: {},
    otherProps: {}
  };
  const config2 = (_b = (_a2 = props == null ? void 0 : props.theme) == null ? void 0 : _a2.unstable_sxConfig) != null ? _b : defaultSxConfig;
  Object.keys(props).forEach((prop) => {
    if (config2[prop]) {
      result.systemProps[prop] = props[prop];
    } else {
      result.otherProps[prop] = props[prop];
    }
  });
  return result;
};
function extendSxProp$1(props) {
  const _a2 = props, {
    sx: inSx
  } = _a2, other = __objRest(_a2, [
    "sx"
  ]);
  const {
    systemProps,
    otherProps
  } = splitProps(other);
  let finalSx;
  if (Array.isArray(inSx)) {
    finalSx = [systemProps, ...inSx];
  } else if (typeof inSx === "function") {
    finalSx = (...args) => {
      const result = inSx(...args);
      if (!isPlainObject$2(result)) {
        return systemProps;
      }
      return __spreadValues(__spreadValues({}, systemProps), result);
    };
  } else {
    finalSx = __spreadValues(__spreadValues({}, systemProps), inSx);
  }
  return __spreadProps(__spreadValues({}, otherProps), {
    sx: finalSx
  });
}
const defaultGenerator = (componentName) => componentName;
const createClassNameGenerator = () => {
  let generate = defaultGenerator;
  return {
    configure(generator) {
      generate = generator;
    },
    generate(componentName) {
      return generate(componentName);
    },
    reset() {
      generate = defaultGenerator;
    }
  };
};
const ClassNameGenerator = createClassNameGenerator();
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
function createBox(options = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2,
    defaultClassName = "MuiBox-root",
    generateClassName
  } = options;
  const BoxRoot = styled$2("div", {
    shouldForwardProp: (prop) => prop !== "theme" && prop !== "sx" && prop !== "as"
  })(styleFunctionSx);
  const Box2 = /* @__PURE__ */ reactExports.forwardRef(function Box3(inProps, ref) {
    const theme2 = useTheme$2(defaultTheme2);
    const _a2 = extendSxProp$1(inProps), {
      className,
      component = "div"
    } = _a2, other = __objRest(_a2, [
      "className",
      "component"
    ]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(BoxRoot, __spreadValues({
      as: component,
      ref,
      className: clsx(className, generateClassName ? generateClassName(defaultClassName) : defaultClassName),
      theme: themeId ? theme2[themeId] || theme2 : theme2
    }, other));
  });
  return Box2;
}
const globalStateClasses = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
  const globalStateClass = globalStateClasses[slot];
  return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator.generate(componentName)}-${slot}`;
}
function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
  const result = {};
  slots.forEach((slot) => {
    result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
  });
  return result;
}
function preprocessStyles(input) {
  const _a2 = input, {
    variants
  } = _a2, style2 = __objRest(_a2, [
    "variants"
  ]);
  const result = {
    variants,
    style: internal_serializeStyles(style2),
    isProcessed: true
  };
  if (result.style === style2) {
    return result;
  }
  if (variants) {
    variants.forEach((variant) => {
      if (typeof variant.style !== "function") {
        variant.style = internal_serializeStyles(variant.style);
      }
    });
  }
  return result;
}
const systemDefaultTheme = createTheme$1();
function shouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
function shallowLayer(serialized, layerName) {
  if (layerName && serialized && typeof serialized === "object" && serialized.styles && !serialized.styles.startsWith("@layer")) {
    serialized.styles = `@layer ${layerName}{${String(serialized.styles)}}`;
  }
  return serialized;
}
function defaultOverridesResolver(slot) {
  if (!slot) {
    return null;
  }
  return (_props, styles2) => styles2[slot];
}
function attachTheme(props, themeId, defaultTheme2) {
  props.theme = isObjectEmpty$1(props.theme) ? defaultTheme2 : props.theme[themeId] || props.theme;
}
function processStyle(props, style2, layerName) {
  const resolvedStyle = typeof style2 === "function" ? style2(props) : style2;
  if (Array.isArray(resolvedStyle)) {
    return resolvedStyle.flatMap((subStyle) => processStyle(props, subStyle, layerName));
  }
  if (Array.isArray(resolvedStyle == null ? void 0 : resolvedStyle.variants)) {
    let rootStyle;
    if (resolvedStyle.isProcessed) {
      rootStyle = layerName ? shallowLayer(resolvedStyle.style, layerName) : resolvedStyle.style;
    } else {
      const _a2 = resolvedStyle, {
        variants
      } = _a2, otherStyles = __objRest(_a2, [
        "variants"
      ]);
      rootStyle = layerName ? shallowLayer(internal_serializeStyles(otherStyles), layerName) : otherStyles;
    }
    return processStyleVariants(props, resolvedStyle.variants, [rootStyle], layerName);
  }
  if (resolvedStyle == null ? void 0 : resolvedStyle.isProcessed) {
    return layerName ? shallowLayer(internal_serializeStyles(resolvedStyle.style), layerName) : resolvedStyle.style;
  }
  return layerName ? shallowLayer(internal_serializeStyles(resolvedStyle), layerName) : resolvedStyle;
}
function processStyleVariants(props, variants, results = [], layerName = void 0) {
  var _a2;
  let mergedState;
  variantLoop: for (let i = 0; i < variants.length; i += 1) {
    const variant = variants[i];
    if (typeof variant.props === "function") {
      mergedState != null ? mergedState : mergedState = __spreadProps(__spreadValues(__spreadValues({}, props), props.ownerState), {
        ownerState: props.ownerState
      });
      if (!variant.props(mergedState)) {
        continue;
      }
    } else {
      for (const key in variant.props) {
        if (props[key] !== variant.props[key] && ((_a2 = props.ownerState) == null ? void 0 : _a2[key]) !== variant.props[key]) {
          continue variantLoop;
        }
      }
    }
    if (typeof variant.style === "function") {
      mergedState != null ? mergedState : mergedState = __spreadProps(__spreadValues(__spreadValues({}, props), props.ownerState), {
        ownerState: props.ownerState
      });
      results.push(layerName ? shallowLayer(internal_serializeStyles(variant.style(mergedState)), layerName) : variant.style(mergedState));
    } else {
      results.push(layerName ? shallowLayer(internal_serializeStyles(variant.style), layerName) : variant.style);
    }
  }
  return results;
}
function createStyled2(input = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2 = systemDefaultTheme,
    rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
    slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp
  } = input;
  function styleAttachTheme(props) {
    attachTheme(props, themeId, defaultTheme2);
  }
  const styled2 = (tag, inputOptions = {}) => {
    internal_mutateStyles(tag, (styles2) => styles2.filter((style2) => style2 !== styleFunctionSx));
    const _a2 = inputOptions, {
      name: componentName,
      slot: componentSlot,
      skipVariantsResolver: inputSkipVariantsResolver,
      skipSx: inputSkipSx,
      overridesResolver: overridesResolver2 = defaultOverridesResolver(lowercaseFirstLetter(componentSlot))
    } = _a2, options = __objRest(_a2, [
      "name",
      "slot",
      "skipVariantsResolver",
      "skipSx",
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      "overridesResolver"
    ]);
    const layerName = componentName && componentName.startsWith("Mui") || !!componentSlot ? "components" : "custom";
    const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
    );
    const skipSx = inputSkipSx || false;
    let shouldForwardPropOption = shouldForwardProp;
    if (componentSlot === "Root" || componentSlot === "root") {
      shouldForwardPropOption = rootShouldForwardProp2;
    } else if (componentSlot) {
      shouldForwardPropOption = slotShouldForwardProp2;
    } else if (isStringTag(tag)) {
      shouldForwardPropOption = void 0;
    }
    const defaultStyledResolver = styled$2(tag, __spreadValues({
      shouldForwardProp: shouldForwardPropOption,
      label: generateStyledLabel()
    }, options));
    const transformStyle = (style2) => {
      if (style2.__emotion_real === style2) {
        return style2;
      }
      if (typeof style2 === "function") {
        return function styleFunctionProcessor(props) {
          return processStyle(props, style2, props.theme.modularCssLayers ? layerName : void 0);
        };
      }
      if (isPlainObject$2(style2)) {
        const serialized = preprocessStyles(style2);
        return function styleObjectProcessor(props) {
          if (!serialized.variants) {
            return props.theme.modularCssLayers ? shallowLayer(serialized.style, layerName) : serialized.style;
          }
          return processStyle(props, serialized, props.theme.modularCssLayers ? layerName : void 0);
        };
      }
      return style2;
    };
    const muiStyledResolver = (...expressionsInput) => {
      const expressionsHead = [];
      const expressionsBody = expressionsInput.map(transformStyle);
      const expressionsTail = [];
      expressionsHead.push(styleAttachTheme);
      if (componentName && overridesResolver2) {
        expressionsTail.push(function styleThemeOverrides(props) {
          var _a3, _b;
          const theme2 = props.theme;
          const styleOverrides = (_b = (_a3 = theme2.components) == null ? void 0 : _a3[componentName]) == null ? void 0 : _b.styleOverrides;
          if (!styleOverrides) {
            return null;
          }
          const resolvedStyleOverrides = {};
          for (const slotKey in styleOverrides) {
            resolvedStyleOverrides[slotKey] = processStyle(props, styleOverrides[slotKey], props.theme.modularCssLayers ? "theme" : void 0);
          }
          return overridesResolver2(props, resolvedStyleOverrides);
        });
      }
      if (componentName && !skipVariantsResolver) {
        expressionsTail.push(function styleThemeVariants(props) {
          var _a3, _b;
          const theme2 = props.theme;
          const themeVariants = (_b = (_a3 = theme2 == null ? void 0 : theme2.components) == null ? void 0 : _a3[componentName]) == null ? void 0 : _b.variants;
          if (!themeVariants) {
            return null;
          }
          return processStyleVariants(props, themeVariants, [], props.theme.modularCssLayers ? "theme" : void 0);
        });
      }
      if (!skipSx) {
        expressionsTail.push(styleFunctionSx);
      }
      if (Array.isArray(expressionsBody[0])) {
        const inputStrings = expressionsBody.shift();
        const placeholdersHead = new Array(expressionsHead.length).fill("");
        const placeholdersTail = new Array(expressionsTail.length).fill("");
        let outputStrings;
        {
          outputStrings = [...placeholdersHead, ...inputStrings, ...placeholdersTail];
          outputStrings.raw = [...placeholdersHead, ...inputStrings.raw, ...placeholdersTail];
        }
        expressionsHead.unshift(outputStrings);
      }
      const expressions = [...expressionsHead, ...expressionsBody, ...expressionsTail];
      const Component = defaultStyledResolver(...expressions);
      if (tag.muiName) {
        Component.muiName = tag.muiName;
      }
      return Component;
    };
    if (defaultStyledResolver.withConfig) {
      muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
    }
    return muiStyledResolver;
  };
  return styled2;
}
function generateStyledLabel(componentName, componentSlot) {
  let label;
  return label;
}
function isObjectEmpty$1(object) {
  for (const _ in object) {
    return false;
  }
  return true;
}
function isStringTag(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96;
}
function lowercaseFirstLetter(string) {
  if (!string) {
    return string;
  }
  return string.charAt(0).toLowerCase() + string.slice(1);
}
const styled$1 = createStyled2();
function resolveProps(defaultProps2, props, mergeClassNameAndStyle = false) {
  const output = __spreadValues({}, props);
  for (const key in defaultProps2) {
    if (Object.prototype.hasOwnProperty.call(defaultProps2, key)) {
      const propName = key;
      if (propName === "components" || propName === "slots") {
        output[propName] = __spreadValues(__spreadValues({}, defaultProps2[propName]), output[propName]);
      } else if (propName === "componentsProps" || propName === "slotProps") {
        const defaultSlotProps = defaultProps2[propName];
        const slotProps = props[propName];
        if (!slotProps) {
          output[propName] = defaultSlotProps || {};
        } else if (!defaultSlotProps) {
          output[propName] = slotProps;
        } else {
          output[propName] = __spreadValues({}, slotProps);
          for (const slotKey in defaultSlotProps) {
            if (Object.prototype.hasOwnProperty.call(defaultSlotProps, slotKey)) {
              const slotPropName = slotKey;
              output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName], mergeClassNameAndStyle);
            }
          }
        }
      } else if (propName === "className" && mergeClassNameAndStyle && props.className) {
        output.className = clsx(defaultProps2 == null ? void 0 : defaultProps2.className, props == null ? void 0 : props.className);
      } else if (propName === "style" && mergeClassNameAndStyle && props.style) {
        output.style = __spreadValues(__spreadValues({}, defaultProps2 == null ? void 0 : defaultProps2.style), props == null ? void 0 : props.style);
      } else if (output[propName] === void 0) {
        output[propName] = defaultProps2[propName];
      }
    }
  }
  return output;
}
function getThemeProps$1(params) {
  const {
    theme: theme2,
    name: name2,
    props
  } = params;
  if (!theme2 || !theme2.components || !theme2.components[name2] || !theme2.components[name2].defaultProps) {
    return props;
  }
  return resolveProps(theme2.components[name2].defaultProps, props);
}
function useThemeProps({
  props,
  name: name2,
  defaultTheme: defaultTheme2,
  themeId
}) {
  let theme2 = useTheme$2(defaultTheme2);
  if (themeId) {
    theme2 = theme2[themeId] || theme2;
  }
  return getThemeProps$1({
    theme: theme2,
    name: name2,
    props
  });
}
const useEnhancedEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function useMediaQueryOld(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr) {
  const [match2, setMatch] = reactExports.useState(() => {
    if (noSsr && matchMedia) {
      return matchMedia(query).matches;
    }
    if (ssrMatchMedia) {
      return ssrMatchMedia(query).matches;
    }
    return defaultMatches;
  });
  useEnhancedEffect(() => {
    if (!matchMedia) {
      return void 0;
    }
    const queryList = matchMedia(query);
    const updateMatch = () => {
      setMatch(queryList.matches);
    };
    updateMatch();
    queryList.addEventListener("change", updateMatch);
    return () => {
      queryList.removeEventListener("change", updateMatch);
    };
  }, [query, matchMedia]);
  return match2;
}
const safeReact$1 = __spreadValues({}, React$1);
const maybeReactUseSyncExternalStore = safeReact$1.useSyncExternalStore;
function useMediaQueryNew(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr) {
  const getDefaultSnapshot = reactExports.useCallback(() => defaultMatches, [defaultMatches]);
  const getServerSnapshot = reactExports.useMemo(() => {
    if (noSsr && matchMedia) {
      return () => matchMedia(query).matches;
    }
    if (ssrMatchMedia !== null) {
      const {
        matches
      } = ssrMatchMedia(query);
      return () => matches;
    }
    return getDefaultSnapshot;
  }, [getDefaultSnapshot, query, ssrMatchMedia, noSsr, matchMedia]);
  const [getSnapshot, subscribe] = reactExports.useMemo(() => {
    if (matchMedia === null) {
      return [getDefaultSnapshot, () => () => {
      }];
    }
    const mediaQueryList = matchMedia(query);
    return [() => mediaQueryList.matches, (notify) => {
      mediaQueryList.addEventListener("change", notify);
      return () => {
        mediaQueryList.removeEventListener("change", notify);
      };
    }];
  }, [getDefaultSnapshot, matchMedia, query]);
  const match2 = maybeReactUseSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
  return match2;
}
function unstable_createUseMediaQuery(params = {}) {
  const {
    themeId
  } = params;
  return function useMediaQuery2(queryInput, options = {}) {
    let theme2 = useTheme$3();
    if (theme2 && themeId) {
      theme2 = theme2[themeId] || theme2;
    }
    const supportMatchMedia = typeof window !== "undefined" && typeof window.matchMedia !== "undefined";
    const {
      defaultMatches = false,
      matchMedia = supportMatchMedia ? window.matchMedia : null,
      ssrMatchMedia = null,
      noSsr = false
    } = getThemeProps$1({
      name: "MuiUseMediaQuery",
      props: options,
      theme: theme2
    });
    let query = typeof queryInput === "function" ? queryInput(theme2) : queryInput;
    query = query.replace(/^@media( ?)/m, "");
    if (query.includes("print")) {
      console.warn([`MUI: You have provided a \`print\` query to the \`useMediaQuery\` hook.`, "Using the print media query to modify print styles can lead to unexpected results.", "Consider using the `displayPrint` field in the `sx` prop instead.", "More information about `displayPrint` on our docs: https://mui.com/system/display/#display-in-print."].join("\n"));
    }
    const useMediaQueryImplementation = maybeReactUseSyncExternalStore !== void 0 ? useMediaQueryNew : useMediaQueryOld;
    const match2 = useMediaQueryImplementation(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr);
    return match2;
  };
}
unstable_createUseMediaQuery();
function clamp(val, min2 = Number.MIN_SAFE_INTEGER, max2 = Number.MAX_SAFE_INTEGER) {
  return Math.max(min2, Math.min(val, max2));
}
function clampWrapper(value, min2 = 0, max2 = 1) {
  return clamp(value, min2, max2);
}
function hexToRgb(color2) {
  color2 = color2.slice(1);
  const re = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
  let colors = color2.match(re);
  if (colors && colors[0].length === 1) {
    colors = colors.map((n) => n + n);
  }
  return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n, index2) => {
    return index2 < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1e3) / 1e3;
  }).join(", ")})` : "";
}
function decomposeColor(color2) {
  if (color2.type) {
    return color2;
  }
  if (color2.charAt(0) === "#") {
    return decomposeColor(hexToRgb(color2));
  }
  const marker = color2.indexOf("(");
  const type = color2.substring(0, marker);
  if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(type)) {
    throw new Error(formatMuiErrorMessage(9, color2));
  }
  let values2 = color2.substring(marker + 1, color2.length - 1);
  let colorSpace;
  if (type === "color") {
    values2 = values2.split(" ");
    colorSpace = values2.shift();
    if (values2.length === 4 && values2[3].charAt(0) === "/") {
      values2[3] = values2[3].slice(1);
    }
    if (!["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(colorSpace)) {
      throw new Error(formatMuiErrorMessage(10, colorSpace));
    }
  } else {
    values2 = values2.split(",");
  }
  values2 = values2.map((value) => parseFloat(value));
  return {
    type,
    values: values2,
    colorSpace
  };
}
const colorChannel = (color2) => {
  const decomposedColor = decomposeColor(color2);
  return decomposedColor.values.slice(0, 3).map((val, idx) => decomposedColor.type.includes("hsl") && idx !== 0 ? `${val}%` : val).join(" ");
};
const private_safeColorChannel = (color2, warning2) => {
  try {
    return colorChannel(color2);
  } catch (error2) {
    return color2;
  }
};
function recomposeColor(color2) {
  const {
    type,
    colorSpace
  } = color2;
  let {
    values: values2
  } = color2;
  if (type.includes("rgb")) {
    values2 = values2.map((n, i) => i < 3 ? parseInt(n, 10) : n);
  } else if (type.includes("hsl")) {
    values2[1] = `${values2[1]}%`;
    values2[2] = `${values2[2]}%`;
  }
  if (type.includes("color")) {
    values2 = `${colorSpace} ${values2.join(" ")}`;
  } else {
    values2 = `${values2.join(", ")}`;
  }
  return `${type}(${values2})`;
}
function hslToRgb(color2) {
  color2 = decomposeColor(color2);
  const {
    values: values2
  } = color2;
  const h = values2[0];
  const s = values2[1] / 100;
  const l = values2[2] / 100;
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  let type = "rgb";
  const rgb = [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
  if (color2.type === "hsla") {
    type += "a";
    rgb.push(values2[3]);
  }
  return recomposeColor({
    type,
    values: rgb
  });
}
function getLuminance(color2) {
  color2 = decomposeColor(color2);
  let rgb = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor(hslToRgb(color2)).values : color2.values;
  rgb = rgb.map((val) => {
    if (color2.type !== "color") {
      val /= 255;
    }
    return val <= 0.03928 ? val / 12.92 : __pow((val + 0.055) / 1.055, 2.4);
  });
  return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}
function getContrastRatio(foreground, background) {
  const lumA = getLuminance(foreground);
  const lumB = getLuminance(background);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
function alpha(color2, value) {
  color2 = decomposeColor(color2);
  value = clampWrapper(value);
  if (color2.type === "rgb" || color2.type === "hsl") {
    color2.type += "a";
  }
  if (color2.type === "color") {
    color2.values[3] = `/${value}`;
  } else {
    color2.values[3] = value;
  }
  return recomposeColor(color2);
}
function private_safeAlpha(color2, value, warning2) {
  try {
    return alpha(color2, value);
  } catch (error2) {
    return color2;
  }
}
function darken(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.includes("hsl")) {
    color2.values[2] *= 1 - coefficient;
  } else if (color2.type.includes("rgb") || color2.type.includes("color")) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] *= 1 - coefficient;
    }
  }
  return recomposeColor(color2);
}
function private_safeDarken(color2, coefficient, warning2) {
  try {
    return darken(color2, coefficient);
  } catch (error2) {
    return color2;
  }
}
function lighten(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.includes("hsl")) {
    color2.values[2] += (100 - color2.values[2]) * coefficient;
  } else if (color2.type.includes("rgb")) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] += (255 - color2.values[i]) * coefficient;
    }
  } else if (color2.type.includes("color")) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] += (1 - color2.values[i]) * coefficient;
    }
  }
  return recomposeColor(color2);
}
function private_safeLighten(color2, coefficient, warning2) {
  try {
    return lighten(color2, coefficient);
  } catch (error2) {
    return color2;
  }
}
function emphasize(color2, coefficient = 0.15) {
  return getLuminance(color2) > 0.5 ? darken(color2, coefficient) : lighten(color2, coefficient);
}
function private_safeEmphasize(color2, coefficient, warning2) {
  try {
    return emphasize(color2, coefficient);
  } catch (error2) {
    return color2;
  }
}
const ThemeContext = /* @__PURE__ */ reactExports.createContext(null);
function useTheme$1() {
  const theme2 = reactExports.useContext(ThemeContext);
  return theme2;
}
const hasSymbol = typeof Symbol === "function" && Symbol.for;
const nested = hasSymbol ? Symbol.for("mui.nested") : "__THEME_NESTED__";
function mergeOuterLocalTheme(outerTheme, localTheme) {
  if (typeof localTheme === "function") {
    const mergedTheme = localTheme(outerTheme);
    return mergedTheme;
  }
  return __spreadValues(__spreadValues({}, outerTheme), localTheme);
}
function ThemeProvider$2(props) {
  const {
    children,
    theme: localTheme
  } = props;
  const outerTheme = useTheme$1();
  const theme2 = reactExports.useMemo(() => {
    const output = outerTheme === null ? __spreadValues({}, localTheme) : mergeOuterLocalTheme(outerTheme, localTheme);
    if (output != null) {
      output[nested] = outerTheme !== null;
    }
    return output;
  }, [localTheme, outerTheme]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeContext.Provider, {
    value: theme2,
    children
  });
}
const RtlContext = /* @__PURE__ */ reactExports.createContext();
function RtlProvider(_k) {
  var _l = _k, {
    value
  } = _l, props = __objRest(_l, [
    "value"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RtlContext.Provider, __spreadValues({
    value: value != null ? value : true
  }, props));
}
const useRtl = () => {
  const value = reactExports.useContext(RtlContext);
  return value != null ? value : false;
};
const PropsContext = /* @__PURE__ */ reactExports.createContext(void 0);
function DefaultPropsProvider({
  value,
  children
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PropsContext.Provider, {
    value,
    children
  });
}
function getThemeProps(params) {
  const {
    theme: theme2,
    name: name2,
    props
  } = params;
  if (!theme2 || !theme2.components || !theme2.components[name2]) {
    return props;
  }
  const config2 = theme2.components[name2];
  if (config2.defaultProps) {
    return resolveProps(config2.defaultProps, props, theme2.components.mergeClassNameAndStyle);
  }
  if (!config2.styleOverrides && !config2.variants) {
    return resolveProps(config2, props, theme2.components.mergeClassNameAndStyle);
  }
  return props;
}
function useDefaultProps$1({
  props,
  name: name2
}) {
  const ctx = reactExports.useContext(PropsContext);
  return getThemeProps({
    props,
    name: name2,
    theme: {
      components: ctx
    }
  });
}
let globalId = 0;
function useGlobalId(idOverride) {
  const [defaultId, setDefaultId] = reactExports.useState(idOverride);
  const id = idOverride || defaultId;
  reactExports.useEffect(() => {
    if (defaultId == null) {
      globalId += 1;
      setDefaultId(`mui-${globalId}`);
    }
  }, [defaultId]);
  return id;
}
const safeReact = __spreadValues({}, React$1);
const maybeReactUseId = safeReact.useId;
function useId(idOverride) {
  if (maybeReactUseId !== void 0) {
    const reactId = maybeReactUseId();
    return idOverride != null ? idOverride : reactId;
  }
  return useGlobalId(idOverride);
}
function useLayerOrder(theme2) {
  const upperTheme = useTheme$3();
  const id = useId() || "";
  const {
    modularCssLayers
  } = theme2;
  let layerOrder = "mui.global, mui.components, mui.theme, mui.custom, mui.sx";
  if (!modularCssLayers || upperTheme !== null) {
    layerOrder = "";
  } else if (typeof modularCssLayers === "string") {
    layerOrder = modularCssLayers.replace(/mui(?!\.)/g, layerOrder);
  } else {
    layerOrder = `@layer ${layerOrder};`;
  }
  useEnhancedEffect(() => {
    var _a2, _b;
    const head2 = document.querySelector("head");
    if (!head2) {
      return;
    }
    const firstChild = head2.firstChild;
    if (layerOrder) {
      if (firstChild && ((_a2 = firstChild.hasAttribute) == null ? void 0 : _a2.call(firstChild, "data-mui-layer-order")) && firstChild.getAttribute("data-mui-layer-order") === id) {
        return;
      }
      const styleElement = document.createElement("style");
      styleElement.setAttribute("data-mui-layer-order", id);
      styleElement.textContent = layerOrder;
      head2.prepend(styleElement);
    } else {
      (_b = head2.querySelector(`style[data-mui-layer-order="${id}"]`)) == null ? void 0 : _b.remove();
    }
  }, [layerOrder, id]);
  if (!layerOrder) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$2, {
    styles: layerOrder
  });
}
const EMPTY_THEME = {};
function useThemeScoping(themeId, upperTheme, localTheme, isPrivate = false) {
  return reactExports.useMemo(() => {
    const resolvedTheme = themeId ? upperTheme[themeId] || upperTheme : upperTheme;
    if (typeof localTheme === "function") {
      const mergedTheme = localTheme(resolvedTheme);
      const result = themeId ? __spreadProps(__spreadValues({}, upperTheme), {
        [themeId]: mergedTheme
      }) : mergedTheme;
      if (isPrivate) {
        return () => result;
      }
      return result;
    }
    return themeId ? __spreadProps(__spreadValues({}, upperTheme), {
      [themeId]: localTheme
    }) : __spreadValues(__spreadValues({}, upperTheme), localTheme);
  }, [themeId, upperTheme, localTheme, isPrivate]);
}
function ThemeProvider$1(props) {
  const {
    children,
    theme: localTheme,
    themeId
  } = props;
  const upperTheme = useTheme$3(EMPTY_THEME);
  const upperPrivateTheme = useTheme$1() || EMPTY_THEME;
  const engineTheme = useThemeScoping(themeId, upperTheme, localTheme);
  const privateTheme = useThemeScoping(themeId, upperPrivateTheme, localTheme, true);
  const rtlValue = (themeId ? engineTheme[themeId] : engineTheme).direction === "rtl";
  const layerOrder = useLayerOrder(engineTheme);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider$2, {
    theme: privateTheme,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeContext$1.Provider, {
      value: engineTheme,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(RtlProvider, {
        value: rtlValue,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DefaultPropsProvider, {
          value: themeId ? engineTheme[themeId].components : engineTheme.components,
          children: [layerOrder, children]
        })
      })
    })
  });
}
const arg = {
  theme: void 0
};
function unstable_memoTheme(styleFn) {
  let lastValue;
  let lastTheme;
  return function styleMemoized(props) {
    let value = lastValue;
    if (value === void 0 || props.theme !== lastTheme) {
      arg.theme = props.theme;
      value = preprocessStyles(styleFn(arg));
      lastValue = value;
      lastTheme = props.theme;
    }
    return value;
  };
}
const DEFAULT_MODE_STORAGE_KEY = "mode";
const DEFAULT_COLOR_SCHEME_STORAGE_KEY = "color-scheme";
const DEFAULT_ATTRIBUTE = "data-color-scheme";
function InitColorSchemeScript(options) {
  const {
    defaultMode = "system",
    defaultLightColorScheme = "light",
    defaultDarkColorScheme = "dark",
    modeStorageKey = DEFAULT_MODE_STORAGE_KEY,
    colorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY,
    attribute: initialAttribute = DEFAULT_ATTRIBUTE,
    colorSchemeNode = "document.documentElement",
    nonce
  } = options || {};
  let setter = "";
  let attribute = initialAttribute;
  if (initialAttribute === "class") {
    attribute = ".%s";
  }
  if (initialAttribute === "data") {
    attribute = "[data-%s]";
  }
  if (attribute.startsWith(".")) {
    const selector = attribute.substring(1);
    setter += `${colorSchemeNode}.classList.remove('${selector}'.replace('%s', light), '${selector}'.replace('%s', dark));
      ${colorSchemeNode}.classList.add('${selector}'.replace('%s', colorScheme));`;
  }
  const matches = attribute.match(/\[([^[\]]+)\]/);
  if (matches) {
    const [attr, value] = matches[1].split("=");
    if (!value) {
      setter += `${colorSchemeNode}.removeAttribute('${attr}'.replace('%s', light));
      ${colorSchemeNode}.removeAttribute('${attr}'.replace('%s', dark));`;
    }
    setter += `
      ${colorSchemeNode}.setAttribute('${attr}'.replace('%s', colorScheme), ${value ? `${value}.replace('%s', colorScheme)` : '""'});`;
  } else {
    setter += `${colorSchemeNode}.setAttribute('${attribute}', colorScheme);`;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("script", {
    suppressHydrationWarning: true,
    nonce: typeof window === "undefined" ? nonce : "",
    dangerouslySetInnerHTML: {
      __html: `(function() {
try {
  let colorScheme = '';
  const mode = localStorage.getItem('${modeStorageKey}') || '${defaultMode}';
  const dark = localStorage.getItem('${colorSchemeStorageKey}-dark') || '${defaultDarkColorScheme}';
  const light = localStorage.getItem('${colorSchemeStorageKey}-light') || '${defaultLightColorScheme}';
  if (mode === 'system') {
    // handle system mode
    const mql = window.matchMedia('(prefers-color-scheme: dark)');
    if (mql.matches) {
      colorScheme = dark
    } else {
      colorScheme = light
    }
  }
  if (mode === 'light') {
    colorScheme = light;
  }
  if (mode === 'dark') {
    colorScheme = dark;
  }
  if (colorScheme) {
    ${setter}
  }
} catch(e){}})();`
    }
  }, "mui-color-scheme-init");
}
function noop$5() {
}
const localStorageManager = ({
  key,
  storageWindow
}) => {
  if (!storageWindow && typeof window !== "undefined") {
    storageWindow = window;
  }
  return {
    get(defaultValue) {
      if (typeof window === "undefined") {
        return void 0;
      }
      if (!storageWindow) {
        return defaultValue;
      }
      let value;
      try {
        value = storageWindow.localStorage.getItem(key);
      } catch (e) {
      }
      return value || defaultValue;
    },
    set: (value) => {
      if (storageWindow) {
        try {
          storageWindow.localStorage.setItem(key, value);
        } catch (e) {
        }
      }
    },
    subscribe: (handler) => {
      if (!storageWindow) {
        return noop$5;
      }
      const listener = (event) => {
        const value = event.newValue;
        if (event.key === key) {
          handler(value);
        }
      };
      storageWindow.addEventListener("storage", listener);
      return () => {
        storageWindow.removeEventListener("storage", listener);
      };
    }
  };
};
function noop$4() {
}
function getSystemMode(mode) {
  if (typeof window !== "undefined" && typeof window.matchMedia === "function" && mode === "system") {
    const mql = window.matchMedia("(prefers-color-scheme: dark)");
    if (mql.matches) {
      return "dark";
    }
    return "light";
  }
  return void 0;
}
function processState(state, callback) {
  if (state.mode === "light" || state.mode === "system" && state.systemMode === "light") {
    return callback("light");
  }
  if (state.mode === "dark" || state.mode === "system" && state.systemMode === "dark") {
    return callback("dark");
  }
  return void 0;
}
function getColorScheme(state) {
  return processState(state, (mode) => {
    if (mode === "light") {
      return state.lightColorScheme;
    }
    if (mode === "dark") {
      return state.darkColorScheme;
    }
    return void 0;
  });
}
function useCurrentColorScheme(options) {
  const {
    defaultMode = "light",
    defaultLightColorScheme,
    defaultDarkColorScheme,
    supportedColorSchemes = [],
    modeStorageKey = DEFAULT_MODE_STORAGE_KEY,
    colorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY,
    storageWindow = typeof window === "undefined" ? void 0 : window,
    storageManager = localStorageManager,
    noSsr = false
  } = options;
  const joinedColorSchemes = supportedColorSchemes.join(",");
  const isMultiSchemes = supportedColorSchemes.length > 1;
  const modeStorage = reactExports.useMemo(() => storageManager == null ? void 0 : storageManager({
    key: modeStorageKey,
    storageWindow
  }), [storageManager, modeStorageKey, storageWindow]);
  const lightStorage = reactExports.useMemo(() => storageManager == null ? void 0 : storageManager({
    key: `${colorSchemeStorageKey}-light`,
    storageWindow
  }), [storageManager, colorSchemeStorageKey, storageWindow]);
  const darkStorage = reactExports.useMemo(() => storageManager == null ? void 0 : storageManager({
    key: `${colorSchemeStorageKey}-dark`,
    storageWindow
  }), [storageManager, colorSchemeStorageKey, storageWindow]);
  const [state, setState] = reactExports.useState(() => {
    const initialMode = (modeStorage == null ? void 0 : modeStorage.get(defaultMode)) || defaultMode;
    const lightColorScheme = (lightStorage == null ? void 0 : lightStorage.get(defaultLightColorScheme)) || defaultLightColorScheme;
    const darkColorScheme = (darkStorage == null ? void 0 : darkStorage.get(defaultDarkColorScheme)) || defaultDarkColorScheme;
    return {
      mode: initialMode,
      systemMode: getSystemMode(initialMode),
      lightColorScheme,
      darkColorScheme
    };
  });
  const [isClient, setIsClient] = reactExports.useState(noSsr || !isMultiSchemes);
  reactExports.useEffect(() => {
    setIsClient(true);
  }, []);
  const colorScheme = getColorScheme(state);
  const setMode = reactExports.useCallback((mode) => {
    setState((currentState) => {
      if (mode === currentState.mode) {
        return currentState;
      }
      const newMode = mode != null ? mode : defaultMode;
      modeStorage == null ? void 0 : modeStorage.set(newMode);
      return __spreadProps(__spreadValues({}, currentState), {
        mode: newMode,
        systemMode: getSystemMode(newMode)
      });
    });
  }, [modeStorage, defaultMode]);
  const setColorScheme = reactExports.useCallback((value) => {
    if (!value) {
      setState((currentState) => {
        lightStorage == null ? void 0 : lightStorage.set(defaultLightColorScheme);
        darkStorage == null ? void 0 : darkStorage.set(defaultDarkColorScheme);
        return __spreadProps(__spreadValues({}, currentState), {
          lightColorScheme: defaultLightColorScheme,
          darkColorScheme: defaultDarkColorScheme
        });
      });
    } else if (typeof value === "string") {
      if (value && !joinedColorSchemes.includes(value)) {
        console.error(`\`${value}\` does not exist in \`theme.colorSchemes\`.`);
      } else {
        setState((currentState) => {
          const newState = __spreadValues({}, currentState);
          processState(currentState, (mode) => {
            if (mode === "light") {
              lightStorage == null ? void 0 : lightStorage.set(value);
              newState.lightColorScheme = value;
            }
            if (mode === "dark") {
              darkStorage == null ? void 0 : darkStorage.set(value);
              newState.darkColorScheme = value;
            }
          });
          return newState;
        });
      }
    } else {
      setState((currentState) => {
        const newState = __spreadValues({}, currentState);
        const newLightColorScheme = value.light === null ? defaultLightColorScheme : value.light;
        const newDarkColorScheme = value.dark === null ? defaultDarkColorScheme : value.dark;
        if (newLightColorScheme) {
          if (!joinedColorSchemes.includes(newLightColorScheme)) {
            console.error(`\`${newLightColorScheme}\` does not exist in \`theme.colorSchemes\`.`);
          } else {
            newState.lightColorScheme = newLightColorScheme;
            lightStorage == null ? void 0 : lightStorage.set(newLightColorScheme);
          }
        }
        if (newDarkColorScheme) {
          if (!joinedColorSchemes.includes(newDarkColorScheme)) {
            console.error(`\`${newDarkColorScheme}\` does not exist in \`theme.colorSchemes\`.`);
          } else {
            newState.darkColorScheme = newDarkColorScheme;
            darkStorage == null ? void 0 : darkStorage.set(newDarkColorScheme);
          }
        }
        return newState;
      });
    }
  }, [joinedColorSchemes, lightStorage, darkStorage, defaultLightColorScheme, defaultDarkColorScheme]);
  const handleMediaQuery = reactExports.useCallback((event) => {
    if (state.mode === "system") {
      setState((currentState) => {
        const systemMode = (event == null ? void 0 : event.matches) ? "dark" : "light";
        if (currentState.systemMode === systemMode) {
          return currentState;
        }
        return __spreadProps(__spreadValues({}, currentState), {
          systemMode
        });
      });
    }
  }, [state.mode]);
  const mediaListener = reactExports.useRef(handleMediaQuery);
  mediaListener.current = handleMediaQuery;
  reactExports.useEffect(() => {
    if (typeof window.matchMedia !== "function" || !isMultiSchemes) {
      return void 0;
    }
    const handler = (...args) => mediaListener.current(...args);
    const media = window.matchMedia("(prefers-color-scheme: dark)");
    media.addListener(handler);
    handler(media);
    return () => {
      media.removeListener(handler);
    };
  }, [isMultiSchemes]);
  reactExports.useEffect(() => {
    if (isMultiSchemes) {
      const unsubscribeMode = (modeStorage == null ? void 0 : modeStorage.subscribe((value) => {
        if (!value || ["light", "dark", "system"].includes(value)) {
          setMode(value || defaultMode);
        }
      })) || noop$4;
      const unsubscribeLight = (lightStorage == null ? void 0 : lightStorage.subscribe((value) => {
        if (!value || joinedColorSchemes.match(value)) {
          setColorScheme({
            light: value
          });
        }
      })) || noop$4;
      const unsubscribeDark = (darkStorage == null ? void 0 : darkStorage.subscribe((value) => {
        if (!value || joinedColorSchemes.match(value)) {
          setColorScheme({
            dark: value
          });
        }
      })) || noop$4;
      return () => {
        unsubscribeMode();
        unsubscribeLight();
        unsubscribeDark();
      };
    }
    return void 0;
  }, [setColorScheme, setMode, joinedColorSchemes, defaultMode, storageWindow, isMultiSchemes, modeStorage, lightStorage, darkStorage]);
  return __spreadProps(__spreadValues({}, state), {
    mode: isClient ? state.mode : void 0,
    systemMode: isClient ? state.systemMode : void 0,
    colorScheme: isClient ? colorScheme : void 0,
    setMode,
    setColorScheme
  });
}
const DISABLE_CSS_TRANSITION = "*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
function createCssVarsProvider(options) {
  const {
    themeId,
    /**
     * This `theme` object needs to follow a certain structure to
     * be used correctly by the finel `CssVarsProvider`. It should have a
     * `colorSchemes` key with the light and dark (and any other) palette.
     * It should also ideally have a vars object created using `prepareCssVars`.
     */
    theme: defaultTheme2 = {},
    modeStorageKey: defaultModeStorageKey = DEFAULT_MODE_STORAGE_KEY,
    colorSchemeStorageKey: defaultColorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY,
    disableTransitionOnChange: designSystemTransitionOnChange = false,
    defaultColorScheme,
    resolveTheme
  } = options;
  const defaultContext = {
    allColorSchemes: [],
    colorScheme: void 0,
    darkColorScheme: void 0,
    lightColorScheme: void 0,
    mode: void 0,
    setColorScheme: () => {
    },
    setMode: () => {
    },
    systemMode: void 0
  };
  const ColorSchemeContext = /* @__PURE__ */ reactExports.createContext(void 0);
  const useColorScheme = () => reactExports.useContext(ColorSchemeContext) || defaultContext;
  const defaultColorSchemes = {};
  const defaultComponents = {};
  function CssVarsProvider2(props) {
    var _a2, _b, _c, _d;
    const {
      children,
      theme: themeProp,
      modeStorageKey = defaultModeStorageKey,
      colorSchemeStorageKey = defaultColorSchemeStorageKey,
      disableTransitionOnChange = designSystemTransitionOnChange,
      storageManager,
      storageWindow = typeof window === "undefined" ? void 0 : window,
      documentNode = typeof document === "undefined" ? void 0 : document,
      colorSchemeNode = typeof document === "undefined" ? void 0 : document.documentElement,
      disableNestedContext = false,
      disableStyleSheetGeneration = false,
      defaultMode: initialMode = "system",
      forceThemeRerender = false,
      noSsr
    } = props;
    const hasMounted = reactExports.useRef(false);
    const upperTheme = useTheme$1();
    const ctx = reactExports.useContext(ColorSchemeContext);
    const nested2 = !!ctx && !disableNestedContext;
    const initialTheme = reactExports.useMemo(() => {
      if (themeProp) {
        return themeProp;
      }
      return typeof defaultTheme2 === "function" ? defaultTheme2() : defaultTheme2;
    }, [themeProp]);
    const scopedTheme = initialTheme[themeId];
    const restThemeProp = scopedTheme || initialTheme;
    const {
      colorSchemes = defaultColorSchemes,
      components = defaultComponents,
      cssVarPrefix
    } = restThemeProp;
    const joinedColorSchemes = Object.keys(colorSchemes).filter((k) => !!colorSchemes[k]).join(",");
    const allColorSchemes = reactExports.useMemo(() => joinedColorSchemes.split(","), [joinedColorSchemes]);
    const defaultLightColorScheme2 = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.light;
    const defaultDarkColorScheme2 = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.dark;
    const defaultMode = colorSchemes[defaultLightColorScheme2] && colorSchemes[defaultDarkColorScheme2] ? initialMode : ((_b = (_a2 = colorSchemes[restThemeProp.defaultColorScheme]) == null ? void 0 : _a2.palette) == null ? void 0 : _b.mode) || ((_c = restThemeProp.palette) == null ? void 0 : _c.mode);
    const {
      mode: stateMode,
      setMode,
      systemMode,
      lightColorScheme,
      darkColorScheme,
      colorScheme: stateColorScheme,
      setColorScheme
    } = useCurrentColorScheme({
      supportedColorSchemes: allColorSchemes,
      defaultLightColorScheme: defaultLightColorScheme2,
      defaultDarkColorScheme: defaultDarkColorScheme2,
      modeStorageKey,
      colorSchemeStorageKey,
      defaultMode,
      storageManager,
      storageWindow,
      noSsr
    });
    let mode = stateMode;
    let colorScheme = stateColorScheme;
    if (nested2) {
      mode = ctx.mode;
      colorScheme = ctx.colorScheme;
    }
    let calculatedColorScheme = colorScheme || restThemeProp.defaultColorScheme;
    if (restThemeProp.vars && !forceThemeRerender) {
      calculatedColorScheme = restThemeProp.defaultColorScheme;
    }
    const memoTheme2 = reactExports.useMemo(() => {
      var _a3;
      const themeVars = ((_a3 = restThemeProp.generateThemeVars) == null ? void 0 : _a3.call(restThemeProp)) || restThemeProp.vars;
      const theme2 = __spreadProps(__spreadValues({}, restThemeProp), {
        components,
        colorSchemes,
        cssVarPrefix,
        vars: themeVars
      });
      if (typeof theme2.generateSpacing === "function") {
        theme2.spacing = theme2.generateSpacing();
      }
      if (calculatedColorScheme) {
        const scheme = colorSchemes[calculatedColorScheme];
        if (scheme && typeof scheme === "object") {
          Object.keys(scheme).forEach((schemeKey) => {
            if (scheme[schemeKey] && typeof scheme[schemeKey] === "object") {
              theme2[schemeKey] = __spreadValues(__spreadValues({}, theme2[schemeKey]), scheme[schemeKey]);
            } else {
              theme2[schemeKey] = scheme[schemeKey];
            }
          });
        }
      }
      return resolveTheme ? resolveTheme(theme2) : theme2;
    }, [restThemeProp, calculatedColorScheme, components, colorSchemes, cssVarPrefix]);
    const colorSchemeSelector = restThemeProp.colorSchemeSelector;
    useEnhancedEffect(() => {
      if (colorScheme && colorSchemeNode && colorSchemeSelector && colorSchemeSelector !== "media") {
        const selector = colorSchemeSelector;
        let rule = colorSchemeSelector;
        if (selector === "class") {
          rule = `.%s`;
        }
        if (selector === "data") {
          rule = `[data-%s]`;
        }
        if ((selector == null ? void 0 : selector.startsWith("data-")) && !selector.includes("%s")) {
          rule = `[${selector}="%s"]`;
        }
        if (rule.startsWith(".")) {
          colorSchemeNode.classList.remove(...allColorSchemes.map((scheme) => rule.substring(1).replace("%s", scheme)));
          colorSchemeNode.classList.add(rule.substring(1).replace("%s", colorScheme));
        } else {
          const matches = rule.replace("%s", colorScheme).match(/\[([^\]]+)\]/);
          if (matches) {
            const [attr, value] = matches[1].split("=");
            if (!value) {
              allColorSchemes.forEach((scheme) => {
                colorSchemeNode.removeAttribute(attr.replace(colorScheme, scheme));
              });
            }
            colorSchemeNode.setAttribute(attr, value ? value.replace(/"|'/g, "") : "");
          } else {
            colorSchemeNode.setAttribute(rule, colorScheme);
          }
        }
      }
    }, [colorScheme, colorSchemeSelector, colorSchemeNode, allColorSchemes]);
    reactExports.useEffect(() => {
      let timer;
      if (disableTransitionOnChange && hasMounted.current && documentNode) {
        const css2 = documentNode.createElement("style");
        css2.appendChild(documentNode.createTextNode(DISABLE_CSS_TRANSITION));
        documentNode.head.appendChild(css2);
        (() => window.getComputedStyle(documentNode.body))();
        timer = setTimeout(() => {
          documentNode.head.removeChild(css2);
        }, 1);
      }
      return () => {
        clearTimeout(timer);
      };
    }, [colorScheme, disableTransitionOnChange, documentNode]);
    reactExports.useEffect(() => {
      hasMounted.current = true;
      return () => {
        hasMounted.current = false;
      };
    }, []);
    const contextValue = reactExports.useMemo(() => ({
      allColorSchemes,
      colorScheme,
      darkColorScheme,
      lightColorScheme,
      mode,
      setColorScheme,
      setMode,
      systemMode
    }), [allColorSchemes, colorScheme, darkColorScheme, lightColorScheme, mode, setColorScheme, setMode, systemMode, memoTheme2.colorSchemeSelector]);
    let shouldGenerateStyleSheet = true;
    if (disableStyleSheetGeneration || restThemeProp.cssVariables === false || nested2 && (upperTheme == null ? void 0 : upperTheme.cssVarPrefix) === cssVarPrefix) {
      shouldGenerateStyleSheet = false;
    }
    const element = /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider$1, {
        themeId: scopedTheme ? themeId : void 0,
        theme: memoTheme2,
        children
      }), shouldGenerateStyleSheet && /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$3, {
        styles: ((_d = memoTheme2.generateStyleSheets) == null ? void 0 : _d.call(memoTheme2)) || []
      })]
    });
    if (nested2) {
      return element;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ColorSchemeContext.Provider, {
      value: contextValue,
      children: element
    });
  }
  const defaultLightColorScheme = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.light;
  const defaultDarkColorScheme = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.dark;
  const getInitColorSchemeScript = (params) => InitColorSchemeScript(__spreadValues({
    colorSchemeStorageKey: defaultColorSchemeStorageKey,
    defaultLightColorScheme,
    defaultDarkColorScheme,
    modeStorageKey: defaultModeStorageKey
  }, params));
  return {
    CssVarsProvider: CssVarsProvider2,
    useColorScheme,
    getInitColorSchemeScript
  };
}
function createGetCssVar$1(prefix2 = "") {
  function appendVar(...vars) {
    if (!vars.length) {
      return "";
    }
    const value = vars[0];
    if (typeof value === "string" && !value.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/)) {
      return `, var(--${prefix2 ? `${prefix2}-` : ""}${value}${appendVar(...vars.slice(1))})`;
    }
    return `, ${value}`;
  }
  const getCssVar = (field, ...fallbacks) => {
    return `var(--${prefix2 ? `${prefix2}-` : ""}${field}${appendVar(...fallbacks)})`;
  };
  return getCssVar;
}
const assignNestedKeys = (obj, keys, value, arrayKeys = []) => {
  let temp = obj;
  keys.forEach((k, index2) => {
    if (index2 === keys.length - 1) {
      if (Array.isArray(temp)) {
        temp[Number(k)] = value;
      } else if (temp && typeof temp === "object") {
        temp[k] = value;
      }
    } else if (temp && typeof temp === "object") {
      if (!temp[k]) {
        temp[k] = arrayKeys.includes(k) ? [] : {};
      }
      temp = temp[k];
    }
  });
};
const walkObjectDeep = (obj, callback, shouldSkipPaths) => {
  function recurse(object, parentKeys = [], arrayKeys = []) {
    Object.entries(object).forEach(([key, value]) => {
      if (!shouldSkipPaths || shouldSkipPaths && !shouldSkipPaths([...parentKeys, key])) {
        if (value !== void 0 && value !== null) {
          if (typeof value === "object" && Object.keys(value).length > 0) {
            recurse(value, [...parentKeys, key], Array.isArray(value) ? [...arrayKeys, key] : arrayKeys);
          } else {
            callback([...parentKeys, key], value, arrayKeys);
          }
        }
      }
    });
  }
  recurse(obj);
};
const getCssValue = (keys, value) => {
  if (typeof value === "number") {
    if (["lineHeight", "fontWeight", "opacity", "zIndex"].some((prop) => keys.includes(prop))) {
      return value;
    }
    const lastKey = keys[keys.length - 1];
    if (lastKey.toLowerCase().includes("opacity")) {
      return value;
    }
    return `${value}px`;
  }
  return value;
};
function cssVarsParser(theme2, options) {
  const {
    prefix: prefix2,
    shouldSkipGeneratingVar: shouldSkipGeneratingVar2
  } = options || {};
  const css2 = {};
  const vars = {};
  const varsWithDefaults = {};
  walkObjectDeep(
    theme2,
    (keys, value, arrayKeys) => {
      if (typeof value === "string" || typeof value === "number") {
        if (!shouldSkipGeneratingVar2 || !shouldSkipGeneratingVar2(keys, value)) {
          const cssVar = `--${prefix2 ? `${prefix2}-` : ""}${keys.join("-")}`;
          const resolvedValue = getCssValue(keys, value);
          Object.assign(css2, {
            [cssVar]: resolvedValue
          });
          assignNestedKeys(vars, keys, `var(${cssVar})`, arrayKeys);
          assignNestedKeys(varsWithDefaults, keys, `var(${cssVar}, ${resolvedValue})`, arrayKeys);
        }
      }
    },
    (keys) => keys[0] === "vars"
    // skip 'vars/*' paths
  );
  return {
    css: css2,
    vars,
    varsWithDefaults
  };
}
function prepareCssVars(theme2, parserConfig = {}) {
  const {
    getSelector = defaultGetSelector2,
    disableCssColorScheme,
    colorSchemeSelector: selector,
    enableContrastVars
  } = parserConfig;
  const _a2 = theme2, {
    colorSchemes = {},
    components,
    defaultColorScheme = "light"
  } = _a2, otherTheme = __objRest(_a2, [
    "colorSchemes",
    "components",
    "defaultColorScheme"
  ]);
  const {
    vars: rootVars,
    css: rootCss,
    varsWithDefaults: rootVarsWithDefaults
  } = cssVarsParser(otherTheme, parserConfig);
  let themeVars = rootVarsWithDefaults;
  const colorSchemesMap = {};
  const _b = colorSchemes, {
    [defaultColorScheme]: defaultScheme
  } = _b, otherColorSchemes = __objRest(_b, [
    __restKey(defaultColorScheme)
  ]);
  Object.entries(otherColorSchemes || {}).forEach(([key, scheme]) => {
    const {
      vars,
      css: css2,
      varsWithDefaults
    } = cssVarsParser(scheme, parserConfig);
    themeVars = deepmerge(themeVars, varsWithDefaults);
    colorSchemesMap[key] = {
      css: css2,
      vars
    };
  });
  if (defaultScheme) {
    const {
      css: css2,
      vars,
      varsWithDefaults
    } = cssVarsParser(defaultScheme, parserConfig);
    themeVars = deepmerge(themeVars, varsWithDefaults);
    colorSchemesMap[defaultColorScheme] = {
      css: css2,
      vars
    };
  }
  function defaultGetSelector2(colorScheme, cssObject) {
    var _a3, _b2;
    let rule = selector;
    if (selector === "class") {
      rule = ".%s";
    }
    if (selector === "data") {
      rule = "[data-%s]";
    }
    if ((selector == null ? void 0 : selector.startsWith("data-")) && !selector.includes("%s")) {
      rule = `[${selector}="%s"]`;
    }
    if (colorScheme) {
      if (rule === "media") {
        if (theme2.defaultColorScheme === colorScheme) {
          return ":root";
        }
        const mode = ((_b2 = (_a3 = colorSchemes[colorScheme]) == null ? void 0 : _a3.palette) == null ? void 0 : _b2.mode) || colorScheme;
        return {
          [`@media (prefers-color-scheme: ${mode})`]: {
            ":root": cssObject
          }
        };
      }
      if (rule) {
        if (theme2.defaultColorScheme === colorScheme) {
          return `:root, ${rule.replace("%s", String(colorScheme))}`;
        }
        return rule.replace("%s", String(colorScheme));
      }
    }
    return ":root";
  }
  const generateThemeVars = () => {
    let vars = __spreadValues({}, rootVars);
    Object.entries(colorSchemesMap).forEach(([, {
      vars: schemeVars
    }]) => {
      vars = deepmerge(vars, schemeVars);
    });
    return vars;
  };
  const generateStyleSheets = () => {
    var _b2, _c;
    const stylesheets = [];
    const colorScheme = theme2.defaultColorScheme || "light";
    function insertStyleSheet(key, css2) {
      if (Object.keys(css2).length) {
        stylesheets.push(typeof key === "string" ? {
          [key]: __spreadValues({}, css2)
        } : key);
      }
    }
    insertStyleSheet(getSelector(void 0, __spreadValues({}, rootCss)), rootCss);
    const _a3 = colorSchemesMap, {
      [colorScheme]: defaultSchemeVal
    } = _a3, other = __objRest(_a3, [
      __restKey(colorScheme)
    ]);
    if (defaultSchemeVal) {
      const {
        css: css2
      } = defaultSchemeVal;
      const cssColorSheme = (_c = (_b2 = colorSchemes[colorScheme]) == null ? void 0 : _b2.palette) == null ? void 0 : _c.mode;
      const finalCss = !disableCssColorScheme && cssColorSheme ? __spreadValues({
        colorScheme: cssColorSheme
      }, css2) : __spreadValues({}, css2);
      insertStyleSheet(getSelector(colorScheme, __spreadValues({}, finalCss)), finalCss);
    }
    Object.entries(other).forEach(([key, {
      css: css2
    }]) => {
      var _a4, _b3;
      const cssColorSheme = (_b3 = (_a4 = colorSchemes[key]) == null ? void 0 : _a4.palette) == null ? void 0 : _b3.mode;
      const finalCss = !disableCssColorScheme && cssColorSheme ? __spreadValues({
        colorScheme: cssColorSheme
      }, css2) : __spreadValues({}, css2);
      insertStyleSheet(getSelector(key, __spreadValues({}, finalCss)), finalCss);
    });
    if (enableContrastVars) {
      stylesheets.push({
        ":root": {
          // use double underscore to indicate that these are private variables
          "--__l-threshold": "0.7",
          "--__l": "clamp(0, (l / var(--__l-threshold) - 1) * -infinity, 1)",
          "--__a": "clamp(0.87, (l / var(--__l-threshold) - 1) * -infinity, 1)"
          // 0.87 is the default alpha value for black text.
        }
      });
    }
    return stylesheets;
  };
  return {
    vars: themeVars,
    generateThemeVars,
    generateStyleSheets
  };
}
function createGetColorSchemeSelector(selector) {
  return function getColorSchemeSelector(colorScheme) {
    if (selector === "media") {
      return `@media (prefers-color-scheme: ${colorScheme})`;
    }
    if (selector) {
      if (selector.startsWith("data-") && !selector.includes("%s")) {
        return `[${selector}="${colorScheme}"] &`;
      }
      if (selector === "class") {
        return `.${colorScheme} &`;
      }
      if (selector === "data") {
        return `[data-${colorScheme}] &`;
      }
      return `${selector.replace("%s", colorScheme)} &`;
    }
    return "&";
  };
}
function composeClasses(slots, getUtilityClass, classes = void 0) {
  const output = {};
  for (const slotName in slots) {
    const slot = slots[slotName];
    let buffer = "";
    let start2 = true;
    for (let i = 0; i < slot.length; i += 1) {
      const value = slot[i];
      if (value) {
        buffer += (start2 === true ? "" : " ") + getUtilityClass(value);
        start2 = false;
        if (classes && classes[value]) {
          buffer += " " + classes[value];
        }
      }
    }
    output[slotName] = buffer;
  }
  return output;
}
const defaultTheme$4 = createTheme$1();
const defaultCreateStyledComponent$2 = styled$1("div", {
  name: "MuiContainer",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`maxWidth${capitalize(String(ownerState.maxWidth))}`], ownerState.fixed && styles2.fixed, ownerState.disableGutters && styles2.disableGutters];
  }
});
const useThemePropsDefault$2 = (inProps) => useThemeProps({
  props: inProps,
  name: "MuiContainer",
  defaultTheme: defaultTheme$4
});
const useUtilityClasses$1f = (ownerState, componentName) => {
  const getContainerUtilityClass = (slot) => {
    return generateUtilityClass(componentName, slot);
  };
  const {
    classes,
    fixed,
    disableGutters,
    maxWidth: maxWidth2
  } = ownerState;
  const slots = {
    root: ["root", maxWidth2 && `maxWidth${capitalize(String(maxWidth2))}`, fixed && "fixed", disableGutters && "disableGutters"]
  };
  return composeClasses(slots, getContainerUtilityClass, classes);
};
function createContainer(options = {}) {
  const {
    // This will allow adding custom styled fn (for example for custom sx style function)
    createStyledComponent = defaultCreateStyledComponent$2,
    useThemeProps: useThemeProps2 = useThemePropsDefault$2,
    componentName = "MuiContainer"
  } = options;
  const ContainerRoot = createStyledComponent(({
    theme: theme2,
    ownerState
  }) => __spreadValues({
    width: "100%",
    marginLeft: "auto",
    boxSizing: "border-box",
    marginRight: "auto"
  }, !ownerState.disableGutters && {
    paddingLeft: theme2.spacing(2),
    paddingRight: theme2.spacing(2),
    // @ts-ignore module augmentation fails if custom breakpoints are used
    [theme2.breakpoints.up("sm")]: {
      paddingLeft: theme2.spacing(3),
      paddingRight: theme2.spacing(3)
    }
  }), ({
    theme: theme2,
    ownerState
  }) => ownerState.fixed && Object.keys(theme2.breakpoints.values).reduce((acc, breakpointValueKey) => {
    const breakpoint = breakpointValueKey;
    const value = theme2.breakpoints.values[breakpoint];
    if (value !== 0) {
      acc[theme2.breakpoints.up(breakpoint)] = {
        maxWidth: `${value}${theme2.breakpoints.unit}`
      };
    }
    return acc;
  }, {}), ({
    theme: theme2,
    ownerState
  }) => __spreadValues(__spreadValues({}, ownerState.maxWidth === "xs" && {
    // @ts-ignore module augmentation fails if custom breakpoints are used
    [theme2.breakpoints.up("xs")]: {
      // @ts-ignore module augmentation fails if custom breakpoints are used
      maxWidth: Math.max(theme2.breakpoints.values.xs, 444)
    }
  }), ownerState.maxWidth && // @ts-ignore module augmentation fails if custom breakpoints are used
  ownerState.maxWidth !== "xs" && {
    // @ts-ignore module augmentation fails if custom breakpoints are used
    [theme2.breakpoints.up(ownerState.maxWidth)]: {
      // @ts-ignore module augmentation fails if custom breakpoints are used
      maxWidth: `${theme2.breakpoints.values[ownerState.maxWidth]}${theme2.breakpoints.unit}`
    }
  }));
  const Container2 = /* @__PURE__ */ reactExports.forwardRef(function Container22(inProps, ref) {
    const props = useThemeProps2(inProps);
    const _a2 = props, {
      className,
      component = "div",
      disableGutters = false,
      fixed = false,
      maxWidth: maxWidth2 = "lg",
      classes: classesProp
    } = _a2, other = __objRest(_a2, [
      "className",
      "component",
      "disableGutters",
      "fixed",
      "maxWidth",
      "classes"
    ]);
    const ownerState = __spreadProps(__spreadValues({}, props), {
      component,
      disableGutters,
      fixed,
      maxWidth: maxWidth2
    });
    const classes = useUtilityClasses$1f(ownerState, componentName);
    return (
      // @ts-ignore theme is injected by the styled util
      /* @__PURE__ */ jsxRuntimeExports.jsx(ContainerRoot, __spreadValues({
        as: component,
        ownerState,
        className: clsx(classes.root, className),
        ref
      }, other))
    );
  });
  return Container2;
}
function isMuiElement(element, muiNames) {
  var _a2, _b, _c, _d;
  return /* @__PURE__ */ reactExports.isValidElement(element) && muiNames.indexOf(
    // For server components `muiName` is available in element.type._payload.value.muiName
    // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
    // eslint-disable-next-line no-underscore-dangle
    (_d = element.type.muiName) != null ? _d : (_c = (_b = (_a2 = element.type) == null ? void 0 : _a2._payload) == null ? void 0 : _b.value) == null ? void 0 : _c.muiName
  ) !== -1;
}
const filterBreakpointKeys = (breakpointsKeys, responsiveKeys) => breakpointsKeys.filter((key) => responsiveKeys.includes(key));
const traverseBreakpoints = (breakpoints, responsive, iterator) => {
  const smallestBreakpoint = breakpoints.keys[0];
  if (Array.isArray(responsive)) {
    responsive.forEach((breakpointValue, index2) => {
      iterator((responsiveStyles, style2) => {
        if (index2 <= breakpoints.keys.length - 1) {
          if (index2 === 0) {
            Object.assign(responsiveStyles, style2);
          } else {
            responsiveStyles[breakpoints.up(breakpoints.keys[index2])] = style2;
          }
        }
      }, breakpointValue);
    });
  } else if (responsive && typeof responsive === "object") {
    const keys = Object.keys(responsive).length > breakpoints.keys.length ? breakpoints.keys : filterBreakpointKeys(breakpoints.keys, Object.keys(responsive));
    keys.forEach((key) => {
      if (breakpoints.keys.includes(key)) {
        const breakpointValue = responsive[key];
        if (breakpointValue !== void 0) {
          iterator((responsiveStyles, style2) => {
            if (smallestBreakpoint === key) {
              Object.assign(responsiveStyles, style2);
            } else {
              responsiveStyles[breakpoints.up(key)] = style2;
            }
          }, breakpointValue);
        }
      }
    });
  } else if (typeof responsive === "number" || typeof responsive === "string") {
    iterator((responsiveStyles, style2) => {
      Object.assign(responsiveStyles, style2);
    }, responsive);
  }
};
function getSelfSpacingVar(axis) {
  return `--Grid-${axis}Spacing`;
}
function getParentSpacingVar(axis) {
  return `--Grid-parent-${axis}Spacing`;
}
const selfColumnsVar = "--Grid-columns";
const parentColumnsVar = "--Grid-parent-columns";
const generateGridSizeStyles = ({
  theme: theme2,
  ownerState
}) => {
  const styles2 = {};
  traverseBreakpoints(theme2.breakpoints, ownerState.size, (appendStyle, value) => {
    let style2 = {};
    if (value === "grow") {
      style2 = {
        flexBasis: 0,
        flexGrow: 1,
        maxWidth: "100%"
      };
    }
    if (value === "auto") {
      style2 = {
        flexBasis: "auto",
        flexGrow: 0,
        flexShrink: 0,
        maxWidth: "none",
        width: "auto"
      };
    }
    if (typeof value === "number") {
      style2 = {
        flexGrow: 0,
        flexBasis: "auto",
        width: `calc(100% * ${value} / var(${parentColumnsVar}) - (var(${parentColumnsVar}) - ${value}) * (var(${getParentSpacingVar("column")}) / var(${parentColumnsVar})))`
      };
    }
    appendStyle(styles2, style2);
  });
  return styles2;
};
const generateGridOffsetStyles = ({
  theme: theme2,
  ownerState
}) => {
  const styles2 = {};
  traverseBreakpoints(theme2.breakpoints, ownerState.offset, (appendStyle, value) => {
    let style2 = {};
    if (value === "auto") {
      style2 = {
        marginLeft: "auto"
      };
    }
    if (typeof value === "number") {
      style2 = {
        marginLeft: value === 0 ? "0px" : `calc(100% * ${value} / var(${parentColumnsVar}) + var(${getParentSpacingVar("column")}) * ${value} / var(${parentColumnsVar}))`
      };
    }
    appendStyle(styles2, style2);
  });
  return styles2;
};
const generateGridColumnsStyles = ({
  theme: theme2,
  ownerState
}) => {
  if (!ownerState.container) {
    return {};
  }
  const styles2 = {
    [selfColumnsVar]: 12
  };
  traverseBreakpoints(theme2.breakpoints, ownerState.columns, (appendStyle, value) => {
    const columns = value != null ? value : 12;
    appendStyle(styles2, {
      [selfColumnsVar]: columns,
      "> *": {
        [parentColumnsVar]: columns
      }
    });
  });
  return styles2;
};
const generateGridRowSpacingStyles = ({
  theme: theme2,
  ownerState
}) => {
  if (!ownerState.container) {
    return {};
  }
  const styles2 = {};
  traverseBreakpoints(theme2.breakpoints, ownerState.rowSpacing, (appendStyle, value) => {
    var _a2;
    const spacing = typeof value === "string" ? value : (_a2 = theme2.spacing) == null ? void 0 : _a2.call(theme2, value);
    appendStyle(styles2, {
      [getSelfSpacingVar("row")]: spacing,
      "> *": {
        [getParentSpacingVar("row")]: spacing
      }
    });
  });
  return styles2;
};
const generateGridColumnSpacingStyles = ({
  theme: theme2,
  ownerState
}) => {
  if (!ownerState.container) {
    return {};
  }
  const styles2 = {};
  traverseBreakpoints(theme2.breakpoints, ownerState.columnSpacing, (appendStyle, value) => {
    var _a2;
    const spacing = typeof value === "string" ? value : (_a2 = theme2.spacing) == null ? void 0 : _a2.call(theme2, value);
    appendStyle(styles2, {
      [getSelfSpacingVar("column")]: spacing,
      "> *": {
        [getParentSpacingVar("column")]: spacing
      }
    });
  });
  return styles2;
};
const generateGridDirectionStyles = ({
  theme: theme2,
  ownerState
}) => {
  if (!ownerState.container) {
    return {};
  }
  const styles2 = {};
  traverseBreakpoints(theme2.breakpoints, ownerState.direction, (appendStyle, value) => {
    appendStyle(styles2, {
      flexDirection: value
    });
  });
  return styles2;
};
const generateGridStyles = ({
  ownerState
}) => {
  return __spreadValues({
    minWidth: 0,
    boxSizing: "border-box"
  }, ownerState.container && __spreadProps(__spreadValues({
    display: "flex",
    flexWrap: "wrap"
  }, ownerState.wrap && ownerState.wrap !== "wrap" && {
    flexWrap: ownerState.wrap
  }), {
    gap: `var(${getSelfSpacingVar("row")}) var(${getSelfSpacingVar("column")})`
  }));
};
const generateSizeClassNames = (size) => {
  const classNames = [];
  Object.entries(size).forEach(([key, value]) => {
    if (value !== false && value !== void 0) {
      classNames.push(`grid-${key}-${String(value)}`);
    }
  });
  return classNames;
};
const generateSpacingClassNames = (spacing, smallestBreakpoint = "xs") => {
  function isValidSpacing(val) {
    if (val === void 0) {
      return false;
    }
    return typeof val === "string" && !Number.isNaN(Number(val)) || typeof val === "number" && val > 0;
  }
  if (isValidSpacing(spacing)) {
    return [`spacing-${smallestBreakpoint}-${String(spacing)}`];
  }
  if (typeof spacing === "object" && !Array.isArray(spacing)) {
    const classNames = [];
    Object.entries(spacing).forEach(([key, value]) => {
      if (isValidSpacing(value)) {
        classNames.push(`spacing-${key}-${String(value)}`);
      }
    });
    return classNames;
  }
  return [];
};
const generateDirectionClasses = (direction) => {
  if (direction === void 0) {
    return [];
  }
  if (typeof direction === "object") {
    return Object.entries(direction).map(([key, value]) => `direction-${key}-${value}`);
  }
  return [`direction-xs-${String(direction)}`];
};
function deleteLegacyGridProps(props, breakpoints) {
  if (props.item !== void 0) {
    delete props.item;
  }
  if (props.zeroMinWidth !== void 0) {
    delete props.zeroMinWidth;
  }
  breakpoints.keys.forEach((breakpoint) => {
    if (props[breakpoint] !== void 0) {
      delete props[breakpoint];
    }
  });
}
const defaultTheme$3 = createTheme$1();
const defaultCreateStyledComponent$1 = styled$1("div", {
  name: "MuiGrid",
  slot: "Root"
});
function useThemePropsDefault$1(props) {
  return useThemeProps({
    props,
    name: "MuiGrid",
    defaultTheme: defaultTheme$3
  });
}
function createGrid(options = {}) {
  const {
    // This will allow adding custom styled fn (for example for custom sx style function)
    createStyledComponent = defaultCreateStyledComponent$1,
    useThemeProps: useThemeProps2 = useThemePropsDefault$1,
    useTheme: useTheme2 = useTheme$2,
    componentName = "MuiGrid"
  } = options;
  const useUtilityClasses2 = (ownerState, theme2) => {
    const {
      container,
      direction,
      spacing,
      wrap,
      size
    } = ownerState;
    const slots = {
      root: ["root", container && "container", wrap !== "wrap" && `wrap-xs-${String(wrap)}`, ...generateDirectionClasses(direction), ...generateSizeClassNames(size), ...container ? generateSpacingClassNames(spacing, theme2.breakpoints.keys[0]) : []]
    };
    return composeClasses(slots, (slot) => generateUtilityClass(componentName, slot), {});
  };
  function parseResponsiveProp(propValue, breakpoints, shouldUseValue = () => true) {
    const parsedProp = {};
    if (propValue === null) {
      return parsedProp;
    }
    if (Array.isArray(propValue)) {
      propValue.forEach((value, index2) => {
        if (value !== null && shouldUseValue(value) && breakpoints.keys[index2]) {
          parsedProp[breakpoints.keys[index2]] = value;
        }
      });
    } else if (typeof propValue === "object") {
      Object.keys(propValue).forEach((key) => {
        const value = propValue[key];
        if (value !== null && value !== void 0 && shouldUseValue(value)) {
          parsedProp[key] = value;
        }
      });
    } else {
      parsedProp[breakpoints.keys[0]] = propValue;
    }
    return parsedProp;
  }
  const GridRoot = createStyledComponent(generateGridColumnsStyles, generateGridColumnSpacingStyles, generateGridRowSpacingStyles, generateGridSizeStyles, generateGridDirectionStyles, generateGridStyles, generateGridOffsetStyles);
  const Grid2 = /* @__PURE__ */ reactExports.forwardRef(function Grid22(inProps, ref) {
    var _b, _c, _d, _e, _f, _g;
    const theme2 = useTheme2();
    const themeProps = useThemeProps2(inProps);
    const props = extendSxProp$1(themeProps);
    deleteLegacyGridProps(props, theme2.breakpoints);
    const _a2 = props, {
      className,
      children,
      columns: columnsProp = 12,
      container = false,
      component = "div",
      direction = "row",
      wrap = "wrap",
      size: sizeProp = {},
      offset: offsetProp = {},
      spacing: spacingProp = 0,
      rowSpacing: rowSpacingProp = spacingProp,
      columnSpacing: columnSpacingProp = spacingProp,
      unstable_level: level = 0
    } = _a2, other = __objRest(_a2, [
      "className",
      "children",
      "columns",
      "container",
      "component",
      "direction",
      "wrap",
      "size",
      "offset",
      "spacing",
      "rowSpacing",
      "columnSpacing",
      "unstable_level"
    ]);
    const size = parseResponsiveProp(sizeProp, theme2.breakpoints, (val) => val !== false);
    const offset2 = parseResponsiveProp(offsetProp, theme2.breakpoints);
    const columns = (_b = inProps.columns) != null ? _b : level ? void 0 : columnsProp;
    const spacing = (_c = inProps.spacing) != null ? _c : level ? void 0 : spacingProp;
    const rowSpacing = (_e = (_d = inProps.rowSpacing) != null ? _d : inProps.spacing) != null ? _e : level ? void 0 : rowSpacingProp;
    const columnSpacing = (_g = (_f = inProps.columnSpacing) != null ? _f : inProps.spacing) != null ? _g : level ? void 0 : columnSpacingProp;
    const ownerState = __spreadProps(__spreadValues({}, props), {
      level,
      columns,
      container,
      direction,
      wrap,
      spacing,
      rowSpacing,
      columnSpacing,
      size,
      offset: offset2
    });
    const classes = useUtilityClasses2(ownerState, theme2);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridRoot, __spreadProps(__spreadValues({
      ref,
      as: component,
      ownerState,
      className: clsx(classes.root, className)
    }, other), {
      children: reactExports.Children.map(children, (child) => {
        var _a3, _b2;
        if (/* @__PURE__ */ reactExports.isValidElement(child) && isMuiElement(child, ["Grid"]) && container && child.props.container) {
          return /* @__PURE__ */ reactExports.cloneElement(child, {
            unstable_level: (_b2 = (_a3 = child.props) == null ? void 0 : _a3.unstable_level) != null ? _b2 : level + 1
          });
        }
        return child;
      })
    }));
  });
  Grid2.muiName = "Grid";
  return Grid2;
}
const defaultTheme$2 = createTheme$1();
const defaultCreateStyledComponent = styled$1("div", {
  name: "MuiStack",
  slot: "Root"
});
function useThemePropsDefault(props) {
  return useThemeProps({
    props,
    name: "MuiStack",
    defaultTheme: defaultTheme$2
  });
}
function joinChildren(children, separator) {
  const childrenArray = reactExports.Children.toArray(children).filter(Boolean);
  return childrenArray.reduce((output, child, index2) => {
    output.push(child);
    if (index2 < childrenArray.length - 1) {
      output.push(/* @__PURE__ */ reactExports.cloneElement(separator, {
        key: `separator-${index2}`
      }));
    }
    return output;
  }, []);
}
const getSideFromDirection = (direction) => {
  return {
    row: "Left",
    "row-reverse": "Right",
    column: "Top",
    "column-reverse": "Bottom"
  }[direction];
};
const style = ({
  ownerState,
  theme: theme2
}) => {
  let styles2 = __spreadValues({
    display: "flex",
    flexDirection: "column"
  }, handleBreakpoints({
    theme: theme2
  }, resolveBreakpointValues({
    values: ownerState.direction,
    breakpoints: theme2.breakpoints.values
  }), (propValue) => ({
    flexDirection: propValue
  })));
  if (ownerState.spacing) {
    const transformer = createUnarySpacing(theme2);
    const base = Object.keys(theme2.breakpoints.values).reduce((acc, breakpoint) => {
      if (typeof ownerState.spacing === "object" && ownerState.spacing[breakpoint] != null || typeof ownerState.direction === "object" && ownerState.direction[breakpoint] != null) {
        acc[breakpoint] = true;
      }
      return acc;
    }, {});
    const directionValues = resolveBreakpointValues({
      values: ownerState.direction,
      base
    });
    const spacingValues = resolveBreakpointValues({
      values: ownerState.spacing,
      base
    });
    if (typeof directionValues === "object") {
      Object.keys(directionValues).forEach((breakpoint, index2, breakpoints) => {
        const directionValue = directionValues[breakpoint];
        if (!directionValue) {
          const previousDirectionValue = index2 > 0 ? directionValues[breakpoints[index2 - 1]] : "column";
          directionValues[breakpoint] = previousDirectionValue;
        }
      });
    }
    const styleFromPropValue = (propValue, breakpoint) => {
      if (ownerState.useFlexGap) {
        return {
          gap: getValue(transformer, propValue)
        };
      }
      return {
        // The useFlexGap={false} implement relies on each child to give up control of the margin.
        // We need to reset the margin to avoid double spacing.
        "& > :not(style):not(style)": {
          margin: 0
        },
        "& > :not(style) ~ :not(style)": {
          [`margin${getSideFromDirection(breakpoint ? directionValues[breakpoint] : ownerState.direction)}`]: getValue(transformer, propValue)
        }
      };
    };
    styles2 = deepmerge(styles2, handleBreakpoints({
      theme: theme2
    }, spacingValues, styleFromPropValue));
  }
  styles2 = mergeBreakpointsInOrder(theme2.breakpoints, styles2);
  return styles2;
};
function createStack(options = {}) {
  const {
    // This will allow adding custom styled fn (for example for custom sx style function)
    createStyledComponent = defaultCreateStyledComponent,
    useThemeProps: useThemeProps2 = useThemePropsDefault,
    componentName = "MuiStack"
  } = options;
  const useUtilityClasses2 = () => {
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, (slot) => generateUtilityClass(componentName, slot), {});
  };
  const StackRoot = createStyledComponent(style);
  const Stack2 = /* @__PURE__ */ reactExports.forwardRef(function Grid2(inProps, ref) {
    const themeProps = useThemeProps2(inProps);
    const props = extendSxProp$1(themeProps);
    const _a2 = props, {
      component = "div",
      direction = "column",
      spacing = 0,
      divider,
      children,
      className,
      useFlexGap = false
    } = _a2, other = __objRest(_a2, [
      "component",
      "direction",
      "spacing",
      "divider",
      "children",
      "className",
      "useFlexGap"
    ]);
    const ownerState = {
      direction,
      spacing,
      useFlexGap
    };
    const classes = useUtilityClasses2();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(StackRoot, __spreadProps(__spreadValues({
      as: component,
      ownerState,
      ref,
      className: clsx(classes.root, className)
    }, other), {
      children: divider ? joinChildren(children, divider) : children
    }));
  });
  return Stack2;
}
function getLight() {
  return {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: common.white,
      default: common.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
}
const light = getLight();
function getDark() {
  return {
    text: {
      primary: common.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: common.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
}
const dark = getDark();
function addLightOrDark(intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === "light") {
      intent.light = lighten(intent.main, tonalOffsetLight);
    } else if (direction === "dark") {
      intent.dark = darken(intent.main, tonalOffsetDark);
    }
  }
}
function mixLightOrDark(colorSpace, intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === "light") {
      intent.light = `color-mix(in ${colorSpace}, ${intent.main}, #fff ${(tonalOffsetLight * 100).toFixed(0)}%)`;
    } else if (direction === "dark") {
      intent.dark = `color-mix(in ${colorSpace}, ${intent.main}, #000 ${(tonalOffsetDark * 100).toFixed(0)}%)`;
    }
  }
}
function getDefaultPrimary(mode = "light") {
  if (mode === "dark") {
    return {
      main: blue[200],
      light: blue[50],
      dark: blue[400]
    };
  }
  return {
    main: blue[700],
    light: blue[400],
    dark: blue[800]
  };
}
function getDefaultSecondary(mode = "light") {
  if (mode === "dark") {
    return {
      main: purple[200],
      light: purple[50],
      dark: purple[400]
    };
  }
  return {
    main: purple[500],
    light: purple[300],
    dark: purple[700]
  };
}
function getDefaultError(mode = "light") {
  if (mode === "dark") {
    return {
      main: red[500],
      light: red[300],
      dark: red[700]
    };
  }
  return {
    main: red[700],
    light: red[400],
    dark: red[800]
  };
}
function getDefaultInfo(mode = "light") {
  if (mode === "dark") {
    return {
      main: lightBlue[400],
      light: lightBlue[300],
      dark: lightBlue[700]
    };
  }
  return {
    main: lightBlue[700],
    light: lightBlue[500],
    dark: lightBlue[900]
  };
}
function getDefaultSuccess(mode = "light") {
  if (mode === "dark") {
    return {
      main: green[400],
      light: green[300],
      dark: green[700]
    };
  }
  return {
    main: green[800],
    light: green[500],
    dark: green[900]
  };
}
function getDefaultWarning(mode = "light") {
  if (mode === "dark") {
    return {
      main: orange[400],
      light: orange[300],
      dark: orange[700]
    };
  }
  return {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: orange[500],
    dark: orange[900]
  };
}
function contrastColor(background) {
  return `oklch(from ${background} var(--__l) 0 h / var(--__a))`;
}
function createPalette(palette) {
  const _a2 = palette, {
    mode = "light",
    contrastThreshold = 3,
    tonalOffset = 0.2,
    colorSpace
  } = _a2, other = __objRest(_a2, [
    "mode",
    "contrastThreshold",
    "tonalOffset",
    "colorSpace"
  ]);
  const primary = palette.primary || getDefaultPrimary(mode);
  const secondary = palette.secondary || getDefaultSecondary(mode);
  const error2 = palette.error || getDefaultError(mode);
  const info = palette.info || getDefaultInfo(mode);
  const success = palette.success || getDefaultSuccess(mode);
  const warning2 = palette.warning || getDefaultWarning(mode);
  function getContrastText(background) {
    if (colorSpace) {
      return contrastColor(background);
    }
    const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    return contrastText;
  }
  const augmentColor = ({
    color: color2,
    name: name2,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    color2 = __spreadValues({}, color2);
    if (!color2.main && color2[mainShade]) {
      color2.main = color2[mainShade];
    }
    if (!color2.hasOwnProperty("main")) {
      throw new Error(formatMuiErrorMessage(11, name2 ? ` (${name2})` : "", mainShade));
    }
    if (typeof color2.main !== "string") {
      throw new Error(formatMuiErrorMessage(12, name2 ? ` (${name2})` : "", JSON.stringify(color2.main)));
    }
    if (colorSpace) {
      mixLightOrDark(colorSpace, color2, "light", lightShade, tonalOffset);
      mixLightOrDark(colorSpace, color2, "dark", darkShade, tonalOffset);
    } else {
      addLightOrDark(color2, "light", lightShade, tonalOffset);
      addLightOrDark(color2, "dark", darkShade, tonalOffset);
    }
    if (!color2.contrastText) {
      color2.contrastText = getContrastText(color2.main);
    }
    return color2;
  };
  let modeHydrated;
  if (mode === "light") {
    modeHydrated = getLight();
  } else if (mode === "dark") {
    modeHydrated = getDark();
  }
  const paletteOutput = deepmerge(__spreadValues({
    // A collection of common colors.
    common: __spreadValues({}, common),
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode,
    // The colors used to represent primary interface elements for a user.
    primary: augmentColor({
      color: primary,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: augmentColor({
      color: secondary,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: augmentColor({
      color: error2,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: augmentColor({
      color: warning2,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: augmentColor({
      color: info,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: augmentColor({
      color: success,
      name: "success"
    }),
    // The grey colors.
    grey,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText,
    // Generate a rich color object.
    augmentColor,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset
  }, modeHydrated), other);
  return paletteOutput;
}
function prepareTypographyVars(typography) {
  const vars = {};
  const entries = Object.entries(typography);
  entries.forEach((entry) => {
    const [key, value] = entry;
    if (typeof value === "object") {
      vars[key] = `${value.fontStyle ? `${value.fontStyle} ` : ""}${value.fontVariant ? `${value.fontVariant} ` : ""}${value.fontWeight ? `${value.fontWeight} ` : ""}${value.fontStretch ? `${value.fontStretch} ` : ""}${value.fontSize || ""}${value.lineHeight ? `/${value.lineHeight} ` : ""}${value.fontFamily || ""}`;
    }
  });
  return vars;
}
function createMixins(breakpoints, mixins) {
  return __spreadValues({
    toolbar: {
      minHeight: 56,
      [breakpoints.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [breakpoints.up("sm")]: {
        minHeight: 64
      }
    }
  }, mixins);
}
function round$2(value) {
  return Math.round(value * 1e5) / 1e5;
}
const caseAllCaps = {
  textTransform: "uppercase"
};
const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(palette, typography) {
  const _a2 = typeof typography === "function" ? typography(palette) : typography, {
    fontFamily = defaultFontFamily,
    fontSize: fontSize = 14,
    fontWeightLight: fontWeightLight = 300,
    fontWeightRegular = 400,
    fontWeightMedium = 500,
    fontWeightBold = 700,
    htmlFontSize: htmlFontSize = 16,
    allVariants: allVariants,
    pxToRem: pxToRem2
  } = _a2, other = __objRest(_a2, [
    "fontFamily",
    // The default font size of the Material Specification.
    "fontSize",
    // px
    "fontWeightLight",
    "fontWeightRegular",
    "fontWeightMedium",
    "fontWeightBold",
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    "htmlFontSize",
    // Apply the CSS properties to all the variants.
    "allVariants",
    "pxToRem"
  ]);
  const coef = fontSize / 14;
  const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
  const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) => __spreadValues(__spreadValues(__spreadValues({
    fontFamily,
    fontWeight,
    fontSize: pxToRem(size),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight
  }, fontFamily === defaultFontFamily ? {
    letterSpacing: `${round$2(letterSpacing / size)}em`
  } : {}), casing), allVariants);
  const variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return deepmerge(__spreadValues({
    htmlFontSize,
    pxToRem,
    fontFamily,
    fontSize,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold
  }, variants), other, {
    clone: false
    // No need to clone deep
  });
}
const shadowKeyUmbraOpacity = 0.2;
const shadowKeyPenumbraOpacity = 0.14;
const shadowAmbientShadowOpacity = 0.12;
function createShadow(...px) {
  return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
}
const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
const easing = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
const duration = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function formatMs(milliseconds) {
  return `${Math.round(milliseconds)}ms`;
}
function getAutoHeightDuration(height2) {
  if (!height2) {
    return 0;
  }
  const constant = height2 / 36;
  return Math.min(Math.round((4 + 15 * __pow(constant, 0.25) + constant / 5) * 10), 3e3);
}
function createTransitions(inputTransitions) {
  const mergedEasing = __spreadValues(__spreadValues({}, easing), inputTransitions.easing);
  const mergedDuration = __spreadValues(__spreadValues({}, duration), inputTransitions.duration);
  const create = (props = ["all"], options = {}) => {
    const _a2 = options, {
      duration: durationOption = mergedDuration.standard,
      easing: easingOption = mergedEasing.easeInOut,
      delay = 0
    } = _a2, other = __objRest(_a2, [
      "duration",
      "easing",
      "delay"
    ]);
    return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
  };
  return __spreadProps(__spreadValues({
    getAutoHeightDuration,
    create
  }, inputTransitions), {
    easing: mergedEasing,
    duration: mergedDuration
  });
}
const zIndex = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
function isSerializable(val) {
  return isPlainObject$2(val) || typeof val === "undefined" || typeof val === "string" || typeof val === "boolean" || typeof val === "number" || Array.isArray(val);
}
function stringifyTheme(baseTheme = {}) {
  const serializableTheme = __spreadValues({}, baseTheme);
  function serializeTheme(object) {
    const array = Object.entries(object);
    for (let index2 = 0; index2 < array.length; index2++) {
      const [key, value] = array[index2];
      if (!isSerializable(value) || key.startsWith("unstable_")) {
        delete object[key];
      } else if (isPlainObject$2(value)) {
        object[key] = __spreadValues({}, value);
        serializeTheme(object[key]);
      }
    }
  }
  serializeTheme(serializableTheme);
  return `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(serializableTheme, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
}
function coefficientToPercentage(coefficient) {
  if (typeof coefficient === "number") {
    return `${(coefficient * 100).toFixed(0)}%`;
  }
  return `calc((${coefficient}) * 100%)`;
}
const parseAddition = (str) => {
  if (!Number.isNaN(+str)) {
    return +str;
  }
  const numbers = str.match(/\d*\.?\d+/g);
  if (!numbers) {
    return 0;
  }
  let sum = 0;
  for (let i = 0; i < numbers.length; i += 1) {
    sum += +numbers[i];
  }
  return sum;
};
function attachColorManipulators(theme2) {
  Object.assign(theme2, {
    alpha(color2, coefficient) {
      const obj = this || theme2;
      if (obj.colorSpace) {
        return `oklch(from ${color2} l c h / ${typeof coefficient === "string" ? `calc(${coefficient})` : coefficient})`;
      }
      if (obj.vars) {
        return `rgba(${color2.replace(/var\(--([^,\s)]+)(?:,[^)]+)?\)+/g, "var(--$1Channel)")} / ${typeof coefficient === "string" ? `calc(${coefficient})` : coefficient})`;
      }
      return alpha(color2, parseAddition(coefficient));
    },
    lighten(color2, coefficient) {
      const obj = this || theme2;
      if (obj.colorSpace) {
        return `color-mix(in ${obj.colorSpace}, ${color2}, #fff ${coefficientToPercentage(coefficient)})`;
      }
      return lighten(color2, coefficient);
    },
    darken(color2, coefficient) {
      const obj = this || theme2;
      if (obj.colorSpace) {
        return `color-mix(in ${obj.colorSpace}, ${color2}, #000 ${coefficientToPercentage(coefficient)})`;
      }
      return darken(color2, coefficient);
    }
  });
}
function createThemeNoVars(options = {}, ...args) {
  const _a2 = options, {
    breakpoints: breakpointsInput,
    mixins: mixinsInput = {},
    spacing: spacingInput,
    palette: paletteInput = {},
    transitions: transitionsInput = {},
    typography: typographyInput = {},
    shape: shapeInput,
    colorSpace
  } = _a2, other = __objRest(_a2, [
    "breakpoints",
    "mixins",
    "spacing",
    "palette",
    "transitions",
    "typography",
    "shape",
    "colorSpace"
  ]);
  if (options.vars && // The error should throw only for the root theme creation because user is not allowed to use a custom node `vars`.
  // `generateThemeVars` is the closest identifier for checking that the `options` is a result of `createTheme` with CSS variables so that user can create new theme for nested ThemeProvider.
  options.generateThemeVars === void 0) {
    throw new Error(formatMuiErrorMessage(20));
  }
  const palette = createPalette(__spreadProps(__spreadValues({}, paletteInput), {
    colorSpace
  }));
  const systemTheme = createTheme$1(options);
  let muiTheme = deepmerge(systemTheme, {
    mixins: createMixins(systemTheme.breakpoints, mixinsInput),
    palette,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: shadows.slice(),
    typography: createTypography(palette, typographyInput),
    transitions: createTransitions(transitionsInput),
    zIndex: __spreadValues({}, zIndex)
  });
  muiTheme = deepmerge(muiTheme, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = __spreadValues(__spreadValues({}, defaultSxConfig), other == null ? void 0 : other.unstable_sxConfig);
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  muiTheme.toRuntimeSource = stringifyTheme;
  attachColorManipulators(muiTheme);
  return muiTheme;
}
function getOverlayAlpha(elevation) {
  let alphaValue;
  if (elevation < 1) {
    alphaValue = 5.11916 * __pow(elevation, 2);
  } else {
    alphaValue = 4.5 * Math.log(elevation + 1) + 2;
  }
  return Math.round(alphaValue * 10) / 1e3;
}
const defaultDarkOverlays = [...Array(25)].map((_, index2) => {
  if (index2 === 0) {
    return "none";
  }
  const overlay = getOverlayAlpha(index2);
  return `linear-gradient(rgba(255 255 255 / ${overlay}), rgba(255 255 255 / ${overlay}))`;
});
function getOpacity(mode) {
  return {
    inputPlaceholder: mode === "dark" ? 0.5 : 0.42,
    inputUnderline: mode === "dark" ? 0.7 : 0.42,
    switchTrackDisabled: mode === "dark" ? 0.2 : 0.12,
    switchTrack: mode === "dark" ? 0.3 : 0.38
  };
}
function getOverlays(mode) {
  return mode === "dark" ? defaultDarkOverlays : [];
}
function createColorScheme(options) {
  const _a2 = options, {
    palette: paletteInput = {
      mode: "light"
    },
    opacity: opacity,
    overlays,
    colorSpace
  } = _a2, other = __objRest(_a2, [
    "palette",
    // need to cast to avoid module augmentation test
    "opacity",
    "overlays",
    "colorSpace"
  ]);
  const palette = createPalette(__spreadProps(__spreadValues({}, paletteInput), {
    colorSpace
  }));
  return __spreadValues({
    palette,
    opacity: __spreadValues(__spreadValues({}, getOpacity(palette.mode)), opacity),
    overlays: overlays || getOverlays(palette.mode)
  }, other);
}
function shouldSkipGeneratingVar(keys) {
  var _a2;
  return !!keys[0].match(/(cssVarPrefix|colorSchemeSelector|modularCssLayers|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!keys[0].match(/sxConfig$/) || // ends with sxConfig
  keys[0] === "palette" && !!((_a2 = keys[1]) == null ? void 0 : _a2.match(/(mode|contrastThreshold|tonalOffset)/));
}
const excludeVariablesFromRoot = (cssVarPrefix) => [...[...Array(25)].map((_, index2) => `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}overlays-${index2}`), `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkBg`, `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkColor`];
const defaultGetSelector = (theme2) => (colorScheme, css2) => {
  const root = theme2.rootSelector || ":root";
  const selector = theme2.colorSchemeSelector;
  let rule = selector;
  if (selector === "class") {
    rule = ".%s";
  }
  if (selector === "data") {
    rule = "[data-%s]";
  }
  if ((selector == null ? void 0 : selector.startsWith("data-")) && !selector.includes("%s")) {
    rule = `[${selector}="%s"]`;
  }
  if (theme2.defaultColorScheme === colorScheme) {
    if (colorScheme === "dark") {
      const excludedVariables = {};
      excludeVariablesFromRoot(theme2.cssVarPrefix).forEach((cssVar) => {
        excludedVariables[cssVar] = css2[cssVar];
        delete css2[cssVar];
      });
      if (rule === "media") {
        return {
          [root]: css2,
          [`@media (prefers-color-scheme: dark)`]: {
            [root]: excludedVariables
          }
        };
      }
      if (rule) {
        return {
          [rule.replace("%s", colorScheme)]: excludedVariables,
          [`${root}, ${rule.replace("%s", colorScheme)}`]: css2
        };
      }
      return {
        [root]: __spreadValues(__spreadValues({}, css2), excludedVariables)
      };
    }
    if (rule && rule !== "media") {
      return `${root}, ${rule.replace("%s", String(colorScheme))}`;
    }
  } else if (colorScheme) {
    if (rule === "media") {
      return {
        [`@media (prefers-color-scheme: ${String(colorScheme)})`]: {
          [root]: css2
        }
      };
    }
    if (rule) {
      return rule.replace("%s", String(colorScheme));
    }
  }
  return root;
};
function assignNode(obj, keys) {
  keys.forEach((k) => {
    if (!obj[k]) {
      obj[k] = {};
    }
  });
}
function setColor(obj, key, defaultValue) {
  if (!obj[key] && defaultValue) {
    obj[key] = defaultValue;
  }
}
function toRgb(color2) {
  if (typeof color2 !== "string" || !color2.startsWith("hsl")) {
    return color2;
  }
  return hslToRgb(color2);
}
function setColorChannel(obj, key) {
  if (!(`${key}Channel` in obj)) {
    obj[`${key}Channel`] = private_safeColorChannel(toRgb(obj[key]));
  }
}
function getSpacingVal(spacingInput) {
  if (typeof spacingInput === "number") {
    return `${spacingInput}px`;
  }
  if (typeof spacingInput === "string" || typeof spacingInput === "function" || Array.isArray(spacingInput)) {
    return spacingInput;
  }
  return "8px";
}
const silent = (fn2) => {
  try {
    return fn2();
  } catch (error2) {
  }
  return void 0;
};
const createGetCssVar = (cssVarPrefix = "mui") => createGetCssVar$1(cssVarPrefix);
function attachColorScheme$1(colorSpace, colorSchemes, scheme, restTheme, colorScheme) {
  if (!scheme) {
    return void 0;
  }
  scheme = scheme === true ? {} : scheme;
  const mode = colorScheme === "dark" ? "dark" : "light";
  if (!restTheme) {
    colorSchemes[colorScheme] = createColorScheme(__spreadProps(__spreadValues({}, scheme), {
      palette: __spreadValues({
        mode
      }, scheme == null ? void 0 : scheme.palette),
      colorSpace
    }));
    return void 0;
  }
  const _a2 = createThemeNoVars(__spreadProps(__spreadValues({}, restTheme), {
    palette: __spreadValues({
      mode
    }, scheme == null ? void 0 : scheme.palette),
    colorSpace
  })), {
    palette
  } = _a2, muiTheme = __objRest(_a2, [
    "palette"
  ]);
  colorSchemes[colorScheme] = __spreadProps(__spreadValues({}, scheme), {
    palette,
    opacity: __spreadValues(__spreadValues({}, getOpacity(mode)), scheme == null ? void 0 : scheme.opacity),
    overlays: (scheme == null ? void 0 : scheme.overlays) || getOverlays(mode)
  });
  return muiTheme;
}
function createThemeWithVars(options = {}, ...args) {
  const _a2 = options, {
    colorSchemes: colorSchemesInput = {
      light: true
    },
    defaultColorScheme: defaultColorSchemeInput,
    disableCssColorScheme = false,
    cssVarPrefix = "mui",
    nativeColor = false,
    shouldSkipGeneratingVar: shouldSkipGeneratingVar$1 = shouldSkipGeneratingVar,
    colorSchemeSelector: selector = colorSchemesInput.light && colorSchemesInput.dark ? "media" : void 0,
    rootSelector = ":root"
  } = _a2, input = __objRest(_a2, [
    "colorSchemes",
    "defaultColorScheme",
    "disableCssColorScheme",
    "cssVarPrefix",
    "nativeColor",
    "shouldSkipGeneratingVar",
    "colorSchemeSelector",
    "rootSelector"
  ]);
  const firstColorScheme = Object.keys(colorSchemesInput)[0];
  const defaultColorScheme = defaultColorSchemeInput || (colorSchemesInput.light && firstColorScheme !== "light" ? "light" : firstColorScheme);
  const getCssVar = createGetCssVar(cssVarPrefix);
  const _b = colorSchemesInput, {
    [defaultColorScheme]: defaultSchemeInput,
    light: builtInLight,
    dark: builtInDark
  } = _b, customColorSchemes = __objRest(_b, [
    __restKey(defaultColorScheme),
    "light",
    "dark"
  ]);
  const colorSchemes = __spreadValues({}, customColorSchemes);
  let defaultScheme = defaultSchemeInput;
  if (defaultColorScheme === "dark" && !("dark" in colorSchemesInput) || defaultColorScheme === "light" && !("light" in colorSchemesInput)) {
    defaultScheme = true;
  }
  if (!defaultScheme) {
    throw new Error(formatMuiErrorMessage(21, defaultColorScheme));
  }
  let colorSpace;
  if (nativeColor) {
    colorSpace = "oklch";
  }
  const muiTheme = attachColorScheme$1(colorSpace, colorSchemes, defaultScheme, input, defaultColorScheme);
  if (builtInLight && !colorSchemes.light) {
    attachColorScheme$1(colorSpace, colorSchemes, builtInLight, void 0, "light");
  }
  if (builtInDark && !colorSchemes.dark) {
    attachColorScheme$1(colorSpace, colorSchemes, builtInDark, void 0, "dark");
  }
  let theme2 = __spreadProps(__spreadValues({
    defaultColorScheme
  }, muiTheme), {
    cssVarPrefix,
    colorSchemeSelector: selector,
    rootSelector,
    getCssVar,
    colorSchemes,
    font: __spreadValues(__spreadValues({}, prepareTypographyVars(muiTheme.typography)), muiTheme.font),
    spacing: getSpacingVal(input.spacing)
  });
  Object.keys(theme2.colorSchemes).forEach((key) => {
    const palette = theme2.colorSchemes[key].palette;
    const setCssVarColor = (cssVar) => {
      const tokens = cssVar.split("-");
      const color2 = tokens[1];
      const colorToken = tokens[2];
      return getCssVar(cssVar, palette[color2][colorToken]);
    };
    if (palette.mode === "light") {
      setColor(palette.common, "background", "#fff");
      setColor(palette.common, "onBackground", "#000");
    }
    if (palette.mode === "dark") {
      setColor(palette.common, "background", "#000");
      setColor(palette.common, "onBackground", "#fff");
    }
    function colorMix(method, color2, coefficient) {
      if (colorSpace) {
        let mixer;
        if (method === private_safeAlpha) {
          mixer = `transparent ${((1 - coefficient) * 100).toFixed(0)}%`;
        }
        if (method === private_safeDarken) {
          mixer = `#000 ${(coefficient * 100).toFixed(0)}%`;
        }
        if (method === private_safeLighten) {
          mixer = `#fff ${(coefficient * 100).toFixed(0)}%`;
        }
        return `color-mix(in ${colorSpace}, ${color2}, ${mixer})`;
      }
      return method(color2, coefficient);
    }
    assignNode(palette, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]);
    if (palette.mode === "light") {
      setColor(palette.Alert, "errorColor", colorMix(private_safeDarken, palette.error.light, 0.6));
      setColor(palette.Alert, "infoColor", colorMix(private_safeDarken, palette.info.light, 0.6));
      setColor(palette.Alert, "successColor", colorMix(private_safeDarken, palette.success.light, 0.6));
      setColor(palette.Alert, "warningColor", colorMix(private_safeDarken, palette.warning.light, 0.6));
      setColor(palette.Alert, "errorFilledBg", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoFilledBg", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successFilledBg", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningFilledBg", setCssVarColor("palette-warning-main"));
      setColor(palette.Alert, "errorFilledColor", silent(() => palette.getContrastText(palette.error.main)));
      setColor(palette.Alert, "infoFilledColor", silent(() => palette.getContrastText(palette.info.main)));
      setColor(palette.Alert, "successFilledColor", silent(() => palette.getContrastText(palette.success.main)));
      setColor(palette.Alert, "warningFilledColor", silent(() => palette.getContrastText(palette.warning.main)));
      setColor(palette.Alert, "errorStandardBg", colorMix(private_safeLighten, palette.error.light, 0.9));
      setColor(palette.Alert, "infoStandardBg", colorMix(private_safeLighten, palette.info.light, 0.9));
      setColor(palette.Alert, "successStandardBg", colorMix(private_safeLighten, palette.success.light, 0.9));
      setColor(palette.Alert, "warningStandardBg", colorMix(private_safeLighten, palette.warning.light, 0.9));
      setColor(palette.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successIconColor", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
      setColor(palette.AppBar, "defaultBg", setCssVarColor("palette-grey-100"));
      setColor(palette.Avatar, "defaultBg", setCssVarColor("palette-grey-400"));
      setColor(palette.Button, "inheritContainedBg", setCssVarColor("palette-grey-300"));
      setColor(palette.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-A100"));
      setColor(palette.Chip, "defaultBorder", setCssVarColor("palette-grey-400"));
      setColor(palette.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultIconColor", setCssVarColor("palette-grey-700"));
      setColor(palette.FilledInput, "bg", "rgba(0, 0, 0, 0.06)");
      setColor(palette.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)");
      setColor(palette.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)");
      setColor(palette.LinearProgress, "primaryBg", colorMix(private_safeLighten, palette.primary.main, 0.62));
      setColor(palette.LinearProgress, "secondaryBg", colorMix(private_safeLighten, palette.secondary.main, 0.62));
      setColor(palette.LinearProgress, "errorBg", colorMix(private_safeLighten, palette.error.main, 0.62));
      setColor(palette.LinearProgress, "infoBg", colorMix(private_safeLighten, palette.info.main, 0.62));
      setColor(palette.LinearProgress, "successBg", colorMix(private_safeLighten, palette.success.main, 0.62));
      setColor(palette.LinearProgress, "warningBg", colorMix(private_safeLighten, palette.warning.main, 0.62));
      setColor(palette.Skeleton, "bg", colorSpace ? colorMix(private_safeAlpha, palette.text.primary, 0.11) : `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.11)`);
      setColor(palette.Slider, "primaryTrack", colorMix(private_safeLighten, palette.primary.main, 0.62));
      setColor(palette.Slider, "secondaryTrack", colorMix(private_safeLighten, palette.secondary.main, 0.62));
      setColor(palette.Slider, "errorTrack", colorMix(private_safeLighten, palette.error.main, 0.62));
      setColor(palette.Slider, "infoTrack", colorMix(private_safeLighten, palette.info.main, 0.62));
      setColor(palette.Slider, "successTrack", colorMix(private_safeLighten, palette.success.main, 0.62));
      setColor(palette.Slider, "warningTrack", colorMix(private_safeLighten, palette.warning.main, 0.62));
      const snackbarContentBackground = colorSpace ? colorMix(private_safeDarken, palette.background.default, 0.6825) : private_safeEmphasize(palette.background.default, 0.8);
      setColor(palette.SnackbarContent, "bg", snackbarContentBackground);
      setColor(palette.SnackbarContent, "color", silent(() => colorSpace ? dark.text.primary : palette.getContrastText(snackbarContentBackground)));
      setColor(palette.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette.background.paper, 0.15));
      setColor(palette.StepConnector, "border", setCssVarColor("palette-grey-400"));
      setColor(palette.StepContent, "border", setCssVarColor("palette-grey-400"));
      setColor(palette.Switch, "defaultColor", setCssVarColor("palette-common-white"));
      setColor(palette.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-100"));
      setColor(palette.Switch, "primaryDisabledColor", colorMix(private_safeLighten, palette.primary.main, 0.62));
      setColor(palette.Switch, "secondaryDisabledColor", colorMix(private_safeLighten, palette.secondary.main, 0.62));
      setColor(palette.Switch, "errorDisabledColor", colorMix(private_safeLighten, palette.error.main, 0.62));
      setColor(palette.Switch, "infoDisabledColor", colorMix(private_safeLighten, palette.info.main, 0.62));
      setColor(palette.Switch, "successDisabledColor", colorMix(private_safeLighten, palette.success.main, 0.62));
      setColor(palette.Switch, "warningDisabledColor", colorMix(private_safeLighten, palette.warning.main, 0.62));
      setColor(palette.TableCell, "border", colorMix(private_safeLighten, colorMix(private_safeAlpha, palette.divider, 1), 0.88));
      setColor(palette.Tooltip, "bg", colorMix(private_safeAlpha, palette.grey[700], 0.92));
    }
    if (palette.mode === "dark") {
      setColor(palette.Alert, "errorColor", colorMix(private_safeLighten, palette.error.light, 0.6));
      setColor(palette.Alert, "infoColor", colorMix(private_safeLighten, palette.info.light, 0.6));
      setColor(palette.Alert, "successColor", colorMix(private_safeLighten, palette.success.light, 0.6));
      setColor(palette.Alert, "warningColor", colorMix(private_safeLighten, palette.warning.light, 0.6));
      setColor(palette.Alert, "errorFilledBg", setCssVarColor("palette-error-dark"));
      setColor(palette.Alert, "infoFilledBg", setCssVarColor("palette-info-dark"));
      setColor(palette.Alert, "successFilledBg", setCssVarColor("palette-success-dark"));
      setColor(palette.Alert, "warningFilledBg", setCssVarColor("palette-warning-dark"));
      setColor(palette.Alert, "errorFilledColor", silent(() => palette.getContrastText(palette.error.dark)));
      setColor(palette.Alert, "infoFilledColor", silent(() => palette.getContrastText(palette.info.dark)));
      setColor(palette.Alert, "successFilledColor", silent(() => palette.getContrastText(palette.success.dark)));
      setColor(palette.Alert, "warningFilledColor", silent(() => palette.getContrastText(palette.warning.dark)));
      setColor(palette.Alert, "errorStandardBg", colorMix(private_safeDarken, palette.error.light, 0.9));
      setColor(palette.Alert, "infoStandardBg", colorMix(private_safeDarken, palette.info.light, 0.9));
      setColor(palette.Alert, "successStandardBg", colorMix(private_safeDarken, palette.success.light, 0.9));
      setColor(palette.Alert, "warningStandardBg", colorMix(private_safeDarken, palette.warning.light, 0.9));
      setColor(palette.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successIconColor", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
      setColor(palette.AppBar, "defaultBg", setCssVarColor("palette-grey-900"));
      setColor(palette.AppBar, "darkBg", setCssVarColor("palette-background-paper"));
      setColor(palette.AppBar, "darkColor", setCssVarColor("palette-text-primary"));
      setColor(palette.Avatar, "defaultBg", setCssVarColor("palette-grey-600"));
      setColor(palette.Button, "inheritContainedBg", setCssVarColor("palette-grey-800"));
      setColor(palette.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultBorder", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-300"));
      setColor(palette.Chip, "defaultIconColor", setCssVarColor("palette-grey-300"));
      setColor(palette.FilledInput, "bg", "rgba(255, 255, 255, 0.09)");
      setColor(palette.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)");
      setColor(palette.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)");
      setColor(palette.LinearProgress, "primaryBg", colorMix(private_safeDarken, palette.primary.main, 0.5));
      setColor(palette.LinearProgress, "secondaryBg", colorMix(private_safeDarken, palette.secondary.main, 0.5));
      setColor(palette.LinearProgress, "errorBg", colorMix(private_safeDarken, palette.error.main, 0.5));
      setColor(palette.LinearProgress, "infoBg", colorMix(private_safeDarken, palette.info.main, 0.5));
      setColor(palette.LinearProgress, "successBg", colorMix(private_safeDarken, palette.success.main, 0.5));
      setColor(palette.LinearProgress, "warningBg", colorMix(private_safeDarken, palette.warning.main, 0.5));
      setColor(palette.Skeleton, "bg", colorSpace ? colorMix(private_safeAlpha, palette.text.primary, 0.13) : `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.13)`);
      setColor(palette.Slider, "primaryTrack", colorMix(private_safeDarken, palette.primary.main, 0.5));
      setColor(palette.Slider, "secondaryTrack", colorMix(private_safeDarken, palette.secondary.main, 0.5));
      setColor(palette.Slider, "errorTrack", colorMix(private_safeDarken, palette.error.main, 0.5));
      setColor(palette.Slider, "infoTrack", colorMix(private_safeDarken, palette.info.main, 0.5));
      setColor(palette.Slider, "successTrack", colorMix(private_safeDarken, palette.success.main, 0.5));
      setColor(palette.Slider, "warningTrack", colorMix(private_safeDarken, palette.warning.main, 0.5));
      const snackbarContentBackground = colorSpace ? colorMix(private_safeLighten, palette.background.default, 0.985) : private_safeEmphasize(palette.background.default, 0.98);
      setColor(palette.SnackbarContent, "bg", snackbarContentBackground);
      setColor(palette.SnackbarContent, "color", silent(() => colorSpace ? light.text.primary : palette.getContrastText(snackbarContentBackground)));
      setColor(palette.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette.background.paper, 0.15));
      setColor(palette.StepConnector, "border", setCssVarColor("palette-grey-600"));
      setColor(palette.StepContent, "border", setCssVarColor("palette-grey-600"));
      setColor(palette.Switch, "defaultColor", setCssVarColor("palette-grey-300"));
      setColor(palette.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-600"));
      setColor(palette.Switch, "primaryDisabledColor", colorMix(private_safeDarken, palette.primary.main, 0.55));
      setColor(palette.Switch, "secondaryDisabledColor", colorMix(private_safeDarken, palette.secondary.main, 0.55));
      setColor(palette.Switch, "errorDisabledColor", colorMix(private_safeDarken, palette.error.main, 0.55));
      setColor(palette.Switch, "infoDisabledColor", colorMix(private_safeDarken, palette.info.main, 0.55));
      setColor(palette.Switch, "successDisabledColor", colorMix(private_safeDarken, palette.success.main, 0.55));
      setColor(palette.Switch, "warningDisabledColor", colorMix(private_safeDarken, palette.warning.main, 0.55));
      setColor(palette.TableCell, "border", colorMix(private_safeDarken, colorMix(private_safeAlpha, palette.divider, 1), 0.68));
      setColor(palette.Tooltip, "bg", colorMix(private_safeAlpha, palette.grey[700], 0.92));
    }
    setColorChannel(palette.background, "default");
    setColorChannel(palette.background, "paper");
    setColorChannel(palette.common, "background");
    setColorChannel(palette.common, "onBackground");
    setColorChannel(palette, "divider");
    Object.keys(palette).forEach((color2) => {
      const colors = palette[color2];
      if (color2 !== "tonalOffset" && colors && typeof colors === "object") {
        if (colors.main) {
          setColor(palette[color2], "mainChannel", private_safeColorChannel(toRgb(colors.main)));
        }
        if (colors.light) {
          setColor(palette[color2], "lightChannel", private_safeColorChannel(toRgb(colors.light)));
        }
        if (colors.dark) {
          setColor(palette[color2], "darkChannel", private_safeColorChannel(toRgb(colors.dark)));
        }
        if (colors.contrastText) {
          setColor(palette[color2], "contrastTextChannel", private_safeColorChannel(toRgb(colors.contrastText)));
        }
        if (color2 === "text") {
          setColorChannel(palette[color2], "primary");
          setColorChannel(palette[color2], "secondary");
        }
        if (color2 === "action") {
          if (colors.active) {
            setColorChannel(palette[color2], "active");
          }
          if (colors.selected) {
            setColorChannel(palette[color2], "selected");
          }
        }
      }
    });
  });
  theme2 = args.reduce((acc, argument) => deepmerge(acc, argument), theme2);
  const parserConfig = {
    prefix: cssVarPrefix,
    disableCssColorScheme,
    shouldSkipGeneratingVar: shouldSkipGeneratingVar$1,
    getSelector: defaultGetSelector(theme2),
    enableContrastVars: nativeColor
  };
  const {
    vars,
    generateThemeVars,
    generateStyleSheets
  } = prepareCssVars(theme2, parserConfig);
  theme2.vars = vars;
  Object.entries(theme2.colorSchemes[theme2.defaultColorScheme]).forEach(([key, value]) => {
    theme2[key] = value;
  });
  theme2.generateThemeVars = generateThemeVars;
  theme2.generateStyleSheets = generateStyleSheets;
  theme2.generateSpacing = function generateSpacing() {
    return createSpacing(input.spacing, createUnarySpacing(this));
  };
  theme2.getColorSchemeSelector = createGetColorSchemeSelector(selector);
  theme2.spacing = theme2.generateSpacing();
  theme2.shouldSkipGeneratingVar = shouldSkipGeneratingVar$1;
  theme2.unstable_sxConfig = __spreadValues(__spreadValues({}, defaultSxConfig), input == null ? void 0 : input.unstable_sxConfig);
  theme2.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  theme2.toRuntimeSource = stringifyTheme;
  return theme2;
}
function attachColorScheme(theme2, scheme, colorScheme) {
  if (!theme2.colorSchemes) {
    return void 0;
  }
  if (colorScheme) {
    theme2.colorSchemes[scheme] = __spreadProps(__spreadValues({}, colorScheme !== true && colorScheme), {
      palette: createPalette(__spreadProps(__spreadValues({}, colorScheme === true ? {} : colorScheme.palette), {
        mode: scheme
      }))
      // cast type to skip module augmentation test
    });
  }
}
function createTheme(options = {}, ...args) {
  const _a2 = options, {
    palette,
    cssVariables = false,
    colorSchemes: initialColorSchemes = !palette ? {
      light: true
    } : void 0,
    defaultColorScheme: initialDefaultColorScheme = palette == null ? void 0 : palette.mode
  } = _a2, other = __objRest(_a2, [
    "palette",
    "cssVariables",
    "colorSchemes",
    "defaultColorScheme"
  ]);
  const defaultColorSchemeInput = initialDefaultColorScheme || "light";
  const defaultScheme = initialColorSchemes == null ? void 0 : initialColorSchemes[defaultColorSchemeInput];
  const colorSchemesInput = __spreadValues(__spreadValues({}, initialColorSchemes), palette ? {
    [defaultColorSchemeInput]: __spreadProps(__spreadValues({}, typeof defaultScheme !== "boolean" && defaultScheme), {
      palette
    })
  } : void 0);
  if (cssVariables === false) {
    if (!("colorSchemes" in options)) {
      return createThemeNoVars(options, ...args);
    }
    let paletteOptions = palette;
    if (!("palette" in options)) {
      if (colorSchemesInput[defaultColorSchemeInput]) {
        if (colorSchemesInput[defaultColorSchemeInput] !== true) {
          paletteOptions = colorSchemesInput[defaultColorSchemeInput].palette;
        } else if (defaultColorSchemeInput === "dark") {
          paletteOptions = {
            mode: "dark"
          };
        }
      }
    }
    const theme2 = createThemeNoVars(__spreadProps(__spreadValues({}, options), {
      palette: paletteOptions
    }), ...args);
    theme2.defaultColorScheme = defaultColorSchemeInput;
    theme2.colorSchemes = colorSchemesInput;
    if (theme2.palette.mode === "light") {
      theme2.colorSchemes.light = __spreadProps(__spreadValues({}, colorSchemesInput.light !== true && colorSchemesInput.light), {
        palette: theme2.palette
      });
      attachColorScheme(theme2, "dark", colorSchemesInput.dark);
    }
    if (theme2.palette.mode === "dark") {
      theme2.colorSchemes.dark = __spreadProps(__spreadValues({}, colorSchemesInput.dark !== true && colorSchemesInput.dark), {
        palette: theme2.palette
      });
      attachColorScheme(theme2, "light", colorSchemesInput.light);
    }
    return theme2;
  }
  if (!palette && !("light" in colorSchemesInput) && defaultColorSchemeInput === "light") {
    colorSchemesInput.light = true;
  }
  return createThemeWithVars(__spreadValues(__spreadProps(__spreadValues({}, other), {
    colorSchemes: colorSchemesInput,
    defaultColorScheme: defaultColorSchemeInput
  }), typeof cssVariables !== "boolean" && cssVariables), ...args);
}
function getUnit(input) {
  return String(input).match(/[\d.\-+]*\s*(.*)/)[1] || "";
}
function toUnitless(length2) {
  return parseFloat(length2);
}
const defaultTheme$1 = createTheme();
function useTheme() {
  const theme2 = useTheme$2(defaultTheme$1);
  return theme2[THEME_ID] || theme2;
}
function slotShouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
const rootShouldForwardProp = (prop) => slotShouldForwardProp(prop) && prop !== "classes";
const styled = createStyled2({
  themeId: THEME_ID,
  defaultTheme: defaultTheme$1,
  rootShouldForwardProp
});
function ThemeProviderNoVars(_m) {
  var _n = _m, {
    theme: themeInput
  } = _n, props = __objRest(_n, [
    "theme"
  ]);
  const scopedTheme = THEME_ID in themeInput ? themeInput[THEME_ID] : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider$1, __spreadProps(__spreadValues({}, props), {
    themeId: scopedTheme ? THEME_ID : void 0,
    theme: scopedTheme || themeInput
  }));
}
const defaultConfig = {
  colorSchemeStorageKey: "mui-color-scheme",
  defaultLightColorScheme: "light",
  defaultDarkColorScheme: "dark",
  modeStorageKey: "mui-mode"
};
const {
  CssVarsProvider: InternalCssVarsProvider
} = createCssVarsProvider({
  themeId: THEME_ID,
  // @ts-ignore ignore module augmentation tests
  theme: () => createTheme({
    cssVariables: true
  }),
  colorSchemeStorageKey: defaultConfig.colorSchemeStorageKey,
  modeStorageKey: defaultConfig.modeStorageKey,
  defaultColorScheme: {
    light: defaultConfig.defaultLightColorScheme,
    dark: defaultConfig.defaultDarkColorScheme
  },
  resolveTheme: (theme2) => {
    const newTheme = __spreadProps(__spreadValues({}, theme2), {
      typography: createTypography(theme2.palette, theme2.typography)
    });
    newTheme.unstable_sx = function sx(props) {
      return styleFunctionSx({
        sx: props,
        theme: this
      });
    };
    return newTheme;
  }
});
const CssVarsProvider = InternalCssVarsProvider;
function ThemeProvider(_o) {
  var _p = _o, {
    theme: theme2
  } = _p, props = __objRest(_p, [
    "theme"
  ]);
  const noVarsTheme = reactExports.useMemo(() => {
    if (typeof theme2 === "function") {
      return theme2;
    }
    const muiTheme = THEME_ID in theme2 ? theme2[THEME_ID] : theme2;
    if (!("colorSchemes" in muiTheme)) {
      if (!("vars" in muiTheme)) {
        return __spreadProps(__spreadValues({}, theme2), {
          vars: null
        });
      }
      return theme2;
    }
    return null;
  }, [theme2]);
  if (noVarsTheme) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProviderNoVars, __spreadValues({
      theme: noVarsTheme
    }, props));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CssVarsProvider, __spreadValues({
    theme: theme2
  }, props));
}
function createChainedFunction(...funcs) {
  return funcs.reduce((acc, func) => {
    if (func == null) {
      return acc;
    }
    return function chainedFunction(...args) {
      acc.apply(this, args);
      func.apply(this, args);
    };
  }, () => {
  });
}
function GlobalStyles$1(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$2, __spreadProps(__spreadValues({}, props), {
    defaultTheme: defaultTheme$1,
    themeId: THEME_ID
  }));
}
function globalCss(styles2) {
  return function GlobalStylesWrapper(props) {
    return (
      // Pigment CSS `globalCss` support callback with theme inside an object but `GlobalStyles` support theme as a callback value.
      /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$1, {
        styles: typeof styles2 === "function" ? (theme2) => styles2(__spreadValues({
          theme: theme2
        }, props)) : styles2
      })
    );
  };
}
function internal_createExtendSxProp() {
  return extendSxProp$1;
}
const memoTheme = unstable_memoTheme;
function useDefaultProps(params) {
  return useDefaultProps$1(params);
}
function getSvgIconUtilityClass(slot) {
  return generateUtilityClass("MuiSvgIcon", slot);
}
generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const useUtilityClasses$1e = (ownerState) => {
  const {
    color: color2,
    fontSize,
    classes
  } = ownerState;
  const slots = {
    root: ["root", color2 !== "inherit" && `color${capitalize(color2)}`, `fontSize${capitalize(fontSize)}`]
  };
  return composeClasses(slots, getSvgIconUtilityClass, classes);
};
const SvgIconRoot = styled("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "inherit" && styles2[`color${capitalize(ownerState.color)}`], styles2[`fontSize${capitalize(ownerState.fontSize)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
  return {
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    flexShrink: 0,
    transition: (_e = (_a2 = theme2.transitions) == null ? void 0 : _a2.create) == null ? void 0 : _e.call(_a2, "fill", {
      duration: (_d = (_c = ((_b = theme2.vars) != null ? _b : theme2).transitions) == null ? void 0 : _c.duration) == null ? void 0 : _d.shorter
    }),
    variants: [
      {
        props: (props) => !props.hasSvgAsChild,
        style: {
          // the <svg> will define the property that has `currentColor`
          // for example heroicons uses fill="none" and stroke="currentColor"
          fill: "currentColor"
        }
      },
      {
        props: {
          fontSize: "inherit"
        },
        style: {
          fontSize: "inherit"
        }
      },
      {
        props: {
          fontSize: "small"
        },
        style: {
          fontSize: ((_g = (_f = theme2.typography) == null ? void 0 : _f.pxToRem) == null ? void 0 : _g.call(_f, 20)) || "1.25rem"
        }
      },
      {
        props: {
          fontSize: "medium"
        },
        style: {
          fontSize: ((_i = (_h = theme2.typography) == null ? void 0 : _h.pxToRem) == null ? void 0 : _i.call(_h, 24)) || "1.5rem"
        }
      },
      {
        props: {
          fontSize: "large"
        },
        style: {
          fontSize: ((_k = (_j = theme2.typography) == null ? void 0 : _j.pxToRem) == null ? void 0 : _k.call(_j, 35)) || "2.1875rem"
        }
      },
      // TODO v5 deprecate color prop, v6 remove for sx
      ...Object.entries(((_l = theme2.vars) != null ? _l : theme2).palette).filter(([, value]) => value && value.main).map(([color2]) => {
        var _a3, _b2, _c2;
        return {
          props: {
            color: color2
          },
          style: {
            color: (_c2 = (_b2 = ((_a3 = theme2.vars) != null ? _a3 : theme2).palette) == null ? void 0 : _b2[color2]) == null ? void 0 : _c2.main
          }
        };
      }),
      {
        props: {
          color: "action"
        },
        style: {
          color: (_o = (_n = ((_m = theme2.vars) != null ? _m : theme2).palette) == null ? void 0 : _n.action) == null ? void 0 : _o.active
        }
      },
      {
        props: {
          color: "disabled"
        },
        style: {
          color: (_r = (_q = ((_p = theme2.vars) != null ? _p : theme2).palette) == null ? void 0 : _q.action) == null ? void 0 : _r.disabled
        }
      },
      {
        props: {
          color: "inherit"
        },
        style: {
          color: void 0
        }
      }
    ]
  };
}));
const SvgIcon = /* @__PURE__ */ reactExports.forwardRef(function SvgIcon2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSvgIcon"
  });
  const _a2 = props, {
    children,
    className,
    color: color2 = "inherit",
    component = "svg",
    fontSize = "medium",
    htmlColor,
    inheritViewBox = false,
    titleAccess,
    viewBox = "0 0 24 24"
  } = _a2, other = __objRest(_a2, [
    "children",
    "className",
    "color",
    "component",
    "fontSize",
    "htmlColor",
    "inheritViewBox",
    "titleAccess",
    "viewBox"
  ]);
  const hasSvgAsChild = /* @__PURE__ */ reactExports.isValidElement(children) && children.type === "svg";
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: color2,
    component,
    fontSize,
    instanceFontSize: inProps.fontSize,
    inheritViewBox,
    viewBox,
    hasSvgAsChild
  });
  const more = {};
  if (!inheritViewBox) {
    more.viewBox = viewBox;
  }
  const classes = useUtilityClasses$1e(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SvgIconRoot, __spreadProps(__spreadValues(__spreadValues(__spreadValues({
    as: component,
    className: clsx(classes.root, className),
    focusable: "false",
    color: htmlColor,
    "aria-hidden": titleAccess ? void 0 : true,
    role: titleAccess ? "img" : void 0,
    ref
  }, more), other), hasSvgAsChild && children.props), {
    ownerState,
    children: [hasSvgAsChild ? children.props.children : children, titleAccess ? /* @__PURE__ */ jsxRuntimeExports.jsx("title", {
      children: titleAccess
    }) : null]
  }));
});
SvgIcon.muiName = "SvgIcon";
function createSvgIcon(path, displayName) {
  function Component(props, ref) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgIcon, __spreadProps(__spreadValues({
      "data-testid": void 0,
      ref
    }, props), {
      children: path
    }));
  }
  Component.muiName = SvgIcon.muiName;
  return /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(Component));
}
function debounce$1(func, wait = 166) {
  let timeout;
  function debounced(...args) {
    const later = () => {
      func.apply(this, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  }
  debounced.clear = () => {
    clearTimeout(timeout);
  };
  return debounced;
}
function ownerDocument(node2) {
  return node2 && node2.ownerDocument || document;
}
function ownerWindow(node2) {
  const doc = ownerDocument(node2);
  return doc.defaultView || window;
}
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}
function useControlled(props) {
  const {
    controlled,
    default: defaultProp,
    name: name2,
    state = "value"
  } = props;
  const {
    current: isControlled
  } = reactExports.useRef(controlled !== void 0);
  const [valueState, setValue] = reactExports.useState(defaultProp);
  const value = isControlled ? controlled : valueState;
  const setValueIfUncontrolled = reactExports.useCallback((newValue) => {
    if (!isControlled) {
      setValue(newValue);
    }
  }, []);
  return [value, setValueIfUncontrolled];
}
function useEventCallback(fn2) {
  const ref = reactExports.useRef(fn2);
  useEnhancedEffect(() => {
    ref.current = fn2;
  });
  return reactExports.useRef((...args) => (
    // @ts-expect-error hide `this`
    (0, ref.current)(...args)
  )).current;
}
function useForkRef(...refs) {
  const cleanupRef = reactExports.useRef(void 0);
  const refEffect = reactExports.useCallback((instance) => {
    const cleanups = refs.map((ref) => {
      if (ref == null) {
        return null;
      }
      if (typeof ref === "function") {
        const refCallback = ref;
        const refCleanup = refCallback(instance);
        return typeof refCleanup === "function" ? refCleanup : () => {
          refCallback(null);
        };
      }
      ref.current = instance;
      return () => {
        ref.current = null;
      };
    });
    return () => {
      cleanups.forEach((refCleanup) => refCleanup == null ? void 0 : refCleanup());
    };
  }, refs);
  return reactExports.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (value) => {
      if (cleanupRef.current) {
        cleanupRef.current();
        cleanupRef.current = void 0;
      }
      if (value != null) {
        cleanupRef.current = refEffect(value);
      }
    };
  }, refs);
}
function isEventHandler(key, value) {
  const thirdCharCode = key.charCodeAt(2);
  return key[0] === "o" && key[1] === "n" && thirdCharCode >= 65 && thirdCharCode <= 90 && typeof value === "function";
}
function mergeSlotProps$1(externalSlotProps, defaultSlotProps) {
  if (!externalSlotProps) {
    return defaultSlotProps;
  }
  function extractHandlers(externalSlotPropsValue, defaultSlotPropsValue) {
    const handlers2 = {};
    Object.keys(defaultSlotPropsValue).forEach((key) => {
      if (isEventHandler(key, defaultSlotPropsValue[key]) && typeof externalSlotPropsValue[key] === "function") {
        handlers2[key] = (...args) => {
          externalSlotPropsValue[key](...args);
          defaultSlotPropsValue[key](...args);
        };
      }
    });
    return handlers2;
  }
  if (typeof externalSlotProps === "function" || typeof defaultSlotProps === "function") {
    return (ownerState) => {
      const defaultSlotPropsValue = typeof defaultSlotProps === "function" ? defaultSlotProps(ownerState) : defaultSlotProps;
      const externalSlotPropsValue = typeof externalSlotProps === "function" ? externalSlotProps(__spreadValues(__spreadValues({}, ownerState), defaultSlotPropsValue)) : externalSlotProps;
      const className2 = clsx(ownerState == null ? void 0 : ownerState.className, defaultSlotPropsValue == null ? void 0 : defaultSlotPropsValue.className, externalSlotPropsValue == null ? void 0 : externalSlotPropsValue.className);
      const handlers2 = extractHandlers(externalSlotPropsValue, defaultSlotPropsValue);
      return __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, defaultSlotPropsValue), externalSlotPropsValue), handlers2), !!className2 && {
        className: className2
      }), (defaultSlotPropsValue == null ? void 0 : defaultSlotPropsValue.style) && (externalSlotPropsValue == null ? void 0 : externalSlotPropsValue.style) && {
        style: __spreadValues(__spreadValues({}, defaultSlotPropsValue.style), externalSlotPropsValue.style)
      }), (defaultSlotPropsValue == null ? void 0 : defaultSlotPropsValue.sx) && (externalSlotPropsValue == null ? void 0 : externalSlotPropsValue.sx) && {
        sx: [...Array.isArray(defaultSlotPropsValue.sx) ? defaultSlotPropsValue.sx : [defaultSlotPropsValue.sx], ...Array.isArray(externalSlotPropsValue.sx) ? externalSlotPropsValue.sx : [externalSlotPropsValue.sx]]
      });
    };
  }
  const typedDefaultSlotProps = defaultSlotProps;
  const handlers = extractHandlers(externalSlotProps, typedDefaultSlotProps);
  const className = clsx(typedDefaultSlotProps == null ? void 0 : typedDefaultSlotProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
  return __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, defaultSlotProps), externalSlotProps), handlers), !!className && {
    className
  }), (typedDefaultSlotProps == null ? void 0 : typedDefaultSlotProps.style) && (externalSlotProps == null ? void 0 : externalSlotProps.style) && {
    style: __spreadValues(__spreadValues({}, typedDefaultSlotProps.style), externalSlotProps.style)
  }), (typedDefaultSlotProps == null ? void 0 : typedDefaultSlotProps.sx) && (externalSlotProps == null ? void 0 : externalSlotProps.sx) && {
    sx: [...Array.isArray(typedDefaultSlotProps.sx) ? typedDefaultSlotProps.sx : [typedDefaultSlotProps.sx], ...Array.isArray(externalSlotProps.sx) ? externalSlotProps.sx : [externalSlotProps.sx]]
  });
}
function _objectWithoutPropertiesLoose(r2, e) {
  if (null == r2) return {};
  var t = {};
  for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r2[n];
  }
  return t;
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, _setPrototypeOf(t, e);
}
function _inheritsLoose(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
}
const config = {
  disabled: false
};
const TransitionGroupContext = React.createContext(null);
var forceReflow = function forceReflow2(node2) {
  return node2.scrollTop;
};
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = /* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number") {
      exit = timeout2.exit;
      enter = timeout2.enter;
      appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
          if (node2) forceReflow(node2);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node2 || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === "function" ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps))
    );
  };
  return Transition2;
})(React.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};
function noop$3() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop$3,
  onEntering: noop$3,
  onEntered: noop$3,
  onExit: noop$3,
  onExiting: noop$3,
  onExited: noop$3
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function getChildMapping(children, mapFn) {
  var mapper = function mapper2(child) {
    return mapFn && reactExports.isValidElement(child) ? mapFn(child) : child;
  };
  var result = /* @__PURE__ */ Object.create(null);
  if (children) reactExports.Children.map(children, function(c) {
    return c;
  }).forEach(function(child) {
    result[child.key] = mapper(child);
  });
  return result;
}
function mergeChildMappings(prev2, next2) {
  prev2 = prev2 || {};
  next2 = next2 || {};
  function getValueForKey(key) {
    return key in next2 ? next2[key] : prev2[key];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev2) {
    if (prevKey in next2) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i;
  var childMapping = {};
  for (var nextKey in next2) {
    if (nextKeysPending[nextKey]) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }
  return childMapping;
}
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return reactExports.cloneElement(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function(key) {
    var child = children[key];
    if (!reactExports.isValidElement(child)) return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children[key] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children[key] = reactExports.cloneElement(child, {
        in: false
      });
    } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
      children[key] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children;
}
var values = Object.values || function(obj) {
  return Object.keys(obj).map(function(k) {
    return obj[k];
  });
};
var defaultProps = {
  component: "div",
  childFactory: function childFactory(child) {
    return child;
  }
};
var TransitionGroup = /* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };
  TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };
  _proto.handleExited = function handleExited(child, node2) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping) return;
    if (child.props.onExited) {
      child.props.onExited(node2);
    }
    if (this.mounted) {
      this.setState(function(state) {
        var children = _extends({}, state.children);
        delete children[child.key];
        return {
          children
        };
      });
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component === null) {
      return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }
    return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, /* @__PURE__ */ React.createElement(Component, props, children));
  };
  return TransitionGroup2;
})(React.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps;
const UNINITIALIZED = {};
function useLazyRef(init, initArg) {
  const ref = reactExports.useRef(UNINITIALIZED);
  if (ref.current === UNINITIALIZED) {
    ref.current = init(initArg);
  }
  return ref;
}
const EMPTY = [];
function useOnMount(fn2) {
  reactExports.useEffect(fn2, EMPTY);
}
class Timeout {
  constructor() {
    __publicField(this, "currentId", null);
    __publicField(this, "clear", () => {
      if (this.currentId !== null) {
        clearTimeout(this.currentId);
        this.currentId = null;
      }
    });
    __publicField(this, "disposeEffect", () => {
      return this.clear;
    });
  }
  static create() {
    return new Timeout();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(delay, fn2) {
    this.clear();
    this.currentId = setTimeout(() => {
      this.currentId = null;
      fn2();
    }, delay);
  }
}
function useTimeout() {
  const timeout = useLazyRef(Timeout.create).current;
  useOnMount(timeout.disposeEffect);
  return timeout;
}
const reflow = (node2) => node2.scrollTop;
function getTransitionProps(props, options) {
  var _a2, _b;
  const {
    timeout,
    easing: easing2,
    style: style2 = {}
  } = props;
  return {
    duration: (_a2 = style2.transitionDuration) != null ? _a2 : typeof timeout === "number" ? timeout : timeout[options.mode] || 0,
    easing: (_b = style2.transitionTimingFunction) != null ? _b : typeof easing2 === "object" ? easing2[options.mode] : easing2,
    delay: style2.transitionDelay
  };
}
function getPaperUtilityClass(slot) {
  return generateUtilityClass("MuiPaper", slot);
}
generateUtilityClasses("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const useUtilityClasses$1d = (ownerState) => {
  const {
    square,
    elevation,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, !square && "rounded", variant === "elevation" && `elevation${elevation}`]
  };
  return composeClasses(slots, getPaperUtilityClass, classes);
};
const PaperRoot = styled("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], !ownerState.square && styles2.rounded, ownerState.variant === "elevation" && styles2[`elevation${ownerState.elevation}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  backgroundColor: (theme2.vars || theme2).palette.background.paper,
  color: (theme2.vars || theme2).palette.text.primary,
  transition: theme2.transitions.create("box-shadow"),
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.square,
    style: {
      borderRadius: theme2.shape.borderRadius
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      border: `1px solid ${(theme2.vars || theme2).palette.divider}`
    }
  }, {
    props: {
      variant: "elevation"
    },
    style: {
      boxShadow: "var(--Paper-shadow)",
      backgroundImage: "var(--Paper-overlay)"
    }
  }]
})));
const Paper = /* @__PURE__ */ reactExports.forwardRef(function Paper2(inProps, ref) {
  var _b;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiPaper"
  });
  const theme2 = useTheme();
  const _a2 = props, {
    className,
    component = "div",
    elevation = 1,
    square = false,
    variant = "elevation"
  } = _a2, other = __objRest(_a2, [
    "className",
    "component",
    "elevation",
    "square",
    "variant"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component,
    elevation,
    square,
    variant
  });
  const classes = useUtilityClasses$1d(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PaperRoot, __spreadProps(__spreadValues({
    as: component,
    ownerState,
    className: clsx(classes.root, className),
    ref
  }, other), {
    style: __spreadValues(__spreadValues({}, variant === "elevation" && __spreadValues(__spreadValues({
      "--Paper-shadow": (theme2.vars || theme2).shadows[elevation]
    }, theme2.vars && {
      "--Paper-overlay": (_b = theme2.vars.overlays) == null ? void 0 : _b[elevation]
    }), !theme2.vars && theme2.palette.mode === "dark" && {
      "--Paper-overlay": `linear-gradient(${alpha("#fff", getOverlayAlpha(elevation))}, ${alpha("#fff", getOverlayAlpha(elevation))})`
    })), other.style)
  }));
});
function isHostComponent(element) {
  return typeof element === "string";
}
function appendOwnerState(elementType, otherProps, ownerState) {
  if (elementType === void 0 || isHostComponent(elementType)) {
    return otherProps;
  }
  return __spreadProps(__spreadValues({}, otherProps), {
    ownerState: __spreadValues(__spreadValues({}, otherProps.ownerState), ownerState)
  });
}
function resolveComponentProps(componentProps, ownerState, slotState) {
  if (typeof componentProps === "function") {
    return componentProps(ownerState, slotState);
  }
  return componentProps;
}
function extractEventHandlers(object, excludeKeys = []) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function omitEventHandlers(object) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] === "function")).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function mergeSlotProps(parameters) {
  const {
    getSlotProps,
    additionalProps,
    externalSlotProps,
    externalForwardedProps,
    className
  } = parameters;
  if (!getSlotProps) {
    const joinedClasses2 = clsx(additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
    const mergedStyle2 = __spreadValues(__spreadValues(__spreadValues({}, additionalProps == null ? void 0 : additionalProps.style), externalForwardedProps == null ? void 0 : externalForwardedProps.style), externalSlotProps == null ? void 0 : externalSlotProps.style);
    const props2 = __spreadValues(__spreadValues(__spreadValues({}, additionalProps), externalForwardedProps), externalSlotProps);
    if (joinedClasses2.length > 0) {
      props2.className = joinedClasses2;
    }
    if (Object.keys(mergedStyle2).length > 0) {
      props2.style = mergedStyle2;
    }
    return {
      props: props2,
      internalRef: void 0
    };
  }
  const eventHandlers = extractEventHandlers(__spreadValues(__spreadValues({}, externalForwardedProps), externalSlotProps));
  const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
  const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
  const internalSlotProps = getSlotProps(eventHandlers);
  const joinedClasses = clsx(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
  const mergedStyle = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, internalSlotProps == null ? void 0 : internalSlotProps.style), additionalProps == null ? void 0 : additionalProps.style), externalForwardedProps == null ? void 0 : externalForwardedProps.style), externalSlotProps == null ? void 0 : externalSlotProps.style);
  const props = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, internalSlotProps), additionalProps), otherPropsWithoutEventHandlers), componentsPropsWithoutEventHandlers);
  if (joinedClasses.length > 0) {
    props.className = joinedClasses;
  }
  if (Object.keys(mergedStyle).length > 0) {
    props.style = mergedStyle;
  }
  return {
    props,
    internalRef: internalSlotProps.ref
  };
}
function useSlot(name2, parameters) {
  const _a2 = parameters, {
    className,
    elementType: initialElementType,
    ownerState,
    externalForwardedProps,
    internalForwardedProps,
    shouldForwardComponentProp = false
  } = _a2, useSlotPropsParams = __objRest(_a2, [
    "className",
    "elementType",
    "ownerState",
    "externalForwardedProps",
    "internalForwardedProps",
    "shouldForwardComponentProp"
  ]);
  const _b = externalForwardedProps, {
    component: rootComponent,
    slots = {
      [name2]: void 0
    },
    slotProps = {
      [name2]: void 0
    }
  } = _b, other = __objRest(_b, [
    "component",
    "slots",
    "slotProps"
  ]);
  const elementType = slots[name2] || initialElementType;
  const resolvedComponentsProps = resolveComponentProps(slotProps[name2], ownerState);
  const _c = mergeSlotProps(__spreadProps(__spreadValues({
    className
  }, useSlotPropsParams), {
    externalForwardedProps: name2 === "root" ? other : void 0,
    externalSlotProps: resolvedComponentsProps
  })), {
    props: _d
  } = _c, _e = _d, {
    component: slotComponent
  } = _e, mergedProps = __objRest(_e, [
    "component"
  ]), {
    internalRef
  } = _c;
  const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, parameters.ref);
  const LeafComponent = name2 === "root" ? slotComponent || rootComponent : slotComponent;
  const props = appendOwnerState(elementType, __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, name2 === "root" && !rootComponent && !slots[name2] && internalForwardedProps), name2 !== "root" && !slots[name2] && internalForwardedProps), mergedProps), LeafComponent && !shouldForwardComponentProp && {
    as: LeafComponent
  }), LeafComponent && shouldForwardComponentProp && {
    component: LeafComponent
  }), {
    ref
  }), ownerState);
  return [elementType, props];
}
function isFocusVisible(element) {
  try {
    return element.matches(":focus-visible");
  } catch (error2) {
  }
  return false;
}
class LazyRipple {
  constructor() {
    __publicField(this, "mountEffect", () => {
      if (this.shouldMount && !this.didMount) {
        if (this.ref.current !== null) {
          this.didMount = true;
          this.mounted.resolve();
        }
      }
    });
    this.ref = {
      current: null
    };
    this.mounted = null;
    this.didMount = false;
    this.shouldMount = false;
    this.setShouldMount = null;
  }
  /** React ref to the ripple instance */
  /** If the ripple component should be mounted */
  /** Promise that resolves when the ripple component is mounted */
  /** If the ripple component has been mounted */
  /** React state hook setter */
  static create() {
    return new LazyRipple();
  }
  static use() {
    const ripple = useLazyRef(LazyRipple.create).current;
    const [shouldMount, setShouldMount] = reactExports.useState(false);
    ripple.shouldMount = shouldMount;
    ripple.setShouldMount = setShouldMount;
    reactExports.useEffect(ripple.mountEffect, [shouldMount]);
    return ripple;
  }
  mount() {
    if (!this.mounted) {
      this.mounted = createControlledPromise();
      this.shouldMount = true;
      this.setShouldMount(this.shouldMount);
    }
    return this.mounted;
  }
  /* Ripple API */
  start(...args) {
    this.mount().then(() => {
      var _a2;
      return (_a2 = this.ref.current) == null ? void 0 : _a2.start(...args);
    });
  }
  stop(...args) {
    this.mount().then(() => {
      var _a2;
      return (_a2 = this.ref.current) == null ? void 0 : _a2.stop(...args);
    });
  }
  pulsate(...args) {
    this.mount().then(() => {
      var _a2;
      return (_a2 = this.ref.current) == null ? void 0 : _a2.pulsate(...args);
    });
  }
}
function useLazyRipple() {
  return LazyRipple.use();
}
function createControlledPromise() {
  let resolve;
  let reject;
  const p = new Promise((resolveFn, rejectFn) => {
    resolve = resolveFn;
    reject = rejectFn;
  });
  p.resolve = resolve;
  p.reject = reject;
  return p;
}
function Ripple(props) {
  const {
    className,
    classes,
    pulsate = false,
    rippleX,
    rippleY,
    rippleSize,
    in: inProp,
    onExited,
    timeout
  } = props;
  const [leaving, setLeaving] = reactExports.useState(false);
  const rippleClassName = clsx(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
  const rippleStyles = {
    width: rippleSize,
    height: rippleSize,
    top: -(rippleSize / 2) + rippleY,
    left: -(rippleSize / 2) + rippleX
  };
  const childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
  if (!inProp && !leaving) {
    setLeaving(true);
  }
  reactExports.useEffect(() => {
    if (!inProp && onExited != null) {
      const timeoutId = setTimeout(onExited, timeout);
      return () => {
        clearTimeout(timeoutId);
      };
    }
    return void 0;
  }, [onExited, inProp, timeout]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
    className: rippleClassName,
    style: rippleStyles,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: childClassName
    })
  });
}
const touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
const DURATION = 550;
const DELAY_RIPPLE = 80;
const enterKeyframe = keyframes`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`;
const exitKeyframe = keyframes`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`;
const pulsateKeyframe = keyframes`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`;
const TouchRippleRoot = styled("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
});
const TouchRippleRipple = styled(Ripple, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})`
  opacity: 0;
  position: absolute;

  &.${touchRippleClasses.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${enterKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${({
  theme: theme2
}) => theme2.transitions.easing.easeInOut};
  }

  &.${touchRippleClasses.ripplePulsate} {
    animation-duration: ${({
  theme: theme2
}) => theme2.transitions.duration.shorter}ms;
  }

  & .${touchRippleClasses.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${touchRippleClasses.childLeaving} {
    opacity: 0;
    animation-name: ${exitKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${({
  theme: theme2
}) => theme2.transitions.easing.easeInOut};
  }

  & .${touchRippleClasses.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${pulsateKeyframe};
    animation-duration: 2500ms;
    animation-timing-function: ${({
  theme: theme2
}) => theme2.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`;
const TouchRipple = /* @__PURE__ */ reactExports.forwardRef(function TouchRipple2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTouchRipple"
  });
  const _a2 = props, {
    center: centerProp = false,
    classes = {},
    className
  } = _a2, other = __objRest(_a2, [
    "center",
    "classes",
    "className"
  ]);
  const [ripples, setRipples] = reactExports.useState([]);
  const nextKey = reactExports.useRef(0);
  const rippleCallback = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (rippleCallback.current) {
      rippleCallback.current();
      rippleCallback.current = null;
    }
  }, [ripples]);
  const ignoringMouseDown = reactExports.useRef(false);
  const startTimer = useTimeout();
  const startTimerCommit = reactExports.useRef(null);
  const container = reactExports.useRef(null);
  const startCommit = reactExports.useCallback((params) => {
    const {
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize,
      cb
    } = params;
    setRipples((oldRipples) => [...oldRipples, /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRipple, {
      classes: {
        ripple: clsx(classes.ripple, touchRippleClasses.ripple),
        rippleVisible: clsx(classes.rippleVisible, touchRippleClasses.rippleVisible),
        ripplePulsate: clsx(classes.ripplePulsate, touchRippleClasses.ripplePulsate),
        child: clsx(classes.child, touchRippleClasses.child),
        childLeaving: clsx(classes.childLeaving, touchRippleClasses.childLeaving),
        childPulsate: clsx(classes.childPulsate, touchRippleClasses.childPulsate)
      },
      timeout: DURATION,
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize
    }, nextKey.current)]);
    nextKey.current += 1;
    rippleCallback.current = cb;
  }, [classes]);
  const start2 = reactExports.useCallback((event = {}, options = {}, cb = () => {
  }) => {
    const {
      pulsate: pulsate2 = false,
      center = centerProp || options.pulsate,
      fakeElement = false
      // For test purposes
    } = options;
    if ((event == null ? void 0 : event.type) === "mousedown" && ignoringMouseDown.current) {
      ignoringMouseDown.current = false;
      return;
    }
    if ((event == null ? void 0 : event.type) === "touchstart") {
      ignoringMouseDown.current = true;
    }
    const element = fakeElement ? null : container.current;
    const rect = element ? element.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let rippleX;
    let rippleY;
    let rippleSize;
    if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
      rippleX = Math.round(rect.width / 2);
      rippleY = Math.round(rect.height / 2);
    } else {
      const {
        clientX,
        clientY
      } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
      rippleX = Math.round(clientX - rect.left);
      rippleY = Math.round(clientY - rect.top);
    }
    if (center) {
      rippleSize = Math.sqrt((2 * __pow(rect.width, 2) + __pow(rect.height, 2)) / 3);
      if (rippleSize % 2 === 0) {
        rippleSize += 1;
      }
    } else {
      const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
      const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
      rippleSize = Math.sqrt(__pow(sizeX, 2) + __pow(sizeY, 2));
    }
    if (event == null ? void 0 : event.touches) {
      if (startTimerCommit.current === null) {
        startTimerCommit.current = () => {
          startCommit({
            pulsate: pulsate2,
            rippleX,
            rippleY,
            rippleSize,
            cb
          });
        };
        startTimer.start(DELAY_RIPPLE, () => {
          if (startTimerCommit.current) {
            startTimerCommit.current();
            startTimerCommit.current = null;
          }
        });
      }
    } else {
      startCommit({
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize,
        cb
      });
    }
  }, [centerProp, startCommit, startTimer]);
  const pulsate = reactExports.useCallback(() => {
    start2({}, {
      pulsate: true
    });
  }, [start2]);
  const stop = reactExports.useCallback((event, cb) => {
    startTimer.clear();
    if ((event == null ? void 0 : event.type) === "touchend" && startTimerCommit.current) {
      startTimerCommit.current();
      startTimerCommit.current = null;
      startTimer.start(0, () => {
        stop(event, cb);
      });
      return;
    }
    startTimerCommit.current = null;
    setRipples((oldRipples) => {
      if (oldRipples.length > 0) {
        return oldRipples.slice(1);
      }
      return oldRipples;
    });
    rippleCallback.current = cb;
  }, [startTimer]);
  reactExports.useImperativeHandle(ref, () => ({
    pulsate,
    start: start2,
    stop
  }), [pulsate, start2, stop]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRoot, __spreadProps(__spreadValues({
    className: clsx(touchRippleClasses.root, classes.root, className),
    ref: container
  }, other), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionGroup, {
      component: null,
      exit: true,
      children: ripples
    })
  }));
});
function getButtonBaseUtilityClass(slot) {
  return generateUtilityClass("MuiButtonBase", slot);
}
const buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]);
const useUtilityClasses$1c = (ownerState) => {
  const {
    disabled,
    focusVisible,
    focusVisibleClassName,
    classes
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
  };
  const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);
  if (focusVisible && focusVisibleClassName) {
    composedClasses.root += ` ${focusVisibleClassName}`;
  }
  return composedClasses;
};
const ButtonBaseRoot = styled("button", {
  name: "MuiButtonBase",
  slot: "Root"
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${buttonBaseClasses.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
});
const ButtonBase = /* @__PURE__ */ reactExports.forwardRef(function ButtonBase2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiButtonBase"
  });
  const _a2 = props, {
    action,
    centerRipple = false,
    children,
    className,
    component = "button",
    disabled = false,
    disableRipple = false,
    disableTouchRipple = false,
    focusRipple = false,
    focusVisibleClassName,
    LinkComponent = "a",
    onBlur,
    onClick,
    onContextMenu,
    onDragLeave,
    onFocus,
    onFocusVisible,
    onKeyDown,
    onKeyUp,
    onMouseDown,
    onMouseLeave,
    onMouseUp,
    onTouchEnd,
    onTouchMove,
    onTouchStart,
    tabIndex = 0,
    TouchRippleProps,
    touchRippleRef,
    type
  } = _a2, other = __objRest(_a2, [
    "action",
    "centerRipple",
    "children",
    "className",
    "component",
    "disabled",
    "disableRipple",
    "disableTouchRipple",
    "focusRipple",
    "focusVisibleClassName",
    "LinkComponent",
    "onBlur",
    "onClick",
    "onContextMenu",
    "onDragLeave",
    "onFocus",
    "onFocusVisible",
    "onKeyDown",
    "onKeyUp",
    "onMouseDown",
    "onMouseLeave",
    "onMouseUp",
    "onTouchEnd",
    "onTouchMove",
    "onTouchStart",
    "tabIndex",
    "TouchRippleProps",
    "touchRippleRef",
    "type"
  ]);
  const buttonRef = reactExports.useRef(null);
  const ripple = useLazyRipple();
  const handleRippleRef = useForkRef(ripple.ref, touchRippleRef);
  const [focusVisible, setFocusVisible] = reactExports.useState(false);
  if (disabled && focusVisible) {
    setFocusVisible(false);
  }
  reactExports.useImperativeHandle(action, () => ({
    focusVisible: () => {
      setFocusVisible(true);
      buttonRef.current.focus();
    }
  }), []);
  const enableTouchRipple = ripple.shouldMount && !disableRipple && !disabled;
  reactExports.useEffect(() => {
    if (focusVisible && focusRipple && !disableRipple) {
      ripple.pulsate();
    }
  }, [disableRipple, focusRipple, focusVisible, ripple]);
  const handleMouseDown = useRippleHandler(ripple, "start", onMouseDown, disableTouchRipple);
  const handleContextMenu = useRippleHandler(ripple, "stop", onContextMenu, disableTouchRipple);
  const handleDragLeave = useRippleHandler(ripple, "stop", onDragLeave, disableTouchRipple);
  const handleMouseUp = useRippleHandler(ripple, "stop", onMouseUp, disableTouchRipple);
  const handleMouseLeave = useRippleHandler(ripple, "stop", (event) => {
    if (focusVisible) {
      event.preventDefault();
    }
    if (onMouseLeave) {
      onMouseLeave(event);
    }
  }, disableTouchRipple);
  const handleTouchStart = useRippleHandler(ripple, "start", onTouchStart, disableTouchRipple);
  const handleTouchEnd = useRippleHandler(ripple, "stop", onTouchEnd, disableTouchRipple);
  const handleTouchMove = useRippleHandler(ripple, "stop", onTouchMove, disableTouchRipple);
  const handleBlur = useRippleHandler(ripple, "stop", (event) => {
    if (!isFocusVisible(event.target)) {
      setFocusVisible(false);
    }
    if (onBlur) {
      onBlur(event);
    }
  }, false);
  const handleFocus = useEventCallback((event) => {
    if (!buttonRef.current) {
      buttonRef.current = event.currentTarget;
    }
    if (isFocusVisible(event.target)) {
      setFocusVisible(true);
      if (onFocusVisible) {
        onFocusVisible(event);
      }
    }
    if (onFocus) {
      onFocus(event);
    }
  });
  const isNonNativeButton = () => {
    const button = buttonRef.current;
    return component && component !== "button" && !(button.tagName === "A" && button.href);
  };
  const handleKeyDown = useEventCallback((event) => {
    if (focusRipple && !event.repeat && focusVisible && event.key === " ") {
      ripple.stop(event, () => {
        ripple.start(event);
      });
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
      event.preventDefault();
      if (onClick) {
        onClick(event);
      }
    }
  });
  const handleKeyUp = useEventCallback((event) => {
    if (focusRipple && event.key === " " && focusVisible && !event.defaultPrevented) {
      ripple.stop(event, () => {
        ripple.pulsate(event);
      });
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
    if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
      onClick(event);
    }
  });
  let ComponentProp = component;
  if (ComponentProp === "button" && (other.href || other.to)) {
    ComponentProp = LinkComponent;
  }
  const buttonProps = {};
  if (ComponentProp === "button") {
    buttonProps.type = type === void 0 ? "button" : type;
    buttonProps.disabled = disabled;
  } else {
    if (!other.href && !other.to) {
      buttonProps.role = "button";
    }
    if (disabled) {
      buttonProps["aria-disabled"] = disabled;
    }
  }
  const handleRef = useForkRef(ref, buttonRef);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    centerRipple,
    component,
    disabled,
    disableRipple,
    disableTouchRipple,
    focusRipple,
    tabIndex,
    focusVisible
  });
  const classes = useUtilityClasses$1c(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonBaseRoot, __spreadProps(__spreadValues(__spreadValues({
    as: ComponentProp,
    className: clsx(classes.root, className),
    ownerState,
    onBlur: handleBlur,
    onClick,
    onContextMenu: handleContextMenu,
    onFocus: handleFocus,
    onKeyDown: handleKeyDown,
    onKeyUp: handleKeyUp,
    onMouseDown: handleMouseDown,
    onMouseLeave: handleMouseLeave,
    onMouseUp: handleMouseUp,
    onDragLeave: handleDragLeave,
    onTouchEnd: handleTouchEnd,
    onTouchMove: handleTouchMove,
    onTouchStart: handleTouchStart,
    ref: handleRef,
    tabIndex: disabled ? -1 : tabIndex,
    type
  }, buttonProps), other), {
    children: [children, enableTouchRipple ? /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRipple, __spreadValues({
      ref: handleRippleRef,
      center: centerRipple
    }, TouchRippleProps)) : null]
  }));
});
function useRippleHandler(ripple, rippleAction, eventCallback, skipRippleAction = false) {
  return useEventCallback((event) => {
    if (eventCallback) {
      eventCallback(event);
    }
    if (!skipRippleAction) {
      ripple[rippleAction](event);
    }
    return true;
  });
}
function hasCorrectMainProperty(obj) {
  return typeof obj.main === "string";
}
function checkSimplePaletteColorValues(obj, additionalPropertiesToCheck = []) {
  if (!hasCorrectMainProperty(obj)) {
    return false;
  }
  for (const value of additionalPropertiesToCheck) {
    if (!obj.hasOwnProperty(value) || typeof obj[value] !== "string") {
      return false;
    }
  }
  return true;
}
function createSimplePaletteValueFilter(additionalPropertiesToCheck = []) {
  return ([, value]) => value && checkSimplePaletteColorValues(value, additionalPropertiesToCheck);
}
function getAlertUtilityClass(slot) {
  return generateUtilityClass("MuiAlert", slot);
}
const alertClasses = generateUtilityClasses("MuiAlert", ["root", "action", "icon", "message", "filled", "colorSuccess", "colorInfo", "colorWarning", "colorError", "filledSuccess", "filledInfo", "filledWarning", "filledError", "outlined", "outlinedSuccess", "outlinedInfo", "outlinedWarning", "outlinedError", "standard", "standardSuccess", "standardInfo", "standardWarning", "standardError"]);
function getCircularProgressUtilityClass(slot) {
  return generateUtilityClass("MuiCircularProgress", slot);
}
generateUtilityClasses("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "track", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);
const SIZE = 44;
const circularRotateKeyframe = keyframes`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`;
const circularDashKeyframe = keyframes`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: -126px;
  }
`;
const rotateAnimation = typeof circularRotateKeyframe !== "string" ? css`
        animation: ${circularRotateKeyframe} 1.4s linear infinite;
      ` : null;
const dashAnimation = typeof circularDashKeyframe !== "string" ? css`
        animation: ${circularDashKeyframe} 1.4s ease-in-out infinite;
      ` : null;
const useUtilityClasses$1b = (ownerState) => {
  const {
    classes,
    variant,
    color: color2,
    disableShrink
  } = ownerState;
  const slots = {
    root: ["root", variant, `color${capitalize(color2)}`],
    svg: ["svg"],
    track: ["track"],
    circle: ["circle", `circle${capitalize(variant)}`, disableShrink && "circleDisableShrink"]
  };
  return composeClasses(slots, getCircularProgressUtilityClass, classes);
};
const CircularProgressRoot = styled("span", {
  name: "MuiCircularProgress",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`color${capitalize(ownerState.color)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  display: "inline-block",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: theme2.transitions.create("transform")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: rotateAnimation || {
      animation: `${circularRotateKeyframe} 1.4s linear infinite`
    }
  }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      color: (theme2.vars || theme2).palette[color2].main
    }
  }))]
})));
const CircularProgressSVG = styled("svg", {
  name: "MuiCircularProgress",
  slot: "Svg"
})({
  display: "block"
  // Keeps the progress centered
});
const CircularProgressCircle = styled("circle", {
  name: "MuiCircularProgress",
  slot: "Circle",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.circle, styles2[`circle${capitalize(ownerState.variant)}`], ownerState.disableShrink && styles2.circleDisableShrink];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  stroke: "currentColor",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: theme2.transitions.create("stroke-dashoffset")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: {
      // Some default value that looks fine waiting for the animation to kicks in.
      strokeDasharray: "80px, 200px",
      strokeDashoffset: 0
      // Add the unit to fix a Edge 16 and below bug.
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.variant === "indeterminate" && !ownerState.disableShrink,
    style: dashAnimation || {
      // At runtime for Pigment CSS, `bufferAnimation` will be null and the generated keyframe will be used.
      animation: `${circularDashKeyframe} 1.4s ease-in-out infinite`
    }
  }]
})));
const CircularProgressTrack = styled("circle", {
  name: "MuiCircularProgress",
  slot: "Track"
})(memoTheme(({
  theme: theme2
}) => ({
  stroke: "currentColor",
  opacity: (theme2.vars || theme2).palette.action.activatedOpacity
})));
const CircularProgress = /* @__PURE__ */ reactExports.forwardRef(function CircularProgress2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCircularProgress"
  });
  const _a2 = props, {
    className,
    color: color2 = "primary",
    disableShrink = false,
    enableTrackSlot = false,
    size = 40,
    style: style2,
    thickness = 3.6,
    value = 0,
    variant = "indeterminate"
  } = _a2, other = __objRest(_a2, [
    "className",
    "color",
    "disableShrink",
    "enableTrackSlot",
    "size",
    "style",
    "thickness",
    "value",
    "variant"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: color2,
    disableShrink,
    size,
    thickness,
    value,
    variant,
    enableTrackSlot
  });
  const classes = useUtilityClasses$1b(ownerState);
  const circleStyle = {};
  const rootStyle = {};
  const rootProps = {};
  if (variant === "determinate") {
    const circumference = 2 * Math.PI * ((SIZE - thickness) / 2);
    circleStyle.strokeDasharray = circumference.toFixed(3);
    rootProps["aria-valuenow"] = Math.round(value);
    circleStyle.strokeDashoffset = `${((100 - value) / 100 * circumference).toFixed(3)}px`;
    rootStyle.transform = "rotate(-90deg)";
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressRoot, __spreadProps(__spreadValues(__spreadValues({
    className: clsx(classes.root, className),
    style: __spreadValues(__spreadValues({
      width: size,
      height: size
    }, rootStyle), style2),
    ownerState,
    ref,
    role: "progressbar"
  }, rootProps), other), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CircularProgressSVG, {
      className: classes.svg,
      ownerState,
      viewBox: `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`,
      children: [enableTrackSlot ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressTrack, {
        className: classes.track,
        ownerState,
        cx: SIZE,
        cy: SIZE,
        r: (SIZE - thickness) / 2,
        fill: "none",
        strokeWidth: thickness,
        "aria-hidden": "true"
      }) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCircle, {
        className: classes.circle,
        style: circleStyle,
        ownerState,
        cx: SIZE,
        cy: SIZE,
        r: (SIZE - thickness) / 2,
        fill: "none",
        strokeWidth: thickness
      })]
    })
  }));
});
function getIconButtonUtilityClass(slot) {
  return generateUtilityClass("MuiIconButton", slot);
}
const iconButtonClasses = generateUtilityClasses("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge", "loading", "loadingIndicator", "loadingWrapper"]);
const useUtilityClasses$1a = (ownerState) => {
  const {
    classes,
    disabled,
    color: color2,
    edge,
    size,
    loading
  } = ownerState;
  const slots = {
    root: ["root", loading && "loading", disabled && "disabled", color2 !== "default" && `color${capitalize(color2)}`, edge && `edge${capitalize(edge)}`, `size${capitalize(size)}`],
    loadingIndicator: ["loadingIndicator"],
    loadingWrapper: ["loadingWrapper"]
  };
  return composeClasses(slots, getIconButtonUtilityClass, classes);
};
const IconButtonRoot = styled(ButtonBase, {
  name: "MuiIconButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.loading && styles2.loading, ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`], ownerState.edge && styles2[`edge${capitalize(ownerState.edge)}`], styles2[`size${capitalize(ownerState.size)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  textAlign: "center",
  flex: "0 0 auto",
  fontSize: theme2.typography.pxToRem(24),
  padding: 8,
  borderRadius: "50%",
  color: (theme2.vars || theme2).palette.action.active,
  transition: theme2.transitions.create("background-color", {
    duration: theme2.transitions.duration.shortest
  }),
  variants: [{
    props: (props) => !props.disableRipple,
    style: {
      "--IconButton-hoverBg": theme2.alpha((theme2.vars || theme2).palette.action.active, (theme2.vars || theme2).palette.action.hoverOpacity),
      "&:hover": {
        backgroundColor: "var(--IconButton-hoverBg)",
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }, {
    props: {
      edge: "start"
    },
    style: {
      marginLeft: -12
    }
  }, {
    props: {
      edge: "start",
      size: "small"
    },
    style: {
      marginLeft: -3
    }
  }, {
    props: {
      edge: "end"
    },
    style: {
      marginRight: -12
    }
  }, {
    props: {
      edge: "end",
      size: "small"
    },
    style: {
      marginRight: -3
    }
  }]
})), memoTheme(({
  theme: theme2
}) => ({
  variants: [{
    props: {
      color: "inherit"
    },
    style: {
      color: "inherit"
    }
  }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      color: (theme2.vars || theme2).palette[color2].main
    }
  })), ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      "--IconButton-hoverBg": theme2.alpha((theme2.vars || theme2).palette[color2].main, (theme2.vars || theme2).palette.action.hoverOpacity)
    }
  })), {
    props: {
      size: "small"
    },
    style: {
      padding: 5,
      fontSize: theme2.typography.pxToRem(18)
    }
  }, {
    props: {
      size: "large"
    },
    style: {
      padding: 12,
      fontSize: theme2.typography.pxToRem(28)
    }
  }],
  [`&.${iconButtonClasses.disabled}`]: {
    backgroundColor: "transparent",
    color: (theme2.vars || theme2).palette.action.disabled
  },
  [`&.${iconButtonClasses.loading}`]: {
    color: "transparent"
  }
})));
const IconButtonLoadingIndicator = styled("span", {
  name: "MuiIconButton",
  slot: "LoadingIndicator"
})(({
  theme: theme2
}) => ({
  display: "none",
  position: "absolute",
  visibility: "visible",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  color: (theme2.vars || theme2).palette.action.disabled,
  variants: [{
    props: {
      loading: true
    },
    style: {
      display: "flex"
    }
  }]
}));
const IconButton$1 = /* @__PURE__ */ reactExports.forwardRef(function IconButton2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiIconButton"
  });
  const _a2 = props, {
    edge = false,
    children,
    className,
    color: color2 = "default",
    disabled = false,
    disableFocusRipple = false,
    size = "medium",
    id: idProp,
    loading = null,
    loadingIndicator: loadingIndicatorProp
  } = _a2, other = __objRest(_a2, [
    "edge",
    "children",
    "className",
    "color",
    "disabled",
    "disableFocusRipple",
    "size",
    "id",
    "loading",
    "loadingIndicator"
  ]);
  const loadingId = useId(idProp);
  const loadingIndicator = loadingIndicatorProp != null ? loadingIndicatorProp : /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {
    "aria-labelledby": loadingId,
    color: "inherit",
    size: 16
  });
  const ownerState = __spreadProps(__spreadValues({}, props), {
    edge,
    color: color2,
    disabled,
    disableFocusRipple,
    loading,
    loadingIndicator,
    size
  });
  const classes = useUtilityClasses$1a(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IconButtonRoot, __spreadProps(__spreadValues({
    id: loading ? loadingId : idProp,
    className: clsx(classes.root, className),
    centerRipple: true,
    focusRipple: !disableFocusRipple,
    disabled: disabled || loading,
    ref
  }, other), {
    ownerState,
    children: [typeof loading === "boolean" && // use plain HTML span to minimize the runtime overhead
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: classes.loadingWrapper,
      style: {
        display: "contents"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButtonLoadingIndicator, {
        className: classes.loadingIndicator,
        ownerState,
        children: loading && loadingIndicator
      })
    }), children]
  }));
});
const SuccessOutlinedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z"
}));
const ReportProblemOutlinedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z"
}));
const ErrorOutlineIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
}));
const InfoOutlinedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z"
}));
const ClearIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}));
const useUtilityClasses$19 = (ownerState) => {
  const {
    variant,
    color: color2,
    severity,
    classes
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize(color2 || severity)}`, `${variant}${capitalize(color2 || severity)}`, `${variant}`],
    icon: ["icon"],
    message: ["message"],
    action: ["action"]
  };
  return composeClasses(slots, getAlertUtilityClass, classes);
};
const AlertRoot = styled(Paper, {
  name: "MuiAlert",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize(ownerState.color || ownerState.severity)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => {
  const getColor = theme2.palette.mode === "light" ? theme2.darken : theme2.lighten;
  const getBackgroundColor = theme2.palette.mode === "light" ? theme2.lighten : theme2.darken;
  return __spreadProps(__spreadValues({}, theme2.typography.body2), {
    backgroundColor: "transparent",
    display: "flex",
    padding: "6px 16px",
    variants: [...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["light"])).map(([color2]) => ({
      props: {
        colorSeverity: color2,
        variant: "standard"
      },
      style: {
        color: theme2.vars ? theme2.vars.palette.Alert[`${color2}Color`] : getColor(theme2.palette[color2].light, 0.6),
        backgroundColor: theme2.vars ? theme2.vars.palette.Alert[`${color2}StandardBg`] : getBackgroundColor(theme2.palette[color2].light, 0.9),
        [`& .${alertClasses.icon}`]: theme2.vars ? {
          color: theme2.vars.palette.Alert[`${color2}IconColor`]
        } : {
          color: theme2.palette[color2].main
        }
      }
    })), ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["light"])).map(([color2]) => ({
      props: {
        colorSeverity: color2,
        variant: "outlined"
      },
      style: {
        color: theme2.vars ? theme2.vars.palette.Alert[`${color2}Color`] : getColor(theme2.palette[color2].light, 0.6),
        border: `1px solid ${(theme2.vars || theme2).palette[color2].light}`,
        [`& .${alertClasses.icon}`]: theme2.vars ? {
          color: theme2.vars.palette.Alert[`${color2}IconColor`]
        } : {
          color: theme2.palette[color2].main
        }
      }
    })), ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["dark"])).map(([color2]) => ({
      props: {
        colorSeverity: color2,
        variant: "filled"
      },
      style: __spreadValues({
        fontWeight: theme2.typography.fontWeightMedium
      }, theme2.vars ? {
        color: theme2.vars.palette.Alert[`${color2}FilledColor`],
        backgroundColor: theme2.vars.palette.Alert[`${color2}FilledBg`]
      } : {
        backgroundColor: theme2.palette.mode === "dark" ? theme2.palette[color2].dark : theme2.palette[color2].main,
        color: theme2.palette.getContrastText(theme2.palette[color2].main)
      })
    }))]
  });
}));
const AlertIcon = styled("div", {
  name: "MuiAlert",
  slot: "Icon"
})({
  marginRight: 12,
  padding: "7px 0",
  display: "flex",
  fontSize: 22,
  opacity: 0.9
});
const AlertMessage = styled("div", {
  name: "MuiAlert",
  slot: "Message"
})({
  padding: "8px 0",
  minWidth: 0,
  overflow: "auto"
});
const AlertAction = styled("div", {
  name: "MuiAlert",
  slot: "Action"
})({
  display: "flex",
  alignItems: "flex-start",
  padding: "4px 0 0 16px",
  marginLeft: "auto",
  marginRight: -8
});
const defaultIconMapping = {
  success: /* @__PURE__ */ jsxRuntimeExports.jsx(SuccessOutlinedIcon, {
    fontSize: "inherit"
  }),
  warning: /* @__PURE__ */ jsxRuntimeExports.jsx(ReportProblemOutlinedIcon, {
    fontSize: "inherit"
  }),
  error: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorOutlineIcon, {
    fontSize: "inherit"
  }),
  info: /* @__PURE__ */ jsxRuntimeExports.jsx(InfoOutlinedIcon, {
    fontSize: "inherit"
  })
};
const Alert = /* @__PURE__ */ reactExports.forwardRef(function Alert2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiAlert"
  });
  const _a2 = props, {
    action,
    children,
    className,
    closeText = "Close",
    color: color2,
    components = {},
    componentsProps = {},
    icon,
    iconMapping = defaultIconMapping,
    onClose,
    role = "alert",
    severity = "success",
    slotProps = {},
    slots = {},
    variant = "standard"
  } = _a2, other = __objRest(_a2, [
    "action",
    "children",
    "className",
    "closeText",
    "color",
    "components",
    "componentsProps",
    "icon",
    "iconMapping",
    "onClose",
    "role",
    "severity",
    "slotProps",
    "slots",
    "variant"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: color2,
    severity,
    variant,
    colorSeverity: color2 || severity
  });
  const classes = useUtilityClasses$19(ownerState);
  const externalForwardedProps = {
    slots: __spreadValues({
      closeButton: components.CloseButton,
      closeIcon: components.CloseIcon
    }, slots),
    slotProps: __spreadValues(__spreadValues({}, componentsProps), slotProps)
  };
  const [RootSlot, rootSlotProps] = useSlot("root", {
    ref,
    shouldForwardComponentProp: true,
    className: clsx(classes.root, className),
    elementType: AlertRoot,
    externalForwardedProps: __spreadValues(__spreadValues({}, externalForwardedProps), other),
    ownerState,
    additionalProps: {
      role,
      elevation: 0
    }
  });
  const [IconSlot, iconSlotProps] = useSlot("icon", {
    className: classes.icon,
    elementType: AlertIcon,
    externalForwardedProps,
    ownerState
  });
  const [MessageSlot, messageSlotProps] = useSlot("message", {
    className: classes.message,
    elementType: AlertMessage,
    externalForwardedProps,
    ownerState
  });
  const [ActionSlot, actionSlotProps] = useSlot("action", {
    className: classes.action,
    elementType: AlertAction,
    externalForwardedProps,
    ownerState
  });
  const [CloseButtonSlot, closeButtonProps] = useSlot("closeButton", {
    elementType: IconButton$1,
    externalForwardedProps,
    ownerState
  });
  const [CloseIconSlot, closeIconProps] = useSlot("closeIcon", {
    elementType: ClearIcon,
    externalForwardedProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, __spreadProps(__spreadValues({}, rootSlotProps), {
    children: [icon !== false ? /* @__PURE__ */ jsxRuntimeExports.jsx(IconSlot, __spreadProps(__spreadValues({}, iconSlotProps), {
      children: icon || iconMapping[severity] || defaultIconMapping[severity]
    })) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(MessageSlot, __spreadProps(__spreadValues({}, messageSlotProps), {
      children
    })), action != null ? /* @__PURE__ */ jsxRuntimeExports.jsx(ActionSlot, __spreadProps(__spreadValues({}, actionSlotProps), {
      children: action
    })) : null, action == null && onClose ? /* @__PURE__ */ jsxRuntimeExports.jsx(ActionSlot, __spreadProps(__spreadValues({}, actionSlotProps), {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseButtonSlot, __spreadProps(__spreadValues({
        size: "small",
        "aria-label": closeText,
        title: closeText,
        color: "inherit",
        onClick: onClose
      }, closeButtonProps), {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIconSlot, __spreadValues({
          fontSize: "small"
        }, closeIconProps))
      }))
    })) : null]
  }));
});
function getTypographyUtilityClass(slot) {
  return generateUtilityClass("MuiTypography", slot);
}
const typographyClasses = generateUtilityClasses("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
const v6Colors$1 = {
  primary: true,
  secondary: true,
  error: true,
  info: true,
  success: true,
  warning: true,
  textPrimary: true,
  textSecondary: true,
  textDisabled: true
};
const extendSxProp = internal_createExtendSxProp();
const useUtilityClasses$18 = (ownerState) => {
  const {
    align,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, ownerState.align !== "inherit" && `align${capitalize(align)}`, gutterBottom && "gutterBottom", noWrap && "noWrap", paragraph && "paragraph"]
  };
  return composeClasses(slots, getTypographyUtilityClass, classes);
};
const TypographyRoot = styled("span", {
  name: "MuiTypography",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.variant && styles2[ownerState.variant], ownerState.align !== "inherit" && styles2[`align${capitalize(ownerState.align)}`], ownerState.noWrap && styles2.noWrap, ownerState.gutterBottom && styles2.gutterBottom, ownerState.paragraph && styles2.paragraph];
  }
})(memoTheme(({
  theme: theme2
}) => {
  var _a2;
  return {
    margin: 0,
    variants: [{
      props: {
        variant: "inherit"
      },
      style: {
        // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
        font: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit"
      }
    }, ...Object.entries(theme2.typography).filter(([variant, value]) => variant !== "inherit" && value && typeof value === "object").map(([variant, value]) => ({
      props: {
        variant
      },
      style: value
    })), ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
      props: {
        color: color2
      },
      style: {
        color: (theme2.vars || theme2).palette[color2].main
      }
    })), ...Object.entries(((_a2 = theme2.palette) == null ? void 0 : _a2.text) || {}).filter(([, value]) => typeof value === "string").map(([color2]) => ({
      props: {
        color: `text${capitalize(color2)}`
      },
      style: {
        color: (theme2.vars || theme2).palette.text[color2]
      }
    })), {
      props: ({
        ownerState
      }) => ownerState.align !== "inherit",
      style: {
        textAlign: "var(--Typography-textAlign)"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.noWrap,
      style: {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.gutterBottom,
      style: {
        marginBottom: "0.35em"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.paragraph,
      style: {
        marginBottom: 16
      }
    }]
  };
}));
const defaultVariantMapping = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  body1: "p",
  body2: "p",
  inherit: "p"
};
const Typography = /* @__PURE__ */ reactExports.forwardRef(function Typography2(inProps, ref) {
  const _a2 = useDefaultProps({
    props: inProps,
    name: "MuiTypography"
  }), {
    color: color2
  } = _a2, themeProps = __objRest(_a2, [
    "color"
  ]);
  const isSxColor = !v6Colors$1[color2];
  const props = extendSxProp(__spreadValues(__spreadValues({}, themeProps), isSxColor && {
    color: color2
  }));
  const _b = props, {
    align = "inherit",
    className,
    component,
    gutterBottom = false,
    noWrap = false,
    paragraph = false,
    variant = "body1",
    variantMapping = defaultVariantMapping
  } = _b, other = __objRest(_b, [
    "align",
    "className",
    "component",
    "gutterBottom",
    "noWrap",
    "paragraph",
    "variant",
    "variantMapping"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    align,
    color: color2,
    className,
    component,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    variantMapping
  });
  const Component = component || (paragraph ? "p" : variantMapping[variant] || defaultVariantMapping[variant]) || "span";
  const classes = useUtilityClasses$18(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TypographyRoot, __spreadProps(__spreadValues({
    as: Component,
    ref,
    className: clsx(classes.root, className)
  }, other), {
    ownerState,
    style: __spreadValues(__spreadValues({}, align !== "inherit" && {
      "--Typography-textAlign": align
    }), other.style)
  }));
});
function usePreviousProps(value) {
  const ref = reactExports.useRef({});
  reactExports.useEffect(() => {
    ref.current = value;
  });
  return ref.current;
}
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node2) {
  if (node2 == null) {
    return window;
  }
  if (node2.toString() !== "[object Window]") {
    var ownerDocument2 = node2.ownerDocument;
    return ownerDocument2 ? ownerDocument2.defaultView || window : window;
  }
  return node2;
}
function isElement(node2) {
  var OwnElement = getWindow(node2).Element;
  return node2 instanceof OwnElement || node2 instanceof Element;
}
function isHTMLElement$1(node2) {
  var OwnElement = getWindow(node2).HTMLElement;
  return node2 instanceof OwnElement || node2 instanceof HTMLElement;
}
function isShadowRoot(node2) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node2).ShadowRoot;
  return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name2) {
    var style2 = state.styles[name2] || {};
    var attributes = state.attributes[name2] || {};
    var element = state.elements[name2];
    if (!isHTMLElement$1(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style2);
    Object.keys(attributes).forEach(function(name3) {
      var value = attributes[name3];
      if (value === false) {
        element.removeAttribute(name3);
      } else {
        element.setAttribute(name3, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name2) {
      var element = state.elements[name2];
      var attributes = state.attributes[name2] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name2) ? state.styles[name2] : initialStyles[name2]);
      var style2 = styleProperties.reduce(function(style3, property) {
        style3[property] = "";
        return style3;
      }, {});
      if (!isHTMLElement$1(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max = Math.max;
var min = Math.min;
var round$1 = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement$1(element)) {
    scaleX = element.offsetWidth > 0 ? round$1(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round$1(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width2 = clientRect.width / scaleX;
  var height2 = clientRect.height / scaleY;
  return {
    width: width2,
    height: height2,
    top: y,
    right: x + width2,
    bottom: y + height2,
    left: x,
    x,
    y
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width2 = element.offsetWidth;
  var height2 = element.offsetHeight;
  if (Math.abs(clientRect.width - width2) <= 1) {
    width2 = clientRect.width;
  }
  if (Math.abs(clientRect.height - height2) <= 1) {
    height2 = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width2,
    height: height2
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next2 = child;
    do {
      if (next2 && parent.isSameNode(next2)) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    } while (next2);
  }
  return false;
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement$1(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement$1(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement$1(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css2 = getComputedStyle(currentNode);
    if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding2, state) {
  padding2 = typeof padding2 === "function" ? padding2(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding2;
  return mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name2 = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name2] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
const arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round$1(x * dpr) / dpr || 0,
    y: round$1(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle(offsetParent).position !== "static" && position2 === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position2
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node2) {
  var win = getWindow(node2);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html2 = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width2 = html2.clientWidth;
  var height2 = html2.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width2 = visualViewport.width;
    height2 = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width: width2,
    height: height2,
    x: x + getWindowScrollBarX(element),
    y
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html2 = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body2 = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width2 = max(html2.scrollWidth, html2.clientWidth, body2 ? body2.scrollWidth : 0, body2 ? body2.clientWidth : 0);
  var height2 = max(html2.scrollHeight, html2.clientHeight, body2 ? body2.scrollHeight : 0, body2 ? body2.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle(body2 || html2).direction === "rtl") {
    x += max(html2.clientWidth, body2 ? body2.clientWidth : 0) - width2;
  }
  return {
    width: width2,
    height: height2,
    x,
    y
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node2) {
  if (["html", "body", "#document"].indexOf(getNodeName(node2)) >= 0) {
    return node2.ownerDocument.body;
  }
  if (isHTMLElement$1(node2) && isScrollParent(node2)) {
    return node2;
  }
  return getScrollParent(getParentNode(node2));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement$1(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding2 = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding2 = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding: padding2
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name2 = _ref.name;
  if (state.modifiersData[name2]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding2 = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding: padding2,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding: padding2
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name2]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
const flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name2 = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name2] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
const hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name2 = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name2] = data;
}
const offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref) {
  var state = _ref.state, name2 = _ref.name;
  state.modifiersData[name2] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    placement: state.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name2 = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding2 = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding: padding2,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$1 = offset2 + overflow[mainSide];
    var max$1 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name2] = data;
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node2) {
  if (node2 === getWindow(node2) || !isHTMLElement$1(node2)) {
    return getWindowScroll(node2);
  } else {
    return getHTMLElementScroll(node2);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round$1(rect.width) / element.offsetWidth || 1;
  var scaleY = round$1(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  var offsetParentIsScaled = isHTMLElement$1(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var DEFAULT_OPTIONS$1 = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS$1 : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS$1, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
          if (state.reset === true) {
            state.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name2 = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name: name2,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name2 = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name: name2,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
function useSlotProps(parameters) {
  var _b;
  const _a2 = parameters, {
    elementType,
    externalSlotProps,
    ownerState,
    skipResolvingSlotProps = false
  } = _a2, other = __objRest(_a2, [
    "elementType",
    "externalSlotProps",
    "ownerState",
    "skipResolvingSlotProps"
  ]);
  const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps(externalSlotProps, ownerState);
  const {
    props: mergedProps,
    internalRef
  } = mergeSlotProps(__spreadProps(__spreadValues({}, other), {
    externalSlotProps: resolvedComponentsProps
  }));
  const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_b = parameters.additionalProps) == null ? void 0 : _b.ref);
  const props = appendOwnerState(elementType, __spreadProps(__spreadValues({}, mergedProps), {
    ref
  }), ownerState);
  return props;
}
function getReactElementRef(element) {
  var _a2;
  if (parseInt(reactExports.version, 10) >= 19) {
    return ((_a2 = element == null ? void 0 : element.props) == null ? void 0 : _a2.ref) || null;
  }
  return (element == null ? void 0 : element.ref) || null;
}
function getContainer$1(container) {
  return typeof container === "function" ? container() : container;
}
const Portal = /* @__PURE__ */ reactExports.forwardRef(function Portal2(props, forwardedRef) {
  const {
    children,
    container,
    disablePortal = false
  } = props;
  const [mountNode, setMountNode] = reactExports.useState(null);
  const handleRef = useForkRef(/* @__PURE__ */ reactExports.isValidElement(children) ? getReactElementRef(children) : null, forwardedRef);
  useEnhancedEffect(() => {
    if (!disablePortal) {
      setMountNode(getContainer$1(container) || document.body);
    }
  }, [container, disablePortal]);
  useEnhancedEffect(() => {
    if (mountNode && !disablePortal) {
      setRef(forwardedRef, mountNode);
      return () => {
        setRef(forwardedRef, null);
      };
    }
    return void 0;
  }, [forwardedRef, mountNode, disablePortal]);
  if (disablePortal) {
    if (/* @__PURE__ */ reactExports.isValidElement(children)) {
      const newProps = {
        ref: handleRef
      };
      return /* @__PURE__ */ reactExports.cloneElement(children, newProps);
    }
    return children;
  }
  return mountNode ? /* @__PURE__ */ reactDomExports.createPortal(children, mountNode) : mountNode;
});
function getPopperUtilityClass(slot) {
  return generateUtilityClass("MuiPopper", slot);
}
generateUtilityClasses("MuiPopper", ["root"]);
function flipPlacement(placement, direction) {
  if (direction === "ltr") {
    return placement;
  }
  switch (placement) {
    case "bottom-end":
      return "bottom-start";
    case "bottom-start":
      return "bottom-end";
    case "top-end":
      return "top-start";
    case "top-start":
      return "top-end";
    default:
      return placement;
  }
}
function resolveAnchorEl$1(anchorEl) {
  return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
function isHTMLElement(element) {
  return element.nodeType !== void 0;
}
const useUtilityClasses$17 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getPopperUtilityClass, classes);
};
const defaultPopperOptions = {};
const PopperTooltip = /* @__PURE__ */ reactExports.forwardRef(function PopperTooltip2(props, forwardedRef) {
  var _b;
  const _a2 = props, {
    anchorEl,
    children,
    direction,
    disablePortal,
    modifiers,
    open,
    placement: initialPlacement,
    popperOptions,
    popperRef: popperRefProp,
    slotProps = {},
    slots = {},
    TransitionProps,
    ownerState: ownerStateProp
  } = _a2, other = __objRest(_a2, [
    "anchorEl",
    "children",
    "direction",
    "disablePortal",
    "modifiers",
    "open",
    "placement",
    "popperOptions",
    "popperRef",
    "slotProps",
    "slots",
    "TransitionProps",
    // @ts-ignore internal logic
    "ownerState"
  ]);
  const tooltipRef = reactExports.useRef(null);
  const ownRef = useForkRef(tooltipRef, forwardedRef);
  const popperRef = reactExports.useRef(null);
  const handlePopperRef = useForkRef(popperRef, popperRefProp);
  const handlePopperRefRef = reactExports.useRef(handlePopperRef);
  useEnhancedEffect(() => {
    handlePopperRefRef.current = handlePopperRef;
  }, [handlePopperRef]);
  reactExports.useImperativeHandle(popperRefProp, () => popperRef.current, []);
  const rtlPlacement = flipPlacement(initialPlacement, direction);
  const [placement, setPlacement] = reactExports.useState(rtlPlacement);
  const [resolvedAnchorElement, setResolvedAnchorElement] = reactExports.useState(resolveAnchorEl$1(anchorEl));
  reactExports.useEffect(() => {
    if (popperRef.current) {
      popperRef.current.forceUpdate();
    }
  });
  reactExports.useEffect(() => {
    if (anchorEl) {
      setResolvedAnchorElement(resolveAnchorEl$1(anchorEl));
    }
  }, [anchorEl]);
  useEnhancedEffect(() => {
    if (!resolvedAnchorElement || !open) {
      return void 0;
    }
    const handlePopperUpdate = (data) => {
      setPlacement(data.placement);
    };
    let popperModifiers = [{
      name: "preventOverflow",
      options: {
        altBoundary: disablePortal
      }
    }, {
      name: "flip",
      options: {
        altBoundary: disablePortal
      }
    }, {
      name: "onUpdate",
      enabled: true,
      phase: "afterWrite",
      fn: ({
        state
      }) => {
        handlePopperUpdate(state);
      }
    }];
    if (modifiers != null) {
      popperModifiers = popperModifiers.concat(modifiers);
    }
    if (popperOptions && popperOptions.modifiers != null) {
      popperModifiers = popperModifiers.concat(popperOptions.modifiers);
    }
    const popper2 = createPopper(resolvedAnchorElement, tooltipRef.current, __spreadProps(__spreadValues({
      placement: rtlPlacement
    }, popperOptions), {
      modifiers: popperModifiers
    }));
    handlePopperRefRef.current(popper2);
    return () => {
      popper2.destroy();
      handlePopperRefRef.current(null);
    };
  }, [resolvedAnchorElement, disablePortal, modifiers, open, popperOptions, rtlPlacement]);
  const childProps = {
    placement
  };
  if (TransitionProps !== null) {
    childProps.TransitionProps = TransitionProps;
  }
  const classes = useUtilityClasses$17(props);
  const Root = (_b = slots.root) != null ? _b : "div";
  const rootProps = useSlotProps({
    elementType: Root,
    externalSlotProps: slotProps.root,
    externalForwardedProps: other,
    additionalProps: {
      role: "tooltip",
      ref: ownRef
    },
    ownerState: props,
    className: classes.root
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root, __spreadProps(__spreadValues({}, rootProps), {
    children: typeof children === "function" ? children(childProps) : children
  }));
});
const Popper$1 = /* @__PURE__ */ reactExports.forwardRef(function Popper2(props, forwardedRef) {
  const _a2 = props, {
    anchorEl,
    children,
    container: containerProp,
    direction = "ltr",
    disablePortal = false,
    keepMounted = false,
    modifiers,
    open,
    placement = "bottom",
    popperOptions = defaultPopperOptions,
    popperRef,
    style: style2,
    transition = false,
    slotProps = {},
    slots = {}
  } = _a2, other = __objRest(_a2, [
    "anchorEl",
    "children",
    "container",
    "direction",
    "disablePortal",
    "keepMounted",
    "modifiers",
    "open",
    "placement",
    "popperOptions",
    "popperRef",
    "style",
    "transition",
    "slotProps",
    "slots"
  ]);
  const [exited, setExited] = reactExports.useState(true);
  const handleEnter = () => {
    setExited(false);
  };
  const handleExited = () => {
    setExited(true);
  };
  if (!keepMounted && !open && (!transition || exited)) {
    return null;
  }
  let container;
  if (containerProp) {
    container = containerProp;
  } else if (anchorEl) {
    const resolvedAnchorEl = resolveAnchorEl$1(anchorEl);
    container = resolvedAnchorEl && isHTMLElement(resolvedAnchorEl) ? ownerDocument(resolvedAnchorEl).body : ownerDocument(null).body;
  }
  const display = !open && keepMounted && (!transition || exited) ? "none" : void 0;
  const transitionProps = transition ? {
    in: open,
    onEnter: handleEnter,
    onExited: handleExited
  } : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
    disablePortal,
    container,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopperTooltip, __spreadProps(__spreadValues({
      anchorEl,
      direction,
      disablePortal,
      modifiers,
      ref: forwardedRef,
      open: transition ? !exited : open,
      placement,
      popperOptions,
      popperRef,
      slotProps,
      slots
    }, other), {
      style: __spreadValues({
        // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
        position: "fixed",
        // Fix Popper.js display issue
        top: 0,
        left: 0,
        display
      }, style2),
      TransitionProps: transitionProps,
      children
    }))
  });
});
const PopperRoot = styled(Popper$1, {
  name: "MuiPopper",
  slot: "Root"
})({});
const Popper = /* @__PURE__ */ reactExports.forwardRef(function Popper22(inProps, ref) {
  var _b;
  const isRtl = useRtl();
  const props = useDefaultProps({
    props: inProps,
    name: "MuiPopper"
  });
  const _a2 = props, {
    anchorEl,
    component,
    components,
    componentsProps,
    container,
    disablePortal,
    keepMounted,
    modifiers,
    open,
    placement,
    popperOptions,
    popperRef,
    transition,
    slots,
    slotProps
  } = _a2, other = __objRest(_a2, [
    "anchorEl",
    "component",
    "components",
    "componentsProps",
    "container",
    "disablePortal",
    "keepMounted",
    "modifiers",
    "open",
    "placement",
    "popperOptions",
    "popperRef",
    "transition",
    "slots",
    "slotProps"
  ]);
  const RootComponent = (_b = slots == null ? void 0 : slots.root) != null ? _b : components == null ? void 0 : components.Root;
  const otherProps = __spreadValues({
    anchorEl,
    container,
    disablePortal,
    keepMounted,
    modifiers,
    open,
    placement,
    popperOptions,
    popperRef,
    transition
  }, other);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperRoot, __spreadProps(__spreadValues({
    as: component,
    direction: isRtl ? "rtl" : "ltr",
    slots: {
      root: RootComponent
    },
    slotProps: slotProps != null ? slotProps : componentsProps
  }, otherProps), {
    ref
  }));
});
const CancelIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"
}));
function getChipUtilityClass(slot) {
  return generateUtilityClass("MuiChip", slot);
}
const chipClasses = generateUtilityClasses("MuiChip", ["root", "sizeSmall", "sizeMedium", "colorDefault", "colorError", "colorInfo", "colorPrimary", "colorSecondary", "colorSuccess", "colorWarning", "disabled", "clickable", "clickableColorPrimary", "clickableColorSecondary", "deletable", "deletableColorPrimary", "deletableColorSecondary", "outlined", "filled", "outlinedPrimary", "outlinedSecondary", "filledPrimary", "filledSecondary", "avatar", "avatarSmall", "avatarMedium", "avatarColorPrimary", "avatarColorSecondary", "icon", "iconSmall", "iconMedium", "iconColorPrimary", "iconColorSecondary", "label", "labelSmall", "labelMedium", "deleteIcon", "deleteIconSmall", "deleteIconMedium", "deleteIconColorPrimary", "deleteIconColorSecondary", "deleteIconOutlinedColorPrimary", "deleteIconOutlinedColorSecondary", "deleteIconFilledColorPrimary", "deleteIconFilledColorSecondary", "focusVisible"]);
const useUtilityClasses$16 = (ownerState) => {
  const {
    classes,
    disabled,
    size,
    color: color2,
    iconColor,
    onDelete,
    clickable,
    variant
  } = ownerState;
  const slots = {
    root: ["root", variant, disabled && "disabled", `size${capitalize(size)}`, `color${capitalize(color2)}`, clickable && "clickable", clickable && `clickableColor${capitalize(color2)}`, onDelete && "deletable", onDelete && `deletableColor${capitalize(color2)}`, `${variant}${capitalize(color2)}`],
    label: ["label", `label${capitalize(size)}`],
    avatar: ["avatar", `avatar${capitalize(size)}`, `avatarColor${capitalize(color2)}`],
    icon: ["icon", `icon${capitalize(size)}`, `iconColor${capitalize(iconColor)}`],
    deleteIcon: ["deleteIcon", `deleteIcon${capitalize(size)}`, `deleteIconColor${capitalize(color2)}`, `deleteIcon${capitalize(variant)}Color${capitalize(color2)}`]
  };
  return composeClasses(slots, getChipUtilityClass, classes);
};
const ChipRoot = styled("div", {
  name: "MuiChip",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      color: color2,
      iconColor,
      clickable,
      onDelete,
      size,
      variant
    } = ownerState;
    return [{
      [`& .${chipClasses.avatar}`]: styles2.avatar
    }, {
      [`& .${chipClasses.avatar}`]: styles2[`avatar${capitalize(size)}`]
    }, {
      [`& .${chipClasses.avatar}`]: styles2[`avatarColor${capitalize(color2)}`]
    }, {
      [`& .${chipClasses.icon}`]: styles2.icon
    }, {
      [`& .${chipClasses.icon}`]: styles2[`icon${capitalize(size)}`]
    }, {
      [`& .${chipClasses.icon}`]: styles2[`iconColor${capitalize(iconColor)}`]
    }, {
      [`& .${chipClasses.deleteIcon}`]: styles2.deleteIcon
    }, {
      [`& .${chipClasses.deleteIcon}`]: styles2[`deleteIcon${capitalize(size)}`]
    }, {
      [`& .${chipClasses.deleteIcon}`]: styles2[`deleteIconColor${capitalize(color2)}`]
    }, {
      [`& .${chipClasses.deleteIcon}`]: styles2[`deleteIcon${capitalize(variant)}Color${capitalize(color2)}`]
    }, styles2.root, styles2[`size${capitalize(size)}`], styles2[`color${capitalize(color2)}`], clickable && styles2.clickable, clickable && color2 !== "default" && styles2[`clickableColor${capitalize(color2)})`], onDelete && styles2.deletable, onDelete && color2 !== "default" && styles2[`deletableColor${capitalize(color2)}`], styles2[variant], styles2[`${variant}${capitalize(color2)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => {
  const textColor = theme2.palette.mode === "light" ? theme2.palette.grey[700] : theme2.palette.grey[300];
  return {
    maxWidth: "100%",
    fontFamily: theme2.typography.fontFamily,
    fontSize: theme2.typography.pxToRem(13),
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    height: 32,
    lineHeight: 1.5,
    color: (theme2.vars || theme2).palette.text.primary,
    backgroundColor: (theme2.vars || theme2).palette.action.selected,
    borderRadius: 32 / 2,
    whiteSpace: "nowrap",
    transition: theme2.transitions.create(["background-color", "box-shadow"]),
    // reset cursor explicitly in case ButtonBase is used
    cursor: "unset",
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    textDecoration: "none",
    border: 0,
    // Remove `button` border
    padding: 0,
    // Remove `button` padding
    verticalAlign: "middle",
    boxSizing: "border-box",
    [`&.${chipClasses.disabled}`]: {
      opacity: (theme2.vars || theme2).palette.action.disabledOpacity,
      pointerEvents: "none"
    },
    [`& .${chipClasses.avatar}`]: {
      marginLeft: 5,
      marginRight: -6,
      width: 24,
      height: 24,
      color: theme2.vars ? theme2.vars.palette.Chip.defaultAvatarColor : textColor,
      fontSize: theme2.typography.pxToRem(12)
    },
    [`& .${chipClasses.avatarColorPrimary}`]: {
      color: (theme2.vars || theme2).palette.primary.contrastText,
      backgroundColor: (theme2.vars || theme2).palette.primary.dark
    },
    [`& .${chipClasses.avatarColorSecondary}`]: {
      color: (theme2.vars || theme2).palette.secondary.contrastText,
      backgroundColor: (theme2.vars || theme2).palette.secondary.dark
    },
    [`& .${chipClasses.avatarSmall}`]: {
      marginLeft: 4,
      marginRight: -4,
      width: 18,
      height: 18,
      fontSize: theme2.typography.pxToRem(10)
    },
    [`& .${chipClasses.icon}`]: {
      marginLeft: 5,
      marginRight: -6
    },
    [`& .${chipClasses.deleteIcon}`]: {
      WebkitTapHighlightColor: "transparent",
      color: theme2.alpha((theme2.vars || theme2).palette.text.primary, 0.26),
      fontSize: 22,
      cursor: "pointer",
      margin: "0 5px 0 -6px",
      "&:hover": {
        color: theme2.alpha((theme2.vars || theme2).palette.text.primary, 0.4)
      }
    },
    variants: [{
      props: {
        size: "small"
      },
      style: {
        height: 24,
        [`& .${chipClasses.icon}`]: {
          fontSize: 18,
          marginLeft: 4,
          marginRight: -4
        },
        [`& .${chipClasses.deleteIcon}`]: {
          fontSize: 16,
          marginRight: 4,
          marginLeft: -4
        }
      }
    }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["contrastText"])).map(([color2]) => {
      return {
        props: {
          color: color2
        },
        style: {
          backgroundColor: (theme2.vars || theme2).palette[color2].main,
          color: (theme2.vars || theme2).palette[color2].contrastText,
          [`& .${chipClasses.deleteIcon}`]: {
            color: theme2.alpha((theme2.vars || theme2).palette[color2].contrastText, 0.7),
            "&:hover, &:active": {
              color: (theme2.vars || theme2).palette[color2].contrastText
            }
          }
        }
      };
    }), {
      props: (props) => props.iconColor === props.color,
      style: {
        [`& .${chipClasses.icon}`]: {
          color: theme2.vars ? theme2.vars.palette.Chip.defaultIconColor : textColor
        }
      }
    }, {
      props: (props) => props.iconColor === props.color && props.color !== "default",
      style: {
        [`& .${chipClasses.icon}`]: {
          color: "inherit"
        }
      }
    }, {
      props: {
        onDelete: true
      },
      style: {
        [`&.${chipClasses.focusVisible}`]: {
          backgroundColor: theme2.alpha((theme2.vars || theme2).palette.action.selected, `${(theme2.vars || theme2).palette.action.selectedOpacity} + ${(theme2.vars || theme2).palette.action.focusOpacity}`)
        }
      }
    }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["dark"])).map(([color2]) => {
      return {
        props: {
          color: color2,
          onDelete: true
        },
        style: {
          [`&.${chipClasses.focusVisible}`]: {
            background: (theme2.vars || theme2).palette[color2].dark
          }
        }
      };
    }), {
      props: {
        clickable: true
      },
      style: {
        userSelect: "none",
        WebkitTapHighlightColor: "transparent",
        cursor: "pointer",
        "&:hover": {
          backgroundColor: theme2.alpha((theme2.vars || theme2).palette.action.selected, `${(theme2.vars || theme2).palette.action.selectedOpacity} + ${(theme2.vars || theme2).palette.action.hoverOpacity}`)
        },
        [`&.${chipClasses.focusVisible}`]: {
          backgroundColor: theme2.alpha((theme2.vars || theme2).palette.action.selected, `${(theme2.vars || theme2).palette.action.selectedOpacity} + ${(theme2.vars || theme2).palette.action.focusOpacity}`)
        },
        "&:active": {
          boxShadow: (theme2.vars || theme2).shadows[1]
        }
      }
    }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["dark"])).map(([color2]) => ({
      props: {
        color: color2,
        clickable: true
      },
      style: {
        [`&:hover, &.${chipClasses.focusVisible}`]: {
          backgroundColor: (theme2.vars || theme2).palette[color2].dark
        }
      }
    })), {
      props: {
        variant: "outlined"
      },
      style: {
        backgroundColor: "transparent",
        border: theme2.vars ? `1px solid ${theme2.vars.palette.Chip.defaultBorder}` : `1px solid ${theme2.palette.mode === "light" ? theme2.palette.grey[400] : theme2.palette.grey[700]}`,
        [`&.${chipClasses.clickable}:hover`]: {
          backgroundColor: (theme2.vars || theme2).palette.action.hover
        },
        [`&.${chipClasses.focusVisible}`]: {
          backgroundColor: (theme2.vars || theme2).palette.action.focus
        },
        [`& .${chipClasses.avatar}`]: {
          marginLeft: 4
        },
        [`& .${chipClasses.avatarSmall}`]: {
          marginLeft: 2
        },
        [`& .${chipClasses.icon}`]: {
          marginLeft: 4
        },
        [`& .${chipClasses.iconSmall}`]: {
          marginLeft: 2
        },
        [`& .${chipClasses.deleteIcon}`]: {
          marginRight: 5
        },
        [`& .${chipClasses.deleteIconSmall}`]: {
          marginRight: 3
        }
      }
    }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
      props: {
        variant: "outlined",
        color: color2
      },
      style: {
        color: (theme2.vars || theme2).palette[color2].main,
        border: `1px solid ${theme2.alpha((theme2.vars || theme2).palette[color2].main, 0.7)}`,
        [`&.${chipClasses.clickable}:hover`]: {
          backgroundColor: theme2.alpha((theme2.vars || theme2).palette[color2].main, (theme2.vars || theme2).palette.action.hoverOpacity)
        },
        [`&.${chipClasses.focusVisible}`]: {
          backgroundColor: theme2.alpha((theme2.vars || theme2).palette[color2].main, (theme2.vars || theme2).palette.action.focusOpacity)
        },
        [`& .${chipClasses.deleteIcon}`]: {
          color: theme2.alpha((theme2.vars || theme2).palette[color2].main, 0.7),
          "&:hover, &:active": {
            color: (theme2.vars || theme2).palette[color2].main
          }
        }
      }
    }))]
  };
}));
const ChipLabel = styled("span", {
  name: "MuiChip",
  slot: "Label",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      size
    } = ownerState;
    return [styles2.label, styles2[`label${capitalize(size)}`]];
  }
})({
  overflow: "hidden",
  textOverflow: "ellipsis",
  paddingLeft: 12,
  paddingRight: 12,
  whiteSpace: "nowrap",
  variants: [{
    props: {
      variant: "outlined"
    },
    style: {
      paddingLeft: 11,
      paddingRight: 11
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      paddingLeft: 8,
      paddingRight: 8
    }
  }, {
    props: {
      size: "small",
      variant: "outlined"
    },
    style: {
      paddingLeft: 7,
      paddingRight: 7
    }
  }]
});
function isDeleteKeyboardEvent(keyboardEvent) {
  return keyboardEvent.key === "Backspace" || keyboardEvent.key === "Delete";
}
const Chip = /* @__PURE__ */ reactExports.forwardRef(function Chip2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiChip"
  });
  const _a2 = props, {
    avatar: avatarProp,
    className,
    clickable: clickableProp,
    color: color2 = "default",
    component: ComponentProp,
    deleteIcon: deleteIconProp,
    disabled = false,
    icon: iconProp,
    label,
    onClick,
    onDelete,
    onKeyDown,
    onKeyUp,
    size = "medium",
    variant = "filled",
    tabIndex,
    skipFocusWhenDisabled = false,
    slots: slots = {},
    slotProps = {}
  } = _a2, other = __objRest(_a2, [
    "avatar",
    "className",
    "clickable",
    "color",
    "component",
    "deleteIcon",
    "disabled",
    "icon",
    "label",
    "onClick",
    "onDelete",
    "onKeyDown",
    "onKeyUp",
    "size",
    "variant",
    "tabIndex",
    "skipFocusWhenDisabled",
    // TODO v6: Rename to `focusableWhenDisabled`.
    "slots",
    "slotProps"
  ]);
  const chipRef = reactExports.useRef(null);
  const handleRef = useForkRef(chipRef, ref);
  const handleDeleteIconClick = (event) => {
    event.stopPropagation();
    if (onDelete) {
      onDelete(event);
    }
  };
  const handleKeyDown = (event) => {
    if (event.currentTarget === event.target && isDeleteKeyboardEvent(event)) {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  };
  const handleKeyUp = (event) => {
    if (event.currentTarget === event.target) {
      if (onDelete && isDeleteKeyboardEvent(event)) {
        onDelete(event);
      }
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
  };
  const clickable = clickableProp !== false && onClick ? true : clickableProp;
  const component = clickable || onDelete ? ButtonBase : ComponentProp || "div";
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component,
    disabled,
    size,
    color: color2,
    iconColor: /* @__PURE__ */ reactExports.isValidElement(iconProp) ? iconProp.props.color || color2 : color2,
    onDelete: !!onDelete,
    clickable,
    variant
  });
  const classes = useUtilityClasses$16(ownerState);
  const moreProps = component === ButtonBase ? __spreadValues({
    component: ComponentProp || "div",
    focusVisibleClassName: classes.focusVisible
  }, onDelete && {
    disableRipple: true
  }) : {};
  let deleteIcon = null;
  if (onDelete) {
    deleteIcon = deleteIconProp && /* @__PURE__ */ reactExports.isValidElement(deleteIconProp) ? /* @__PURE__ */ reactExports.cloneElement(deleteIconProp, {
      className: clsx(deleteIconProp.props.className, classes.deleteIcon),
      onClick: handleDeleteIconClick
    }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CancelIcon, {
      className: classes.deleteIcon,
      onClick: handleDeleteIconClick
    });
  }
  let avatar = null;
  if (avatarProp && /* @__PURE__ */ reactExports.isValidElement(avatarProp)) {
    avatar = /* @__PURE__ */ reactExports.cloneElement(avatarProp, {
      className: clsx(classes.avatar, avatarProp.props.className)
    });
  }
  let icon = null;
  if (iconProp && /* @__PURE__ */ reactExports.isValidElement(iconProp)) {
    icon = /* @__PURE__ */ reactExports.cloneElement(iconProp, {
      className: clsx(classes.icon, iconProp.props.className)
    });
  }
  const externalForwardedProps = {
    slots,
    slotProps
  };
  const [RootSlot, rootProps] = useSlot("root", {
    elementType: ChipRoot,
    externalForwardedProps: __spreadValues(__spreadValues({}, externalForwardedProps), other),
    ownerState,
    // The `component` prop is preserved because `Chip` relies on it for internal logic. If `shouldForwardComponentProp` were `false`, `useSlot` would remove the `component` prop, potentially breaking the component's behavior.
    shouldForwardComponentProp: true,
    ref: handleRef,
    className: clsx(classes.root, className),
    additionalProps: __spreadValues({
      disabled: clickable && disabled ? true : void 0,
      tabIndex: skipFocusWhenDisabled && disabled ? -1 : tabIndex
    }, moreProps),
    getSlotProps: (handlers) => __spreadProps(__spreadValues({}, handlers), {
      onClick: (event) => {
        var _a3;
        (_a3 = handlers.onClick) == null ? void 0 : _a3.call(handlers, event);
        onClick == null ? void 0 : onClick(event);
      },
      onKeyDown: (event) => {
        var _a3;
        (_a3 = handlers.onKeyDown) == null ? void 0 : _a3.call(handlers, event);
        handleKeyDown(event);
      },
      onKeyUp: (event) => {
        var _a3;
        (_a3 = handlers.onKeyUp) == null ? void 0 : _a3.call(handlers, event);
        handleKeyUp(event);
      }
    })
  });
  const [LabelSlot, labelProps] = useSlot("label", {
    elementType: ChipLabel,
    externalForwardedProps,
    ownerState,
    className: classes.label
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, __spreadProps(__spreadValues({
    as: component
  }, rootProps), {
    children: [avatar || icon, /* @__PURE__ */ jsxRuntimeExports.jsx(LabelSlot, __spreadProps(__spreadValues({}, labelProps), {
      children: label
    })), deleteIcon]
  }));
});
function getStyleValue(value) {
  return parseInt(value, 10) || 0;
}
const styles$4 = {
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: "hidden",
    // Remove from the content flow
    position: "absolute",
    // Ignore the scrollbar width
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: "translateZ(0)"
  }
};
function isObjectEmpty(object) {
  for (const _ in object) {
    return false;
  }
  return true;
}
function isEmpty$1(obj) {
  return isObjectEmpty(obj) || obj.outerHeightStyle === 0 && !obj.overflowing;
}
const TextareaAutosize = /* @__PURE__ */ reactExports.forwardRef(function TextareaAutosize2(props, forwardedRef) {
  const _a2 = props, {
    onChange,
    maxRows,
    minRows = 1,
    style: style2,
    value
  } = _a2, other = __objRest(_a2, [
    "onChange",
    "maxRows",
    "minRows",
    "style",
    "value"
  ]);
  const {
    current: isControlled
  } = reactExports.useRef(value != null);
  const textareaRef = reactExports.useRef(null);
  const handleRef = useForkRef(forwardedRef, textareaRef);
  const heightRef = reactExports.useRef(null);
  const hiddenTextareaRef = reactExports.useRef(null);
  const calculateTextareaStyles = reactExports.useCallback(() => {
    const textarea = textareaRef.current;
    const hiddenTextarea = hiddenTextareaRef.current;
    if (!textarea || !hiddenTextarea) {
      return void 0;
    }
    const containerWindow = ownerWindow(textarea);
    const computedStyle = containerWindow.getComputedStyle(textarea);
    if (computedStyle.width === "0px") {
      return {
        outerHeightStyle: 0,
        overflowing: false
      };
    }
    hiddenTextarea.style.width = computedStyle.width;
    hiddenTextarea.value = textarea.value || props.placeholder || "x";
    if (hiddenTextarea.value.slice(-1) === "\n") {
      hiddenTextarea.value += " ";
    }
    const boxSizing2 = computedStyle.boxSizing;
    const padding2 = getStyleValue(computedStyle.paddingBottom) + getStyleValue(computedStyle.paddingTop);
    const border2 = getStyleValue(computedStyle.borderBottomWidth) + getStyleValue(computedStyle.borderTopWidth);
    const innerHeight = hiddenTextarea.scrollHeight;
    hiddenTextarea.value = "x";
    const singleRowHeight = hiddenTextarea.scrollHeight;
    let outerHeight = innerHeight;
    if (minRows) {
      outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
    }
    if (maxRows) {
      outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
    }
    outerHeight = Math.max(outerHeight, singleRowHeight);
    const outerHeightStyle = outerHeight + (boxSizing2 === "border-box" ? padding2 + border2 : 0);
    const overflowing = Math.abs(outerHeight - innerHeight) <= 1;
    return {
      outerHeightStyle,
      overflowing
    };
  }, [maxRows, minRows, props.placeholder]);
  const didHeightChange = useEventCallback(() => {
    const textarea = textareaRef.current;
    const textareaStyles = calculateTextareaStyles();
    if (!textarea || !textareaStyles || isEmpty$1(textareaStyles)) {
      return false;
    }
    const outerHeightStyle = textareaStyles.outerHeightStyle;
    return heightRef.current != null && heightRef.current !== outerHeightStyle;
  });
  const syncHeight = reactExports.useCallback(() => {
    const textarea = textareaRef.current;
    const textareaStyles = calculateTextareaStyles();
    if (!textarea || !textareaStyles || isEmpty$1(textareaStyles)) {
      return;
    }
    const outerHeightStyle = textareaStyles.outerHeightStyle;
    if (heightRef.current !== outerHeightStyle) {
      heightRef.current = outerHeightStyle;
      textarea.style.height = `${outerHeightStyle}px`;
    }
    textarea.style.overflow = textareaStyles.overflowing ? "hidden" : "";
  }, [calculateTextareaStyles]);
  const frameRef = reactExports.useRef(-1);
  useEnhancedEffect(() => {
    const debouncedHandleResize = debounce$1(syncHeight);
    const textarea = textareaRef == null ? void 0 : textareaRef.current;
    if (!textarea) {
      return void 0;
    }
    const containerWindow = ownerWindow(textarea);
    containerWindow.addEventListener("resize", debouncedHandleResize);
    let resizeObserver;
    if (typeof ResizeObserver !== "undefined") {
      resizeObserver = new ResizeObserver(() => {
        if (didHeightChange()) {
          resizeObserver.unobserve(textarea);
          cancelAnimationFrame(frameRef.current);
          syncHeight();
          frameRef.current = requestAnimationFrame(() => {
            resizeObserver.observe(textarea);
          });
        }
      });
      resizeObserver.observe(textarea);
    }
    return () => {
      debouncedHandleResize.clear();
      cancelAnimationFrame(frameRef.current);
      containerWindow.removeEventListener("resize", debouncedHandleResize);
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    };
  }, [calculateTextareaStyles, syncHeight, didHeightChange]);
  useEnhancedEffect(() => {
    syncHeight();
  });
  const handleChange = (event) => {
    if (!isControlled) {
      syncHeight();
    }
    const textarea = event.target;
    const countOfCharacters = textarea.value.length;
    const isLastCharacterNewLine = textarea.value.endsWith("\n");
    const isEndOfTheLine = textarea.selectionStart === countOfCharacters;
    if (isLastCharacterNewLine && isEndOfTheLine) {
      textarea.setSelectionRange(countOfCharacters, countOfCharacters);
    }
    if (onChange) {
      onChange(event);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("textarea", __spreadValues({
      value,
      onChange: handleChange,
      ref: handleRef,
      rows: minRows,
      style: style2
    }, other)), /* @__PURE__ */ jsxRuntimeExports.jsx("textarea", {
      "aria-hidden": true,
      className: props.className,
      readOnly: true,
      ref: hiddenTextareaRef,
      tabIndex: -1,
      style: __spreadProps(__spreadValues(__spreadValues({}, styles$4.shadow), style2), {
        paddingTop: 0,
        paddingBottom: 0
      })
    })]
  });
});
function formControlState({
  props,
  states,
  muiFormControl
}) {
  return states.reduce((acc, state) => {
    acc[state] = props[state];
    if (muiFormControl) {
      if (typeof props[state] === "undefined") {
        acc[state] = muiFormControl[state];
      }
    }
    return acc;
  }, {});
}
const FormControlContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useFormControl() {
  return reactExports.useContext(FormControlContext);
}
function hasValue(value) {
  return value != null && !(Array.isArray(value) && value.length === 0);
}
function isFilled(obj, SSR = false) {
  return obj && (hasValue(obj.value) && obj.value !== "" || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== "");
}
function isAdornedStart(obj) {
  return obj.startAdornment;
}
function getInputBaseUtilityClass(slot) {
  return generateUtilityClass("MuiInputBase", slot);
}
const inputBaseClasses = generateUtilityClasses("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
var _InputGlobalStyles;
const rootOverridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.formControl && styles2.formControl, ownerState.startAdornment && styles2.adornedStart, ownerState.endAdornment && styles2.adornedEnd, ownerState.error && styles2.error, ownerState.size === "small" && styles2.sizeSmall, ownerState.multiline && styles2.multiline, ownerState.color && styles2[`color${capitalize(ownerState.color)}`], ownerState.fullWidth && styles2.fullWidth, ownerState.hiddenLabel && styles2.hiddenLabel];
};
const inputOverridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.input, ownerState.size === "small" && styles2.inputSizeSmall, ownerState.multiline && styles2.inputMultiline, ownerState.type === "search" && styles2.inputTypeSearch, ownerState.startAdornment && styles2.inputAdornedStart, ownerState.endAdornment && styles2.inputAdornedEnd, ownerState.hiddenLabel && styles2.inputHiddenLabel];
};
const useUtilityClasses$15 = (ownerState) => {
  const {
    classes,
    color: color2,
    disabled,
    error: error2,
    endAdornment,
    focused,
    formControl,
    fullWidth,
    hiddenLabel,
    multiline,
    readOnly,
    size,
    startAdornment,
    type
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize(color2)}`, disabled && "disabled", error2 && "error", fullWidth && "fullWidth", focused && "focused", formControl && "formControl", size && size !== "medium" && `size${capitalize(size)}`, multiline && "multiline", startAdornment && "adornedStart", endAdornment && "adornedEnd", hiddenLabel && "hiddenLabel", readOnly && "readOnly"],
    input: ["input", disabled && "disabled", type === "search" && "inputTypeSearch", multiline && "inputMultiline", size === "small" && "inputSizeSmall", hiddenLabel && "inputHiddenLabel", startAdornment && "inputAdornedStart", endAdornment && "inputAdornedEnd", readOnly && "readOnly"]
  };
  return composeClasses(slots, getInputBaseUtilityClass, classes);
};
const InputBaseRoot = styled("div", {
  name: "MuiInputBase",
  slot: "Root",
  overridesResolver: rootOverridesResolver
})(memoTheme(({
  theme: theme2
}) => __spreadProps(__spreadValues({}, theme2.typography.body1), {
  color: (theme2.vars || theme2).palette.text.primary,
  lineHeight: "1.4375em",
  // 23px
  boxSizing: "border-box",
  // Prevent padding issue with fullWidth.
  position: "relative",
  cursor: "text",
  display: "inline-flex",
  alignItems: "center",
  [`&.${inputBaseClasses.disabled}`]: {
    color: (theme2.vars || theme2).palette.text.disabled,
    cursor: "default"
  },
  variants: [{
    props: ({
      ownerState
    }) => ownerState.multiline,
    style: {
      padding: "4px 0 5px"
    }
  }, {
    props: ({
      ownerState,
      size
    }) => ownerState.multiline && size === "small",
    style: {
      paddingTop: 1
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.fullWidth,
    style: {
      width: "100%"
    }
  }]
})));
const InputBaseInput = styled("input", {
  name: "MuiInputBase",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(memoTheme(({
  theme: theme2
}) => {
  const light2 = theme2.palette.mode === "light";
  const placeholder = __spreadProps(__spreadValues({
    color: "currentColor"
  }, theme2.vars ? {
    opacity: theme2.vars.opacity.inputPlaceholder
  } : {
    opacity: light2 ? 0.42 : 0.5
  }), {
    transition: theme2.transitions.create("opacity", {
      duration: theme2.transitions.duration.shorter
    })
  });
  const placeholderHidden = {
    opacity: "0 !important"
  };
  const placeholderVisible = theme2.vars ? {
    opacity: theme2.vars.opacity.inputPlaceholder
  } : {
    opacity: light2 ? 0.42 : 0.5
  };
  return {
    font: "inherit",
    letterSpacing: "inherit",
    color: "currentColor",
    padding: "4px 0 5px",
    border: 0,
    boxSizing: "content-box",
    background: "none",
    height: "1.4375em",
    // Reset 23pxthe native input line-height
    margin: 0,
    // Reset for Safari
    WebkitTapHighlightColor: "transparent",
    display: "block",
    // Make the flex item shrink with Firefox
    minWidth: 0,
    width: "100%",
    "&::-webkit-input-placeholder": placeholder,
    "&::-moz-placeholder": placeholder,
    // Firefox 19+
    "&::-ms-input-placeholder": placeholder,
    // Edge
    "&:focus": {
      outline: 0
    },
    // Reset Firefox invalid required input style
    "&:invalid": {
      boxShadow: "none"
    },
    "&::-webkit-search-decoration": {
      // Remove the padding when type=search.
      WebkitAppearance: "none"
    },
    // Show and hide the placeholder logic
    [`label[data-shrink=false] + .${inputBaseClasses.formControl} &`]: {
      "&::-webkit-input-placeholder": placeholderHidden,
      "&::-moz-placeholder": placeholderHidden,
      // Firefox 19+
      "&::-ms-input-placeholder": placeholderHidden,
      // Edge
      "&:focus::-webkit-input-placeholder": placeholderVisible,
      "&:focus::-moz-placeholder": placeholderVisible,
      // Firefox 19+
      "&:focus::-ms-input-placeholder": placeholderVisible
      // Edge
    },
    [`&.${inputBaseClasses.disabled}`]: {
      opacity: 1,
      // Reset iOS opacity
      WebkitTextFillColor: (theme2.vars || theme2).palette.text.disabled
      // Fix opacity Safari bug
    },
    variants: [{
      props: ({
        ownerState
      }) => !ownerState.disableInjectingGlobalStyles,
      style: {
        animationName: "mui-auto-fill-cancel",
        animationDuration: "10ms",
        "&:-webkit-autofill": {
          animationDuration: "5000s",
          animationName: "mui-auto-fill"
        }
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        paddingTop: 1
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.multiline,
      style: {
        height: "auto",
        resize: "none",
        padding: 0,
        paddingTop: 0
      }
    }, {
      props: {
        type: "search"
      },
      style: {
        MozAppearance: "textfield"
        // Improve type search style.
      }
    }]
  };
}));
const InputGlobalStyles = globalCss({
  "@keyframes mui-auto-fill": {
    from: {
      display: "block"
    }
  },
  "@keyframes mui-auto-fill-cancel": {
    from: {
      display: "block"
    }
  }
});
const InputBase = /* @__PURE__ */ reactExports.forwardRef(function InputBase2(inProps, ref) {
  var _b;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiInputBase"
  });
  const _a2 = props, {
    "aria-describedby": ariaDescribedby,
    autoComplete,
    autoFocus,
    className,
    color: color2,
    components = {},
    componentsProps = {},
    defaultValue,
    disabled,
    disableInjectingGlobalStyles,
    endAdornment,
    error: error2,
    fullWidth = false,
    id,
    inputComponent = "input",
    inputProps: inputPropsProp = {},
    inputRef: inputRefProp,
    margin: margin2,
    maxRows,
    minRows,
    multiline = false,
    name: name2,
    onBlur,
    onChange,
    onClick,
    onFocus,
    onKeyDown,
    onKeyUp,
    placeholder,
    readOnly,
    renderSuffix,
    rows,
    size,
    slotProps = {},
    slots = {},
    startAdornment,
    type = "text",
    value: valueProp
  } = _a2, other = __objRest(_a2, [
    "aria-describedby",
    "autoComplete",
    "autoFocus",
    "className",
    "color",
    "components",
    "componentsProps",
    "defaultValue",
    "disabled",
    "disableInjectingGlobalStyles",
    "endAdornment",
    "error",
    "fullWidth",
    "id",
    "inputComponent",
    "inputProps",
    "inputRef",
    "margin",
    "maxRows",
    "minRows",
    "multiline",
    "name",
    "onBlur",
    "onChange",
    "onClick",
    "onFocus",
    "onKeyDown",
    "onKeyUp",
    "placeholder",
    "readOnly",
    "renderSuffix",
    "rows",
    "size",
    "slotProps",
    "slots",
    "startAdornment",
    "type",
    "value"
  ]);
  const value = inputPropsProp.value != null ? inputPropsProp.value : valueProp;
  const {
    current: isControlled
  } = reactExports.useRef(value != null);
  const inputRef = reactExports.useRef();
  const handleInputRefWarning = reactExports.useCallback((instance) => {
  }, []);
  const handleInputRef = useForkRef(inputRef, inputRefProp, inputPropsProp.ref, handleInputRefWarning);
  const [focused, setFocused] = reactExports.useState(false);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
  });
  fcs.focused = muiFormControl ? muiFormControl.focused : focused;
  reactExports.useEffect(() => {
    if (!muiFormControl && disabled && focused) {
      setFocused(false);
      if (onBlur) {
        onBlur();
      }
    }
  }, [muiFormControl, disabled, focused, onBlur]);
  const onFilled = muiFormControl && muiFormControl.onFilled;
  const onEmpty = muiFormControl && muiFormControl.onEmpty;
  const checkDirty = reactExports.useCallback((obj) => {
    if (isFilled(obj)) {
      if (onFilled) {
        onFilled();
      }
    } else if (onEmpty) {
      onEmpty();
    }
  }, [onFilled, onEmpty]);
  useEnhancedEffect(() => {
    if (isControlled) {
      checkDirty({
        value
      });
    }
  }, [value, checkDirty, isControlled]);
  const handleFocus = (event) => {
    if (onFocus) {
      onFocus(event);
    }
    if (inputPropsProp.onFocus) {
      inputPropsProp.onFocus(event);
    }
    if (muiFormControl && muiFormControl.onFocus) {
      muiFormControl.onFocus(event);
    } else {
      setFocused(true);
    }
  };
  const handleBlur = (event) => {
    if (onBlur) {
      onBlur(event);
    }
    if (inputPropsProp.onBlur) {
      inputPropsProp.onBlur(event);
    }
    if (muiFormControl && muiFormControl.onBlur) {
      muiFormControl.onBlur(event);
    } else {
      setFocused(false);
    }
  };
  const handleChange = (event, ...args) => {
    if (!isControlled) {
      const element = event.target || inputRef.current;
      if (element == null) {
        throw new Error(formatMuiErrorMessage(1));
      }
      checkDirty({
        value: element.value
      });
    }
    if (inputPropsProp.onChange) {
      inputPropsProp.onChange(event, ...args);
    }
    if (onChange) {
      onChange(event, ...args);
    }
  };
  reactExports.useEffect(() => {
    checkDirty(inputRef.current);
  }, []);
  const handleClick = (event) => {
    if (inputRef.current && event.currentTarget === event.target) {
      inputRef.current.focus();
    }
    if (onClick) {
      onClick(event);
    }
  };
  let InputComponent = inputComponent;
  let inputProps = inputPropsProp;
  if (multiline && InputComponent === "input") {
    if (rows) {
      inputProps = __spreadValues({
        type: void 0,
        minRows: rows,
        maxRows: rows
      }, inputProps);
    } else {
      inputProps = __spreadValues({
        type: void 0,
        maxRows,
        minRows
      }, inputProps);
    }
    InputComponent = TextareaAutosize;
  }
  const handleAutoFill = (event) => {
    checkDirty(event.animationName === "mui-auto-fill-cancel" ? inputRef.current : {
      value: "x"
    });
  };
  reactExports.useEffect(() => {
    if (muiFormControl) {
      muiFormControl.setAdornedStart(Boolean(startAdornment));
    }
  }, [muiFormControl, startAdornment]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: fcs.color || "primary",
    disabled: fcs.disabled,
    endAdornment,
    error: fcs.error,
    focused: fcs.focused,
    formControl: muiFormControl,
    fullWidth,
    hiddenLabel: fcs.hiddenLabel,
    multiline,
    size: fcs.size,
    startAdornment,
    type
  });
  const classes = useUtilityClasses$15(ownerState);
  const Root = slots.root || components.Root || InputBaseRoot;
  const rootProps = slotProps.root || componentsProps.root || {};
  const Input3 = slots.input || components.Input || InputBaseInput;
  inputProps = __spreadValues(__spreadValues({}, inputProps), (_b = slotProps.input) != null ? _b : componentsProps.input);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [!disableInjectingGlobalStyles && typeof InputGlobalStyles === "function" && // For Emotion/Styled-components, InputGlobalStyles will be a function
    // For Pigment CSS, this has no effect because the InputGlobalStyles will be null.
    (_InputGlobalStyles || (_InputGlobalStyles = /* @__PURE__ */ jsxRuntimeExports.jsx(InputGlobalStyles, {}))), /* @__PURE__ */ jsxRuntimeExports.jsxs(Root, __spreadProps(__spreadValues(__spreadValues(__spreadProps(__spreadValues({}, rootProps), {
      ref,
      onClick: handleClick
    }), other), !isHostComponent(Root) && {
      ownerState: __spreadValues(__spreadValues({}, ownerState), rootProps.ownerState)
    }), {
      className: clsx(classes.root, rootProps.className, className, readOnly && "MuiInputBase-readOnly"),
      children: [startAdornment, /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext.Provider, {
        value: null,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input3, __spreadProps(__spreadValues(__spreadValues({
          "aria-invalid": fcs.error,
          "aria-describedby": ariaDescribedby,
          autoComplete,
          autoFocus,
          defaultValue,
          disabled: fcs.disabled,
          id,
          onAnimationStart: handleAutoFill,
          name: name2,
          placeholder,
          readOnly,
          required: fcs.required,
          rows,
          value,
          onKeyDown,
          onKeyUp,
          type
        }, inputProps), !isHostComponent(Input3) && {
          as: InputComponent,
          ownerState: __spreadValues(__spreadValues({}, ownerState), inputProps.ownerState)
        }), {
          ref: handleInputRef,
          className: clsx(classes.input, inputProps.className, readOnly && "MuiInputBase-readOnly"),
          onBlur: handleBlur,
          onChange: handleChange,
          onFocus: handleFocus
        }))
      }), endAdornment, renderSuffix ? renderSuffix(__spreadProps(__spreadValues({}, fcs), {
        startAdornment
      })) : null]
    }))]
  });
});
function getInputUtilityClass(slot) {
  return generateUtilityClass("MuiInput", slot);
}
const inputClasses = __spreadValues(__spreadValues({}, inputBaseClasses), generateUtilityClasses("MuiInput", ["root", "underline", "input"]));
function getOutlinedInputUtilityClass(slot) {
  return generateUtilityClass("MuiOutlinedInput", slot);
}
const outlinedInputClasses = __spreadValues(__spreadValues({}, inputBaseClasses), generateUtilityClasses("MuiOutlinedInput", ["root", "notchedOutline", "input"]));
function getFilledInputUtilityClass(slot) {
  return generateUtilityClass("MuiFilledInput", slot);
}
const filledInputClasses = __spreadValues(__spreadValues({}, inputBaseClasses), generateUtilityClasses("MuiFilledInput", ["root", "underline", "input", "adornedStart", "adornedEnd", "sizeSmall", "multiline", "hiddenLabel"]));
const ArrowDropDownIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M7 10l5 5 5-5z"
}));
const Person = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"
}));
function getAvatarUtilityClass(slot) {
  return generateUtilityClass("MuiAvatar", slot);
}
generateUtilityClasses("MuiAvatar", ["root", "colorDefault", "circular", "rounded", "square", "img", "fallback"]);
const useUtilityClasses$14 = (ownerState) => {
  const {
    classes,
    variant,
    colorDefault
  } = ownerState;
  const slots = {
    root: ["root", variant, colorDefault && "colorDefault"],
    img: ["img"],
    fallback: ["fallback"]
  };
  return composeClasses(slots, getAvatarUtilityClass, classes);
};
const AvatarRoot = styled("div", {
  name: "MuiAvatar",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], ownerState.colorDefault && styles2.colorDefault];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  position: "relative",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  flexShrink: 0,
  width: 40,
  height: 40,
  fontFamily: theme2.typography.fontFamily,
  fontSize: theme2.typography.pxToRem(20),
  lineHeight: 1,
  borderRadius: "50%",
  overflow: "hidden",
  userSelect: "none",
  variants: [{
    props: {
      variant: "rounded"
    },
    style: {
      borderRadius: (theme2.vars || theme2).shape.borderRadius
    }
  }, {
    props: {
      variant: "square"
    },
    style: {
      borderRadius: 0
    }
  }, {
    props: {
      colorDefault: true
    },
    style: __spreadValues({
      color: (theme2.vars || theme2).palette.background.default
    }, theme2.vars ? {
      backgroundColor: theme2.vars.palette.Avatar.defaultBg
    } : __spreadValues({
      backgroundColor: theme2.palette.grey[400]
    }, theme2.applyStyles("dark", {
      backgroundColor: theme2.palette.grey[600]
    })))
  }]
})));
const AvatarImg = styled("img", {
  name: "MuiAvatar",
  slot: "Img"
})({
  width: "100%",
  height: "100%",
  textAlign: "center",
  // Handle non-square image.
  objectFit: "cover",
  // Hide alt text.
  color: "transparent",
  // Hide the image broken icon, only works on Chrome.
  textIndent: 1e4
});
const AvatarFallback = styled(Person, {
  name: "MuiAvatar",
  slot: "Fallback"
})({
  width: "75%",
  height: "75%"
});
function useLoaded({
  crossOrigin,
  referrerPolicy,
  src,
  srcSet
}) {
  const [loaded, setLoaded] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (!src && !srcSet) {
      return void 0;
    }
    setLoaded(false);
    let active = true;
    const image = new Image();
    image.onload = () => {
      if (!active) {
        return;
      }
      setLoaded("loaded");
    };
    image.onerror = () => {
      if (!active) {
        return;
      }
      setLoaded("error");
    };
    image.crossOrigin = crossOrigin;
    image.referrerPolicy = referrerPolicy;
    image.src = src;
    if (srcSet) {
      image.srcset = srcSet;
    }
    return () => {
      active = false;
    };
  }, [crossOrigin, referrerPolicy, src, srcSet]);
  return loaded;
}
const Avatar = /* @__PURE__ */ reactExports.forwardRef(function Avatar2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiAvatar"
  });
  const _a2 = props, {
    alt,
    children: childrenProp,
    className,
    component = "div",
    slots = {},
    slotProps = {},
    imgProps,
    sizes,
    src,
    srcSet,
    variant = "circular"
  } = _a2, other = __objRest(_a2, [
    "alt",
    "children",
    "className",
    "component",
    "slots",
    "slotProps",
    "imgProps",
    "sizes",
    "src",
    "srcSet",
    "variant"
  ]);
  let children = null;
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component,
    variant
  });
  const loaded = useLoaded(__spreadProps(__spreadValues(__spreadValues({}, imgProps), typeof slotProps.img === "function" ? slotProps.img(ownerState) : slotProps.img), {
    src,
    srcSet
  }));
  const hasImg = src || srcSet;
  const hasImgNotFailing = hasImg && loaded !== "error";
  ownerState.colorDefault = !hasImgNotFailing;
  delete ownerState.ownerState;
  const classes = useUtilityClasses$14(ownerState);
  const [RootSlot, rootSlotProps] = useSlot("root", {
    ref,
    className: clsx(classes.root, className),
    elementType: AvatarRoot,
    externalForwardedProps: __spreadValues({
      slots,
      slotProps,
      component
    }, other),
    ownerState
  });
  const [ImgSlot, imgSlotProps] = useSlot("img", {
    className: classes.img,
    elementType: AvatarImg,
    externalForwardedProps: {
      slots,
      slotProps: {
        img: __spreadValues(__spreadValues({}, imgProps), slotProps.img)
      }
    },
    additionalProps: {
      alt,
      src,
      srcSet,
      sizes
    },
    ownerState
  });
  const [FallbackSlot, fallbackSlotProps] = useSlot("fallback", {
    className: classes.fallback,
    elementType: AvatarFallback,
    externalForwardedProps: {
      slots,
      slotProps
    },
    shouldForwardComponentProp: true,
    ownerState
  });
  if (hasImgNotFailing) {
    children = /* @__PURE__ */ jsxRuntimeExports.jsx(ImgSlot, __spreadValues({}, imgSlotProps));
  } else if (!!childrenProp || childrenProp === 0) {
    children = childrenProp;
  } else if (hasImg && alt) {
    children = alt[0];
  } else {
    children = /* @__PURE__ */ jsxRuntimeExports.jsx(FallbackSlot, __spreadValues({}, fallbackSlotProps));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, __spreadProps(__spreadValues({}, rootSlotProps), {
    children
  }));
});
const styles$3 = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
};
const Fade = /* @__PURE__ */ reactExports.forwardRef(function Fade2(props, ref) {
  const theme2 = useTheme();
  const defaultTimeout = {
    enter: theme2.transitions.duration.enteringScreen,
    exit: theme2.transitions.duration.leavingScreen
  };
  const _a2 = props, {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = defaultTimeout,
    TransitionComponent: TransitionComponent = Transition
  } = _a2, other = __objRest(_a2, [
    "addEndListener",
    "appear",
    "children",
    "easing",
    "in",
    "onEnter",
    "onEntered",
    "onEntering",
    "onExit",
    "onExited",
    "onExiting",
    "style",
    "timeout",
    // eslint-disable-next-line react/prop-types
    "TransitionComponent"
  ]);
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef(nodeRef, getReactElementRef(children), ref);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    node2.style.webkitTransition = theme2.transitions.create("opacity", transitionProps);
    node2.style.transition = theme2.transitions.create("opacity", transitionProps);
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    node2.style.webkitTransition = theme2.transitions.create("opacity", transitionProps);
    node2.style.transition = theme2.transitions.create("opacity", transitionProps);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = (next2) => {
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, __spreadProps(__spreadValues({
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout
  }, other), {
    children: (state, _b) => {
      var _c = _b, {
        ownerState
      } = _c, restChildProps = __objRest(_c, [
        "ownerState"
      ]);
      return /* @__PURE__ */ reactExports.cloneElement(children, __spreadValues({
        style: __spreadValues(__spreadValues(__spreadValues({
          opacity: 0,
          visibility: state === "exited" && !inProp ? "hidden" : void 0
        }, styles$3[state]), style2), children.props.style),
        ref: handleRef
      }, restChildProps));
    }
  }));
});
function getBackdropUtilityClass(slot) {
  return generateUtilityClass("MuiBackdrop", slot);
}
generateUtilityClasses("MuiBackdrop", ["root", "invisible"]);
const useUtilityClasses$13 = (ownerState) => {
  const {
    classes,
    invisible
  } = ownerState;
  const slots = {
    root: ["root", invisible && "invisible"]
  };
  return composeClasses(slots, getBackdropUtilityClass, classes);
};
const BackdropRoot = styled("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.invisible && styles2.invisible];
  }
})({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent",
  variants: [{
    props: {
      invisible: true
    },
    style: {
      backgroundColor: "transparent"
    }
  }]
});
const Backdrop = /* @__PURE__ */ reactExports.forwardRef(function Backdrop2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiBackdrop"
  });
  const _a2 = props, {
    children,
    className,
    component = "div",
    invisible = false,
    open,
    components = {},
    componentsProps = {},
    slotProps = {},
    slots = {},
    TransitionComponent: TransitionComponentProp,
    transitionDuration
  } = _a2, other = __objRest(_a2, [
    "children",
    "className",
    "component",
    "invisible",
    "open",
    "components",
    "componentsProps",
    "slotProps",
    "slots",
    "TransitionComponent",
    "transitionDuration"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component,
    invisible
  });
  const classes = useUtilityClasses$13(ownerState);
  const backwardCompatibleSlots = __spreadValues({
    transition: TransitionComponentProp,
    root: components.Root
  }, slots);
  const backwardCompatibleSlotProps = __spreadValues(__spreadValues({}, componentsProps), slotProps);
  const externalForwardedProps = {
    component,
    slots: backwardCompatibleSlots,
    slotProps: backwardCompatibleSlotProps
  };
  const [RootSlot, rootProps] = useSlot("root", {
    elementType: BackdropRoot,
    externalForwardedProps,
    className: clsx(classes.root, className),
    ownerState
  });
  const [TransitionSlot, transitionProps] = useSlot("transition", {
    elementType: Fade,
    externalForwardedProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionSlot, __spreadProps(__spreadValues(__spreadValues({
    in: open,
    timeout: transitionDuration
  }, other), transitionProps), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, __spreadProps(__spreadValues({
      "aria-hidden": true
    }, rootProps), {
      classes,
      ref,
      children
    }))
  }));
});
function useBadge(parameters) {
  const {
    badgeContent: badgeContentProp,
    invisible: invisibleProp = false,
    max: maxProp = 99,
    showZero = false
  } = parameters;
  const prevProps = usePreviousProps({
    badgeContent: badgeContentProp,
    max: maxProp
  });
  let invisible = invisibleProp;
  if (invisibleProp === false && badgeContentProp === 0 && !showZero) {
    invisible = true;
  }
  const {
    badgeContent,
    max: max2 = maxProp
  } = invisible ? prevProps : parameters;
  const displayValue = badgeContent && Number(badgeContent) > max2 ? `${max2}+` : badgeContent;
  return {
    badgeContent,
    invisible,
    max: max2,
    displayValue
  };
}
function getBadgeUtilityClass(slot) {
  return generateUtilityClass("MuiBadge", slot);
}
const badgeClasses = generateUtilityClasses("MuiBadge", [
  "root",
  "badge",
  "dot",
  "standard",
  "anchorOriginTopRight",
  "anchorOriginBottomRight",
  "anchorOriginTopLeft",
  "anchorOriginBottomLeft",
  "invisible",
  "colorError",
  "colorInfo",
  "colorPrimary",
  "colorSecondary",
  "colorSuccess",
  "colorWarning",
  "overlapRectangular",
  "overlapCircular",
  // TODO: v6 remove the overlap value from these class keys
  "anchorOriginTopLeftCircular",
  "anchorOriginTopLeftRectangular",
  "anchorOriginTopRightCircular",
  "anchorOriginTopRightRectangular",
  "anchorOriginBottomLeftCircular",
  "anchorOriginBottomLeftRectangular",
  "anchorOriginBottomRightCircular",
  "anchorOriginBottomRightRectangular"
]);
const RADIUS_STANDARD = 10;
const RADIUS_DOT = 4;
const useUtilityClasses$12 = (ownerState) => {
  const {
    color: color2,
    anchorOrigin,
    invisible,
    overlap,
    variant,
    classes = {}
  } = ownerState;
  const slots = {
    root: ["root"],
    badge: ["badge", variant, invisible && "invisible", `anchorOrigin${capitalize(anchorOrigin.vertical)}${capitalize(anchorOrigin.horizontal)}`, `anchorOrigin${capitalize(anchorOrigin.vertical)}${capitalize(anchorOrigin.horizontal)}${capitalize(overlap)}`, `overlap${capitalize(overlap)}`, color2 !== "default" && `color${capitalize(color2)}`]
  };
  return composeClasses(slots, getBadgeUtilityClass, classes);
};
const BadgeRoot = styled("span", {
  name: "MuiBadge",
  slot: "Root"
})({
  position: "relative",
  display: "inline-flex",
  // For correct alignment with the text.
  verticalAlign: "middle",
  flexShrink: 0
});
const BadgeBadge = styled("span", {
  name: "MuiBadge",
  slot: "Badge",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.badge, styles2[ownerState.variant], styles2[`anchorOrigin${capitalize(ownerState.anchorOrigin.vertical)}${capitalize(ownerState.anchorOrigin.horizontal)}${capitalize(ownerState.overlap)}`], ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`], ownerState.invisible && styles2.invisible];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  display: "flex",
  flexDirection: "row",
  flexWrap: "wrap",
  justifyContent: "center",
  alignContent: "center",
  alignItems: "center",
  position: "absolute",
  boxSizing: "border-box",
  fontFamily: theme2.typography.fontFamily,
  fontWeight: theme2.typography.fontWeightMedium,
  fontSize: theme2.typography.pxToRem(12),
  minWidth: RADIUS_STANDARD * 2,
  lineHeight: 1,
  padding: "0 6px",
  height: RADIUS_STANDARD * 2,
  borderRadius: RADIUS_STANDARD,
  zIndex: 1,
  // Render the badge on top of potential ripples.
  transition: theme2.transitions.create("transform", {
    easing: theme2.transitions.easing.easeInOut,
    duration: theme2.transitions.duration.enteringScreen
  }),
  variants: [...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["contrastText"])).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      backgroundColor: (theme2.vars || theme2).palette[color2].main,
      color: (theme2.vars || theme2).palette[color2].contrastText
    }
  })), {
    props: {
      variant: "dot"
    },
    style: {
      borderRadius: RADIUS_DOT,
      height: RADIUS_DOT * 2,
      minWidth: RADIUS_DOT * 2,
      padding: 0
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "rectangular",
    style: {
      top: 0,
      right: 0,
      transform: "scale(1) translate(50%, -50%)",
      transformOrigin: "100% 0%",
      [`&.${badgeClasses.invisible}`]: {
        transform: "scale(0) translate(50%, -50%)"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "rectangular",
    style: {
      bottom: 0,
      right: 0,
      transform: "scale(1) translate(50%, 50%)",
      transformOrigin: "100% 100%",
      [`&.${badgeClasses.invisible}`]: {
        transform: "scale(0) translate(50%, 50%)"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "rectangular",
    style: {
      top: 0,
      left: 0,
      transform: "scale(1) translate(-50%, -50%)",
      transformOrigin: "0% 0%",
      [`&.${badgeClasses.invisible}`]: {
        transform: "scale(0) translate(-50%, -50%)"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "rectangular",
    style: {
      bottom: 0,
      left: 0,
      transform: "scale(1) translate(-50%, 50%)",
      transformOrigin: "0% 100%",
      [`&.${badgeClasses.invisible}`]: {
        transform: "scale(0) translate(-50%, 50%)"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "circular",
    style: {
      top: "14%",
      right: "14%",
      transform: "scale(1) translate(50%, -50%)",
      transformOrigin: "100% 0%",
      [`&.${badgeClasses.invisible}`]: {
        transform: "scale(0) translate(50%, -50%)"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "circular",
    style: {
      bottom: "14%",
      right: "14%",
      transform: "scale(1) translate(50%, 50%)",
      transformOrigin: "100% 100%",
      [`&.${badgeClasses.invisible}`]: {
        transform: "scale(0) translate(50%, 50%)"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "circular",
    style: {
      top: "14%",
      left: "14%",
      transform: "scale(1) translate(-50%, -50%)",
      transformOrigin: "0% 0%",
      [`&.${badgeClasses.invisible}`]: {
        transform: "scale(0) translate(-50%, -50%)"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "circular",
    style: {
      bottom: "14%",
      left: "14%",
      transform: "scale(1) translate(-50%, 50%)",
      transformOrigin: "0% 100%",
      [`&.${badgeClasses.invisible}`]: {
        transform: "scale(0) translate(-50%, 50%)"
      }
    }
  }, {
    props: {
      invisible: true
    },
    style: {
      transition: theme2.transitions.create("transform", {
        easing: theme2.transitions.easing.easeInOut,
        duration: theme2.transitions.duration.leavingScreen
      })
    }
  }]
})));
function getAnchorOrigin(anchorOrigin) {
  var _a2, _b;
  return {
    vertical: (_a2 = anchorOrigin == null ? void 0 : anchorOrigin.vertical) != null ? _a2 : "top",
    horizontal: (_b = anchorOrigin == null ? void 0 : anchorOrigin.horizontal) != null ? _b : "right"
  };
}
const Badge = /* @__PURE__ */ reactExports.forwardRef(function Badge2(inProps, ref) {
  var _b, _c, _d, _e;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiBadge"
  });
  const _a2 = props, {
    anchorOrigin: anchorOriginProp,
    className,
    classes: classesProp,
    component,
    components = {},
    componentsProps = {},
    children,
    overlap: overlapProp = "rectangular",
    color: colorProp = "default",
    invisible: invisibleProp = false,
    max: maxProp = 99,
    badgeContent: badgeContentProp,
    slots,
    slotProps,
    showZero = false,
    variant: variantProp = "standard"
  } = _a2, other = __objRest(_a2, [
    "anchorOrigin",
    "className",
    "classes",
    "component",
    "components",
    "componentsProps",
    "children",
    "overlap",
    "color",
    "invisible",
    "max",
    "badgeContent",
    "slots",
    "slotProps",
    "showZero",
    "variant"
  ]);
  const {
    badgeContent,
    invisible: invisibleFromHook,
    max: max2,
    displayValue: displayValueFromHook
  } = useBadge({
    max: maxProp,
    invisible: invisibleProp,
    badgeContent: badgeContentProp,
    showZero
  });
  const prevProps = usePreviousProps({
    anchorOrigin: getAnchorOrigin(anchorOriginProp),
    color: colorProp,
    overlap: overlapProp,
    variant: variantProp,
    badgeContent: badgeContentProp
  });
  const invisible = invisibleFromHook || badgeContent == null && variantProp !== "dot";
  const {
    color: color2 = colorProp,
    overlap = overlapProp,
    anchorOrigin: anchorOriginPropProp,
    variant = variantProp
  } = invisible ? prevProps : props;
  const anchorOrigin = getAnchorOrigin(anchorOriginPropProp);
  const displayValue = variant !== "dot" ? displayValueFromHook : void 0;
  const ownerState = __spreadProps(__spreadValues({}, props), {
    badgeContent,
    invisible,
    max: max2,
    displayValue,
    showZero,
    anchorOrigin,
    color: color2,
    overlap,
    variant
  });
  const classes = useUtilityClasses$12(ownerState);
  const externalForwardedProps = {
    slots: {
      root: (_b = slots == null ? void 0 : slots.root) != null ? _b : components.Root,
      badge: (_c = slots == null ? void 0 : slots.badge) != null ? _c : components.Badge
    },
    slotProps: {
      root: (_d = slotProps == null ? void 0 : slotProps.root) != null ? _d : componentsProps.root,
      badge: (_e = slotProps == null ? void 0 : slotProps.badge) != null ? _e : componentsProps.badge
    }
  };
  const [RootSlot, rootProps] = useSlot("root", {
    elementType: BadgeRoot,
    externalForwardedProps: __spreadValues(__spreadValues({}, externalForwardedProps), other),
    ownerState,
    className: clsx(classes.root, className),
    ref,
    additionalProps: {
      as: component
    }
  });
  const [BadgeSlot, badgeProps] = useSlot("badge", {
    elementType: BadgeBadge,
    externalForwardedProps,
    ownerState,
    className: classes.badge
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, __spreadProps(__spreadValues({}, rootProps), {
    children: [children, /* @__PURE__ */ jsxRuntimeExports.jsx(BadgeSlot, __spreadProps(__spreadValues({}, badgeProps), {
      children: displayValue
    }))]
  }));
});
function getBottomNavigationUtilityClass(slot) {
  return generateUtilityClass("MuiBottomNavigation", slot);
}
generateUtilityClasses("MuiBottomNavigation", ["root"]);
const useUtilityClasses$11 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getBottomNavigationUtilityClass, classes);
};
const BottomNavigationRoot = styled("div", {
  name: "MuiBottomNavigation",
  slot: "Root"
})(memoTheme(({
  theme: theme2
}) => ({
  display: "flex",
  justifyContent: "center",
  height: 56,
  backgroundColor: (theme2.vars || theme2).palette.background.paper
})));
const BottomNavigation = /* @__PURE__ */ reactExports.forwardRef(function BottomNavigation2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiBottomNavigation"
  });
  const _a2 = props, {
    children,
    className,
    component = "div",
    onChange,
    showLabels = false,
    value
  } = _a2, other = __objRest(_a2, [
    "children",
    "className",
    "component",
    "onChange",
    "showLabels",
    "value"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component,
    showLabels
  });
  const classes = useUtilityClasses$11(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(BottomNavigationRoot, __spreadProps(__spreadValues({
    as: component,
    className: clsx(classes.root, className),
    ref,
    ownerState
  }, other), {
    children: reactExports.Children.map(children, (child, childIndex) => {
      if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
        return null;
      }
      const childValue = child.props.value === void 0 ? childIndex : child.props.value;
      return /* @__PURE__ */ reactExports.cloneElement(child, {
        selected: childValue === value,
        showLabel: child.props.showLabel !== void 0 ? child.props.showLabel : showLabels,
        value: childValue,
        onChange
      });
    })
  }));
});
function getBottomNavigationActionUtilityClass(slot) {
  return generateUtilityClass("MuiBottomNavigationAction", slot);
}
const bottomNavigationActionClasses = generateUtilityClasses("MuiBottomNavigationAction", ["root", "iconOnly", "selected", "label"]);
const useUtilityClasses$10 = (ownerState) => {
  const {
    classes,
    showLabel,
    selected
  } = ownerState;
  const slots = {
    root: ["root", !showLabel && !selected && "iconOnly", selected && "selected"],
    label: ["label", !showLabel && !selected && "iconOnly", selected && "selected"]
  };
  return composeClasses(slots, getBottomNavigationActionUtilityClass, classes);
};
const BottomNavigationActionRoot = styled(ButtonBase, {
  name: "MuiBottomNavigationAction",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.showLabel && !ownerState.selected && styles2.iconOnly];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  transition: theme2.transitions.create(["color", "padding-top"], {
    duration: theme2.transitions.duration.short
  }),
  padding: "0px 12px",
  minWidth: 80,
  maxWidth: 168,
  color: (theme2.vars || theme2).palette.text.secondary,
  flexDirection: "column",
  flex: "1",
  [`&.${bottomNavigationActionClasses.selected}`]: {
    color: (theme2.vars || theme2).palette.primary.main
  },
  variants: [{
    props: ({
      showLabel,
      selected
    }) => !showLabel && !selected,
    style: {
      paddingTop: 14
    }
  }, {
    props: ({
      showLabel,
      selected,
      label
    }) => !showLabel && !selected && !label,
    style: {
      paddingTop: 0
    }
  }]
})));
const BottomNavigationActionLabel = styled("span", {
  name: "MuiBottomNavigationAction",
  slot: "Label"
})(memoTheme(({
  theme: theme2
}) => ({
  fontFamily: theme2.typography.fontFamily,
  fontSize: theme2.typography.pxToRem(12),
  opacity: 1,
  transition: "font-size 0.2s, opacity 0.2s",
  transitionDelay: "0.1s",
  [`&.${bottomNavigationActionClasses.selected}`]: {
    fontSize: theme2.typography.pxToRem(14)
  },
  variants: [{
    props: ({
      showLabel,
      selected
    }) => !showLabel && !selected,
    style: {
      opacity: 0,
      transitionDelay: "0s"
    }
  }]
})));
const BottomNavigationAction = /* @__PURE__ */ reactExports.forwardRef(function BottomNavigationAction2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiBottomNavigationAction"
  });
  const _a2 = props, {
    className,
    icon,
    label,
    onChange,
    onClick,
    selected: selected,
    showLabel,
    value,
    slots = {},
    slotProps = {}
  } = _a2, other = __objRest(_a2, [
    "className",
    "icon",
    "label",
    "onChange",
    "onClick",
    // eslint-disable-next-line react/prop-types -- private, always overridden by BottomNavigation
    "selected",
    "showLabel",
    "value",
    "slots",
    "slotProps"
  ]);
  const ownerState = props;
  const classes = useUtilityClasses$10(ownerState);
  const handleChange = (event) => {
    if (onChange) {
      onChange(event, value);
    }
    if (onClick) {
      onClick(event);
    }
  };
  const externalForwardedProps = {
    slots,
    slotProps
  };
  const [RootSlot, rootProps] = useSlot("root", {
    elementType: BottomNavigationActionRoot,
    externalForwardedProps: __spreadValues(__spreadValues({}, externalForwardedProps), other),
    shouldForwardComponentProp: true,
    ownerState,
    ref,
    className: clsx(classes.root, className),
    additionalProps: {
      focusRipple: true
    },
    getSlotProps: (handlers) => __spreadProps(__spreadValues({}, handlers), {
      onClick: (event) => {
        var _a3;
        (_a3 = handlers.onClick) == null ? void 0 : _a3.call(handlers, event);
        handleChange(event);
      }
    })
  });
  const [LabelSlot, labelProps] = useSlot("label", {
    elementType: BottomNavigationActionLabel,
    externalForwardedProps,
    ownerState,
    className: classes.label
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, __spreadProps(__spreadValues({}, rootProps), {
    children: [icon, /* @__PURE__ */ jsxRuntimeExports.jsx(LabelSlot, __spreadProps(__spreadValues({}, labelProps), {
      children: label
    }))]
  }));
});
const boxClasses = generateUtilityClasses("MuiBox", ["root"]);
const defaultTheme = createTheme();
const Box = createBox({
  themeId: THEME_ID,
  defaultTheme,
  defaultClassName: boxClasses.root,
  generateClassName: ClassNameGenerator.generate
});
function getButtonUtilityClass(slot) {
  return generateUtilityClass("MuiButton", slot);
}
const buttonClasses = generateUtilityClasses("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge", "loading", "loadingWrapper", "loadingIconPlaceholder", "loadingIndicator", "loadingPositionCenter", "loadingPositionStart", "loadingPositionEnd"]);
const ButtonGroupContext = /* @__PURE__ */ reactExports.createContext({});
const ButtonGroupButtonContext = /* @__PURE__ */ reactExports.createContext(void 0);
const useUtilityClasses$$ = (ownerState) => {
  const {
    color: color2,
    disableElevation,
    fullWidth,
    size,
    variant,
    loading,
    loadingPosition,
    classes
  } = ownerState;
  const slots = {
    root: ["root", loading && "loading", variant, `${variant}${capitalize(color2)}`, `size${capitalize(size)}`, `${variant}Size${capitalize(size)}`, `color${capitalize(color2)}`, disableElevation && "disableElevation", fullWidth && "fullWidth", loading && `loadingPosition${capitalize(loadingPosition)}`],
    startIcon: ["icon", "startIcon", `iconSize${capitalize(size)}`],
    endIcon: ["icon", "endIcon", `iconSize${capitalize(size)}`],
    loadingIndicator: ["loadingIndicator"],
    loadingWrapper: ["loadingWrapper"]
  };
  const composedClasses = composeClasses(slots, getButtonUtilityClass, classes);
  return __spreadValues(__spreadValues({}, classes), composedClasses);
};
const commonIconStyles = [{
  props: {
    size: "small"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 18
    }
  }
}, {
  props: {
    size: "medium"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 20
    }
  }
}, {
  props: {
    size: "large"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 22
    }
  }
}];
const ButtonRoot = styled(ButtonBase, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize(ownerState.color)}`], styles2[`size${capitalize(ownerState.size)}`], styles2[`${ownerState.variant}Size${capitalize(ownerState.size)}`], ownerState.color === "inherit" && styles2.colorInherit, ownerState.disableElevation && styles2.disableElevation, ownerState.fullWidth && styles2.fullWidth, ownerState.loading && styles2.loading];
  }
})(memoTheme(({
  theme: theme2
}) => {
  const inheritContainedBackgroundColor = theme2.palette.mode === "light" ? theme2.palette.grey[300] : theme2.palette.grey[800];
  const inheritContainedHoverBackgroundColor = theme2.palette.mode === "light" ? theme2.palette.grey.A100 : theme2.palette.grey[700];
  return __spreadProps(__spreadValues({}, theme2.typography.button), {
    minWidth: 64,
    padding: "6px 16px",
    border: 0,
    borderRadius: (theme2.vars || theme2).shape.borderRadius,
    transition: theme2.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
      duration: theme2.transitions.duration.short
    }),
    "&:hover": {
      textDecoration: "none"
    },
    [`&.${buttonClasses.disabled}`]: {
      color: (theme2.vars || theme2).palette.action.disabled
    },
    variants: [{
      props: {
        variant: "contained"
      },
      style: {
        color: `var(--variant-containedColor)`,
        backgroundColor: `var(--variant-containedBg)`,
        boxShadow: (theme2.vars || theme2).shadows[2],
        "&:hover": {
          boxShadow: (theme2.vars || theme2).shadows[4],
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            boxShadow: (theme2.vars || theme2).shadows[2]
          }
        },
        "&:active": {
          boxShadow: (theme2.vars || theme2).shadows[8]
        },
        [`&.${buttonClasses.focusVisible}`]: {
          boxShadow: (theme2.vars || theme2).shadows[6]
        },
        [`&.${buttonClasses.disabled}`]: {
          color: (theme2.vars || theme2).palette.action.disabled,
          boxShadow: (theme2.vars || theme2).shadows[0],
          backgroundColor: (theme2.vars || theme2).palette.action.disabledBackground
        }
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        padding: "5px 15px",
        border: "1px solid currentColor",
        borderColor: `var(--variant-outlinedBorder, currentColor)`,
        backgroundColor: `var(--variant-outlinedBg)`,
        color: `var(--variant-outlinedColor)`,
        [`&.${buttonClasses.disabled}`]: {
          border: `1px solid ${(theme2.vars || theme2).palette.action.disabledBackground}`
        }
      }
    }, {
      props: {
        variant: "text"
      },
      style: {
        padding: "6px 8px",
        color: `var(--variant-textColor)`,
        backgroundColor: `var(--variant-textBg)`
      }
    }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
      props: {
        color: color2
      },
      style: {
        "--variant-textColor": (theme2.vars || theme2).palette[color2].main,
        "--variant-outlinedColor": (theme2.vars || theme2).palette[color2].main,
        "--variant-outlinedBorder": theme2.alpha((theme2.vars || theme2).palette[color2].main, 0.5),
        "--variant-containedColor": (theme2.vars || theme2).palette[color2].contrastText,
        "--variant-containedBg": (theme2.vars || theme2).palette[color2].main,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": (theme2.vars || theme2).palette[color2].dark,
            "--variant-textBg": theme2.alpha((theme2.vars || theme2).palette[color2].main, (theme2.vars || theme2).palette.action.hoverOpacity),
            "--variant-outlinedBorder": (theme2.vars || theme2).palette[color2].main,
            "--variant-outlinedBg": theme2.alpha((theme2.vars || theme2).palette[color2].main, (theme2.vars || theme2).palette.action.hoverOpacity)
          }
        }
      }
    })), {
      props: {
        color: "inherit"
      },
      style: {
        color: "inherit",
        borderColor: "currentColor",
        "--variant-containedBg": theme2.vars ? theme2.vars.palette.Button.inheritContainedBg : inheritContainedBackgroundColor,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": theme2.vars ? theme2.vars.palette.Button.inheritContainedHoverBg : inheritContainedHoverBackgroundColor,
            "--variant-textBg": theme2.alpha((theme2.vars || theme2).palette.text.primary, (theme2.vars || theme2).palette.action.hoverOpacity),
            "--variant-outlinedBg": theme2.alpha((theme2.vars || theme2).palette.text.primary, (theme2.vars || theme2).palette.action.hoverOpacity)
          }
        }
      }
    }, {
      props: {
        size: "small",
        variant: "text"
      },
      style: {
        padding: "4px 5px",
        fontSize: theme2.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "text"
      },
      style: {
        padding: "8px 11px",
        fontSize: theme2.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "outlined"
      },
      style: {
        padding: "3px 9px",
        fontSize: theme2.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "outlined"
      },
      style: {
        padding: "7px 21px",
        fontSize: theme2.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "contained"
      },
      style: {
        padding: "4px 10px",
        fontSize: theme2.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "contained"
      },
      style: {
        padding: "8px 22px",
        fontSize: theme2.typography.pxToRem(15)
      }
    }, {
      props: {
        disableElevation: true
      },
      style: {
        boxShadow: "none",
        "&:hover": {
          boxShadow: "none"
        },
        [`&.${buttonClasses.focusVisible}`]: {
          boxShadow: "none"
        },
        "&:active": {
          boxShadow: "none"
        },
        [`&.${buttonClasses.disabled}`]: {
          boxShadow: "none"
        }
      }
    }, {
      props: {
        fullWidth: true
      },
      style: {
        width: "100%"
      }
    }, {
      props: {
        loadingPosition: "center"
      },
      style: {
        transition: theme2.transitions.create(["background-color", "box-shadow", "border-color"], {
          duration: theme2.transitions.duration.short
        }),
        [`&.${buttonClasses.loading}`]: {
          color: "transparent"
        }
      }
    }]
  });
}));
const ButtonStartIcon = styled("span", {
  name: "MuiButton",
  slot: "StartIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.startIcon, ownerState.loading && styles2.startIconLoadingStart, styles2[`iconSize${capitalize(ownerState.size)}`]];
  }
})(({
  theme: theme2
}) => ({
  display: "inherit",
  marginRight: 8,
  marginLeft: -4,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginLeft: -2
    }
  }, {
    props: {
      loadingPosition: "start",
      loading: true
    },
    style: {
      transition: theme2.transitions.create(["opacity"], {
        duration: theme2.transitions.duration.short
      }),
      opacity: 0
    }
  }, {
    props: {
      loadingPosition: "start",
      loading: true,
      fullWidth: true
    },
    style: {
      marginRight: -8
    }
  }, ...commonIconStyles]
}));
const ButtonEndIcon = styled("span", {
  name: "MuiButton",
  slot: "EndIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.endIcon, ownerState.loading && styles2.endIconLoadingEnd, styles2[`iconSize${capitalize(ownerState.size)}`]];
  }
})(({
  theme: theme2
}) => ({
  display: "inherit",
  marginRight: -4,
  marginLeft: 8,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginRight: -2
    }
  }, {
    props: {
      loadingPosition: "end",
      loading: true
    },
    style: {
      transition: theme2.transitions.create(["opacity"], {
        duration: theme2.transitions.duration.short
      }),
      opacity: 0
    }
  }, {
    props: {
      loadingPosition: "end",
      loading: true,
      fullWidth: true
    },
    style: {
      marginLeft: -8
    }
  }, ...commonIconStyles]
}));
const ButtonLoadingIndicator = styled("span", {
  name: "MuiButton",
  slot: "LoadingIndicator"
})(({
  theme: theme2
}) => ({
  display: "none",
  position: "absolute",
  visibility: "visible",
  variants: [{
    props: {
      loading: true
    },
    style: {
      display: "flex"
    }
  }, {
    props: {
      loadingPosition: "start"
    },
    style: {
      left: 14
    }
  }, {
    props: {
      loadingPosition: "start",
      size: "small"
    },
    style: {
      left: 10
    }
  }, {
    props: {
      variant: "text",
      loadingPosition: "start"
    },
    style: {
      left: 6
    }
  }, {
    props: {
      loadingPosition: "center"
    },
    style: {
      left: "50%",
      transform: "translate(-50%)",
      color: (theme2.vars || theme2).palette.action.disabled
    }
  }, {
    props: {
      loadingPosition: "end"
    },
    style: {
      right: 14
    }
  }, {
    props: {
      loadingPosition: "end",
      size: "small"
    },
    style: {
      right: 10
    }
  }, {
    props: {
      variant: "text",
      loadingPosition: "end"
    },
    style: {
      right: 6
    }
  }, {
    props: {
      loadingPosition: "start",
      fullWidth: true
    },
    style: {
      position: "relative",
      left: -10
    }
  }, {
    props: {
      loadingPosition: "end",
      fullWidth: true
    },
    style: {
      position: "relative",
      right: -10
    }
  }]
}));
const ButtonLoadingIconPlaceholder = styled("span", {
  name: "MuiButton",
  slot: "LoadingIconPlaceholder"
})({
  display: "inline-block",
  width: "1em",
  height: "1em"
});
const Button = /* @__PURE__ */ reactExports.forwardRef(function Button2(inProps, ref) {
  const contextProps = reactExports.useContext(ButtonGroupContext);
  const buttonGroupButtonContextPositionClassName = reactExports.useContext(ButtonGroupButtonContext);
  const resolvedProps = resolveProps(contextProps, inProps);
  const props = useDefaultProps({
    props: resolvedProps,
    name: "MuiButton"
  });
  const _a2 = props, {
    children,
    color: color2 = "primary",
    component = "button",
    className,
    disabled = false,
    disableElevation = false,
    disableFocusRipple = false,
    endIcon: endIconProp,
    focusVisibleClassName,
    fullWidth = false,
    id: idProp,
    loading = null,
    loadingIndicator: loadingIndicatorProp,
    loadingPosition = "center",
    size = "medium",
    startIcon: startIconProp,
    type,
    variant = "text"
  } = _a2, other = __objRest(_a2, [
    "children",
    "color",
    "component",
    "className",
    "disabled",
    "disableElevation",
    "disableFocusRipple",
    "endIcon",
    "focusVisibleClassName",
    "fullWidth",
    "id",
    "loading",
    "loadingIndicator",
    "loadingPosition",
    "size",
    "startIcon",
    "type",
    "variant"
  ]);
  const loadingId = useId(idProp);
  const loadingIndicator = loadingIndicatorProp != null ? loadingIndicatorProp : /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {
    "aria-labelledby": loadingId,
    color: "inherit",
    size: 16
  });
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: color2,
    component,
    disabled,
    disableElevation,
    disableFocusRipple,
    fullWidth,
    loading,
    loadingIndicator,
    loadingPosition,
    size,
    type,
    variant
  });
  const classes = useUtilityClasses$$(ownerState);
  const startIcon = (startIconProp || loading && loadingPosition === "start") && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonStartIcon, {
    className: classes.startIcon,
    ownerState,
    children: startIconProp || /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonLoadingIconPlaceholder, {
      className: classes.loadingIconPlaceholder,
      ownerState
    })
  });
  const endIcon = (endIconProp || loading && loadingPosition === "end") && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonEndIcon, {
    className: classes.endIcon,
    ownerState,
    children: endIconProp || /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonLoadingIconPlaceholder, {
      className: classes.loadingIconPlaceholder,
      ownerState
    })
  });
  const positionClassName = buttonGroupButtonContextPositionClassName || "";
  const loader = typeof loading === "boolean" ? (
    // use plain HTML span to minimize the runtime overhead
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: classes.loadingWrapper,
      style: {
        display: "contents"
      },
      children: loading && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonLoadingIndicator, {
        className: classes.loadingIndicator,
        ownerState,
        children: loadingIndicator
      })
    })
  ) : null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonRoot, __spreadProps(__spreadValues({
    ownerState,
    className: clsx(contextProps.className, classes.root, className, positionClassName),
    component,
    disabled: disabled || loading,
    focusRipple: !disableFocusRipple,
    focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
    ref,
    type,
    id: loading ? loadingId : idProp
  }, other), {
    classes,
    children: [startIcon, loadingPosition !== "end" && loader, children, loadingPosition === "end" && loader, endIcon]
  }));
});
function getValidReactChildren(children) {
  return reactExports.Children.toArray(children).filter((child) => /* @__PURE__ */ reactExports.isValidElement(child));
}
function getButtonGroupUtilityClass(slot) {
  return generateUtilityClass("MuiButtonGroup", slot);
}
const buttonGroupClasses = generateUtilityClasses("MuiButtonGroup", ["root", "contained", "outlined", "text", "disableElevation", "disabled", "firstButton", "fullWidth", "horizontal", "vertical", "colorPrimary", "colorSecondary", "grouped", "groupedHorizontal", "groupedVertical", "groupedText", "groupedTextHorizontal", "groupedTextVertical", "groupedTextPrimary", "groupedTextSecondary", "groupedOutlined", "groupedOutlinedHorizontal", "groupedOutlinedVertical", "groupedOutlinedPrimary", "groupedOutlinedSecondary", "groupedContained", "groupedContainedHorizontal", "groupedContainedVertical", "groupedContainedPrimary", "groupedContainedSecondary", "lastButton", "middleButton"]);
const overridesResolver$3 = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [{
    [`& .${buttonGroupClasses.grouped}`]: styles2.grouped
  }, {
    [`& .${buttonGroupClasses.grouped}`]: styles2[`grouped${capitalize(ownerState.orientation)}`]
  }, {
    [`& .${buttonGroupClasses.grouped}`]: styles2[`grouped${capitalize(ownerState.variant)}`]
  }, {
    [`& .${buttonGroupClasses.grouped}`]: styles2[`grouped${capitalize(ownerState.variant)}${capitalize(ownerState.orientation)}`]
  }, {
    [`& .${buttonGroupClasses.grouped}`]: styles2[`grouped${capitalize(ownerState.variant)}${capitalize(ownerState.color)}`]
  }, {
    [`& .${buttonGroupClasses.firstButton}`]: styles2.firstButton
  }, {
    [`& .${buttonGroupClasses.lastButton}`]: styles2.lastButton
  }, {
    [`& .${buttonGroupClasses.middleButton}`]: styles2.middleButton
  }, styles2.root, styles2[ownerState.variant], ownerState.disableElevation === true && styles2.disableElevation, ownerState.fullWidth && styles2.fullWidth, ownerState.orientation === "vertical" && styles2.vertical];
};
const useUtilityClasses$_ = (ownerState) => {
  const {
    classes,
    color: color2,
    disabled,
    disableElevation,
    fullWidth,
    orientation,
    variant
  } = ownerState;
  const slots = {
    root: ["root", variant, orientation, fullWidth && "fullWidth", disableElevation && "disableElevation", `color${capitalize(color2)}`],
    grouped: ["grouped", `grouped${capitalize(orientation)}`, `grouped${capitalize(variant)}`, `grouped${capitalize(variant)}${capitalize(orientation)}`, `grouped${capitalize(variant)}${capitalize(color2)}`, disabled && "disabled"],
    firstButton: ["firstButton"],
    lastButton: ["lastButton"],
    middleButton: ["middleButton"]
  };
  return composeClasses(slots, getButtonGroupUtilityClass, classes);
};
const ButtonGroupRoot = styled("div", {
  name: "MuiButtonGroup",
  slot: "Root",
  overridesResolver: overridesResolver$3
})(memoTheme(({
  theme: theme2
}) => ({
  display: "inline-flex",
  borderRadius: (theme2.vars || theme2).shape.borderRadius,
  variants: [{
    props: {
      variant: "contained"
    },
    style: {
      boxShadow: (theme2.vars || theme2).shadows[2]
    }
  }, {
    props: {
      disableElevation: true
    },
    style: {
      boxShadow: "none"
    }
  }, {
    props: {
      fullWidth: true
    },
    style: {
      width: "100%"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      flexDirection: "column",
      [`& .${buttonGroupClasses.lastButton},& .${buttonGroupClasses.middleButton}`]: {
        borderTopRightRadius: 0,
        borderTopLeftRadius: 0
      },
      [`& .${buttonGroupClasses.firstButton},& .${buttonGroupClasses.middleButton}`]: {
        borderBottomRightRadius: 0,
        borderBottomLeftRadius: 0
      }
    }
  }, {
    props: {
      orientation: "horizontal"
    },
    style: {
      [`& .${buttonGroupClasses.firstButton},& .${buttonGroupClasses.middleButton}`]: {
        borderTopRightRadius: 0,
        borderBottomRightRadius: 0
      },
      [`& .${buttonGroupClasses.lastButton},& .${buttonGroupClasses.middleButton}`]: {
        borderTopLeftRadius: 0,
        borderBottomLeftRadius: 0
      }
    }
  }, {
    props: {
      variant: "text",
      orientation: "horizontal"
    },
    style: {
      [`& .${buttonGroupClasses.firstButton},& .${buttonGroupClasses.middleButton}`]: {
        borderRight: theme2.vars ? `1px solid ${theme2.alpha(theme2.vars.palette.common.onBackground, 0.23)}` : `1px solid ${theme2.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)"}`,
        [`&.${buttonGroupClasses.disabled}`]: {
          borderRight: `1px solid ${(theme2.vars || theme2).palette.action.disabled}`
        }
      }
    }
  }, {
    props: {
      variant: "text",
      orientation: "vertical"
    },
    style: {
      [`& .${buttonGroupClasses.firstButton},& .${buttonGroupClasses.middleButton}`]: {
        borderBottom: theme2.vars ? `1px solid ${theme2.alpha(theme2.vars.palette.common.onBackground, 0.23)}` : `1px solid ${theme2.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)"}`,
        [`&.${buttonGroupClasses.disabled}`]: {
          borderBottom: `1px solid ${(theme2.vars || theme2).palette.action.disabled}`
        }
      }
    }
  }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).flatMap(([color2]) => [{
    props: {
      variant: "text",
      color: color2
    },
    style: {
      [`& .${buttonGroupClasses.firstButton},& .${buttonGroupClasses.middleButton}`]: {
        borderColor: theme2.alpha((theme2.vars || theme2).palette[color2].main, 0.5)
      }
    }
  }]), {
    props: {
      variant: "outlined",
      orientation: "horizontal"
    },
    style: {
      [`& .${buttonGroupClasses.firstButton},& .${buttonGroupClasses.middleButton}`]: {
        borderRightColor: "transparent",
        "&:hover": {
          borderRightColor: "currentColor"
        }
      },
      [`& .${buttonGroupClasses.lastButton},& .${buttonGroupClasses.middleButton}`]: {
        marginLeft: -1
      }
    }
  }, {
    props: {
      variant: "outlined",
      orientation: "vertical"
    },
    style: {
      [`& .${buttonGroupClasses.firstButton},& .${buttonGroupClasses.middleButton}`]: {
        borderBottomColor: "transparent",
        "&:hover": {
          borderBottomColor: "currentColor"
        }
      },
      [`& .${buttonGroupClasses.lastButton},& .${buttonGroupClasses.middleButton}`]: {
        marginTop: -1
      }
    }
  }, {
    props: {
      variant: "contained",
      orientation: "horizontal"
    },
    style: {
      [`& .${buttonGroupClasses.firstButton},& .${buttonGroupClasses.middleButton}`]: {
        borderRight: `1px solid ${(theme2.vars || theme2).palette.grey[400]}`,
        [`&.${buttonGroupClasses.disabled}`]: {
          borderRight: `1px solid ${(theme2.vars || theme2).palette.action.disabled}`
        }
      }
    }
  }, {
    props: {
      variant: "contained",
      orientation: "vertical"
    },
    style: {
      [`& .${buttonGroupClasses.firstButton},& .${buttonGroupClasses.middleButton}`]: {
        borderBottom: `1px solid ${(theme2.vars || theme2).palette.grey[400]}`,
        [`&.${buttonGroupClasses.disabled}`]: {
          borderBottom: `1px solid ${(theme2.vars || theme2).palette.action.disabled}`
        }
      }
    }
  }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["dark"])).map(([color2]) => ({
    props: {
      variant: "contained",
      color: color2
    },
    style: {
      [`& .${buttonGroupClasses.firstButton},& .${buttonGroupClasses.middleButton}`]: {
        borderColor: (theme2.vars || theme2).palette[color2].dark
      }
    }
  }))],
  [`& .${buttonGroupClasses.grouped}`]: {
    minWidth: 40,
    boxShadow: "none",
    props: {
      variant: "contained"
    },
    style: {
      "&:hover": {
        boxShadow: "none"
      }
    }
  }
})));
const ButtonGroup = /* @__PURE__ */ reactExports.forwardRef(function ButtonGroup2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiButtonGroup"
  });
  const _a2 = props, {
    children,
    className,
    color: color2 = "primary",
    component = "div",
    disabled = false,
    disableElevation = false,
    disableFocusRipple = false,
    disableRipple = false,
    fullWidth = false,
    orientation = "horizontal",
    size = "medium",
    variant = "outlined"
  } = _a2, other = __objRest(_a2, [
    "children",
    "className",
    "color",
    "component",
    "disabled",
    "disableElevation",
    "disableFocusRipple",
    "disableRipple",
    "fullWidth",
    "orientation",
    "size",
    "variant"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: color2,
    component,
    disabled,
    disableElevation,
    disableFocusRipple,
    disableRipple,
    fullWidth,
    orientation,
    size,
    variant
  });
  const classes = useUtilityClasses$_(ownerState);
  const context = reactExports.useMemo(() => ({
    className: classes.grouped,
    color: color2,
    disabled,
    disableElevation,
    disableFocusRipple,
    disableRipple,
    fullWidth,
    size,
    variant
  }), [color2, disabled, disableElevation, disableFocusRipple, disableRipple, fullWidth, size, variant, classes.grouped]);
  const validChildren = getValidReactChildren(children);
  const childrenCount = validChildren.length;
  const getButtonPositionClassName = (index2) => {
    const isFirstButton = index2 === 0;
    const isLastButton = index2 === childrenCount - 1;
    if (isFirstButton && isLastButton) {
      return "";
    }
    if (isFirstButton) {
      return classes.firstButton;
    }
    if (isLastButton) {
      return classes.lastButton;
    }
    return classes.middleButton;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonGroupRoot, __spreadProps(__spreadValues({
    as: component,
    role: "group",
    className: clsx(classes.root, className),
    ref,
    ownerState
  }, other), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonGroupContext.Provider, {
      value: context,
      children: validChildren.map((child, index2) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonGroupButtonContext.Provider, {
          value: getButtonPositionClassName(index2),
          children: child
        }, index2);
      })
    })
  }));
});
function getCardUtilityClass(slot) {
  return generateUtilityClass("MuiCard", slot);
}
generateUtilityClasses("MuiCard", ["root"]);
const useUtilityClasses$Z = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getCardUtilityClass, classes);
};
const CardRoot = styled(Paper, {
  name: "MuiCard",
  slot: "Root"
})({
  overflow: "hidden"
});
const Card = /* @__PURE__ */ reactExports.forwardRef(function Card2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCard"
  });
  const _a2 = props, {
    className,
    raised = false
  } = _a2, other = __objRest(_a2, [
    "className",
    "raised"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    raised
  });
  const classes = useUtilityClasses$Z(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CardRoot, __spreadValues({
    className: clsx(classes.root, className),
    elevation: raised ? 8 : void 0,
    ref,
    ownerState
  }, other));
});
function getCardActionAreaUtilityClass(slot) {
  return generateUtilityClass("MuiCardActionArea", slot);
}
const cardActionAreaClasses = generateUtilityClasses("MuiCardActionArea", ["root", "focusVisible", "focusHighlight"]);
const useUtilityClasses$Y = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    focusHighlight: ["focusHighlight"]
  };
  return composeClasses(slots, getCardActionAreaUtilityClass, classes);
};
const CardActionAreaRoot = styled(ButtonBase, {
  name: "MuiCardActionArea",
  slot: "Root"
})(memoTheme(({
  theme: theme2
}) => ({
  display: "block",
  textAlign: "inherit",
  borderRadius: "inherit",
  // for Safari to work https://github.com/mui/material-ui/issues/36285.
  width: "100%",
  [`&:hover .${cardActionAreaClasses.focusHighlight}`]: {
    opacity: (theme2.vars || theme2).palette.action.hoverOpacity,
    "@media (hover: none)": {
      opacity: 0
    }
  },
  [`&.${cardActionAreaClasses.focusVisible} .${cardActionAreaClasses.focusHighlight}`]: {
    opacity: (theme2.vars || theme2).palette.action.focusOpacity
  }
})));
const CardActionAreaFocusHighlight = styled("span", {
  name: "MuiCardActionArea",
  slot: "FocusHighlight"
})(memoTheme(({
  theme: theme2
}) => ({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit",
  opacity: 0,
  backgroundColor: "currentcolor",
  transition: theme2.transitions.create("opacity", {
    duration: theme2.transitions.duration.short
  })
})));
const CardActionArea = /* @__PURE__ */ reactExports.forwardRef(function CardActionArea2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCardActionArea"
  });
  const _a2 = props, {
    children,
    className,
    focusVisibleClassName,
    slots = {},
    slotProps = {}
  } = _a2, other = __objRest(_a2, [
    "children",
    "className",
    "focusVisibleClassName",
    "slots",
    "slotProps"
  ]);
  const ownerState = props;
  const classes = useUtilityClasses$Y(ownerState);
  const externalForwardedProps = {
    slots,
    slotProps
  };
  const [RootSlot, rootProps] = useSlot("root", {
    elementType: CardActionAreaRoot,
    externalForwardedProps: __spreadValues(__spreadValues({}, externalForwardedProps), other),
    shouldForwardComponentProp: true,
    ownerState,
    ref,
    className: clsx(classes.root, className),
    additionalProps: {
      focusVisibleClassName: clsx(focusVisibleClassName, classes.focusVisible)
    }
  });
  const [FocusHighlightSlot, focusHighlightProps] = useSlot("focusHighlight", {
    elementType: CardActionAreaFocusHighlight,
    externalForwardedProps,
    ownerState,
    ref,
    className: classes.focusHighlight
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, __spreadProps(__spreadValues({}, rootProps), {
    children: [children, /* @__PURE__ */ jsxRuntimeExports.jsx(FocusHighlightSlot, __spreadValues({}, focusHighlightProps))]
  }));
});
function getCardActionsUtilityClass(slot) {
  return generateUtilityClass("MuiCardActions", slot);
}
generateUtilityClasses("MuiCardActions", ["root", "spacing"]);
const useUtilityClasses$X = (ownerState) => {
  const {
    classes,
    disableSpacing
  } = ownerState;
  const slots = {
    root: ["root", !disableSpacing && "spacing"]
  };
  return composeClasses(slots, getCardActionsUtilityClass, classes);
};
const CardActionsRoot = styled("div", {
  name: "MuiCardActions",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.disableSpacing && styles2.spacing];
  }
})({
  display: "flex",
  alignItems: "center",
  padding: 8,
  variants: [{
    props: {
      disableSpacing: false
    },
    style: {
      "& > :not(style) ~ :not(style)": {
        marginLeft: 8
      }
    }
  }]
});
const CardActions = /* @__PURE__ */ reactExports.forwardRef(function CardActions2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCardActions"
  });
  const _a2 = props, {
    disableSpacing = false,
    className
  } = _a2, other = __objRest(_a2, [
    "disableSpacing",
    "className"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    disableSpacing
  });
  const classes = useUtilityClasses$X(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CardActionsRoot, __spreadValues({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
function getCardContentUtilityClass(slot) {
  return generateUtilityClass("MuiCardContent", slot);
}
generateUtilityClasses("MuiCardContent", ["root"]);
const useUtilityClasses$W = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getCardContentUtilityClass, classes);
};
const CardContentRoot = styled("div", {
  name: "MuiCardContent",
  slot: "Root"
})({
  padding: 16,
  "&:last-child": {
    paddingBottom: 24
  }
});
const CardContent = /* @__PURE__ */ reactExports.forwardRef(function CardContent2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCardContent"
  });
  const _a2 = props, {
    className,
    component = "div"
  } = _a2, other = __objRest(_a2, [
    "className",
    "component"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component
  });
  const classes = useUtilityClasses$W(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CardContentRoot, __spreadValues({
    as: component,
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
function getSwitchBaseUtilityClass(slot) {
  return generateUtilityClass("PrivateSwitchBase", slot);
}
generateUtilityClasses("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]);
const useUtilityClasses$V = (ownerState) => {
  const {
    classes,
    checked,
    disabled,
    edge
  } = ownerState;
  const slots = {
    root: ["root", checked && "checked", disabled && "disabled", edge && `edge${capitalize(edge)}`],
    input: ["input"]
  };
  return composeClasses(slots, getSwitchBaseUtilityClass, classes);
};
const SwitchBaseRoot = styled(ButtonBase, {
  name: "MuiSwitchBase"
})({
  padding: 9,
  borderRadius: "50%",
  variants: [{
    props: {
      edge: "start",
      size: "small"
    },
    style: {
      marginLeft: -3
    }
  }, {
    props: ({
      edge,
      ownerState
    }) => edge === "start" && ownerState.size !== "small",
    style: {
      marginLeft: -12
    }
  }, {
    props: {
      edge: "end",
      size: "small"
    },
    style: {
      marginRight: -3
    }
  }, {
    props: ({
      edge,
      ownerState
    }) => edge === "end" && ownerState.size !== "small",
    style: {
      marginRight: -12
    }
  }]
});
const SwitchBaseInput = styled("input", {
  name: "MuiSwitchBase",
  shouldForwardProp: rootShouldForwardProp
})({
  cursor: "inherit",
  position: "absolute",
  opacity: 0,
  width: "100%",
  height: "100%",
  top: 0,
  left: 0,
  margin: 0,
  padding: 0,
  zIndex: 1
});
const SwitchBase = /* @__PURE__ */ reactExports.forwardRef(function SwitchBase2(props, ref) {
  const _a2 = props, {
    autoFocus,
    checked: checkedProp,
    checkedIcon,
    defaultChecked,
    disabled: disabledProp,
    disableFocusRipple = false,
    edge = false,
    icon,
    id,
    inputProps,
    inputRef,
    name: name2,
    onBlur,
    onChange,
    onFocus,
    readOnly,
    required = false,
    tabIndex,
    type,
    value,
    slots = {},
    slotProps = {}
  } = _a2, other = __objRest(_a2, [
    "autoFocus",
    "checked",
    "checkedIcon",
    "defaultChecked",
    "disabled",
    "disableFocusRipple",
    "edge",
    "icon",
    "id",
    "inputProps",
    "inputRef",
    "name",
    "onBlur",
    "onChange",
    "onFocus",
    "readOnly",
    "required",
    "tabIndex",
    "type",
    "value",
    "slots",
    "slotProps"
  ]);
  const [checked, setCheckedState] = useControlled({
    controlled: checkedProp,
    default: Boolean(defaultChecked),
    name: "SwitchBase",
    state: "checked"
  });
  const muiFormControl = useFormControl();
  const handleFocus = (event) => {
    if (onFocus) {
      onFocus(event);
    }
    if (muiFormControl && muiFormControl.onFocus) {
      muiFormControl.onFocus(event);
    }
  };
  const handleBlur = (event) => {
    if (onBlur) {
      onBlur(event);
    }
    if (muiFormControl && muiFormControl.onBlur) {
      muiFormControl.onBlur(event);
    }
  };
  const handleInputChange = (event) => {
    if (event.nativeEvent.defaultPrevented) {
      return;
    }
    const newChecked = event.target.checked;
    setCheckedState(newChecked);
    if (onChange) {
      onChange(event, newChecked);
    }
  };
  let disabled = disabledProp;
  if (muiFormControl) {
    if (typeof disabled === "undefined") {
      disabled = muiFormControl.disabled;
    }
  }
  const hasLabelFor = type === "checkbox" || type === "radio";
  const ownerState = __spreadProps(__spreadValues({}, props), {
    checked,
    disabled,
    disableFocusRipple,
    edge
  });
  const classes = useUtilityClasses$V(ownerState);
  const externalForwardedProps = {
    slots,
    slotProps: __spreadValues({
      input: inputProps
    }, slotProps)
  };
  const [RootSlot, rootSlotProps] = useSlot("root", {
    ref,
    elementType: SwitchBaseRoot,
    className: classes.root,
    shouldForwardComponentProp: true,
    externalForwardedProps: __spreadValues(__spreadProps(__spreadValues({}, externalForwardedProps), {
      component: "span"
    }), other),
    getSlotProps: (handlers) => __spreadProps(__spreadValues({}, handlers), {
      onFocus: (event) => {
        var _a3;
        (_a3 = handlers.onFocus) == null ? void 0 : _a3.call(handlers, event);
        handleFocus(event);
      },
      onBlur: (event) => {
        var _a3;
        (_a3 = handlers.onBlur) == null ? void 0 : _a3.call(handlers, event);
        handleBlur(event);
      }
    }),
    ownerState,
    additionalProps: {
      centerRipple: true,
      focusRipple: !disableFocusRipple,
      disabled,
      role: void 0,
      tabIndex: null
    }
  });
  const [InputSlot, inputSlotProps] = useSlot("input", {
    ref: inputRef,
    elementType: SwitchBaseInput,
    className: classes.input,
    externalForwardedProps,
    getSlotProps: (handlers) => __spreadProps(__spreadValues({}, handlers), {
      onChange: (event) => {
        var _a3;
        (_a3 = handlers.onChange) == null ? void 0 : _a3.call(handlers, event);
        handleInputChange(event);
      }
    }),
    ownerState,
    additionalProps: __spreadValues({
      autoFocus,
      checked: checkedProp,
      defaultChecked,
      disabled,
      id: hasLabelFor ? id : void 0,
      name: name2,
      readOnly,
      required,
      tabIndex,
      type
    }, type === "checkbox" && value === void 0 ? {} : {
      value
    })
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, __spreadProps(__spreadValues({}, rootSlotProps), {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(InputSlot, __spreadValues({}, inputSlotProps)), checked ? checkedIcon : icon]
  }));
});
const CheckBoxOutlineBlankIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
}));
const CheckBoxIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
}));
const IndeterminateCheckBoxIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"
}));
function getCheckboxUtilityClass(slot) {
  return generateUtilityClass("MuiCheckbox", slot);
}
const checkboxClasses = generateUtilityClasses("MuiCheckbox", ["root", "checked", "disabled", "indeterminate", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium"]);
const useUtilityClasses$U = (ownerState) => {
  const {
    classes,
    indeterminate,
    color: color2,
    size
  } = ownerState;
  const slots = {
    root: ["root", indeterminate && "indeterminate", `color${capitalize(color2)}`, `size${capitalize(size)}`]
  };
  const composedClasses = composeClasses(slots, getCheckboxUtilityClass, classes);
  return __spreadValues(__spreadValues({}, classes), composedClasses);
};
const CheckboxRoot = styled(SwitchBase, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiCheckbox",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.indeterminate && styles2.indeterminate, styles2[`size${capitalize(ownerState.size)}`], ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  color: (theme2.vars || theme2).palette.text.secondary,
  variants: [{
    props: {
      color: "default",
      disableRipple: false
    },
    style: {
      "&:hover": {
        backgroundColor: theme2.alpha((theme2.vars || theme2).palette.action.active, (theme2.vars || theme2).palette.action.hoverOpacity)
      }
    }
  }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2,
      disableRipple: false
    },
    style: {
      "&:hover": {
        backgroundColor: theme2.alpha((theme2.vars || theme2).palette[color2].main, (theme2.vars || theme2).palette.action.hoverOpacity)
      }
    }
  })), ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      [`&.${checkboxClasses.checked}, &.${checkboxClasses.indeterminate}`]: {
        color: (theme2.vars || theme2).palette[color2].main
      },
      [`&.${checkboxClasses.disabled}`]: {
        color: (theme2.vars || theme2).palette.action.disabled
      }
    }
  })), {
    // Should be last to override other colors
    props: {
      disableRipple: false
    },
    style: {
      // Reset on touch devices, it doesn't add specificity
      "&:hover": {
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }]
})));
const defaultCheckedIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(CheckBoxIcon, {});
const defaultIcon$1 = /* @__PURE__ */ jsxRuntimeExports.jsx(CheckBoxOutlineBlankIcon, {});
const defaultIndeterminateIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(IndeterminateCheckBoxIcon, {});
const Checkbox = /* @__PURE__ */ reactExports.forwardRef(function Checkbox2(inProps, ref) {
  var _b, _c, _d;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCheckbox"
  });
  const _a2 = props, {
    checkedIcon = defaultCheckedIcon,
    color: color2 = "primary",
    icon: iconProp = defaultIcon$1,
    indeterminate = false,
    indeterminateIcon: indeterminateIconProp = defaultIndeterminateIcon,
    inputProps,
    size = "medium",
    disableRipple = false,
    className,
    slots = {},
    slotProps = {}
  } = _a2, other = __objRest(_a2, [
    "checkedIcon",
    "color",
    "icon",
    "indeterminate",
    "indeterminateIcon",
    "inputProps",
    "size",
    "disableRipple",
    "className",
    "slots",
    "slotProps"
  ]);
  const icon = indeterminate ? indeterminateIconProp : iconProp;
  const indeterminateIcon = indeterminate ? indeterminateIconProp : checkedIcon;
  const ownerState = __spreadProps(__spreadValues({}, props), {
    disableRipple,
    color: color2,
    indeterminate,
    size
  });
  const classes = useUtilityClasses$U(ownerState);
  const externalInputProps = (_b = slotProps.input) != null ? _b : inputProps;
  const [RootSlot, rootSlotProps] = useSlot("root", {
    ref,
    elementType: CheckboxRoot,
    className: clsx(classes.root, className),
    shouldForwardComponentProp: true,
    externalForwardedProps: __spreadValues({
      slots,
      slotProps
    }, other),
    ownerState,
    additionalProps: {
      type: "checkbox",
      icon: /* @__PURE__ */ reactExports.cloneElement(icon, {
        fontSize: (_c = icon.props.fontSize) != null ? _c : size
      }),
      checkedIcon: /* @__PURE__ */ reactExports.cloneElement(indeterminateIcon, {
        fontSize: (_d = indeterminateIcon.props.fontSize) != null ? _d : size
      }),
      disableRipple,
      slots,
      slotProps: {
        input: mergeSlotProps$1(typeof externalInputProps === "function" ? externalInputProps(ownerState) : externalInputProps, {
          "data-indeterminate": indeterminate
        })
      }
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, __spreadProps(__spreadValues({}, rootSlotProps), {
    classes
  }));
});
function mapEventPropToEvent(eventProp) {
  return eventProp.substring(2).toLowerCase();
}
function clickedRootScrollbar(event, doc) {
  return doc.documentElement.clientWidth < event.clientX || doc.documentElement.clientHeight < event.clientY;
}
function ClickAwayListener(props) {
  const {
    children,
    disableReactTree = false,
    mouseEvent = "onClick",
    onClickAway,
    touchEvent = "onTouchEnd"
  } = props;
  const movedRef = reactExports.useRef(false);
  const nodeRef = reactExports.useRef(null);
  const activatedRef = reactExports.useRef(false);
  const syntheticEventRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    setTimeout(() => {
      activatedRef.current = true;
    }, 0);
    return () => {
      activatedRef.current = false;
    };
  }, []);
  const handleRef = useForkRef(getReactElementRef(children), nodeRef);
  const handleClickAway = useEventCallback((event) => {
    const insideReactTree = syntheticEventRef.current;
    syntheticEventRef.current = false;
    const doc = ownerDocument(nodeRef.current);
    if (!activatedRef.current || !nodeRef.current || "clientX" in event && clickedRootScrollbar(event, doc)) {
      return;
    }
    if (movedRef.current) {
      movedRef.current = false;
      return;
    }
    let insideDOM;
    if (event.composedPath) {
      insideDOM = event.composedPath().includes(nodeRef.current);
    } else {
      insideDOM = !doc.documentElement.contains(
        // @ts-expect-error returns `false` as intended when not dispatched from a Node
        event.target
      ) || nodeRef.current.contains(
        // @ts-expect-error returns `false` as intended when not dispatched from a Node
        event.target
      );
    }
    if (!insideDOM && (disableReactTree || !insideReactTree)) {
      onClickAway(event);
    }
  });
  const createHandleSynthetic = (handlerName) => (event) => {
    syntheticEventRef.current = true;
    const childrenPropsHandler = children.props[handlerName];
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  };
  const childrenProps = {
    ref: handleRef
  };
  if (touchEvent !== false) {
    childrenProps[touchEvent] = createHandleSynthetic(touchEvent);
  }
  reactExports.useEffect(() => {
    if (touchEvent !== false) {
      const mappedTouchEvent = mapEventPropToEvent(touchEvent);
      const doc = ownerDocument(nodeRef.current);
      const handleTouchMove = () => {
        movedRef.current = true;
      };
      doc.addEventListener(mappedTouchEvent, handleClickAway);
      doc.addEventListener("touchmove", handleTouchMove);
      return () => {
        doc.removeEventListener(mappedTouchEvent, handleClickAway);
        doc.removeEventListener("touchmove", handleTouchMove);
      };
    }
    return void 0;
  }, [handleClickAway, touchEvent]);
  if (mouseEvent !== false) {
    childrenProps[mouseEvent] = createHandleSynthetic(mouseEvent);
  }
  reactExports.useEffect(() => {
    if (mouseEvent !== false) {
      const mappedMouseEvent = mapEventPropToEvent(mouseEvent);
      const doc = ownerDocument(nodeRef.current);
      doc.addEventListener(mappedMouseEvent, handleClickAway);
      return () => {
        doc.removeEventListener(mappedMouseEvent, handleClickAway);
      };
    }
    return void 0;
  }, [handleClickAway, mouseEvent]);
  return /* @__PURE__ */ reactExports.cloneElement(children, childrenProps);
}
const Container = createContainer({
  createStyledComponent: styled("div", {
    name: "MuiContainer",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, styles2[`maxWidth${capitalize(String(ownerState.maxWidth))}`], ownerState.fixed && styles2.fixed, ownerState.disableGutters && styles2.disableGutters];
    }
  }),
  useThemeProps: (inProps) => useDefaultProps({
    props: inProps,
    name: "MuiContainer"
  })
});
const isDynamicSupport = typeof globalCss({}) === "function";
const html = (theme2, enableColorScheme) => __spreadValues({
  WebkitFontSmoothing: "antialiased",
  // Antialiasing.
  MozOsxFontSmoothing: "grayscale",
  // Antialiasing.
  // Change from `box-sizing: content-box` so that `width`
  // is not affected by `padding` or `border`.
  boxSizing: "border-box",
  // Fix font resize problem in iOS
  WebkitTextSizeAdjust: "100%"
}, enableColorScheme && !theme2.vars && {
  colorScheme: theme2.palette.mode
});
const body = (theme2) => __spreadProps(__spreadValues({
  color: (theme2.vars || theme2).palette.text.primary
}, theme2.typography.body1), {
  backgroundColor: (theme2.vars || theme2).palette.background.default,
  "@media print": {
    // Save printer ink.
    backgroundColor: (theme2.vars || theme2).palette.common.white
  }
});
const styles$2 = (theme2, enableColorScheme = false) => {
  var _a2, _b;
  const colorSchemeStyles = {};
  if (enableColorScheme && theme2.colorSchemes && typeof theme2.getColorSchemeSelector === "function") {
    Object.entries(theme2.colorSchemes).forEach(([key, scheme]) => {
      var _a3, _b2;
      const selector = theme2.getColorSchemeSelector(key);
      if (selector.startsWith("@")) {
        colorSchemeStyles[selector] = {
          ":root": {
            colorScheme: (_a3 = scheme.palette) == null ? void 0 : _a3.mode
          }
        };
      } else {
        colorSchemeStyles[selector.replace(/\s*&/, "")] = {
          colorScheme: (_b2 = scheme.palette) == null ? void 0 : _b2.mode
        };
      }
    });
  }
  let defaultStyles = __spreadValues({
    html: html(theme2, enableColorScheme),
    "*, *::before, *::after": {
      boxSizing: "inherit"
    },
    "strong, b": {
      fontWeight: theme2.typography.fontWeightBold
    },
    body: __spreadProps(__spreadValues({
      margin: 0
    }, body(theme2)), {
      // Add support for document.body.requestFullScreen().
      // Other elements, if background transparent, are not supported.
      "&::backdrop": {
        backgroundColor: (theme2.vars || theme2).palette.background.default
      }
    })
  }, colorSchemeStyles);
  const themeOverrides = (_b = (_a2 = theme2.components) == null ? void 0 : _a2.MuiCssBaseline) == null ? void 0 : _b.styleOverrides;
  if (themeOverrides) {
    defaultStyles = [defaultStyles, themeOverrides];
  }
  return defaultStyles;
};
const SELECTOR = "mui-ecs";
const staticStyles = (theme2) => {
  const result = styles$2(theme2, false);
  const baseStyles = Array.isArray(result) ? result[0] : result;
  if (!theme2.vars && baseStyles) {
    baseStyles.html[`:root:has(${SELECTOR})`] = {
      colorScheme: theme2.palette.mode
    };
  }
  if (theme2.colorSchemes) {
    Object.entries(theme2.colorSchemes).forEach(([key, scheme]) => {
      var _a2, _b;
      const selector = theme2.getColorSchemeSelector(key);
      if (selector.startsWith("@")) {
        baseStyles[selector] = {
          [`:root:not(:has(.${SELECTOR}))`]: {
            colorScheme: (_a2 = scheme.palette) == null ? void 0 : _a2.mode
          }
        };
      } else {
        baseStyles[selector.replace(/\s*&/, "")] = {
          [`&:not(:has(.${SELECTOR}))`]: {
            colorScheme: (_b = scheme.palette) == null ? void 0 : _b.mode
          }
        };
      }
    });
  }
  return result;
};
const GlobalStyles = globalCss(isDynamicSupport ? ({
  theme: theme2,
  enableColorScheme
}) => styles$2(theme2, enableColorScheme) : ({
  theme: theme2
}) => staticStyles(theme2));
function CssBaseline(inProps) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCssBaseline"
  });
  const {
    children,
    enableColorScheme = false
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [isDynamicSupport && /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles, {
      enableColorScheme
    }), !isDynamicSupport && !enableColorScheme && /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: SELECTOR,
      style: {
        display: "none"
      }
    }), children]
  });
}
function getScrollbarSize(win = window) {
  const documentWidth = win.document.documentElement.clientWidth;
  return win.innerWidth - documentWidth;
}
function isOverflowing(container) {
  const doc = ownerDocument(container);
  if (doc.body === container) {
    return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
  }
  return container.scrollHeight > container.clientHeight;
}
function ariaHidden(element, hide2) {
  if (hide2) {
    element.setAttribute("aria-hidden", "true");
  } else {
    element.removeAttribute("aria-hidden");
  }
}
function getPaddingRight(element) {
  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
}
function isAriaHiddenForbiddenOnElement(element) {
  const forbiddenTagNames = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"];
  const isForbiddenTagName = forbiddenTagNames.includes(element.tagName);
  const isInputHidden = element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
  return isForbiddenTagName || isInputHidden;
}
function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, hide2) {
  const blacklist = [mountElement, currentElement, ...elementsToExclude];
  [].forEach.call(container.children, (element) => {
    const isNotExcludedElement = !blacklist.includes(element);
    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
    if (isNotExcludedElement && isNotForbiddenElement) {
      ariaHidden(element, hide2);
    }
  });
}
function findIndexOf(items, callback) {
  let idx = -1;
  items.some((item, index2) => {
    if (callback(item)) {
      idx = index2;
      return true;
    }
    return false;
  });
  return idx;
}
function handleContainer(containerInfo, props) {
  const restoreStyle = [];
  const container = containerInfo.container;
  if (!props.disableScrollLock) {
    if (isOverflowing(container)) {
      const scrollbarSize = getScrollbarSize(ownerWindow(container));
      restoreStyle.push({
        value: container.style.paddingRight,
        property: "padding-right",
        el: container
      });
      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
      const fixedElements2 = ownerDocument(container).querySelectorAll(".mui-fixed");
      [].forEach.call(fixedElements2, (element) => {
        restoreStyle.push({
          value: element.style.paddingRight,
          property: "padding-right",
          el: element
        });
        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
      });
    }
    let scrollContainer;
    if (container.parentNode instanceof DocumentFragment) {
      scrollContainer = ownerDocument(container).body;
    } else {
      const parent = container.parentElement;
      const containerWindow = ownerWindow(container);
      scrollContainer = (parent == null ? void 0 : parent.nodeName) === "HTML" && containerWindow.getComputedStyle(parent).overflowY === "scroll" ? parent : container;
    }
    restoreStyle.push({
      value: scrollContainer.style.overflow,
      property: "overflow",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowX,
      property: "overflow-x",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowY,
      property: "overflow-y",
      el: scrollContainer
    });
    scrollContainer.style.overflow = "hidden";
  }
  const restore = () => {
    restoreStyle.forEach(({
      value,
      el,
      property
    }) => {
      if (value) {
        el.style.setProperty(property, value);
      } else {
        el.style.removeProperty(property);
      }
    });
  };
  return restore;
}
function getHiddenSiblings(container) {
  const hiddenSiblings = [];
  [].forEach.call(container.children, (element) => {
    if (element.getAttribute("aria-hidden") === "true") {
      hiddenSiblings.push(element);
    }
  });
  return hiddenSiblings;
}
class ModalManager {
  constructor() {
    this.modals = [];
    this.containers = [];
  }
  add(modal, container) {
    let modalIndex = this.modals.indexOf(modal);
    if (modalIndex !== -1) {
      return modalIndex;
    }
    modalIndex = this.modals.length;
    this.modals.push(modal);
    if (modal.modalRef) {
      ariaHidden(modal.modalRef, false);
    }
    const hiddenSiblings = getHiddenSiblings(container);
    ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
    const containerIndex = findIndexOf(this.containers, (item) => item.container === container);
    if (containerIndex !== -1) {
      this.containers[containerIndex].modals.push(modal);
      return modalIndex;
    }
    this.containers.push({
      modals: [modal],
      container,
      restore: null,
      hiddenSiblings
    });
    return modalIndex;
  }
  mount(modal, props) {
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.includes(modal));
    const containerInfo = this.containers[containerIndex];
    if (!containerInfo.restore) {
      containerInfo.restore = handleContainer(containerInfo, props);
    }
  }
  remove(modal, ariaHiddenState = true) {
    const modalIndex = this.modals.indexOf(modal);
    if (modalIndex === -1) {
      return modalIndex;
    }
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.includes(modal));
    const containerInfo = this.containers[containerIndex];
    containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
    this.modals.splice(modalIndex, 1);
    if (containerInfo.modals.length === 0) {
      if (containerInfo.restore) {
        containerInfo.restore();
      }
      if (modal.modalRef) {
        ariaHidden(modal.modalRef, ariaHiddenState);
      }
      ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
      this.containers.splice(containerIndex, 1);
    } else {
      const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
      if (nextTop.modalRef) {
        ariaHidden(nextTop.modalRef, false);
      }
    }
    return modalIndex;
  }
  isTopModal(modal) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
  }
}
const candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function getTabIndex(node2) {
  const tabindexAttr = parseInt(node2.getAttribute("tabindex") || "", 10);
  if (!Number.isNaN(tabindexAttr)) {
    return tabindexAttr;
  }
  if (node2.contentEditable === "true" || (node2.nodeName === "AUDIO" || node2.nodeName === "VIDEO" || node2.nodeName === "DETAILS") && node2.getAttribute("tabindex") === null) {
    return 0;
  }
  return node2.tabIndex;
}
function isNonTabbableRadio(node2) {
  if (node2.tagName !== "INPUT" || node2.type !== "radio") {
    return false;
  }
  if (!node2.name) {
    return false;
  }
  const getRadio = (selector) => node2.ownerDocument.querySelector(`input[type="radio"]${selector}`);
  let roving = getRadio(`[name="${node2.name}"]:checked`);
  if (!roving) {
    roving = getRadio(`[name="${node2.name}"]`);
  }
  return roving !== node2;
}
function isNodeMatchingSelectorFocusable(node2) {
  if (node2.disabled || node2.tagName === "INPUT" && node2.type === "hidden" || isNonTabbableRadio(node2)) {
    return false;
  }
  return true;
}
function defaultGetTabbable(root) {
  const regularTabNodes = [];
  const orderedTabNodes = [];
  Array.from(root.querySelectorAll(candidatesSelector)).forEach((node2, i) => {
    const nodeTabIndex = getTabIndex(node2);
    if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node2)) {
      return;
    }
    if (nodeTabIndex === 0) {
      regularTabNodes.push(node2);
    } else {
      orderedTabNodes.push({
        documentOrder: i,
        tabIndex: nodeTabIndex,
        node: node2
      });
    }
  });
  return orderedTabNodes.sort((a, b) => a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex).map((a) => a.node).concat(regularTabNodes);
}
function defaultIsEnabled() {
  return true;
}
function FocusTrap(props) {
  const {
    children,
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableRestoreFocus = false,
    getTabbable = defaultGetTabbable,
    isEnabled = defaultIsEnabled,
    open
  } = props;
  const ignoreNextEnforceFocus = reactExports.useRef(false);
  const sentinelStart = reactExports.useRef(null);
  const sentinelEnd = reactExports.useRef(null);
  const nodeToRestore = reactExports.useRef(null);
  const reactFocusEventTarget = reactExports.useRef(null);
  const activated = reactExports.useRef(false);
  const rootRef = reactExports.useRef(null);
  const handleRef = useForkRef(getReactElementRef(children), rootRef);
  const lastKeydown = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    activated.current = !disableAutoFocus;
  }, [disableAutoFocus, open]);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    if (!rootRef.current.contains(doc.activeElement)) {
      if (!rootRef.current.hasAttribute("tabIndex")) {
        rootRef.current.setAttribute("tabIndex", "-1");
      }
      if (activated.current) {
        rootRef.current.focus();
      }
    }
    return () => {
      if (!disableRestoreFocus) {
        if (nodeToRestore.current && nodeToRestore.current.focus) {
          ignoreNextEnforceFocus.current = true;
          nodeToRestore.current.focus();
        }
        nodeToRestore.current = null;
      }
    };
  }, [open]);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    const loopFocus = (nativeEvent) => {
      lastKeydown.current = nativeEvent;
      if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== "Tab") {
        return;
      }
      if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
        ignoreNextEnforceFocus.current = true;
        if (sentinelEnd.current) {
          sentinelEnd.current.focus();
        }
      }
    };
    const contain = () => {
      var _a2, _b;
      const rootElement = rootRef.current;
      if (rootElement === null) {
        return;
      }
      if (!doc.hasFocus() || !isEnabled() || ignoreNextEnforceFocus.current) {
        ignoreNextEnforceFocus.current = false;
        return;
      }
      if (rootElement.contains(doc.activeElement)) {
        return;
      }
      if (disableEnforceFocus && doc.activeElement !== sentinelStart.current && doc.activeElement !== sentinelEnd.current) {
        return;
      }
      if (doc.activeElement !== reactFocusEventTarget.current) {
        reactFocusEventTarget.current = null;
      } else if (reactFocusEventTarget.current !== null) {
        return;
      }
      if (!activated.current) {
        return;
      }
      let tabbable = [];
      if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
        tabbable = getTabbable(rootRef.current);
      }
      if (tabbable.length > 0) {
        const isShiftTab = Boolean(((_a2 = lastKeydown.current) == null ? void 0 : _a2.shiftKey) && ((_b = lastKeydown.current) == null ? void 0 : _b.key) === "Tab");
        const focusNext = tabbable[0];
        const focusPrevious = tabbable[tabbable.length - 1];
        if (typeof focusNext !== "string" && typeof focusPrevious !== "string") {
          if (isShiftTab) {
            focusPrevious.focus();
          } else {
            focusNext.focus();
          }
        }
      } else {
        rootElement.focus();
      }
    };
    doc.addEventListener("focusin", contain);
    doc.addEventListener("keydown", loopFocus, true);
    const interval = setInterval(() => {
      if (doc.activeElement && doc.activeElement.tagName === "BODY") {
        contain();
      }
    }, 50);
    return () => {
      clearInterval(interval);
      doc.removeEventListener("focusin", contain);
      doc.removeEventListener("keydown", loopFocus, true);
    };
  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);
  const onFocus = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
    reactFocusEventTarget.current = event.target;
    const childrenPropsHandler = children.props.onFocus;
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  };
  const handleFocusSentinel = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelStart,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ reactExports.cloneElement(children, {
      ref: handleRef,
      onFocus
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelEnd,
      "data-testid": "sentinelEnd"
    })]
  });
}
function getContainer(container) {
  return typeof container === "function" ? container() : container;
}
function getHasTransition(children) {
  return children ? children.props.hasOwnProperty("in") : false;
}
const noop$2 = () => {
};
const manager = new ModalManager();
function useModal(parameters) {
  const {
    container,
    disableEscapeKeyDown = false,
    disableScrollLock = false,
    closeAfterTransition = false,
    onTransitionEnter,
    onTransitionExited,
    children,
    onClose,
    open,
    rootRef
  } = parameters;
  const modal = reactExports.useRef({});
  const mountNodeRef = reactExports.useRef(null);
  const modalRef = reactExports.useRef(null);
  const handleRef = useForkRef(modalRef, rootRef);
  const [exited, setExited] = reactExports.useState(!open);
  const hasTransition = getHasTransition(children);
  let ariaHiddenProp = true;
  if (parameters["aria-hidden"] === "false" || parameters["aria-hidden"] === false) {
    ariaHiddenProp = false;
  }
  const getDoc = () => ownerDocument(mountNodeRef.current);
  const getModal = () => {
    modal.current.modalRef = modalRef.current;
    modal.current.mount = mountNodeRef.current;
    return modal.current;
  };
  const handleMounted = () => {
    manager.mount(getModal(), {
      disableScrollLock
    });
    if (modalRef.current) {
      modalRef.current.scrollTop = 0;
    }
  };
  const handleOpen = useEventCallback(() => {
    const resolvedContainer = getContainer(container) || getDoc().body;
    manager.add(getModal(), resolvedContainer);
    if (modalRef.current) {
      handleMounted();
    }
  });
  const isTopModal = () => manager.isTopModal(getModal());
  const handlePortalRef = useEventCallback((node2) => {
    mountNodeRef.current = node2;
    if (!node2) {
      return;
    }
    if (open && isTopModal()) {
      handleMounted();
    } else if (modalRef.current) {
      ariaHidden(modalRef.current, ariaHiddenProp);
    }
  });
  const handleClose = reactExports.useCallback(() => {
    manager.remove(getModal(), ariaHiddenProp);
  }, [ariaHiddenProp]);
  reactExports.useEffect(() => {
    return () => {
      handleClose();
    };
  }, [handleClose]);
  reactExports.useEffect(() => {
    if (open) {
      handleOpen();
    } else if (!hasTransition || !closeAfterTransition) {
      handleClose();
    }
  }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
  const createHandleKeyDown = (otherHandlers) => (event) => {
    var _a2;
    (_a2 = otherHandlers.onKeyDown) == null ? void 0 : _a2.call(otherHandlers, event);
    if (event.key !== "Escape" || event.which === 229 || // Wait until IME is settled.
    !isTopModal()) {
      return;
    }
    if (!disableEscapeKeyDown) {
      event.stopPropagation();
      if (onClose) {
        onClose(event, "escapeKeyDown");
      }
    }
  };
  const createHandleBackdropClick = (otherHandlers) => (event) => {
    var _a2;
    (_a2 = otherHandlers.onClick) == null ? void 0 : _a2.call(otherHandlers, event);
    if (event.target !== event.currentTarget) {
      return;
    }
    if (onClose) {
      onClose(event, "backdropClick");
    }
  };
  const getRootProps = (otherHandlers = {}) => {
    const propsEventHandlers = extractEventHandlers(parameters);
    delete propsEventHandlers.onTransitionEnter;
    delete propsEventHandlers.onTransitionExited;
    const externalEventHandlers = __spreadValues(__spreadValues({}, propsEventHandlers), otherHandlers);
    return __spreadProps(__spreadValues({
      /*
       * Marking an element with the role presentation indicates to assistive technology
       * that this element should be ignored; it exists to support the web application and
       * is not meant for humans to interact with directly.
       * https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-static-element-interactions.md
       */
      role: "presentation"
    }, externalEventHandlers), {
      onKeyDown: createHandleKeyDown(externalEventHandlers),
      ref: handleRef
    });
  };
  const getBackdropProps = (otherHandlers = {}) => {
    const externalEventHandlers = otherHandlers;
    return __spreadProps(__spreadValues({
      "aria-hidden": true
    }, externalEventHandlers), {
      onClick: createHandleBackdropClick(externalEventHandlers),
      open
    });
  };
  const getTransitionProps2 = () => {
    var _a2, _b;
    const handleEnter = () => {
      setExited(false);
      if (onTransitionEnter) {
        onTransitionEnter();
      }
    };
    const handleExited = () => {
      setExited(true);
      if (onTransitionExited) {
        onTransitionExited();
      }
      if (closeAfterTransition) {
        handleClose();
      }
    };
    return {
      onEnter: createChainedFunction(handleEnter, (_a2 = children == null ? void 0 : children.props.onEnter) != null ? _a2 : noop$2),
      onExited: createChainedFunction(handleExited, (_b = children == null ? void 0 : children.props.onExited) != null ? _b : noop$2)
    };
  };
  return {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    rootRef: handleRef,
    portalRef: handlePortalRef,
    isTopModal,
    exited,
    hasTransition
  };
}
function getModalUtilityClass(slot) {
  return generateUtilityClass("MuiModal", slot);
}
generateUtilityClasses("MuiModal", ["root", "hidden", "backdrop"]);
const useUtilityClasses$T = (ownerState) => {
  const {
    open,
    exited,
    classes
  } = ownerState;
  const slots = {
    root: ["root", !open && exited && "hidden"],
    backdrop: ["backdrop"]
  };
  return composeClasses(slots, getModalUtilityClass, classes);
};
const ModalRoot = styled("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.open && ownerState.exited && styles2.hidden];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  position: "fixed",
  zIndex: (theme2.vars || theme2).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.open && ownerState.exited,
    style: {
      visibility: "hidden"
    }
  }]
})));
const ModalBackdrop = styled(Backdrop, {
  name: "MuiModal",
  slot: "Backdrop"
})({
  zIndex: -1
});
const Modal = /* @__PURE__ */ reactExports.forwardRef(function Modal2(inProps, ref) {
  const props = useDefaultProps({
    name: "MuiModal",
    props: inProps
  });
  const _a2 = props, {
    BackdropComponent = ModalBackdrop,
    BackdropProps,
    classes: classesProp,
    className,
    closeAfterTransition = false,
    children,
    container,
    component,
    components = {},
    componentsProps = {},
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableEscapeKeyDown = false,
    disablePortal = false,
    disableRestoreFocus = false,
    disableScrollLock = false,
    hideBackdrop = false,
    keepMounted = false,
    onClose,
    onTransitionEnter,
    onTransitionExited,
    open,
    slotProps = {},
    slots = {},
    theme: theme2
  } = _a2, other = __objRest(_a2, [
    "BackdropComponent",
    "BackdropProps",
    "classes",
    "className",
    "closeAfterTransition",
    "children",
    "container",
    "component",
    "components",
    "componentsProps",
    "disableAutoFocus",
    "disableEnforceFocus",
    "disableEscapeKeyDown",
    "disablePortal",
    "disableRestoreFocus",
    "disableScrollLock",
    "hideBackdrop",
    "keepMounted",
    "onClose",
    "onTransitionEnter",
    "onTransitionExited",
    "open",
    "slotProps",
    "slots",
    // eslint-disable-next-line react/prop-types
    "theme"
  ]);
  const propsWithDefaults = __spreadProps(__spreadValues({}, props), {
    closeAfterTransition,
    disableAutoFocus,
    disableEnforceFocus,
    disableEscapeKeyDown,
    disablePortal,
    disableRestoreFocus,
    disableScrollLock,
    hideBackdrop,
    keepMounted
  });
  const {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    portalRef,
    isTopModal,
    exited,
    hasTransition
  } = useModal(__spreadProps(__spreadValues({}, propsWithDefaults), {
    rootRef: ref
  }));
  const ownerState = __spreadProps(__spreadValues({}, propsWithDefaults), {
    exited
  });
  const classes = useUtilityClasses$T(ownerState);
  const childProps = {};
  if (children.props.tabIndex === void 0) {
    childProps.tabIndex = "-1";
  }
  if (hasTransition) {
    const {
      onEnter,
      onExited
    } = getTransitionProps2();
    childProps.onEnter = onEnter;
    childProps.onExited = onExited;
  }
  const externalForwardedProps = {
    slots: __spreadValues({
      root: components.Root,
      backdrop: components.Backdrop
    }, slots),
    slotProps: __spreadValues(__spreadValues({}, componentsProps), slotProps)
  };
  const [RootSlot, rootProps] = useSlot("root", {
    ref,
    elementType: ModalRoot,
    externalForwardedProps: __spreadProps(__spreadValues(__spreadValues({}, externalForwardedProps), other), {
      component
    }),
    getSlotProps: getRootProps,
    ownerState,
    className: clsx(className, classes == null ? void 0 : classes.root, !ownerState.open && ownerState.exited && (classes == null ? void 0 : classes.hidden))
  });
  const [BackdropSlot, backdropProps] = useSlot("backdrop", {
    ref: BackdropProps == null ? void 0 : BackdropProps.ref,
    elementType: BackdropComponent,
    externalForwardedProps,
    shouldForwardComponentProp: true,
    additionalProps: BackdropProps,
    getSlotProps: (otherHandlers) => {
      return getBackdropProps(__spreadProps(__spreadValues({}, otherHandlers), {
        onClick: (event) => {
          if (otherHandlers == null ? void 0 : otherHandlers.onClick) {
            otherHandlers.onClick(event);
          }
        }
      }));
    },
    className: clsx(BackdropProps == null ? void 0 : BackdropProps.className, classes == null ? void 0 : classes.backdrop),
    ownerState
  });
  if (!keepMounted && !open && (!hasTransition || exited)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
    ref: portalRef,
    container,
    disablePortal,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, __spreadProps(__spreadValues({}, rootProps), {
      children: [!hideBackdrop && BackdropComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropSlot, __spreadValues({}, backdropProps)) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap, {
        disableEnforceFocus,
        disableAutoFocus,
        disableRestoreFocus,
        isEnabled: isTopModal,
        open,
        children: /* @__PURE__ */ reactExports.cloneElement(children, childProps)
      })]
    }))
  });
});
function getDialogUtilityClass(slot) {
  return generateUtilityClass("MuiDialog", slot);
}
const dialogClasses = generateUtilityClasses("MuiDialog", ["root", "scrollPaper", "scrollBody", "container", "paper", "paperScrollPaper", "paperScrollBody", "paperWidthFalse", "paperWidthXs", "paperWidthSm", "paperWidthMd", "paperWidthLg", "paperWidthXl", "paperFullWidth", "paperFullScreen"]);
const DialogContext = /* @__PURE__ */ reactExports.createContext({});
const DialogBackdrop = styled(Backdrop, {
  name: "MuiDialog",
  slot: "Backdrop",
  overrides: (props, styles2) => styles2.backdrop
})({
  // Improve scrollable dialog support.
  zIndex: -1
});
const useUtilityClasses$S = (ownerState) => {
  const {
    classes,
    scroll,
    maxWidth: maxWidth2,
    fullWidth,
    fullScreen
  } = ownerState;
  const slots = {
    root: ["root"],
    container: ["container", `scroll${capitalize(scroll)}`],
    paper: ["paper", `paperScroll${capitalize(scroll)}`, `paperWidth${capitalize(String(maxWidth2))}`, fullWidth && "paperFullWidth", fullScreen && "paperFullScreen"]
  };
  return composeClasses(slots, getDialogUtilityClass, classes);
};
const DialogRoot = styled(Modal, {
  name: "MuiDialog",
  slot: "Root"
})({
  "@media print": {
    // Use !important to override the Modal inline-style.
    position: "absolute !important"
  }
});
const DialogContainer = styled("div", {
  name: "MuiDialog",
  slot: "Container",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.container, styles2[`scroll${capitalize(ownerState.scroll)}`]];
  }
})({
  height: "100%",
  "@media print": {
    height: "auto"
  },
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  variants: [{
    props: {
      scroll: "paper"
    },
    style: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center"
    }
  }, {
    props: {
      scroll: "body"
    },
    style: {
      overflowY: "auto",
      overflowX: "hidden",
      textAlign: "center",
      "&::after": {
        content: '""',
        display: "inline-block",
        verticalAlign: "middle",
        height: "100%",
        width: "0"
      }
    }
  }]
});
const DialogPaper = styled(Paper, {
  name: "MuiDialog",
  slot: "Paper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.paper, styles2[`scrollPaper${capitalize(ownerState.scroll)}`], styles2[`paperWidth${capitalize(String(ownerState.maxWidth))}`], ownerState.fullWidth && styles2.paperFullWidth, ownerState.fullScreen && styles2.paperFullScreen];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  margin: 32,
  position: "relative",
  overflowY: "auto",
  "@media print": {
    overflowY: "visible",
    boxShadow: "none"
  },
  variants: [{
    props: {
      scroll: "paper"
    },
    style: {
      display: "flex",
      flexDirection: "column",
      maxHeight: "calc(100% - 64px)"
    }
  }, {
    props: {
      scroll: "body"
    },
    style: {
      display: "inline-block",
      verticalAlign: "middle",
      textAlign: "initial"
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.maxWidth,
    style: {
      maxWidth: "calc(100% - 64px)"
    }
  }, {
    props: {
      maxWidth: "xs"
    },
    style: {
      maxWidth: theme2.breakpoints.unit === "px" ? Math.max(theme2.breakpoints.values.xs, 444) : `max(${theme2.breakpoints.values.xs}${theme2.breakpoints.unit}, 444px)`,
      [`&.${dialogClasses.paperScrollBody}`]: {
        [theme2.breakpoints.down(Math.max(theme2.breakpoints.values.xs, 444) + 32 * 2)]: {
          maxWidth: "calc(100% - 64px)"
        }
      }
    }
  }, ...Object.keys(theme2.breakpoints.values).filter((maxWidth2) => maxWidth2 !== "xs").map((maxWidth2) => ({
    props: {
      maxWidth: maxWidth2
    },
    style: {
      maxWidth: `${theme2.breakpoints.values[maxWidth2]}${theme2.breakpoints.unit}`,
      [`&.${dialogClasses.paperScrollBody}`]: {
        [theme2.breakpoints.down(theme2.breakpoints.values[maxWidth2] + 32 * 2)]: {
          maxWidth: "calc(100% - 64px)"
        }
      }
    }
  })), {
    props: ({
      ownerState
    }) => ownerState.fullWidth,
    style: {
      width: "calc(100% - 64px)"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.fullScreen,
    style: {
      margin: 0,
      width: "100%",
      maxWidth: "100%",
      height: "100%",
      maxHeight: "none",
      borderRadius: 0,
      [`&.${dialogClasses.paperScrollBody}`]: {
        margin: 0,
        maxWidth: "100%"
      }
    }
  }]
})));
const Dialog = /* @__PURE__ */ reactExports.forwardRef(function Dialog2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDialog"
  });
  const theme2 = useTheme();
  const defaultTransitionDuration = {
    enter: theme2.transitions.duration.enteringScreen,
    exit: theme2.transitions.duration.leavingScreen
  };
  const _a2 = props, {
    "aria-describedby": ariaDescribedby,
    "aria-labelledby": ariaLabelledbyProp,
    "aria-modal": ariaModal = true,
    BackdropComponent,
    BackdropProps,
    children,
    className,
    disableEscapeKeyDown = false,
    fullScreen = false,
    fullWidth = false,
    maxWidth: maxWidth2 = "sm",
    onClick,
    onClose,
    open,
    PaperComponent = Paper,
    PaperProps = {},
    scroll = "paper",
    slots = {},
    slotProps = {},
    TransitionComponent = Fade,
    transitionDuration = defaultTransitionDuration,
    TransitionProps
  } = _a2, other = __objRest(_a2, [
    "aria-describedby",
    "aria-labelledby",
    "aria-modal",
    "BackdropComponent",
    "BackdropProps",
    "children",
    "className",
    "disableEscapeKeyDown",
    "fullScreen",
    "fullWidth",
    "maxWidth",
    "onClick",
    "onClose",
    "open",
    "PaperComponent",
    "PaperProps",
    "scroll",
    "slots",
    "slotProps",
    "TransitionComponent",
    "transitionDuration",
    "TransitionProps"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    disableEscapeKeyDown,
    fullScreen,
    fullWidth,
    maxWidth: maxWidth2,
    scroll
  });
  const classes = useUtilityClasses$S(ownerState);
  const backdropClick = reactExports.useRef();
  const handleMouseDown = (event) => {
    backdropClick.current = event.target === event.currentTarget;
  };
  const handleBackdropClick = (event) => {
    if (onClick) {
      onClick(event);
    }
    if (!backdropClick.current) {
      return;
    }
    backdropClick.current = null;
    if (onClose) {
      onClose(event, "backdropClick");
    }
  };
  const ariaLabelledby = useId(ariaLabelledbyProp);
  const dialogContextValue = reactExports.useMemo(() => {
    return {
      titleId: ariaLabelledby
    };
  }, [ariaLabelledby]);
  const backwardCompatibleSlots = __spreadValues({
    transition: TransitionComponent
  }, slots);
  const backwardCompatibleSlotProps = __spreadValues({
    transition: TransitionProps,
    paper: PaperProps,
    backdrop: BackdropProps
  }, slotProps);
  const externalForwardedProps = {
    slots: backwardCompatibleSlots,
    slotProps: backwardCompatibleSlotProps
  };
  const [RootSlot, rootSlotProps] = useSlot("root", {
    elementType: DialogRoot,
    shouldForwardComponentProp: true,
    externalForwardedProps,
    ownerState,
    className: clsx(classes.root, className),
    ref
  });
  const [BackdropSlot, backdropSlotProps] = useSlot("backdrop", {
    elementType: DialogBackdrop,
    shouldForwardComponentProp: true,
    externalForwardedProps,
    ownerState
  });
  const [PaperSlot, paperSlotProps] = useSlot("paper", {
    elementType: DialogPaper,
    shouldForwardComponentProp: true,
    externalForwardedProps,
    ownerState,
    className: clsx(classes.paper, PaperProps.className)
  });
  const [ContainerSlot, containerSlotProps] = useSlot("container", {
    elementType: DialogContainer,
    externalForwardedProps,
    ownerState,
    className: classes.container
  });
  const [TransitionSlot, transitionSlotProps] = useSlot("transition", {
    elementType: Fade,
    externalForwardedProps,
    ownerState,
    additionalProps: {
      appear: true,
      in: open,
      timeout: transitionDuration,
      role: "presentation"
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, __spreadProps(__spreadValues(__spreadValues({
    closeAfterTransition: true,
    slots: {
      backdrop: BackdropSlot
    },
    slotProps: {
      backdrop: __spreadValues({
        transitionDuration,
        as: BackdropComponent
      }, backdropSlotProps)
    },
    disableEscapeKeyDown,
    onClose,
    open,
    onClick: handleBackdropClick
  }, rootSlotProps), other), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionSlot, __spreadProps(__spreadValues({}, transitionSlotProps), {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ContainerSlot, __spreadProps(__spreadValues({
        onMouseDown: handleMouseDown
      }, containerSlotProps), {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaperSlot, __spreadProps(__spreadValues({
          as: PaperComponent,
          elevation: 24,
          role: "dialog",
          "aria-describedby": ariaDescribedby,
          "aria-labelledby": ariaLabelledby,
          "aria-modal": ariaModal
        }, paperSlotProps), {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContext.Provider, {
            value: dialogContextValue,
            children
          })
        }))
      }))
    }))
  }));
});
function getDialogActionsUtilityClass(slot) {
  return generateUtilityClass("MuiDialogActions", slot);
}
generateUtilityClasses("MuiDialogActions", ["root", "spacing"]);
const useUtilityClasses$R = (ownerState) => {
  const {
    classes,
    disableSpacing
  } = ownerState;
  const slots = {
    root: ["root", !disableSpacing && "spacing"]
  };
  return composeClasses(slots, getDialogActionsUtilityClass, classes);
};
const DialogActionsRoot = styled("div", {
  name: "MuiDialogActions",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.disableSpacing && styles2.spacing];
  }
})({
  display: "flex",
  alignItems: "center",
  padding: 8,
  justifyContent: "flex-end",
  flex: "0 0 auto",
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.disableSpacing,
    style: {
      "& > :not(style) ~ :not(style)": {
        marginLeft: 8
      }
    }
  }]
});
const DialogActions = /* @__PURE__ */ reactExports.forwardRef(function DialogActions2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDialogActions"
  });
  const _a2 = props, {
    className,
    disableSpacing = false
  } = _a2, other = __objRest(_a2, [
    "className",
    "disableSpacing"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    disableSpacing
  });
  const classes = useUtilityClasses$R(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActionsRoot, __spreadValues({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
function getDialogContentUtilityClass(slot) {
  return generateUtilityClass("MuiDialogContent", slot);
}
generateUtilityClasses("MuiDialogContent", ["root", "dividers"]);
function getDialogTitleUtilityClass(slot) {
  return generateUtilityClass("MuiDialogTitle", slot);
}
const dialogTitleClasses = generateUtilityClasses("MuiDialogTitle", ["root"]);
const useUtilityClasses$Q = (ownerState) => {
  const {
    classes,
    dividers
  } = ownerState;
  const slots = {
    root: ["root", dividers && "dividers"]
  };
  return composeClasses(slots, getDialogContentUtilityClass, classes);
};
const DialogContentRoot = styled("div", {
  name: "MuiDialogContent",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.dividers && styles2.dividers];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  flex: "1 1 auto",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch",
  overflowY: "auto",
  padding: "20px 24px",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.dividers,
    style: {
      padding: "16px 24px",
      borderTop: `1px solid ${(theme2.vars || theme2).palette.divider}`,
      borderBottom: `1px solid ${(theme2.vars || theme2).palette.divider}`
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.dividers,
    style: {
      [`.${dialogTitleClasses.root} + &`]: {
        paddingTop: 0
      }
    }
  }]
})));
const DialogContent = /* @__PURE__ */ reactExports.forwardRef(function DialogContent2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDialogContent"
  });
  const _a2 = props, {
    className,
    dividers = false
  } = _a2, other = __objRest(_a2, [
    "className",
    "dividers"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    dividers
  });
  const classes = useUtilityClasses$Q(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentRoot, __spreadValues({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
function getDialogContentTextUtilityClass(slot) {
  return generateUtilityClass("MuiDialogContentText", slot);
}
generateUtilityClasses("MuiDialogContentText", ["root"]);
const useUtilityClasses$P = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  const composedClasses = composeClasses(slots, getDialogContentTextUtilityClass, classes);
  return __spreadValues(__spreadValues({}, classes), composedClasses);
};
const DialogContentTextRoot = styled(Typography, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiDialogContentText",
  slot: "Root"
})({});
const DialogContentText = /* @__PURE__ */ reactExports.forwardRef(function DialogContentText2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDialogContentText"
  });
  const _a2 = props, {
    children,
    className
  } = _a2, ownerState = __objRest(_a2, [
    "children",
    "className"
  ]);
  const classes = useUtilityClasses$P(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentTextRoot, __spreadProps(__spreadValues({
    component: "p",
    variant: "body1",
    color: "textSecondary",
    ref,
    ownerState,
    className: clsx(classes.root, className)
  }, props), {
    classes
  }));
});
const useUtilityClasses$O = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getDialogTitleUtilityClass, classes);
};
const DialogTitleRoot = styled(Typography, {
  name: "MuiDialogTitle",
  slot: "Root"
})({
  padding: "16px 24px",
  flex: "0 0 auto"
});
const DialogTitle = /* @__PURE__ */ reactExports.forwardRef(function DialogTitle2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDialogTitle"
  });
  const _a2 = props, {
    className,
    id: idProp
  } = _a2, other = __objRest(_a2, [
    "className",
    "id"
  ]);
  const ownerState = props;
  const classes = useUtilityClasses$O(ownerState);
  const {
    titleId = idProp
  } = reactExports.useContext(DialogContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitleRoot, __spreadValues({
    component: "h2",
    className: clsx(classes.root, className),
    ownerState,
    ref,
    variant: "h6",
    id: idProp != null ? idProp : titleId
  }, other));
});
function getDividerUtilityClass(slot) {
  return generateUtilityClass("MuiDivider", slot);
}
const dividerClasses = generateUtilityClasses("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]);
const useUtilityClasses$N = (ownerState) => {
  const {
    absolute,
    children,
    classes,
    flexItem,
    light: light2,
    orientation,
    textAlign,
    variant
  } = ownerState;
  const slots = {
    root: ["root", absolute && "absolute", variant, light2 && "light", orientation === "vertical" && "vertical", flexItem && "flexItem", children && "withChildren", children && orientation === "vertical" && "withChildrenVertical", textAlign === "right" && orientation !== "vertical" && "textAlignRight", textAlign === "left" && orientation !== "vertical" && "textAlignLeft"],
    wrapper: ["wrapper", orientation === "vertical" && "wrapperVertical"]
  };
  return composeClasses(slots, getDividerUtilityClass, classes);
};
const DividerRoot = styled("div", {
  name: "MuiDivider",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.absolute && styles2.absolute, styles2[ownerState.variant], ownerState.light && styles2.light, ownerState.orientation === "vertical" && styles2.vertical, ownerState.flexItem && styles2.flexItem, ownerState.children && styles2.withChildren, ownerState.children && ownerState.orientation === "vertical" && styles2.withChildrenVertical, ownerState.textAlign === "right" && ownerState.orientation !== "vertical" && styles2.textAlignRight, ownerState.textAlign === "left" && ownerState.orientation !== "vertical" && styles2.textAlignLeft];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  margin: 0,
  // Reset browser default style.
  flexShrink: 0,
  borderWidth: 0,
  borderStyle: "solid",
  borderColor: (theme2.vars || theme2).palette.divider,
  borderBottomWidth: "thin",
  variants: [{
    props: {
      absolute: true
    },
    style: {
      position: "absolute",
      bottom: 0,
      left: 0,
      width: "100%"
    }
  }, {
    props: {
      light: true
    },
    style: {
      borderColor: theme2.alpha((theme2.vars || theme2).palette.divider, 0.08)
    }
  }, {
    props: {
      variant: "inset"
    },
    style: {
      marginLeft: 72
    }
  }, {
    props: {
      variant: "middle",
      orientation: "horizontal"
    },
    style: {
      marginLeft: theme2.spacing(2),
      marginRight: theme2.spacing(2)
    }
  }, {
    props: {
      variant: "middle",
      orientation: "vertical"
    },
    style: {
      marginTop: theme2.spacing(1),
      marginBottom: theme2.spacing(1)
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      borderBottomWidth: 0,
      borderRightWidth: "thin"
    }
  }, {
    props: {
      flexItem: true
    },
    style: {
      alignSelf: "stretch",
      height: "auto"
    }
  }, {
    props: ({
      ownerState
    }) => !!ownerState.children,
    style: {
      display: "flex",
      textAlign: "center",
      border: 0,
      borderTopStyle: "solid",
      borderLeftStyle: "solid",
      "&::before, &::after": {
        content: '""',
        alignSelf: "center"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.children && ownerState.orientation !== "vertical",
    style: {
      "&::before, &::after": {
        width: "100%",
        borderTop: `thin solid ${(theme2.vars || theme2).palette.divider}`,
        borderTopStyle: "inherit"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.orientation === "vertical" && ownerState.children,
    style: {
      flexDirection: "column",
      "&::before, &::after": {
        height: "100%",
        borderLeft: `thin solid ${(theme2.vars || theme2).palette.divider}`,
        borderLeftStyle: "inherit"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.textAlign === "right" && ownerState.orientation !== "vertical",
    style: {
      "&::before": {
        width: "90%"
      },
      "&::after": {
        width: "10%"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.textAlign === "left" && ownerState.orientation !== "vertical",
    style: {
      "&::before": {
        width: "10%"
      },
      "&::after": {
        width: "90%"
      }
    }
  }]
})));
const DividerWrapper = styled("span", {
  name: "MuiDivider",
  slot: "Wrapper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.wrapper, ownerState.orientation === "vertical" && styles2.wrapperVertical];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  display: "inline-block",
  paddingLeft: `calc(${theme2.spacing(1)} * 1.2)`,
  paddingRight: `calc(${theme2.spacing(1)} * 1.2)`,
  whiteSpace: "nowrap",
  variants: [{
    props: {
      orientation: "vertical"
    },
    style: {
      paddingTop: `calc(${theme2.spacing(1)} * 1.2)`,
      paddingBottom: `calc(${theme2.spacing(1)} * 1.2)`
    }
  }]
})));
const Divider = /* @__PURE__ */ reactExports.forwardRef(function Divider2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDivider"
  });
  const _a2 = props, {
    absolute = false,
    children,
    className,
    orientation = "horizontal",
    component = children || orientation === "vertical" ? "div" : "hr",
    flexItem = false,
    light: light2 = false,
    role = component !== "hr" ? "separator" : void 0,
    textAlign = "center",
    variant = "fullWidth"
  } = _a2, other = __objRest(_a2, [
    "absolute",
    "children",
    "className",
    "orientation",
    "component",
    "flexItem",
    "light",
    "role",
    "textAlign",
    "variant"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    absolute,
    component,
    flexItem,
    light: light2,
    orientation,
    role,
    textAlign,
    variant
  });
  const classes = useUtilityClasses$N(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DividerRoot, __spreadProps(__spreadValues({
    as: component,
    className: clsx(classes.root, className),
    role,
    ref,
    ownerState,
    "aria-orientation": role === "separator" && (component !== "hr" || orientation === "vertical") ? orientation : void 0
  }, other), {
    children: children ? /* @__PURE__ */ jsxRuntimeExports.jsx(DividerWrapper, {
      className: classes.wrapper,
      ownerState,
      children
    }) : null
  }));
});
if (Divider) {
  Divider.muiSkipListHighlight = true;
}
function getFabUtilityClass(slot) {
  return generateUtilityClass("MuiFab", slot);
}
const fabClasses = generateUtilityClasses("MuiFab", ["root", "primary", "secondary", "extended", "circular", "focusVisible", "disabled", "colorInherit", "sizeSmall", "sizeMedium", "sizeLarge", "info", "error", "warning", "success"]);
const useUtilityClasses$M = (ownerState) => {
  const {
    color: color2,
    variant,
    classes,
    size
  } = ownerState;
  const slots = {
    root: ["root", variant, `size${capitalize(size)}`, color2 === "inherit" ? "colorInherit" : color2]
  };
  const composedClasses = composeClasses(slots, getFabUtilityClass, classes);
  return __spreadValues(__spreadValues({}, classes), composedClasses);
};
const FabRoot = styled(ButtonBase, {
  name: "MuiFab",
  slot: "Root",
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`size${capitalize(ownerState.size)}`], ownerState.color === "inherit" && styles2.colorInherit, styles2[capitalize(ownerState.size)], styles2[ownerState.color]];
  }
})(memoTheme(({
  theme: theme2
}) => {
  var _a2, _b;
  return __spreadProps(__spreadValues({}, theme2.typography.button), {
    minHeight: 36,
    transition: theme2.transitions.create(["background-color", "box-shadow", "border-color"], {
      duration: theme2.transitions.duration.short
    }),
    borderRadius: "50%",
    padding: 0,
    minWidth: 0,
    width: 56,
    height: 56,
    zIndex: (theme2.vars || theme2).zIndex.fab,
    boxShadow: (theme2.vars || theme2).shadows[6],
    "&:active": {
      boxShadow: (theme2.vars || theme2).shadows[12]
    },
    color: theme2.vars ? theme2.vars.palette.grey[900] : (_b = (_a2 = theme2.palette).getContrastText) == null ? void 0 : _b.call(_a2, theme2.palette.grey[300]),
    backgroundColor: (theme2.vars || theme2).palette.grey[300],
    "&:hover": {
      backgroundColor: (theme2.vars || theme2).palette.grey.A100,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: (theme2.vars || theme2).palette.grey[300]
      },
      textDecoration: "none"
    },
    [`&.${fabClasses.focusVisible}`]: {
      boxShadow: (theme2.vars || theme2).shadows[6]
    },
    variants: [{
      props: {
        size: "small"
      },
      style: {
        width: 40,
        height: 40
      }
    }, {
      props: {
        size: "medium"
      },
      style: {
        width: 48,
        height: 48
      }
    }, {
      props: {
        variant: "extended"
      },
      style: {
        borderRadius: 48 / 2,
        padding: "0 16px",
        width: "auto",
        minHeight: "auto",
        minWidth: 48,
        height: 48
      }
    }, {
      props: {
        variant: "extended",
        size: "small"
      },
      style: {
        width: "auto",
        padding: "0 8px",
        borderRadius: 34 / 2,
        minWidth: 34,
        height: 34
      }
    }, {
      props: {
        variant: "extended",
        size: "medium"
      },
      style: {
        width: "auto",
        padding: "0 16px",
        borderRadius: 40 / 2,
        minWidth: 40,
        height: 40
      }
    }, {
      props: {
        color: "inherit"
      },
      style: {
        color: "inherit"
      }
    }]
  });
}), memoTheme(({
  theme: theme2
}) => ({
  variants: [...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["dark", "contrastText"])).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      color: (theme2.vars || theme2).palette[color2].contrastText,
      backgroundColor: (theme2.vars || theme2).palette[color2].main,
      "&:hover": {
        backgroundColor: (theme2.vars || theme2).palette[color2].dark,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: (theme2.vars || theme2).palette[color2].main
        }
      }
    }
  }))]
})), memoTheme(({
  theme: theme2
}) => ({
  [`&.${fabClasses.disabled}`]: {
    color: (theme2.vars || theme2).palette.action.disabled,
    boxShadow: (theme2.vars || theme2).shadows[0],
    backgroundColor: (theme2.vars || theme2).palette.action.disabledBackground
  }
})));
const Fab = /* @__PURE__ */ reactExports.forwardRef(function Fab2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFab"
  });
  const _a2 = props, {
    children,
    className,
    color: color2 = "default",
    component = "button",
    disabled = false,
    disableFocusRipple = false,
    focusVisibleClassName,
    size = "large",
    variant = "circular"
  } = _a2, other = __objRest(_a2, [
    "children",
    "className",
    "color",
    "component",
    "disabled",
    "disableFocusRipple",
    "focusVisibleClassName",
    "size",
    "variant"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: color2,
    component,
    disabled,
    disableFocusRipple,
    size,
    variant
  });
  const classes = useUtilityClasses$M(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FabRoot, __spreadProps(__spreadValues({
    className: clsx(classes.root, className),
    component,
    disabled,
    focusRipple: !disableFocusRipple,
    focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
    ownerState,
    ref
  }, other), {
    classes,
    children
  }));
});
const useUtilityClasses$L = (ownerState) => {
  const {
    classes,
    disableUnderline,
    startAdornment,
    endAdornment,
    size,
    hiddenLabel,
    multiline
  } = ownerState;
  const slots = {
    root: ["root", !disableUnderline && "underline", startAdornment && "adornedStart", endAdornment && "adornedEnd", size === "small" && `size${capitalize(size)}`, hiddenLabel && "hiddenLabel", multiline && "multiline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getFilledInputUtilityClass, classes);
  return __spreadValues(__spreadValues({}, classes), composedClasses);
};
const FilledInputRoot = styled(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiFilledInput",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
  }
})(memoTheme(({
  theme: theme2
}) => {
  const light2 = theme2.palette.mode === "light";
  const bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  const backgroundColor2 = light2 ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)";
  const hoverBackground = light2 ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)";
  const disabledBackground = light2 ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
  return {
    position: "relative",
    backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.bg : backgroundColor2,
    borderTopLeftRadius: (theme2.vars || theme2).shape.borderRadius,
    borderTopRightRadius: (theme2.vars || theme2).shape.borderRadius,
    transition: theme2.transitions.create("background-color", {
      duration: theme2.transitions.duration.shorter,
      easing: theme2.transitions.easing.easeOut
    }),
    "&:hover": {
      backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.hoverBg : hoverBackground,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.bg : backgroundColor2
      }
    },
    [`&.${filledInputClasses.focused}`]: {
      backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.bg : backgroundColor2
    },
    [`&.${filledInputClasses.disabled}`]: {
      backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.disabledBg : disabledBackground
    },
    variants: [{
      props: ({
        ownerState
      }) => !ownerState.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: theme2.transitions.create("transform", {
            duration: theme2.transitions.duration.shorter,
            easing: theme2.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${filledInputClasses.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${filledInputClasses.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (theme2.vars || theme2).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${theme2.vars ? theme2.alpha(theme2.vars.palette.common.onBackground, theme2.vars.opacity.inputUnderline) : bottomLineColor}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: theme2.transitions.create("border-bottom-color", {
            duration: theme2.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${filledInputClasses.disabled}, .${filledInputClasses.error}):before`]: {
          borderBottom: `1px solid ${(theme2.vars || theme2).palette.text.primary}`
        },
        [`&.${filledInputClasses.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => {
      var _a2;
      return {
        props: {
          disableUnderline: false,
          color: color2
        },
        style: {
          "&::after": {
            borderBottom: `2px solid ${(_a2 = (theme2.vars || theme2).palette[color2]) == null ? void 0 : _a2.main}`
          }
        }
      };
    }), {
      props: ({
        ownerState
      }) => ownerState.startAdornment,
      style: {
        paddingLeft: 12
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.endAdornment,
      style: {
        paddingRight: 12
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.multiline,
      style: {
        padding: "25px 12px 8px"
      }
    }, {
      props: ({
        ownerState,
        size
      }) => ownerState.multiline && size === "small",
      style: {
        paddingTop: 21,
        paddingBottom: 4
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.multiline && ownerState.hiddenLabel,
      style: {
        paddingTop: 16,
        paddingBottom: 17
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.multiline && ownerState.hiddenLabel && ownerState.size === "small",
      style: {
        paddingTop: 8,
        paddingBottom: 9
      }
    }]
  };
}));
const FilledInputInput = styled(InputBaseInput, {
  name: "MuiFilledInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(memoTheme(({
  theme: theme2
}) => __spreadProps(__spreadValues(__spreadValues({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12
}, !theme2.vars && {
  "&:-webkit-autofill": {
    WebkitBoxShadow: theme2.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
    WebkitTextFillColor: theme2.palette.mode === "light" ? null : "#fff",
    caretColor: theme2.palette.mode === "light" ? null : "#fff",
    borderTopLeftRadius: "inherit",
    borderTopRightRadius: "inherit"
  }
}), theme2.vars && {
  "&:-webkit-autofill": {
    borderTopLeftRadius: "inherit",
    borderTopRightRadius: "inherit"
  },
  [theme2.getColorSchemeSelector("dark")]: {
    "&:-webkit-autofill": {
      WebkitBoxShadow: "0 0 0 100px #266798 inset",
      WebkitTextFillColor: "#fff",
      caretColor: "#fff"
    }
  }
}), {
  variants: [{
    props: {
      size: "small"
    },
    style: {
      paddingTop: 21,
      paddingBottom: 4
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.hiddenLabel,
    style: {
      paddingTop: 16,
      paddingBottom: 17
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.endAdornment,
    style: {
      paddingRight: 0
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.hiddenLabel && ownerState.size === "small",
    style: {
      paddingTop: 8,
      paddingBottom: 9
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.multiline,
    style: {
      paddingTop: 0,
      paddingBottom: 0,
      paddingLeft: 0,
      paddingRight: 0
    }
  }]
})));
const FilledInput = /* @__PURE__ */ reactExports.forwardRef(function FilledInput2(inProps, ref) {
  var _b, _c, _d, _e;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFilledInput"
  });
  const _a2 = props, {
    disableUnderline = false,
    components = {},
    componentsProps: componentsPropsProp,
    fullWidth = false,
    hiddenLabel,
    inputComponent: inputComponent = "input",
    multiline = false,
    slotProps,
    slots = {},
    type = "text"
  } = _a2, other = __objRest(_a2, [
    "disableUnderline",
    "components",
    "componentsProps",
    "fullWidth",
    "hiddenLabel",
    // declare here to prevent spreading to DOM
    "inputComponent",
    "multiline",
    "slotProps",
    "slots",
    "type"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    disableUnderline,
    fullWidth,
    inputComponent,
    multiline,
    type
  });
  const classes = useUtilityClasses$L(props);
  const filledInputComponentsProps = {
    root: {
      ownerState
    },
    input: {
      ownerState
    }
  };
  const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge(filledInputComponentsProps, slotProps != null ? slotProps : componentsPropsProp) : filledInputComponentsProps;
  const RootSlot = (_c = (_b = slots.root) != null ? _b : components.Root) != null ? _c : FilledInputRoot;
  const InputSlot = (_e = (_d = slots.input) != null ? _d : components.Input) != null ? _e : FilledInputInput;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase, __spreadProps(__spreadValues({
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    slotProps: componentsProps,
    fullWidth,
    inputComponent,
    multiline,
    ref,
    type
  }, other), {
    classes
  }));
});
FilledInput.muiName = "Input";
function getFormControlUtilityClasses(slot) {
  return generateUtilityClass("MuiFormControl", slot);
}
generateUtilityClasses("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
const useUtilityClasses$K = (ownerState) => {
  const {
    classes,
    margin: margin2,
    fullWidth
  } = ownerState;
  const slots = {
    root: ["root", margin2 !== "none" && `margin${capitalize(margin2)}`, fullWidth && "fullWidth"]
  };
  return composeClasses(slots, getFormControlUtilityClasses, classes);
};
const FormControlRoot = styled("div", {
  name: "MuiFormControl",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`margin${capitalize(ownerState.margin)}`], ownerState.fullWidth && styles2.fullWidth];
  }
})({
  display: "inline-flex",
  flexDirection: "column",
  position: "relative",
  // Reset fieldset default style.
  minWidth: 0,
  padding: 0,
  margin: 0,
  border: 0,
  verticalAlign: "top",
  // Fix alignment issue on Safari.
  variants: [{
    props: {
      margin: "normal"
    },
    style: {
      marginTop: 16,
      marginBottom: 8
    }
  }, {
    props: {
      margin: "dense"
    },
    style: {
      marginTop: 8,
      marginBottom: 4
    }
  }, {
    props: {
      fullWidth: true
    },
    style: {
      width: "100%"
    }
  }]
});
const FormControl = /* @__PURE__ */ reactExports.forwardRef(function FormControl2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFormControl"
  });
  const _a2 = props, {
    children,
    className,
    color: color2 = "primary",
    component = "div",
    disabled = false,
    error: error2 = false,
    focused: visuallyFocused,
    fullWidth = false,
    hiddenLabel = false,
    margin: margin2 = "none",
    required = false,
    size = "medium",
    variant = "outlined"
  } = _a2, other = __objRest(_a2, [
    "children",
    "className",
    "color",
    "component",
    "disabled",
    "error",
    "focused",
    "fullWidth",
    "hiddenLabel",
    "margin",
    "required",
    "size",
    "variant"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: color2,
    component,
    disabled,
    error: error2,
    fullWidth,
    hiddenLabel,
    margin: margin2,
    required,
    size,
    variant
  });
  const classes = useUtilityClasses$K(ownerState);
  const [adornedStart, setAdornedStart] = reactExports.useState(() => {
    let initialAdornedStart = false;
    if (children) {
      reactExports.Children.forEach(children, (child) => {
        if (!isMuiElement(child, ["Input", "Select"])) {
          return;
        }
        const input = isMuiElement(child, ["Select"]) ? child.props.input : child;
        if (input && isAdornedStart(input.props)) {
          initialAdornedStart = true;
        }
      });
    }
    return initialAdornedStart;
  });
  const [filled, setFilled] = reactExports.useState(() => {
    let initialFilled = false;
    if (children) {
      reactExports.Children.forEach(children, (child) => {
        if (!isMuiElement(child, ["Input", "Select"])) {
          return;
        }
        if (isFilled(child.props, true) || isFilled(child.props.inputProps, true)) {
          initialFilled = true;
        }
      });
    }
    return initialFilled;
  });
  const [focusedState, setFocused] = reactExports.useState(false);
  if (disabled && focusedState) {
    setFocused(false);
  }
  const focused = visuallyFocused !== void 0 && !disabled ? visuallyFocused : focusedState;
  let registerEffect;
  reactExports.useRef(false);
  const onFilled = reactExports.useCallback(() => {
    setFilled(true);
  }, []);
  const onEmpty = reactExports.useCallback(() => {
    setFilled(false);
  }, []);
  const childContext = reactExports.useMemo(() => {
    return {
      adornedStart,
      setAdornedStart,
      color: color2,
      disabled,
      error: error2,
      filled,
      focused,
      fullWidth,
      hiddenLabel,
      size,
      onBlur: () => {
        setFocused(false);
      },
      onFocus: () => {
        setFocused(true);
      },
      onEmpty,
      onFilled,
      registerEffect,
      required,
      variant
    };
  }, [adornedStart, color2, disabled, error2, filled, focused, fullWidth, hiddenLabel, registerEffect, onEmpty, onFilled, required, size, variant]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlRoot, __spreadProps(__spreadValues({
      as: component,
      ownerState,
      className: clsx(classes.root, className),
      ref
    }, other), {
      children
    }))
  });
});
function getFormControlLabelUtilityClasses(slot) {
  return generateUtilityClass("MuiFormControlLabel", slot);
}
const formControlLabelClasses = generateUtilityClasses("MuiFormControlLabel", ["root", "labelPlacementStart", "labelPlacementTop", "labelPlacementBottom", "disabled", "label", "error", "required", "asterisk"]);
const useUtilityClasses$J = (ownerState) => {
  const {
    classes,
    disabled,
    labelPlacement,
    error: error2,
    required
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", `labelPlacement${capitalize(labelPlacement)}`, error2 && "error", required && "required"],
    label: ["label", disabled && "disabled"],
    asterisk: ["asterisk", error2 && "error"]
  };
  return composeClasses(slots, getFormControlLabelUtilityClasses, classes);
};
const FormControlLabelRoot = styled("label", {
  name: "MuiFormControlLabel",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${formControlLabelClasses.label}`]: styles2.label
    }, styles2.root, styles2[`labelPlacement${capitalize(ownerState.labelPlacement)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  display: "inline-flex",
  alignItems: "center",
  cursor: "pointer",
  // For correct alignment with the text.
  verticalAlign: "middle",
  WebkitTapHighlightColor: "transparent",
  marginLeft: -11,
  marginRight: 16,
  // used for row presentation of radio/checkbox
  [`&.${formControlLabelClasses.disabled}`]: {
    cursor: "default"
  },
  [`& .${formControlLabelClasses.label}`]: {
    [`&.${formControlLabelClasses.disabled}`]: {
      color: (theme2.vars || theme2).palette.text.disabled
    }
  },
  variants: [{
    props: {
      labelPlacement: "start"
    },
    style: {
      flexDirection: "row-reverse",
      marginRight: -11
    }
  }, {
    props: {
      labelPlacement: "top"
    },
    style: {
      flexDirection: "column-reverse"
    }
  }, {
    props: {
      labelPlacement: "bottom"
    },
    style: {
      flexDirection: "column"
    }
  }, {
    props: ({
      labelPlacement
    }) => labelPlacement === "start" || labelPlacement === "top" || labelPlacement === "bottom",
    style: {
      marginLeft: 16
      // used for row presentation of radio/checkbox
    }
  }]
})));
const AsteriskComponent$1 = styled("span", {
  name: "MuiFormControlLabel",
  slot: "Asterisk"
})(memoTheme(({
  theme: theme2
}) => ({
  [`&.${formControlLabelClasses.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  }
})));
const FormControlLabel = /* @__PURE__ */ reactExports.forwardRef(function FormControlLabel2(inProps, ref) {
  var _b;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFormControlLabel"
  });
  const _a2 = props, {
    checked,
    className,
    componentsProps = {},
    control,
    disabled: disabledProp,
    disableTypography,
    inputRef,
    label: labelProp,
    labelPlacement = "end",
    name: name2,
    onChange,
    required: requiredProp,
    slots = {},
    slotProps = {},
    value
  } = _a2, other = __objRest(_a2, [
    "checked",
    "className",
    "componentsProps",
    "control",
    "disabled",
    "disableTypography",
    "inputRef",
    "label",
    "labelPlacement",
    "name",
    "onChange",
    "required",
    "slots",
    "slotProps",
    "value"
  ]);
  const muiFormControl = useFormControl();
  const disabled = (_b = disabledProp != null ? disabledProp : control.props.disabled) != null ? _b : muiFormControl == null ? void 0 : muiFormControl.disabled;
  const required = requiredProp != null ? requiredProp : control.props.required;
  const controlProps = {
    disabled,
    required
  };
  ["checked", "name", "onChange", "value", "inputRef"].forEach((key) => {
    if (typeof control.props[key] === "undefined" && typeof props[key] !== "undefined") {
      controlProps[key] = props[key];
    }
  });
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["error"]
  });
  const ownerState = __spreadProps(__spreadValues({}, props), {
    disabled,
    labelPlacement,
    required,
    error: fcs.error
  });
  const classes = useUtilityClasses$J(ownerState);
  const externalForwardedProps = {
    slots,
    slotProps: __spreadValues(__spreadValues({}, componentsProps), slotProps)
  };
  const [TypographySlot, typographySlotProps] = useSlot("typography", {
    elementType: Typography,
    externalForwardedProps,
    ownerState
  });
  let label = labelProp;
  if (label != null && label.type !== Typography && !disableTypography) {
    label = /* @__PURE__ */ jsxRuntimeExports.jsx(TypographySlot, __spreadProps(__spreadValues({
      component: "span"
    }, typographySlotProps), {
      className: clsx(classes.label, typographySlotProps == null ? void 0 : typographySlotProps.className),
      children: label
    }));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControlLabelRoot, __spreadProps(__spreadValues({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other), {
    children: [/* @__PURE__ */ reactExports.cloneElement(control, controlProps), required ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
      children: [label, /* @__PURE__ */ jsxRuntimeExports.jsxs(AsteriskComponent$1, {
        ownerState,
        "aria-hidden": true,
        className: classes.asterisk,
        children: ["", "*"]
      })]
    }) : label]
  }));
});
function getFormHelperTextUtilityClasses(slot) {
  return generateUtilityClass("MuiFormHelperText", slot);
}
const formHelperTextClasses = generateUtilityClasses("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
var _span$3;
const useUtilityClasses$I = (ownerState) => {
  const {
    classes,
    contained,
    size,
    disabled,
    error: error2,
    filled,
    focused,
    required
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", error2 && "error", size && `size${capitalize(size)}`, contained && "contained", focused && "focused", filled && "filled", required && "required"]
  };
  return composeClasses(slots, getFormHelperTextUtilityClasses, classes);
};
const FormHelperTextRoot = styled("p", {
  name: "MuiFormHelperText",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.size && styles2[`size${capitalize(ownerState.size)}`], ownerState.contained && styles2.contained, ownerState.filled && styles2.filled];
  }
})(memoTheme(({
  theme: theme2
}) => __spreadProps(__spreadValues({
  color: (theme2.vars || theme2).palette.text.secondary
}, theme2.typography.caption), {
  textAlign: "left",
  marginTop: 3,
  marginRight: 0,
  marginBottom: 0,
  marginLeft: 0,
  [`&.${formHelperTextClasses.disabled}`]: {
    color: (theme2.vars || theme2).palette.text.disabled
  },
  [`&.${formHelperTextClasses.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginTop: 4
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.contained,
    style: {
      marginLeft: 14,
      marginRight: 14
    }
  }]
})));
const FormHelperText = /* @__PURE__ */ reactExports.forwardRef(function FormHelperText2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFormHelperText"
  });
  const _a2 = props, {
    children,
    className,
    component = "p",
    disabled,
    error: error2,
    filled,
    focused,
    margin: margin2,
    required,
    variant
  } = _a2, other = __objRest(_a2, [
    "children",
    "className",
    "component",
    "disabled",
    "error",
    "filled",
    "focused",
    "margin",
    "required",
    "variant"
  ]);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
  });
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component,
    contained: fcs.variant === "filled" || fcs.variant === "outlined",
    variant: fcs.variant,
    size: fcs.size,
    disabled: fcs.disabled,
    error: fcs.error,
    filled: fcs.filled,
    focused: fcs.focused,
    required: fcs.required
  });
  delete ownerState.ownerState;
  const classes = useUtilityClasses$I(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperTextRoot, __spreadProps(__spreadValues({
    as: component,
    className: clsx(classes.root, className),
    ref
  }, other), {
    ownerState,
    children: children === " " ? (
      // notranslate needed while Google Translate will not fix zero-width space issue
      _span$3 || (_span$3 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: "notranslate",
        "aria-hidden": true,
        children: ""
      }))
    ) : children
  }));
});
function getFormLabelUtilityClasses(slot) {
  return generateUtilityClass("MuiFormLabel", slot);
}
const formLabelClasses = generateUtilityClasses("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]);
const useUtilityClasses$H = (ownerState) => {
  const {
    classes,
    color: color2,
    focused,
    disabled,
    error: error2,
    filled,
    required
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize(color2)}`, disabled && "disabled", error2 && "error", filled && "filled", focused && "focused", required && "required"],
    asterisk: ["asterisk", error2 && "error"]
  };
  return composeClasses(slots, getFormLabelUtilityClasses, classes);
};
const FormLabelRoot = styled("label", {
  name: "MuiFormLabel",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color === "secondary" && styles2.colorSecondary, ownerState.filled && styles2.filled];
  }
})(memoTheme(({
  theme: theme2
}) => __spreadProps(__spreadValues({
  color: (theme2.vars || theme2).palette.text.secondary
}, theme2.typography.body1), {
  lineHeight: "1.4375em",
  padding: 0,
  position: "relative",
  variants: [...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      [`&.${formLabelClasses.focused}`]: {
        color: (theme2.vars || theme2).palette[color2].main
      }
    }
  })), {
    props: {},
    style: {
      [`&.${formLabelClasses.disabled}`]: {
        color: (theme2.vars || theme2).palette.text.disabled
      },
      [`&.${formLabelClasses.error}`]: {
        color: (theme2.vars || theme2).palette.error.main
      }
    }
  }]
})));
const AsteriskComponent = styled("span", {
  name: "MuiFormLabel",
  slot: "Asterisk"
})(memoTheme(({
  theme: theme2
}) => ({
  [`&.${formLabelClasses.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  }
})));
const FormLabel = /* @__PURE__ */ reactExports.forwardRef(function FormLabel2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFormLabel"
  });
  const _a2 = props, {
    children,
    className,
    color: color2,
    component = "label",
    disabled,
    error: error2,
    filled,
    focused,
    required
  } = _a2, other = __objRest(_a2, [
    "children",
    "className",
    "color",
    "component",
    "disabled",
    "error",
    "filled",
    "focused",
    "required"
  ]);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "required", "focused", "disabled", "error", "filled"]
  });
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: fcs.color || "primary",
    component,
    disabled: fcs.disabled,
    error: fcs.error,
    filled: fcs.filled,
    focused: fcs.focused,
    required: fcs.required
  });
  const classes = useUtilityClasses$H(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(FormLabelRoot, __spreadProps(__spreadValues({
    as: component,
    ownerState,
    className: clsx(classes.root, className),
    ref
  }, other), {
    children: [children, fcs.required && /* @__PURE__ */ jsxRuntimeExports.jsxs(AsteriskComponent, {
      ownerState,
      "aria-hidden": true,
      className: classes.asterisk,
      children: ["", "*"]
    })]
  }));
});
const Grid = createGrid({
  createStyledComponent: styled("div", {
    name: "MuiGrid",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.container && styles2.container];
    }
  }),
  componentName: "MuiGrid",
  useThemeProps: (inProps) => useDefaultProps({
    props: inProps,
    name: "MuiGrid"
  }),
  useTheme
});
function getScale(value) {
  return `scale(${value}, ${__pow(value, 2)})`;
}
const styles$1 = {
  entering: {
    opacity: 1,
    transform: getScale(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
};
const isWebKit154 = typeof navigator !== "undefined" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent);
const Grow = /* @__PURE__ */ reactExports.forwardRef(function Grow2(props, ref) {
  const _a2 = props, {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = "auto",
    TransitionComponent: TransitionComponent = Transition
  } = _a2, other = __objRest(_a2, [
    "addEndListener",
    "appear",
    "children",
    "easing",
    "in",
    "onEnter",
    "onEntered",
    "onEntering",
    "onExit",
    "onExited",
    "onExiting",
    "style",
    "timeout",
    // eslint-disable-next-line react/prop-types
    "TransitionComponent"
  ]);
  const timer = useTimeout();
  const autoTimeout = reactExports.useRef();
  const theme2 = useTheme();
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef(nodeRef, getReactElementRef(children), ref);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const {
      duration: transitionDuration,
      delay,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    let duration2;
    if (timeout === "auto") {
      duration2 = theme2.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme2.transitions.create("opacity", {
      duration: duration2,
      delay
    }), theme2.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay,
      easing: transitionTimingFunction
    })].join(",");
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const {
      duration: transitionDuration,
      delay,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    let duration2;
    if (timeout === "auto") {
      duration2 = theme2.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme2.transitions.create("opacity", {
      duration: duration2,
      delay
    }), theme2.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay: isWebKit154 ? delay : delay || duration2 * 0.333,
      easing: transitionTimingFunction
    })].join(",");
    node2.style.opacity = 0;
    node2.style.transform = getScale(0.75);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = (next2) => {
    if (timeout === "auto") {
      timer.start(autoTimeout.current || 0, next2);
    }
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, __spreadProps(__spreadValues({
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout: timeout === "auto" ? null : timeout
  }, other), {
    children: (state, _b) => {
      var _c = _b, {
        ownerState
      } = _c, restChildProps = __objRest(_c, [
        "ownerState"
      ]);
      return /* @__PURE__ */ reactExports.cloneElement(children, __spreadValues({
        style: __spreadValues(__spreadValues(__spreadValues({
          opacity: 0,
          transform: getScale(0.75),
          visibility: state === "exited" && !inProp ? "hidden" : void 0
        }, styles$1[state]), style2), children.props.style),
        ref: handleRef
      }, restChildProps));
    }
  }));
});
if (Grow) {
  Grow.muiSupportAuto = true;
}
const useUtilityClasses$G = (ownerState) => {
  const {
    classes,
    disableUnderline
  } = ownerState;
  const slots = {
    root: ["root", !disableUnderline && "underline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getInputUtilityClass, classes);
  return __spreadValues(__spreadValues({}, classes), composedClasses);
};
const InputRoot = styled(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiInput",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
  }
})(memoTheme(({
  theme: theme2
}) => {
  const light2 = theme2.palette.mode === "light";
  let bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  if (theme2.vars) {
    bottomLineColor = theme2.alpha(theme2.vars.palette.common.onBackground, theme2.vars.opacity.inputUnderline);
  }
  return {
    position: "relative",
    variants: [{
      props: ({
        ownerState
      }) => ownerState.formControl,
      style: {
        "label + &": {
          marginTop: 16
        }
      }
    }, {
      props: ({
        ownerState
      }) => !ownerState.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: theme2.transitions.create("transform", {
            duration: theme2.transitions.duration.shorter,
            easing: theme2.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${inputClasses.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${inputClasses.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (theme2.vars || theme2).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${bottomLineColor}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: theme2.transitions.create("border-bottom-color", {
            duration: theme2.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${inputClasses.disabled}, .${inputClasses.error}):before`]: {
          borderBottom: `2px solid ${(theme2.vars || theme2).palette.text.primary}`,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            borderBottom: `1px solid ${bottomLineColor}`
          }
        },
        [`&.${inputClasses.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
      props: {
        color: color2,
        disableUnderline: false
      },
      style: {
        "&::after": {
          borderBottom: `2px solid ${(theme2.vars || theme2).palette[color2].main}`
        }
      }
    }))]
  };
}));
const InputInput = styled(InputBaseInput, {
  name: "MuiInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})({});
const Input = /* @__PURE__ */ reactExports.forwardRef(function Input2(inProps, ref) {
  var _b, _c, _d, _e;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiInput"
  });
  const _a2 = props, {
    disableUnderline = false,
    components = {},
    componentsProps: componentsPropsProp,
    fullWidth = false,
    inputComponent = "input",
    multiline = false,
    slotProps,
    slots = {},
    type = "text"
  } = _a2, other = __objRest(_a2, [
    "disableUnderline",
    "components",
    "componentsProps",
    "fullWidth",
    "inputComponent",
    "multiline",
    "slotProps",
    "slots",
    "type"
  ]);
  const classes = useUtilityClasses$G(props);
  const ownerState = {
    disableUnderline
  };
  const inputComponentsProps = {
    root: {
      ownerState
    }
  };
  const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge(slotProps != null ? slotProps : componentsPropsProp, inputComponentsProps) : inputComponentsProps;
  const RootSlot = (_c = (_b = slots.root) != null ? _b : components.Root) != null ? _c : InputRoot;
  const InputSlot = (_e = (_d = slots.input) != null ? _d : components.Input) != null ? _e : InputInput;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase, __spreadProps(__spreadValues({
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    slotProps: componentsProps,
    fullWidth,
    inputComponent,
    multiline,
    ref,
    type
  }, other), {
    classes
  }));
});
Input.muiName = "Input";
function getInputAdornmentUtilityClass(slot) {
  return generateUtilityClass("MuiInputAdornment", slot);
}
const inputAdornmentClasses = generateUtilityClasses("MuiInputAdornment", ["root", "filled", "standard", "outlined", "positionStart", "positionEnd", "disablePointerEvents", "hiddenLabel", "sizeSmall"]);
var _span$2;
const overridesResolver$2 = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, styles2[`position${capitalize(ownerState.position)}`], ownerState.disablePointerEvents === true && styles2.disablePointerEvents, styles2[ownerState.variant]];
};
const useUtilityClasses$F = (ownerState) => {
  const {
    classes,
    disablePointerEvents,
    hiddenLabel,
    position: position2,
    size,
    variant
  } = ownerState;
  const slots = {
    root: ["root", disablePointerEvents && "disablePointerEvents", position2 && `position${capitalize(position2)}`, variant, hiddenLabel && "hiddenLabel", size && `size${capitalize(size)}`]
  };
  return composeClasses(slots, getInputAdornmentUtilityClass, classes);
};
const InputAdornmentRoot = styled("div", {
  name: "MuiInputAdornment",
  slot: "Root",
  overridesResolver: overridesResolver$2
})(memoTheme(({
  theme: theme2
}) => ({
  display: "flex",
  maxHeight: "2em",
  alignItems: "center",
  whiteSpace: "nowrap",
  color: (theme2.vars || theme2).palette.action.active,
  variants: [{
    props: {
      variant: "filled"
    },
    style: {
      [`&.${inputAdornmentClasses.positionStart}&:not(.${inputAdornmentClasses.hiddenLabel})`]: {
        marginTop: 16
      }
    }
  }, {
    props: {
      position: "start"
    },
    style: {
      marginRight: 8
    }
  }, {
    props: {
      position: "end"
    },
    style: {
      marginLeft: 8
    }
  }, {
    props: {
      disablePointerEvents: true
    },
    style: {
      pointerEvents: "none"
    }
  }]
})));
const InputAdornment = /* @__PURE__ */ reactExports.forwardRef(function InputAdornment2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiInputAdornment"
  });
  const _a2 = props, {
    children,
    className,
    component = "div",
    disablePointerEvents = false,
    disableTypography = false,
    position: position2,
    variant: variantProp
  } = _a2, other = __objRest(_a2, [
    "children",
    "className",
    "component",
    "disablePointerEvents",
    "disableTypography",
    "position",
    "variant"
  ]);
  const muiFormControl = useFormControl() || {};
  let variant = variantProp;
  if (variantProp && muiFormControl.variant) ;
  if (muiFormControl && !variant) {
    variant = muiFormControl.variant;
  }
  const ownerState = __spreadProps(__spreadValues({}, props), {
    hiddenLabel: muiFormControl.hiddenLabel,
    size: muiFormControl.size,
    disablePointerEvents,
    position: position2,
    variant
  });
  const classes = useUtilityClasses$F(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext.Provider, {
    value: null,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(InputAdornmentRoot, __spreadProps(__spreadValues({
      as: component,
      ownerState,
      className: clsx(classes.root, className),
      ref
    }, other), {
      children: typeof children === "string" && !disableTypography ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, {
        color: "textSecondary",
        children
      }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [position2 === "start" ? (
          /* notranslate needed while Google Translate will not fix zero-width space issue */
          _span$2 || (_span$2 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
            className: "notranslate",
            "aria-hidden": true,
            children: ""
          }))
        ) : null, children]
      })
    }))
  });
});
function getInputLabelUtilityClasses(slot) {
  return generateUtilityClass("MuiInputLabel", slot);
}
generateUtilityClasses("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
const useUtilityClasses$E = (ownerState) => {
  const {
    classes,
    formControl,
    size,
    shrink,
    disableAnimation,
    variant,
    required
  } = ownerState;
  const slots = {
    root: ["root", formControl && "formControl", !disableAnimation && "animated", shrink && "shrink", size && size !== "medium" && `size${capitalize(size)}`, variant],
    asterisk: [required && "asterisk"]
  };
  const composedClasses = composeClasses(slots, getInputLabelUtilityClasses, classes);
  return __spreadValues(__spreadValues({}, classes), composedClasses);
};
const InputLabelRoot = styled(FormLabel, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiInputLabel",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${formLabelClasses.asterisk}`]: styles2.asterisk
    }, styles2.root, ownerState.formControl && styles2.formControl, ownerState.size === "small" && styles2.sizeSmall, ownerState.shrink && styles2.shrink, !ownerState.disableAnimation && styles2.animated, ownerState.focused && styles2.focused, styles2[ownerState.variant]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  display: "block",
  transformOrigin: "top left",
  whiteSpace: "nowrap",
  overflow: "hidden",
  textOverflow: "ellipsis",
  maxWidth: "100%",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.formControl,
    style: {
      position: "absolute",
      left: 0,
      top: 0,
      // slight alteration to spec spacing to match visual spec result
      transform: "translate(0, 20px) scale(1)"
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      // Compensation for the `Input.inputSizeSmall` style.
      transform: "translate(0, 17px) scale(1)"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.shrink,
    style: {
      transform: "translate(0, -1.5px) scale(0.75)",
      transformOrigin: "top left",
      maxWidth: "133%"
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.disableAnimation,
    style: {
      transition: theme2.transitions.create(["color", "transform", "max-width"], {
        duration: theme2.transitions.duration.shorter,
        easing: theme2.transitions.easing.easeOut
      })
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      // Chrome's autofill feature gives the input field a yellow background.
      // Since the input field is behind the label in the HTML tree,
      // the input field is drawn last and hides the label with an opaque background color.
      // zIndex: 1 will raise the label above opaque background-colors of input.
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(12px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }
  }, {
    props: {
      variant: "filled",
      size: "small"
    },
    style: {
      transform: "translate(12px, 13px) scale(1)"
    }
  }, {
    props: ({
      variant,
      ownerState
    }) => variant === "filled" && ownerState.shrink,
    style: {
      userSelect: "none",
      pointerEvents: "auto",
      transform: "translate(12px, 7px) scale(0.75)",
      maxWidth: "calc(133% - 24px)"
    }
  }, {
    props: ({
      variant,
      ownerState,
      size
    }) => variant === "filled" && ownerState.shrink && size === "small",
    style: {
      transform: "translate(12px, 4px) scale(0.75)"
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      // see comment above on filled.zIndex
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(14px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }
  }, {
    props: {
      variant: "outlined",
      size: "small"
    },
    style: {
      transform: "translate(14px, 9px) scale(1)"
    }
  }, {
    props: ({
      variant,
      ownerState
    }) => variant === "outlined" && ownerState.shrink,
    style: {
      userSelect: "none",
      pointerEvents: "auto",
      // Theoretically, we should have (8+5)*2/0.75 = 34px
      // but it feels a better when it bleeds a bit on the left, so 32px.
      maxWidth: "calc(133% - 32px)",
      transform: "translate(14px, -9px) scale(0.75)"
    }
  }]
})));
const InputLabel = /* @__PURE__ */ reactExports.forwardRef(function InputLabel2(inProps, ref) {
  const props = useDefaultProps({
    name: "MuiInputLabel",
    props: inProps
  });
  const _a2 = props, {
    disableAnimation = false,
    margin: margin2,
    shrink: shrinkProp,
    variant,
    className
  } = _a2, other = __objRest(_a2, [
    "disableAnimation",
    "margin",
    "shrink",
    "variant",
    "className"
  ]);
  const muiFormControl = useFormControl();
  let shrink = shrinkProp;
  if (typeof shrink === "undefined" && muiFormControl) {
    shrink = muiFormControl.filled || muiFormControl.focused || muiFormControl.adornedStart;
  }
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["size", "variant", "required", "focused"]
  });
  const ownerState = __spreadProps(__spreadValues({}, props), {
    disableAnimation,
    formControl: muiFormControl,
    shrink,
    size: fcs.size,
    variant: fcs.variant,
    required: fcs.required,
    focused: fcs.focused
  });
  const classes = useUtilityClasses$E(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabelRoot, __spreadProps(__spreadValues({
    "data-shrink": shrink,
    ref,
    className: clsx(classes.root, className)
  }, other), {
    ownerState,
    classes
  }));
});
function getLinearProgressUtilityClass(slot) {
  return generateUtilityClass("MuiLinearProgress", slot);
}
generateUtilityClasses("MuiLinearProgress", ["root", "colorPrimary", "colorSecondary", "determinate", "indeterminate", "buffer", "query", "dashed", "dashedColorPrimary", "dashedColorSecondary", "bar", "bar1", "bar2", "barColorPrimary", "barColorSecondary", "bar1Indeterminate", "bar1Determinate", "bar1Buffer", "bar2Indeterminate", "bar2Buffer"]);
const TRANSITION_DURATION = 4;
const indeterminate1Keyframe = keyframes`
  0% {
    left: -35%;
    right: 100%;
  }

  60% {
    left: 100%;
    right: -90%;
  }

  100% {
    left: 100%;
    right: -90%;
  }
`;
const indeterminate1Animation = typeof indeterminate1Keyframe !== "string" ? css`
        animation: ${indeterminate1Keyframe} 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite;
      ` : null;
const indeterminate2Keyframe = keyframes`
  0% {
    left: -200%;
    right: 100%;
  }

  60% {
    left: 107%;
    right: -8%;
  }

  100% {
    left: 107%;
    right: -8%;
  }
`;
const indeterminate2Animation = typeof indeterminate2Keyframe !== "string" ? css`
        animation: ${indeterminate2Keyframe} 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) 1.15s infinite;
      ` : null;
const bufferKeyframe = keyframes`
  0% {
    opacity: 1;
    background-position: 0 -23px;
  }

  60% {
    opacity: 0;
    background-position: 0 -23px;
  }

  100% {
    opacity: 1;
    background-position: -200px -23px;
  }
`;
const bufferAnimation = typeof bufferKeyframe !== "string" ? css`
        animation: ${bufferKeyframe} 3s infinite linear;
      ` : null;
const useUtilityClasses$D = (ownerState) => {
  const {
    classes,
    variant,
    color: color2
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize(color2)}`, variant],
    dashed: ["dashed", `dashedColor${capitalize(color2)}`],
    bar1: ["bar", "bar1", `barColor${capitalize(color2)}`, (variant === "indeterminate" || variant === "query") && "bar1Indeterminate", variant === "determinate" && "bar1Determinate", variant === "buffer" && "bar1Buffer"],
    bar2: ["bar", "bar2", variant !== "buffer" && `barColor${capitalize(color2)}`, variant === "buffer" && `color${capitalize(color2)}`, (variant === "indeterminate" || variant === "query") && "bar2Indeterminate", variant === "buffer" && "bar2Buffer"]
  };
  return composeClasses(slots, getLinearProgressUtilityClass, classes);
};
const getColorShade = (theme2, color2) => {
  if (theme2.vars) {
    return theme2.vars.palette.LinearProgress[`${color2}Bg`];
  }
  return theme2.palette.mode === "light" ? theme2.lighten(theme2.palette[color2].main, 0.62) : theme2.darken(theme2.palette[color2].main, 0.5);
};
const LinearProgressRoot = styled("span", {
  name: "MuiLinearProgress",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`color${capitalize(ownerState.color)}`], styles2[ownerState.variant]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  position: "relative",
  overflow: "hidden",
  display: "block",
  height: 4,
  // Fix Safari's bug during composition of different paint.
  zIndex: 0,
  "@media print": {
    colorAdjust: "exact"
  },
  variants: [...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      backgroundColor: getColorShade(theme2, color2)
    }
  })), {
    props: ({
      ownerState
    }) => ownerState.color === "inherit" && ownerState.variant !== "buffer",
    style: {
      "&::before": {
        content: '""',
        position: "absolute",
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        backgroundColor: "currentColor",
        opacity: 0.3
      }
    }
  }, {
    props: {
      variant: "buffer"
    },
    style: {
      backgroundColor: "transparent"
    }
  }, {
    props: {
      variant: "query"
    },
    style: {
      transform: "rotate(180deg)"
    }
  }]
})));
const LinearProgressDashed = styled("span", {
  name: "MuiLinearProgress",
  slot: "Dashed",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.dashed, styles2[`dashedColor${capitalize(ownerState.color)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  position: "absolute",
  marginTop: 0,
  height: "100%",
  width: "100%",
  backgroundSize: "10px 10px",
  backgroundPosition: "0 -23px",
  variants: [{
    props: {
      color: "inherit"
    },
    style: {
      opacity: 0.3,
      backgroundImage: `radial-gradient(currentColor 0%, currentColor 16%, transparent 42%)`
    }
  }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => {
    const backgroundColor2 = getColorShade(theme2, color2);
    return {
      props: {
        color: color2
      },
      style: {
        backgroundImage: `radial-gradient(${backgroundColor2} 0%, ${backgroundColor2} 16%, transparent 42%)`
      }
    };
  })]
})), bufferAnimation || {
  // At runtime for Pigment CSS, `bufferAnimation` will be null and the generated keyframe will be used.
  animation: `${bufferKeyframe} 3s infinite linear`
});
const LinearProgressBar1 = styled("span", {
  name: "MuiLinearProgress",
  slot: "Bar1",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.bar, styles2.bar1, styles2[`barColor${capitalize(ownerState.color)}`], (ownerState.variant === "indeterminate" || ownerState.variant === "query") && styles2.bar1Indeterminate, ownerState.variant === "determinate" && styles2.bar1Determinate, ownerState.variant === "buffer" && styles2.bar1Buffer];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  width: "100%",
  position: "absolute",
  left: 0,
  bottom: 0,
  top: 0,
  transition: "transform 0.2s linear",
  transformOrigin: "left",
  variants: [{
    props: {
      color: "inherit"
    },
    style: {
      backgroundColor: "currentColor"
    }
  }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      backgroundColor: (theme2.vars || theme2).palette[color2].main
    }
  })), {
    props: {
      variant: "determinate"
    },
    style: {
      transition: `transform .${TRANSITION_DURATION}s linear`
    }
  }, {
    props: {
      variant: "buffer"
    },
    style: {
      zIndex: 1,
      transition: `transform .${TRANSITION_DURATION}s linear`
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.variant === "indeterminate" || ownerState.variant === "query",
    style: {
      width: "auto"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.variant === "indeterminate" || ownerState.variant === "query",
    style: indeterminate1Animation || {
      animation: `${indeterminate1Keyframe} 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite`
    }
  }]
})));
const LinearProgressBar2 = styled("span", {
  name: "MuiLinearProgress",
  slot: "Bar2",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.bar, styles2.bar2, styles2[`barColor${capitalize(ownerState.color)}`], (ownerState.variant === "indeterminate" || ownerState.variant === "query") && styles2.bar2Indeterminate, ownerState.variant === "buffer" && styles2.bar2Buffer];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  width: "100%",
  position: "absolute",
  left: 0,
  bottom: 0,
  top: 0,
  transition: "transform 0.2s linear",
  transformOrigin: "left",
  variants: [...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      "--LinearProgressBar2-barColor": (theme2.vars || theme2).palette[color2].main
    }
  })), {
    props: ({
      ownerState
    }) => ownerState.variant !== "buffer" && ownerState.color !== "inherit",
    style: {
      backgroundColor: "var(--LinearProgressBar2-barColor, currentColor)"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.variant !== "buffer" && ownerState.color === "inherit",
    style: {
      backgroundColor: "currentColor"
    }
  }, {
    props: {
      color: "inherit"
    },
    style: {
      opacity: 0.3
    }
  }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2,
      variant: "buffer"
    },
    style: {
      backgroundColor: getColorShade(theme2, color2),
      transition: `transform .${TRANSITION_DURATION}s linear`
    }
  })), {
    props: ({
      ownerState
    }) => ownerState.variant === "indeterminate" || ownerState.variant === "query",
    style: {
      width: "auto"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.variant === "indeterminate" || ownerState.variant === "query",
    style: indeterminate2Animation || {
      animation: `${indeterminate2Keyframe} 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) 1.15s infinite`
    }
  }]
})));
const LinearProgress = /* @__PURE__ */ reactExports.forwardRef(function LinearProgress2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiLinearProgress"
  });
  const _a2 = props, {
    className,
    color: color2 = "primary",
    value,
    valueBuffer,
    variant = "indeterminate"
  } = _a2, other = __objRest(_a2, [
    "className",
    "color",
    "value",
    "valueBuffer",
    "variant"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: color2,
    variant
  });
  const classes = useUtilityClasses$D(ownerState);
  const isRtl = useRtl();
  const rootProps = {};
  const inlineStyles = {
    bar1: {},
    bar2: {}
  };
  if (variant === "determinate" || variant === "buffer") {
    if (value !== void 0) {
      rootProps["aria-valuenow"] = Math.round(value);
      rootProps["aria-valuemin"] = 0;
      rootProps["aria-valuemax"] = 100;
      let transform = value - 100;
      if (isRtl) {
        transform = -transform;
      }
      inlineStyles.bar1.transform = `translateX(${transform}%)`;
    }
  }
  if (variant === "buffer") {
    if (valueBuffer !== void 0) {
      let transform = (valueBuffer || 0) - 100;
      if (isRtl) {
        transform = -transform;
      }
      inlineStyles.bar2.transform = `translateX(${transform}%)`;
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(LinearProgressRoot, __spreadProps(__spreadValues(__spreadProps(__spreadValues({
    className: clsx(classes.root, className),
    ownerState,
    role: "progressbar"
  }, rootProps), {
    ref
  }), other), {
    children: [variant === "buffer" ? /* @__PURE__ */ jsxRuntimeExports.jsx(LinearProgressDashed, {
      className: classes.dashed,
      ownerState
    }) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(LinearProgressBar1, {
      className: classes.bar1,
      ownerState,
      style: inlineStyles.bar1
    }), variant === "determinate" ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(LinearProgressBar2, {
      className: classes.bar2,
      ownerState,
      style: inlineStyles.bar2
    })]
  }));
});
function getLinkUtilityClass(slot) {
  return generateUtilityClass("MuiLink", slot);
}
const linkClasses = generateUtilityClasses("MuiLink", ["root", "underlineNone", "underlineHover", "underlineAlways", "button", "focusVisible"]);
const getTextDecoration = ({
  theme: theme2,
  ownerState
}) => {
  const transformedColor = ownerState.color;
  if ("colorSpace" in theme2 && theme2.colorSpace) {
    const color3 = getPath(theme2, `palette.${transformedColor}.main`) || getPath(theme2, `palette.${transformedColor}`) || ownerState.color;
    return theme2.alpha(color3, 0.4);
  }
  const color2 = getPath(theme2, `palette.${transformedColor}.main`, false) || getPath(theme2, `palette.${transformedColor}`, false) || ownerState.color;
  const channelColor = getPath(theme2, `palette.${transformedColor}.mainChannel`) || getPath(theme2, `palette.${transformedColor}Channel`);
  if ("vars" in theme2 && channelColor) {
    return `rgba(${channelColor} / 0.4)`;
  }
  return alpha(color2, 0.4);
};
const v6Colors = {
  primary: true,
  secondary: true,
  error: true,
  info: true,
  success: true,
  warning: true,
  textPrimary: true,
  textSecondary: true,
  textDisabled: true
};
const useUtilityClasses$C = (ownerState) => {
  const {
    classes,
    component,
    focusVisible,
    underline
  } = ownerState;
  const slots = {
    root: ["root", `underline${capitalize(underline)}`, component === "button" && "button", focusVisible && "focusVisible"]
  };
  return composeClasses(slots, getLinkUtilityClass, classes);
};
const LinkRoot = styled(Typography, {
  name: "MuiLink",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`underline${capitalize(ownerState.underline)}`], ownerState.component === "button" && styles2.button];
  }
})(memoTheme(({
  theme: theme2
}) => {
  return {
    variants: [{
      props: {
        underline: "none"
      },
      style: {
        textDecoration: "none"
      }
    }, {
      props: {
        underline: "hover"
      },
      style: {
        textDecoration: "none",
        "&:hover": {
          textDecoration: "underline"
        }
      }
    }, {
      props: {
        underline: "always"
      },
      style: {
        textDecoration: "underline",
        "&:hover": {
          textDecorationColor: "inherit"
        }
      }
    }, {
      props: ({
        underline,
        ownerState
      }) => underline === "always" && ownerState.color !== "inherit",
      style: {
        textDecorationColor: "var(--Link-underlineColor)"
      }
    }, {
      props: ({
        underline,
        ownerState
      }) => underline === "always" && ownerState.color === "inherit",
      style: theme2.colorSpace ? {
        textDecorationColor: theme2.alpha("currentColor", 0.4)
      } : null
    }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
      props: {
        underline: "always",
        color: color2
      },
      style: {
        "--Link-underlineColor": theme2.alpha((theme2.vars || theme2).palette[color2].main, 0.4)
      }
    })), {
      props: {
        underline: "always",
        color: "textPrimary"
      },
      style: {
        "--Link-underlineColor": theme2.alpha((theme2.vars || theme2).palette.text.primary, 0.4)
      }
    }, {
      props: {
        underline: "always",
        color: "textSecondary"
      },
      style: {
        "--Link-underlineColor": theme2.alpha((theme2.vars || theme2).palette.text.secondary, 0.4)
      }
    }, {
      props: {
        underline: "always",
        color: "textDisabled"
      },
      style: {
        "--Link-underlineColor": (theme2.vars || theme2).palette.text.disabled
      }
    }, {
      props: {
        component: "button"
      },
      style: {
        position: "relative",
        WebkitTapHighlightColor: "transparent",
        backgroundColor: "transparent",
        // Reset default value
        // We disable the focus ring for mouse, touch and keyboard users.
        outline: 0,
        border: 0,
        margin: 0,
        // Remove the margin in Safari
        borderRadius: 0,
        padding: 0,
        // Remove the padding in Firefox
        cursor: "pointer",
        userSelect: "none",
        verticalAlign: "middle",
        MozAppearance: "none",
        // Reset
        WebkitAppearance: "none",
        // Reset
        "&::-moz-focus-inner": {
          borderStyle: "none"
          // Remove Firefox dotted outline.
        },
        [`&.${linkClasses.focusVisible}`]: {
          outline: "auto"
        }
      }
    }]
  };
}));
const Link = /* @__PURE__ */ reactExports.forwardRef(function Link2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiLink"
  });
  const theme2 = useTheme();
  const _a2 = props, {
    className,
    color: color2 = "primary",
    component = "a",
    onBlur,
    onFocus,
    TypographyClasses,
    underline = "always",
    variant = "inherit",
    sx
  } = _a2, other = __objRest(_a2, [
    "className",
    "color",
    "component",
    "onBlur",
    "onFocus",
    "TypographyClasses",
    "underline",
    "variant",
    "sx"
  ]);
  const [focusVisible, setFocusVisible] = reactExports.useState(false);
  const handleBlur = (event) => {
    if (!isFocusVisible(event.target)) {
      setFocusVisible(false);
    }
    if (onBlur) {
      onBlur(event);
    }
  };
  const handleFocus = (event) => {
    if (isFocusVisible(event.target)) {
      setFocusVisible(true);
    }
    if (onFocus) {
      onFocus(event);
    }
  };
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: color2,
    component,
    focusVisible,
    underline,
    variant
  });
  const classes = useUtilityClasses$C(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LinkRoot, __spreadProps(__spreadValues({
    color: color2,
    className: clsx(classes.root, className),
    classes: TypographyClasses,
    component,
    onBlur: handleBlur,
    onFocus: handleFocus,
    ref,
    ownerState,
    variant
  }, other), {
    sx: [...v6Colors[color2] === void 0 ? [{
      color: color2
    }] : [], ...Array.isArray(sx) ? sx : [sx]],
    style: __spreadValues(__spreadValues({}, other.style), underline === "always" && color2 !== "inherit" && !v6Colors[color2] && {
      "--Link-underlineColor": getTextDecoration({
        theme: theme2,
        ownerState
      })
    })
  }));
});
const ListContext = /* @__PURE__ */ reactExports.createContext({});
function getListUtilityClass(slot) {
  return generateUtilityClass("MuiList", slot);
}
generateUtilityClasses("MuiList", ["root", "padding", "dense", "subheader"]);
const useUtilityClasses$B = (ownerState) => {
  const {
    classes,
    disablePadding,
    dense,
    subheader
  } = ownerState;
  const slots = {
    root: ["root", !disablePadding && "padding", dense && "dense", subheader && "subheader"]
  };
  return composeClasses(slots, getListUtilityClass, classes);
};
const ListRoot = styled("ul", {
  name: "MuiList",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.disablePadding && styles2.padding, ownerState.dense && styles2.dense, ownerState.subheader && styles2.subheader];
  }
})({
  listStyle: "none",
  margin: 0,
  padding: 0,
  position: "relative",
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.disablePadding,
    style: {
      paddingTop: 8,
      paddingBottom: 8
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.subheader,
    style: {
      paddingTop: 0
    }
  }]
});
const List$1 = /* @__PURE__ */ reactExports.forwardRef(function List2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiList"
  });
  const _a2 = props, {
    children,
    className,
    component = "ul",
    dense = false,
    disablePadding = false,
    subheader
  } = _a2, other = __objRest(_a2, [
    "children",
    "className",
    "component",
    "dense",
    "disablePadding",
    "subheader"
  ]);
  const context = reactExports.useMemo(() => ({
    dense
  }), [dense]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component,
    dense,
    disablePadding
  });
  const classes = useUtilityClasses$B(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext.Provider, {
    value: context,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, __spreadProps(__spreadValues({
      as: component,
      className: clsx(classes.root, className),
      ref,
      ownerState
    }, other), {
      children: [subheader, children]
    }))
  });
});
function getListItemUtilityClass(slot) {
  return generateUtilityClass("MuiListItem", slot);
}
generateUtilityClasses("MuiListItem", ["root", "container", "dense", "alignItemsFlexStart", "divider", "gutters", "padding", "secondaryAction"]);
const listItemButtonClasses = generateUtilityClasses("MuiListItemButton", ["root", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "selected"]);
function getListItemSecondaryActionClassesUtilityClass(slot) {
  return generateUtilityClass("MuiListItemSecondaryAction", slot);
}
generateUtilityClasses("MuiListItemSecondaryAction", ["root", "disableGutters"]);
const useUtilityClasses$A = (ownerState) => {
  const {
    disableGutters,
    classes
  } = ownerState;
  const slots = {
    root: ["root", disableGutters && "disableGutters"]
  };
  return composeClasses(slots, getListItemSecondaryActionClassesUtilityClass, classes);
};
const ListItemSecondaryActionRoot = styled("div", {
  name: "MuiListItemSecondaryAction",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.disableGutters && styles2.disableGutters];
  }
})({
  position: "absolute",
  right: 16,
  top: "50%",
  transform: "translateY(-50%)",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.disableGutters,
    style: {
      right: 0
    }
  }]
});
const ListItemSecondaryAction = /* @__PURE__ */ reactExports.forwardRef(function ListItemSecondaryAction2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiListItemSecondaryAction"
  });
  const _a2 = props, {
    className
  } = _a2, other = __objRest(_a2, [
    "className"
  ]);
  const context = reactExports.useContext(ListContext);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    disableGutters: context.disableGutters
  });
  const classes = useUtilityClasses$A(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemSecondaryActionRoot, __spreadValues({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
ListItemSecondaryAction.muiName = "ListItemSecondaryAction";
const overridesResolver$1 = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.dense && styles2.dense, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters, !ownerState.disablePadding && styles2.padding, ownerState.hasSecondaryAction && styles2.secondaryAction];
};
const useUtilityClasses$z = (ownerState) => {
  const {
    alignItems,
    classes,
    dense,
    disableGutters,
    disablePadding,
    divider,
    hasSecondaryAction
  } = ownerState;
  const slots = {
    root: ["root", dense && "dense", !disableGutters && "gutters", !disablePadding && "padding", divider && "divider", alignItems === "flex-start" && "alignItemsFlexStart", hasSecondaryAction && "secondaryAction"],
    container: ["container"]
  };
  return composeClasses(slots, getListItemUtilityClass, classes);
};
const ListItemRoot = styled("div", {
  name: "MuiListItem",
  slot: "Root",
  overridesResolver: overridesResolver$1
})(memoTheme(({
  theme: theme2
}) => ({
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  width: "100%",
  boxSizing: "border-box",
  textAlign: "left",
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.disablePadding,
    style: {
      paddingTop: 8,
      paddingBottom: 8
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.disablePadding && ownerState.dense,
    style: {
      paddingTop: 4,
      paddingBottom: 4
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.disablePadding && !ownerState.disableGutters,
    style: {
      paddingLeft: 16,
      paddingRight: 16
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.disablePadding && !!ownerState.secondaryAction,
    style: {
      // Add some space to avoid collision as `ListItemSecondaryAction`
      // is absolutely positioned.
      paddingRight: 48
    }
  }, {
    props: ({
      ownerState
    }) => !!ownerState.secondaryAction,
    style: {
      [`& > .${listItemButtonClasses.root}`]: {
        paddingRight: 48
      }
    }
  }, {
    props: {
      alignItems: "flex-start"
    },
    style: {
      alignItems: "flex-start"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.divider,
    style: {
      borderBottom: `1px solid ${(theme2.vars || theme2).palette.divider}`,
      backgroundClip: "padding-box"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.button,
    style: {
      transition: theme2.transitions.create("background-color", {
        duration: theme2.transitions.duration.shortest
      }),
      "&:hover": {
        textDecoration: "none",
        backgroundColor: (theme2.vars || theme2).palette.action.hover,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.hasSecondaryAction,
    style: {
      // Add some space to avoid collision as `ListItemSecondaryAction`
      // is absolutely positioned.
      paddingRight: 48
    }
  }]
})));
const ListItemContainer = styled("li", {
  name: "MuiListItem",
  slot: "Container"
})({
  position: "relative"
});
const ListItem = /* @__PURE__ */ reactExports.forwardRef(function ListItem2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiListItem"
  });
  const _a2 = props, {
    alignItems = "center",
    children: childrenProp,
    className,
    component: componentProp,
    components = {},
    componentsProps = {},
    ContainerComponent = "li",
    ContainerProps: _b = {}
  } = _a2, _c = _b, {
    className: ContainerClassName
  } = _c, ContainerProps = __objRest(_c, [
    "className"
  ]), _d = _a2, {
    dense = false,
    disableGutters = false,
    disablePadding = false,
    divider = false,
    secondaryAction,
    slotProps = {},
    slots = {}
  } = _d, other = __objRest(_d, [
    "alignItems",
    "children",
    "className",
    "component",
    "components",
    "componentsProps",
    "ContainerComponent",
    "ContainerProps",
    "dense",
    "disableGutters",
    "disablePadding",
    "divider",
    "secondaryAction",
    "slotProps",
    "slots"
  ]);
  const context = reactExports.useContext(ListContext);
  const childContext = reactExports.useMemo(() => ({
    dense: dense || context.dense || false,
    alignItems,
    disableGutters
  }), [alignItems, context.dense, dense, disableGutters]);
  const listItemRef = reactExports.useRef(null);
  const children = reactExports.Children.toArray(childrenProp);
  const hasSecondaryAction = children.length && isMuiElement(children[children.length - 1], ["ListItemSecondaryAction"]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    alignItems,
    dense: childContext.dense,
    disableGutters,
    disablePadding,
    divider,
    hasSecondaryAction
  });
  const classes = useUtilityClasses$z(ownerState);
  const handleRef = useForkRef(listItemRef, ref);
  const Root = slots.root || components.Root || ListItemRoot;
  const rootProps = slotProps.root || componentsProps.root || {};
  const componentProps = __spreadValues({
    className: clsx(classes.root, rootProps.className, className)
  }, other);
  let Component = componentProp || "li";
  if (hasSecondaryAction) {
    Component = !componentProps.component && !componentProp ? "div" : Component;
    if (ContainerComponent === "li") {
      if (Component === "li") {
        Component = "div";
      } else if (componentProps.component === "li") {
        componentProps.component = "div";
      }
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext.Provider, {
      value: childContext,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItemContainer, __spreadProps(__spreadValues({
        as: ContainerComponent,
        className: clsx(classes.container, ContainerClassName),
        ref: handleRef,
        ownerState
      }, ContainerProps), {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Root, __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, rootProps), !isHostComponent(Root) && {
          as: Component,
          ownerState: __spreadValues(__spreadValues({}, ownerState), rootProps.ownerState)
        }), componentProps), {
          children
        })), children.pop()]
      }))
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Root, __spreadProps(__spreadValues(__spreadValues(__spreadProps(__spreadValues({}, rootProps), {
      as: Component,
      ref: handleRef
    }), !isHostComponent(Root) && {
      ownerState: __spreadValues(__spreadValues({}, ownerState), rootProps.ownerState)
    }), componentProps), {
      children: [children, secondaryAction && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemSecondaryAction, {
        children: secondaryAction
      })]
    }))
  });
});
function getListItemAvatarUtilityClass(slot) {
  return generateUtilityClass("MuiListItemAvatar", slot);
}
generateUtilityClasses("MuiListItemAvatar", ["root", "alignItemsFlexStart"]);
const useUtilityClasses$y = (ownerState) => {
  const {
    alignItems,
    classes
  } = ownerState;
  const slots = {
    root: ["root", alignItems === "flex-start" && "alignItemsFlexStart"]
  };
  return composeClasses(slots, getListItemAvatarUtilityClass, classes);
};
const ListItemAvatarRoot = styled("div", {
  name: "MuiListItemAvatar",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart];
  }
})({
  minWidth: 56,
  flexShrink: 0,
  variants: [{
    props: {
      alignItems: "flex-start"
    },
    style: {
      marginTop: 8
    }
  }]
});
const ListItemAvatar = /* @__PURE__ */ reactExports.forwardRef(function ListItemAvatar2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiListItemAvatar"
  });
  const _a2 = props, {
    className
  } = _a2, other = __objRest(_a2, [
    "className"
  ]);
  const context = reactExports.useContext(ListContext);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    alignItems: context.alignItems
  });
  const classes = useUtilityClasses$y(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemAvatarRoot, __spreadValues({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
function getListItemIconUtilityClass(slot) {
  return generateUtilityClass("MuiListItemIcon", slot);
}
const listItemIconClasses = generateUtilityClasses("MuiListItemIcon", ["root", "alignItemsFlexStart"]);
const useUtilityClasses$x = (ownerState) => {
  const {
    alignItems,
    classes
  } = ownerState;
  const slots = {
    root: ["root", alignItems === "flex-start" && "alignItemsFlexStart"]
  };
  return composeClasses(slots, getListItemIconUtilityClass, classes);
};
const ListItemIconRoot = styled("div", {
  name: "MuiListItemIcon",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  minWidth: 56,
  color: (theme2.vars || theme2).palette.action.active,
  flexShrink: 0,
  display: "inline-flex",
  variants: [{
    props: {
      alignItems: "flex-start"
    },
    style: {
      marginTop: 8
    }
  }]
})));
const ListItemIcon = /* @__PURE__ */ reactExports.forwardRef(function ListItemIcon2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiListItemIcon"
  });
  const _a2 = props, {
    className
  } = _a2, other = __objRest(_a2, [
    "className"
  ]);
  const context = reactExports.useContext(ListContext);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    alignItems: context.alignItems
  });
  const classes = useUtilityClasses$x(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIconRoot, __spreadValues({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
function getListItemTextUtilityClass(slot) {
  return generateUtilityClass("MuiListItemText", slot);
}
const listItemTextClasses = generateUtilityClasses("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]);
const useUtilityClasses$w = (ownerState) => {
  const {
    classes,
    inset,
    primary,
    secondary,
    dense
  } = ownerState;
  const slots = {
    root: ["root", inset && "inset", dense && "dense", primary && secondary && "multiline"],
    primary: ["primary"],
    secondary: ["secondary"]
  };
  return composeClasses(slots, getListItemTextUtilityClass, classes);
};
const ListItemTextRoot = styled("div", {
  name: "MuiListItemText",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${listItemTextClasses.primary}`]: styles2.primary
    }, {
      [`& .${listItemTextClasses.secondary}`]: styles2.secondary
    }, styles2.root, ownerState.inset && styles2.inset, ownerState.primary && ownerState.secondary && styles2.multiline, ownerState.dense && styles2.dense];
  }
})({
  flex: "1 1 auto",
  minWidth: 0,
  marginTop: 4,
  marginBottom: 4,
  [`.${typographyClasses.root}:where(& .${listItemTextClasses.primary})`]: {
    display: "block"
  },
  [`.${typographyClasses.root}:where(& .${listItemTextClasses.secondary})`]: {
    display: "block"
  },
  variants: [{
    props: ({
      ownerState
    }) => ownerState.primary && ownerState.secondary,
    style: {
      marginTop: 6,
      marginBottom: 6
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.inset,
    style: {
      paddingLeft: 56
    }
  }]
});
const ListItemText = /* @__PURE__ */ reactExports.forwardRef(function ListItemText2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiListItemText"
  });
  const _a2 = props, {
    children,
    className,
    disableTypography = false,
    inset = false,
    primary: primaryProp,
    primaryTypographyProps,
    secondary: secondaryProp,
    secondaryTypographyProps,
    slots = {},
    slotProps = {}
  } = _a2, other = __objRest(_a2, [
    "children",
    "className",
    "disableTypography",
    "inset",
    "primary",
    "primaryTypographyProps",
    "secondary",
    "secondaryTypographyProps",
    "slots",
    "slotProps"
  ]);
  const {
    dense
  } = reactExports.useContext(ListContext);
  let primary = primaryProp != null ? primaryProp : children;
  let secondary = secondaryProp;
  const ownerState = __spreadProps(__spreadValues({}, props), {
    disableTypography,
    inset,
    primary: !!primary,
    secondary: !!secondary,
    dense
  });
  const classes = useUtilityClasses$w(ownerState);
  const externalForwardedProps = {
    slots,
    slotProps: __spreadValues({
      primary: primaryTypographyProps,
      secondary: secondaryTypographyProps
    }, slotProps)
  };
  const [RootSlot, rootSlotProps] = useSlot("root", {
    className: clsx(classes.root, className),
    elementType: ListItemTextRoot,
    externalForwardedProps: __spreadValues(__spreadValues({}, externalForwardedProps), other),
    ownerState,
    ref
  });
  const [PrimarySlot, primarySlotProps] = useSlot("primary", {
    className: classes.primary,
    elementType: Typography,
    externalForwardedProps,
    ownerState
  });
  const [SecondarySlot, secondarySlotProps] = useSlot("secondary", {
    className: classes.secondary,
    elementType: Typography,
    externalForwardedProps,
    ownerState
  });
  if (primary != null && primary.type !== Typography && !disableTypography) {
    primary = /* @__PURE__ */ jsxRuntimeExports.jsx(PrimarySlot, __spreadProps(__spreadValues({
      variant: dense ? "body2" : "body1",
      component: (primarySlotProps == null ? void 0 : primarySlotProps.variant) ? void 0 : "span"
    }, primarySlotProps), {
      children: primary
    }));
  }
  if (secondary != null && secondary.type !== Typography && !disableTypography) {
    secondary = /* @__PURE__ */ jsxRuntimeExports.jsx(SecondarySlot, __spreadProps(__spreadValues({
      variant: "body2",
      color: "textSecondary"
    }, secondarySlotProps), {
      children: secondary
    }));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, __spreadProps(__spreadValues({}, rootSlotProps), {
    children: [primary, secondary]
  }));
});
function nextItem$1(list, item, disableListWrap) {
  if (list === item) {
    return list.firstChild;
  }
  if (item && item.nextElementSibling) {
    return item.nextElementSibling;
  }
  return disableListWrap ? null : list.firstChild;
}
function previousItem$1(list, item, disableListWrap) {
  if (list === item) {
    return disableListWrap ? list.firstChild : list.lastChild;
  }
  if (item && item.previousElementSibling) {
    return item.previousElementSibling;
  }
  return disableListWrap ? null : list.lastChild;
}
function textCriteriaMatches(nextFocus, textCriteria) {
  if (textCriteria === void 0) {
    return true;
  }
  let text = nextFocus.innerText;
  if (text === void 0) {
    text = nextFocus.textContent;
  }
  text = text.trim().toLowerCase();
  if (text.length === 0) {
    return false;
  }
  if (textCriteria.repeating) {
    return text[0] === textCriteria.keys[0];
  }
  return text.startsWith(textCriteria.keys.join(""));
}
function moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
  let wrappedOnce = false;
  let nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);
  while (nextFocus) {
    if (nextFocus === list.firstChild) {
      if (wrappedOnce) {
        return false;
      }
      wrappedOnce = true;
    }
    const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
    if (!nextFocus.hasAttribute("tabindex") || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {
      nextFocus = traversalFunction(list, nextFocus, disableListWrap);
    } else {
      nextFocus.focus();
      return true;
    }
  }
  return false;
}
const MenuList = /* @__PURE__ */ reactExports.forwardRef(function MenuList2(props, ref) {
  const _a2 = props, {
    actions: actions,
    autoFocus = false,
    autoFocusItem = false,
    children,
    className,
    disabledItemsFocusable = false,
    disableListWrap = false,
    onKeyDown,
    variant = "selectedMenu"
  } = _a2, other = __objRest(_a2, [
    // private
    // eslint-disable-next-line react/prop-types
    "actions",
    "autoFocus",
    "autoFocusItem",
    "children",
    "className",
    "disabledItemsFocusable",
    "disableListWrap",
    "onKeyDown",
    "variant"
  ]);
  const listRef = reactExports.useRef(null);
  const textCriteriaRef = reactExports.useRef({
    keys: [],
    repeating: true,
    previousKeyMatched: true,
    lastTime: null
  });
  useEnhancedEffect(() => {
    if (autoFocus) {
      listRef.current.focus();
    }
  }, [autoFocus]);
  reactExports.useImperativeHandle(actions, () => ({
    adjustStyleForScrollbar: (containerElement, {
      direction
    }) => {
      const noExplicitWidth = !listRef.current.style.width;
      if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
        const scrollbarSize = `${getScrollbarSize(ownerWindow(containerElement))}px`;
        listRef.current.style[direction === "rtl" ? "paddingLeft" : "paddingRight"] = scrollbarSize;
        listRef.current.style.width = `calc(100% + ${scrollbarSize})`;
      }
      return listRef.current;
    }
  }), []);
  const handleKeyDown = (event) => {
    const list = listRef.current;
    const key = event.key;
    const isModifierKeyPressed = event.ctrlKey || event.metaKey || event.altKey;
    if (isModifierKeyPressed) {
      if (onKeyDown) {
        onKeyDown(event);
      }
      return;
    }
    const currentFocus = ownerDocument(list).activeElement;
    if (key === "ArrowDown") {
      event.preventDefault();
      moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem$1);
    } else if (key === "ArrowUp") {
      event.preventDefault();
      moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem$1);
    } else if (key === "Home") {
      event.preventDefault();
      moveFocus$1(list, null, disableListWrap, disabledItemsFocusable, nextItem$1);
    } else if (key === "End") {
      event.preventDefault();
      moveFocus$1(list, null, disableListWrap, disabledItemsFocusable, previousItem$1);
    } else if (key.length === 1) {
      const criteria = textCriteriaRef.current;
      const lowerKey = key.toLowerCase();
      const currTime = performance.now();
      if (criteria.keys.length > 0) {
        if (currTime - criteria.lastTime > 500) {
          criteria.keys = [];
          criteria.repeating = true;
          criteria.previousKeyMatched = true;
        } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
          criteria.repeating = false;
        }
      }
      criteria.lastTime = currTime;
      criteria.keys.push(lowerKey);
      const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);
      if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus$1(list, currentFocus, false, disabledItemsFocusable, nextItem$1, criteria))) {
        event.preventDefault();
      } else {
        criteria.previousKeyMatched = false;
      }
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  };
  const handleRef = useForkRef(listRef, ref);
  let activeItemIndex = -1;
  reactExports.Children.forEach(children, (child, index2) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      if (activeItemIndex === index2) {
        activeItemIndex += 1;
        if (activeItemIndex >= children.length) {
          activeItemIndex = -1;
        }
      }
      return;
    }
    if (!child.props.disabled) {
      if (variant === "selectedMenu" && child.props.selected) {
        activeItemIndex = index2;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index2;
      }
    }
    if (activeItemIndex === index2 && (child.props.disabled || child.props.muiSkipListHighlight || child.type.muiSkipListHighlight)) {
      activeItemIndex += 1;
      if (activeItemIndex >= children.length) {
        activeItemIndex = -1;
      }
    }
  });
  const items = reactExports.Children.map(children, (child, index2) => {
    if (index2 === activeItemIndex) {
      const newChildProps = {};
      if (autoFocusItem) {
        newChildProps.autoFocus = true;
      }
      if (child.props.tabIndex === void 0 && variant === "selectedMenu") {
        newChildProps.tabIndex = 0;
      }
      return /* @__PURE__ */ reactExports.cloneElement(child, newChildProps);
    }
    return child;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(List$1, __spreadProps(__spreadValues({
    role: "menu",
    ref: handleRef,
    className,
    onKeyDown: handleKeyDown,
    tabIndex: autoFocus ? 0 : -1
  }, other), {
    children: items
  }));
});
function getPopoverUtilityClass(slot) {
  return generateUtilityClass("MuiPopover", slot);
}
generateUtilityClasses("MuiPopover", ["root", "paper"]);
function getOffsetTop(rect, vertical) {
  let offset2 = 0;
  if (typeof vertical === "number") {
    offset2 = vertical;
  } else if (vertical === "center") {
    offset2 = rect.height / 2;
  } else if (vertical === "bottom") {
    offset2 = rect.height;
  }
  return offset2;
}
function getOffsetLeft(rect, horizontal) {
  let offset2 = 0;
  if (typeof horizontal === "number") {
    offset2 = horizontal;
  } else if (horizontal === "center") {
    offset2 = rect.width / 2;
  } else if (horizontal === "right") {
    offset2 = rect.width;
  }
  return offset2;
}
function getTransformOriginValue(transformOrigin) {
  return [transformOrigin.horizontal, transformOrigin.vertical].map((n) => typeof n === "number" ? `${n}px` : n).join(" ");
}
function resolveAnchorEl(anchorEl) {
  return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
const useUtilityClasses$v = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    paper: ["paper"]
  };
  return composeClasses(slots, getPopoverUtilityClass, classes);
};
const PopoverRoot = styled(Modal, {
  name: "MuiPopover",
  slot: "Root"
})({});
const PopoverPaper = styled(Paper, {
  name: "MuiPopover",
  slot: "Paper"
})({
  position: "absolute",
  overflowY: "auto",
  overflowX: "hidden",
  // So we see the popover when it's empty.
  // It's most likely on issue on userland.
  minWidth: 16,
  minHeight: 16,
  maxWidth: "calc(100% - 32px)",
  maxHeight: "calc(100% - 32px)",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
});
const Popover = /* @__PURE__ */ reactExports.forwardRef(function Popover2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiPopover"
  });
  const _a2 = props, {
    action,
    anchorEl,
    anchorOrigin = {
      vertical: "top",
      horizontal: "left"
    },
    anchorPosition,
    anchorReference = "anchorEl",
    children,
    className,
    container: containerProp,
    elevation = 8,
    marginThreshold = 16,
    open,
    PaperProps: PaperPropsProp = {},
    slots: slots = {},
    slotProps = {},
    transformOrigin = {
      vertical: "top",
      horizontal: "left"
    },
    TransitionComponent,
    transitionDuration: transitionDurationProp = "auto",
    TransitionProps = {},
    disableScrollLock: disableScrollLock = false
  } = _a2, other = __objRest(_a2, [
    "action",
    "anchorEl",
    "anchorOrigin",
    "anchorPosition",
    "anchorReference",
    "children",
    "className",
    "container",
    "elevation",
    "marginThreshold",
    "open",
    "PaperProps",
    // TODO: remove in v7
    "slots",
    "slotProps",
    "transformOrigin",
    "TransitionComponent",
    // TODO: remove in v7
    "transitionDuration",
    "TransitionProps",
    // TODO: remove in v7
    "disableScrollLock"
  ]);
  const paperRef = reactExports.useRef();
  const ownerState = __spreadProps(__spreadValues({}, props), {
    anchorOrigin,
    anchorReference,
    elevation,
    marginThreshold,
    transformOrigin,
    TransitionComponent,
    transitionDuration: transitionDurationProp,
    TransitionProps
  });
  const classes = useUtilityClasses$v(ownerState);
  const getAnchorOffset = reactExports.useCallback(() => {
    if (anchorReference === "anchorPosition") {
      return anchorPosition;
    }
    const resolvedAnchorEl = resolveAnchorEl(anchorEl);
    const anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument(paperRef.current).body;
    const anchorRect = anchorElement.getBoundingClientRect();
    return {
      top: anchorRect.top + getOffsetTop(anchorRect, anchorOrigin.vertical),
      left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
    };
  }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]);
  const getTransformOrigin = reactExports.useCallback((elemRect) => {
    return {
      vertical: getOffsetTop(elemRect, transformOrigin.vertical),
      horizontal: getOffsetLeft(elemRect, transformOrigin.horizontal)
    };
  }, [transformOrigin.horizontal, transformOrigin.vertical]);
  const getPositioningStyle = reactExports.useCallback((element) => {
    const elemRect = {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
    const elemTransformOrigin = getTransformOrigin(elemRect);
    if (anchorReference === "none") {
      return {
        top: null,
        left: null,
        transformOrigin: getTransformOriginValue(elemTransformOrigin)
      };
    }
    const anchorOffset = getAnchorOffset();
    let top2 = anchorOffset.top - elemTransformOrigin.vertical;
    let left2 = anchorOffset.left - elemTransformOrigin.horizontal;
    const bottom2 = top2 + elemRect.height;
    const right2 = left2 + elemRect.width;
    const containerWindow = ownerWindow(resolveAnchorEl(anchorEl));
    const heightThreshold = containerWindow.innerHeight - marginThreshold;
    const widthThreshold = containerWindow.innerWidth - marginThreshold;
    if (marginThreshold !== null && top2 < marginThreshold) {
      const diff = top2 - marginThreshold;
      top2 -= diff;
      elemTransformOrigin.vertical += diff;
    } else if (marginThreshold !== null && bottom2 > heightThreshold) {
      const diff = bottom2 - heightThreshold;
      top2 -= diff;
      elemTransformOrigin.vertical += diff;
    }
    if (marginThreshold !== null && left2 < marginThreshold) {
      const diff = left2 - marginThreshold;
      left2 -= diff;
      elemTransformOrigin.horizontal += diff;
    } else if (right2 > widthThreshold) {
      const diff = right2 - widthThreshold;
      left2 -= diff;
      elemTransformOrigin.horizontal += diff;
    }
    return {
      top: `${Math.round(top2)}px`,
      left: `${Math.round(left2)}px`,
      transformOrigin: getTransformOriginValue(elemTransformOrigin)
    };
  }, [anchorEl, anchorReference, getAnchorOffset, getTransformOrigin, marginThreshold]);
  const [isPositioned, setIsPositioned] = reactExports.useState(open);
  const setPositioningStyles = reactExports.useCallback(() => {
    const element = paperRef.current;
    if (!element) {
      return;
    }
    const positioning = getPositioningStyle(element);
    if (positioning.top !== null) {
      element.style.setProperty("top", positioning.top);
    }
    if (positioning.left !== null) {
      element.style.left = positioning.left;
    }
    element.style.transformOrigin = positioning.transformOrigin;
    setIsPositioned(true);
  }, [getPositioningStyle]);
  reactExports.useEffect(() => {
    if (disableScrollLock) {
      window.addEventListener("scroll", setPositioningStyles);
    }
    return () => window.removeEventListener("scroll", setPositioningStyles);
  }, [anchorEl, disableScrollLock, setPositioningStyles]);
  const handleEntering = () => {
    setPositioningStyles();
  };
  const handleExited = () => {
    setIsPositioned(false);
  };
  reactExports.useEffect(() => {
    if (open) {
      setPositioningStyles();
    }
  });
  reactExports.useImperativeHandle(action, () => open ? {
    updatePosition: () => {
      setPositioningStyles();
    }
  } : null, [open, setPositioningStyles]);
  reactExports.useEffect(() => {
    if (!open) {
      return void 0;
    }
    const handleResize = debounce$1(() => {
      setPositioningStyles();
    });
    const containerWindow = ownerWindow(resolveAnchorEl(anchorEl));
    containerWindow.addEventListener("resize", handleResize);
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
    };
  }, [anchorEl, open, setPositioningStyles]);
  let transitionDuration = transitionDurationProp;
  const externalForwardedProps = {
    slots: __spreadValues({
      transition: TransitionComponent
    }, slots),
    slotProps: __spreadValues({
      transition: TransitionProps,
      paper: PaperPropsProp
    }, slotProps)
  };
  const [TransitionSlot, transitionSlotProps] = useSlot("transition", {
    elementType: Grow,
    externalForwardedProps,
    ownerState,
    getSlotProps: (handlers) => __spreadProps(__spreadValues({}, handlers), {
      onEntering: (element, isAppearing) => {
        var _a3;
        (_a3 = handlers.onEntering) == null ? void 0 : _a3.call(handlers, element, isAppearing);
        handleEntering();
      },
      onExited: (element) => {
        var _a3;
        (_a3 = handlers.onExited) == null ? void 0 : _a3.call(handlers, element);
        handleExited();
      }
    }),
    additionalProps: {
      appear: true,
      in: open
    }
  });
  if (transitionDurationProp === "auto" && !TransitionSlot.muiSupportAuto) {
    transitionDuration = void 0;
  }
  const container = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl(anchorEl)).body : void 0);
  const [RootSlot, _b] = useSlot("root", {
    ref,
    elementType: PopoverRoot,
    externalForwardedProps: __spreadValues(__spreadValues({}, externalForwardedProps), other),
    shouldForwardComponentProp: true,
    additionalProps: {
      slots: {
        backdrop: slots.backdrop
      },
      slotProps: {
        backdrop: mergeSlotProps$1(typeof slotProps.backdrop === "function" ? slotProps.backdrop(ownerState) : slotProps.backdrop, {
          invisible: true
        })
      },
      container,
      open
    },
    ownerState,
    className: clsx(classes.root, className)
  }), _c = _b, {
    slots: rootSlotsProp,
    slotProps: rootSlotPropsProp
  } = _c, rootProps = __objRest(_c, [
    "slots",
    "slotProps"
  ]);
  const [PaperSlot, paperProps] = useSlot("paper", {
    ref: paperRef,
    className: classes.paper,
    elementType: PopoverPaper,
    externalForwardedProps,
    shouldForwardComponentProp: true,
    additionalProps: {
      elevation,
      style: isPositioned ? void 0 : {
        opacity: 0
      }
    },
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, __spreadProps(__spreadValues(__spreadValues({}, rootProps), !isHostComponent(RootSlot) && {
    slots: rootSlotsProp,
    slotProps: rootSlotPropsProp,
    disableScrollLock
  }), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionSlot, __spreadProps(__spreadValues({}, transitionSlotProps), {
      timeout: transitionDuration,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaperSlot, __spreadProps(__spreadValues({}, paperProps), {
        children
      }))
    }))
  }));
});
function getMenuUtilityClass(slot) {
  return generateUtilityClass("MuiMenu", slot);
}
generateUtilityClasses("MuiMenu", ["root", "paper", "list"]);
const RTL_ORIGIN = {
  vertical: "top",
  horizontal: "right"
};
const LTR_ORIGIN = {
  vertical: "top",
  horizontal: "left"
};
const useUtilityClasses$u = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    paper: ["paper"],
    list: ["list"]
  };
  return composeClasses(slots, getMenuUtilityClass, classes);
};
const MenuRoot = styled(Popover, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiMenu",
  slot: "Root"
})({});
const MenuPaper = styled(PopoverPaper, {
  name: "MuiMenu",
  slot: "Paper"
})({
  // specZ: The maximum height of a simple menu should be one or more rows less than the view
  // height. This ensures a tappable area outside of the simple menu with which to dismiss
  // the menu.
  maxHeight: "calc(100% - 96px)",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch"
});
const MenuMenuList = styled(MenuList, {
  name: "MuiMenu",
  slot: "List"
})({
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
});
const Menu = /* @__PURE__ */ reactExports.forwardRef(function Menu2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiMenu"
  });
  const _a2 = props, {
    autoFocus = true,
    children,
    className,
    disableAutoFocusItem = false,
    MenuListProps = {},
    onClose,
    open,
    PaperProps = {},
    PopoverClasses,
    transitionDuration = "auto",
    TransitionProps: _b = {}
  } = _a2, _c = _b, {
    onEntering
  } = _c, TransitionProps = __objRest(_c, [
    "onEntering"
  ]), _d = _a2, {
    variant = "selectedMenu",
    slots = {},
    slotProps = {}
  } = _d, other = __objRest(_d, [
    "autoFocus",
    "children",
    "className",
    "disableAutoFocusItem",
    "MenuListProps",
    "onClose",
    "open",
    "PaperProps",
    "PopoverClasses",
    "transitionDuration",
    "TransitionProps",
    "variant",
    "slots",
    "slotProps"
  ]);
  const isRtl = useRtl();
  const ownerState = __spreadProps(__spreadValues({}, props), {
    autoFocus,
    disableAutoFocusItem,
    MenuListProps,
    onEntering,
    PaperProps,
    transitionDuration,
    TransitionProps,
    variant
  });
  const classes = useUtilityClasses$u(ownerState);
  const autoFocusItem = autoFocus && !disableAutoFocusItem && open;
  const menuListActionsRef = reactExports.useRef(null);
  const handleEntering = (element, isAppearing) => {
    if (menuListActionsRef.current) {
      menuListActionsRef.current.adjustStyleForScrollbar(element, {
        direction: isRtl ? "rtl" : "ltr"
      });
    }
    if (onEntering) {
      onEntering(element, isAppearing);
    }
  };
  const handleListKeyDown = (event) => {
    if (event.key === "Tab") {
      event.preventDefault();
      if (onClose) {
        onClose(event, "tabKeyDown");
      }
    }
  };
  let activeItemIndex = -1;
  reactExports.Children.map(children, (child, index2) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      return;
    }
    if (!child.props.disabled) {
      if (variant === "selectedMenu" && child.props.selected) {
        activeItemIndex = index2;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index2;
      }
    }
  });
  const externalForwardedProps = {
    slots,
    slotProps: __spreadValues({
      list: MenuListProps,
      transition: TransitionProps,
      paper: PaperProps
    }, slotProps)
  };
  const rootSlotProps = useSlotProps({
    elementType: slots.root,
    externalSlotProps: slotProps.root,
    ownerState,
    className: [classes.root, className]
  });
  const [PaperSlot, paperSlotProps] = useSlot("paper", {
    className: classes.paper,
    elementType: MenuPaper,
    externalForwardedProps,
    shouldForwardComponentProp: true,
    ownerState
  });
  const [ListSlot, listSlotProps] = useSlot("list", {
    className: clsx(classes.list, MenuListProps.className),
    elementType: MenuMenuList,
    shouldForwardComponentProp: true,
    externalForwardedProps,
    getSlotProps: (handlers) => __spreadProps(__spreadValues({}, handlers), {
      onKeyDown: (event) => {
        var _a3;
        handleListKeyDown(event);
        (_a3 = handlers.onKeyDown) == null ? void 0 : _a3.call(handlers, event);
      }
    }),
    ownerState
  });
  const resolvedTransitionProps = typeof externalForwardedProps.slotProps.transition === "function" ? externalForwardedProps.slotProps.transition(ownerState) : externalForwardedProps.slotProps.transition;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRoot, __spreadProps(__spreadValues({
    onClose,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: isRtl ? "right" : "left"
    },
    transformOrigin: isRtl ? RTL_ORIGIN : LTR_ORIGIN,
    slots: __spreadValues({
      root: slots.root,
      paper: PaperSlot,
      backdrop: slots.backdrop
    }, slots.transition && {
      // TODO: pass `slots.transition` directly once `TransitionComponent` is removed from Popover
      transition: slots.transition
    }),
    slotProps: {
      root: rootSlotProps,
      paper: paperSlotProps,
      backdrop: typeof slotProps.backdrop === "function" ? slotProps.backdrop(ownerState) : slotProps.backdrop,
      transition: __spreadProps(__spreadValues({}, resolvedTransitionProps), {
        onEntering: (...args) => {
          var _a3;
          handleEntering(...args);
          (_a3 = resolvedTransitionProps == null ? void 0 : resolvedTransitionProps.onEntering) == null ? void 0 : _a3.call(resolvedTransitionProps, ...args);
        }
      })
    },
    open,
    ref,
    transitionDuration,
    ownerState
  }, other), {
    classes: PopoverClasses,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListSlot, __spreadProps(__spreadValues({
      actions: menuListActionsRef,
      autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
      autoFocusItem,
      variant
    }, listSlotProps), {
      children
    }))
  }));
});
function getMenuItemUtilityClass(slot) {
  return generateUtilityClass("MuiMenuItem", slot);
}
const menuItemClasses = generateUtilityClasses("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]);
const overridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.dense && styles2.dense, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters];
};
const useUtilityClasses$t = (ownerState) => {
  const {
    disabled,
    dense,
    divider,
    disableGutters,
    selected,
    classes
  } = ownerState;
  const slots = {
    root: ["root", dense && "dense", disabled && "disabled", !disableGutters && "gutters", divider && "divider", selected && "selected"]
  };
  const composedClasses = composeClasses(slots, getMenuItemUtilityClass, classes);
  return __spreadValues(__spreadValues({}, classes), composedClasses);
};
const MenuItemRoot = styled(ButtonBase, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiMenuItem",
  slot: "Root",
  overridesResolver
})(memoTheme(({
  theme: theme2
}) => __spreadProps(__spreadValues({}, theme2.typography.body1), {
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minHeight: 48,
  paddingTop: 6,
  paddingBottom: 6,
  boxSizing: "border-box",
  whiteSpace: "nowrap",
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (theme2.vars || theme2).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${menuItemClasses.selected}`]: {
    backgroundColor: theme2.alpha((theme2.vars || theme2).palette.primary.main, (theme2.vars || theme2).palette.action.selectedOpacity),
    [`&.${menuItemClasses.focusVisible}`]: {
      backgroundColor: theme2.alpha((theme2.vars || theme2).palette.primary.main, `${(theme2.vars || theme2).palette.action.selectedOpacity} + ${(theme2.vars || theme2).palette.action.focusOpacity}`)
    }
  },
  [`&.${menuItemClasses.selected}:hover`]: {
    backgroundColor: theme2.alpha((theme2.vars || theme2).palette.primary.main, `${(theme2.vars || theme2).palette.action.selectedOpacity} + ${(theme2.vars || theme2).palette.action.hoverOpacity}`),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: theme2.alpha((theme2.vars || theme2).palette.primary.main, (theme2.vars || theme2).palette.action.selectedOpacity)
    }
  },
  [`&.${menuItemClasses.focusVisible}`]: {
    backgroundColor: (theme2.vars || theme2).palette.action.focus
  },
  [`&.${menuItemClasses.disabled}`]: {
    opacity: (theme2.vars || theme2).palette.action.disabledOpacity
  },
  [`& + .${dividerClasses.root}`]: {
    marginTop: theme2.spacing(1),
    marginBottom: theme2.spacing(1)
  },
  [`& + .${dividerClasses.inset}`]: {
    marginLeft: 52
  },
  [`& .${listItemTextClasses.root}`]: {
    marginTop: 0,
    marginBottom: 0
  },
  [`& .${listItemTextClasses.inset}`]: {
    paddingLeft: 36
  },
  [`& .${listItemIconClasses.root}`]: {
    minWidth: 36
  },
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.disableGutters,
    style: {
      paddingLeft: 16,
      paddingRight: 16
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.divider,
    style: {
      borderBottom: `1px solid ${(theme2.vars || theme2).palette.divider}`,
      backgroundClip: "padding-box"
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.dense,
    style: {
      [theme2.breakpoints.up("sm")]: {
        minHeight: "auto"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.dense,
    style: __spreadProps(__spreadValues({
      minHeight: 32,
      // https://m2.material.io/components/menus#specs > Dense
      paddingTop: 4,
      paddingBottom: 4
    }, theme2.typography.body2), {
      [`& .${listItemIconClasses.root} svg`]: {
        fontSize: "1.25rem"
      }
    })
  }]
})));
const MenuItem = /* @__PURE__ */ reactExports.forwardRef(function MenuItem2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiMenuItem"
  });
  const _a2 = props, {
    autoFocus = false,
    component = "li",
    dense = false,
    divider = false,
    disableGutters = false,
    focusVisibleClassName,
    role = "menuitem",
    tabIndex: tabIndexProp,
    className
  } = _a2, other = __objRest(_a2, [
    "autoFocus",
    "component",
    "dense",
    "divider",
    "disableGutters",
    "focusVisibleClassName",
    "role",
    "tabIndex",
    "className"
  ]);
  const context = reactExports.useContext(ListContext);
  const childContext = reactExports.useMemo(() => ({
    dense: dense || context.dense || false,
    disableGutters
  }), [context.dense, dense, disableGutters]);
  const menuItemRef = reactExports.useRef(null);
  useEnhancedEffect(() => {
    if (autoFocus) {
      if (menuItemRef.current) {
        menuItemRef.current.focus();
      }
    }
  }, [autoFocus]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    dense: childContext.dense,
    divider,
    disableGutters
  });
  const classes = useUtilityClasses$t(props);
  const handleRef = useForkRef(menuItemRef, ref);
  let tabIndex;
  if (!props.disabled) {
    tabIndex = tabIndexProp !== void 0 ? tabIndexProp : -1;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItemRoot, __spreadProps(__spreadValues({
      ref: handleRef,
      role,
      tabIndex,
      component,
      focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
      className: clsx(classes.root, className)
    }, other), {
      ownerState,
      classes
    }))
  });
});
function getMobileStepperUtilityClass(slot) {
  return generateUtilityClass("MuiMobileStepper", slot);
}
generateUtilityClasses("MuiMobileStepper", ["root", "positionBottom", "positionTop", "positionStatic", "dots", "dot", "dotActive", "progress"]);
const useUtilityClasses$s = (ownerState) => {
  const {
    classes,
    position: position2
  } = ownerState;
  const slots = {
    root: ["root", `position${capitalize(position2)}`],
    dots: ["dots"],
    dot: ["dot"],
    dotActive: ["dotActive"],
    progress: ["progress"]
  };
  return composeClasses(slots, getMobileStepperUtilityClass, classes);
};
const MobileStepperRoot = styled(Paper, {
  name: "MuiMobileStepper",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`position${capitalize(ownerState.position)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  display: "flex",
  flexDirection: "row",
  justifyContent: "space-between",
  alignItems: "center",
  background: (theme2.vars || theme2).palette.background.default,
  padding: 8,
  variants: [{
    props: ({
      position: position2
    }) => position2 === "top" || position2 === "bottom",
    style: {
      position: "fixed",
      left: 0,
      right: 0,
      zIndex: (theme2.vars || theme2).zIndex.mobileStepper
    }
  }, {
    props: {
      position: "top"
    },
    style: {
      top: 0
    }
  }, {
    props: {
      position: "bottom"
    },
    style: {
      bottom: 0
    }
  }]
})));
const MobileStepperDots = styled("div", {
  name: "MuiMobileStepper",
  slot: "Dots"
})({
  variants: [{
    props: {
      variant: "dots"
    },
    style: {
      display: "flex",
      flexDirection: "row"
    }
  }]
});
const MobileStepperDot = styled("div", {
  name: "MuiMobileStepper",
  slot: "Dot",
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "dotActive",
  overridesResolver: (props, styles2) => {
    const {
      dotActive
    } = props;
    return [styles2.dot, dotActive && styles2.dotActive];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  variants: [{
    props: {
      variant: "dots"
    },
    style: {
      transition: theme2.transitions.create("background-color", {
        duration: theme2.transitions.duration.shortest
      }),
      backgroundColor: (theme2.vars || theme2).palette.action.disabled,
      borderRadius: "50%",
      width: 8,
      height: 8,
      margin: "0 2px"
    }
  }, {
    props: {
      variant: "dots",
      dotActive: true
    },
    style: {
      backgroundColor: (theme2.vars || theme2).palette.primary.main
    }
  }]
})));
const MobileStepperProgress = styled(LinearProgress, {
  name: "MuiMobileStepper",
  slot: "Progress"
})({
  variants: [{
    props: {
      variant: "progress"
    },
    style: {
      width: "50%"
    }
  }]
});
const MobileStepper = /* @__PURE__ */ reactExports.forwardRef(function MobileStepper2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiMobileStepper"
  });
  const _a2 = props, {
    activeStep = 0,
    backButton,
    className,
    LinearProgressProps,
    nextButton,
    position: position2 = "bottom",
    steps,
    variant = "dots",
    slots = {},
    slotProps = {}
  } = _a2, other = __objRest(_a2, [
    "activeStep",
    "backButton",
    "className",
    "LinearProgressProps",
    "nextButton",
    "position",
    "steps",
    "variant",
    "slots",
    "slotProps"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    activeStep,
    position: position2,
    variant
  });
  let value;
  if (variant === "progress") {
    if (steps === 1) {
      value = 100;
    } else {
      value = Math.ceil(activeStep / (steps - 1) * 100);
    }
  }
  const classes = useUtilityClasses$s(ownerState);
  const externalForwardedProps = {
    slots,
    slotProps: __spreadValues({
      progress: LinearProgressProps
    }, slotProps)
  };
  const [RootSlot, rootSlotProps] = useSlot("root", {
    ref,
    elementType: MobileStepperRoot,
    shouldForwardComponentProp: true,
    className: clsx(classes.root, className),
    externalForwardedProps: __spreadValues(__spreadValues({}, externalForwardedProps), other),
    ownerState,
    additionalProps: {
      square: true,
      elevation: 0
    }
  });
  const [DotsSlot, dotsSlotProps] = useSlot("dots", {
    className: classes.dots,
    elementType: MobileStepperDots,
    externalForwardedProps,
    ownerState
  });
  const [DotSlot, dotSlotProps] = useSlot("dot", {
    elementType: MobileStepperDot,
    externalForwardedProps,
    ownerState
  });
  const [ProgressSlot, progressSlotProps] = useSlot("progress", {
    className: classes.progress,
    elementType: MobileStepperProgress,
    shouldForwardComponentProp: true,
    externalForwardedProps,
    ownerState,
    additionalProps: {
      value,
      variant: "determinate"
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, __spreadProps(__spreadValues({}, rootSlotProps), {
    children: [backButton, variant === "text" && /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [activeStep + 1, " / ", steps]
    }), variant === "dots" && /* @__PURE__ */ jsxRuntimeExports.jsx(DotsSlot, __spreadProps(__spreadValues({}, dotsSlotProps), {
      children: [...new Array(steps)].map((_, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(DotSlot, __spreadProps(__spreadValues({}, dotSlotProps), {
        className: clsx(classes.dot, dotSlotProps.className, index2 === activeStep && classes.dotActive),
        dotActive: index2 === activeStep
      }), index2))
    })), variant === "progress" && /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressSlot, __spreadValues({}, progressSlotProps)), nextButton]
  }));
});
function getNativeSelectUtilityClasses(slot) {
  return generateUtilityClass("MuiNativeSelect", slot);
}
const nativeSelectClasses = generateUtilityClasses("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
const useUtilityClasses$r = (ownerState) => {
  const {
    classes,
    variant,
    disabled,
    multiple,
    open,
    error: error2
  } = ownerState;
  const slots = {
    select: ["select", variant, disabled && "disabled", multiple && "multiple", error2 && "error"],
    icon: ["icon", `icon${capitalize(variant)}`, open && "iconOpen", disabled && "disabled"]
  };
  return composeClasses(slots, getNativeSelectUtilityClasses, classes);
};
const StyledSelectSelect = styled("select", {
  name: "MuiNativeSelect"
})(({
  theme: theme2
}) => ({
  // Reset
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // When interacting quickly, the text can end up selected.
  // Native select can't be selected either.
  userSelect: "none",
  // Reset
  borderRadius: 0,
  cursor: "pointer",
  "&:focus": {
    // Reset Chrome style
    borderRadius: 0
  },
  [`&.${nativeSelectClasses.disabled}`]: {
    cursor: "default"
  },
  "&[multiple]": {
    height: "auto"
  },
  "&:not([multiple]) option, &:not([multiple]) optgroup": {
    backgroundColor: (theme2.vars || theme2).palette.background.paper
  },
  variants: [{
    props: ({
      ownerState
    }) => ownerState.variant !== "filled" && ownerState.variant !== "outlined",
    style: {
      // Bump specificity to allow extending custom inputs
      "&&&": {
        paddingRight: 24,
        minWidth: 16
        // So it doesn't collapse.
      }
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      "&&&": {
        paddingRight: 32
      }
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      borderRadius: (theme2.vars || theme2).shape.borderRadius,
      "&:focus": {
        borderRadius: (theme2.vars || theme2).shape.borderRadius
        // Reset the reset for Chrome style
      },
      "&&&": {
        paddingRight: 32
      }
    }
  }]
}));
const NativeSelectSelect = styled(StyledSelectSelect, {
  name: "MuiNativeSelect",
  slot: "Select",
  shouldForwardProp: rootShouldForwardProp,
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.select, styles2[ownerState.variant], ownerState.error && styles2.error, {
      [`&.${nativeSelectClasses.multiple}`]: styles2.multiple
    }];
  }
})({});
const StyledSelectIcon = styled("svg", {
  name: "MuiNativeSelect"
})(({
  theme: theme2
}) => ({
  // We use a position absolute over a flexbox in order to forward the pointer events
  // to the input and to support wrapping tags..
  position: "absolute",
  right: 0,
  // Center vertically, height is 1em
  top: "calc(50% - .5em)",
  // Don't block pointer events on the select under the icon.
  pointerEvents: "none",
  color: (theme2.vars || theme2).palette.action.active,
  [`&.${nativeSelectClasses.disabled}`]: {
    color: (theme2.vars || theme2).palette.action.disabled
  },
  variants: [{
    props: ({
      ownerState
    }) => ownerState.open,
    style: {
      transform: "rotate(180deg)"
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      right: 7
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      right: 7
    }
  }]
}));
const NativeSelectIcon = styled(StyledSelectIcon, {
  name: "MuiNativeSelect",
  slot: "Icon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.icon, ownerState.variant && styles2[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
  }
})({});
const NativeSelectInput = /* @__PURE__ */ reactExports.forwardRef(function NativeSelectInput2(props, ref) {
  const _a2 = props, {
    className,
    disabled,
    error: error2,
    IconComponent,
    inputRef,
    variant = "standard"
  } = _a2, other = __objRest(_a2, [
    "className",
    "disabled",
    "error",
    "IconComponent",
    "inputRef",
    "variant"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    disabled,
    variant,
    error: error2
  });
  const classes = useUtilityClasses$r(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectSelect, __spreadValues({
      ownerState,
      className: clsx(classes.select, className),
      disabled,
      ref: inputRef || ref
    }, other)), props.multiple ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectIcon, {
      as: IconComponent,
      ownerState,
      className: classes.icon
    })]
  });
});
var _span$1;
const NotchedOutlineRoot$1 = styled("fieldset", {
  name: "MuiNotchedOutlined",
  shouldForwardProp: rootShouldForwardProp
})({
  textAlign: "left",
  position: "absolute",
  bottom: 0,
  right: 0,
  top: -5,
  left: 0,
  margin: 0,
  padding: "0 8px",
  pointerEvents: "none",
  borderRadius: "inherit",
  borderStyle: "solid",
  borderWidth: 1,
  overflow: "hidden",
  minWidth: "0%"
});
const NotchedOutlineLegend = styled("legend", {
  name: "MuiNotchedOutlined",
  shouldForwardProp: rootShouldForwardProp
})(memoTheme(({
  theme: theme2
}) => ({
  float: "unset",
  // Fix conflict with bootstrap
  width: "auto",
  // Fix conflict with bootstrap
  overflow: "hidden",
  // Fix Horizontal scroll when label too long
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.withLabel,
    style: {
      padding: 0,
      lineHeight: "11px",
      // sync with `height` in `legend` styles
      transition: theme2.transitions.create("width", {
        duration: 150,
        easing: theme2.transitions.easing.easeOut
      })
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.withLabel,
    style: {
      display: "block",
      // Fix conflict with normalize.css and sanitize.css
      padding: 0,
      height: 11,
      // sync with `lineHeight` in `legend` styles
      fontSize: "0.75em",
      visibility: "hidden",
      maxWidth: 0.01,
      transition: theme2.transitions.create("max-width", {
        duration: 50,
        easing: theme2.transitions.easing.easeOut
      }),
      whiteSpace: "nowrap",
      "& > span": {
        paddingLeft: 5,
        paddingRight: 5,
        display: "inline-block",
        opacity: 0,
        visibility: "visible"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.withLabel && ownerState.notched,
    style: {
      maxWidth: "100%",
      transition: theme2.transitions.create("max-width", {
        duration: 100,
        easing: theme2.transitions.easing.easeOut,
        delay: 50
      })
    }
  }]
})));
function NotchedOutline(props) {
  const _a2 = props, {
    children,
    classes,
    className,
    label,
    notched
  } = _a2, other = __objRest(_a2, [
    "children",
    "classes",
    "className",
    "label",
    "notched"
  ]);
  const withLabel = label != null && label !== "";
  const ownerState = __spreadProps(__spreadValues({}, props), {
    notched,
    withLabel
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineRoot$1, __spreadProps(__spreadValues({
    "aria-hidden": true,
    className,
    ownerState
  }, other), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineLegend, {
      ownerState,
      children: withLabel ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        children: label
      }) : (
        // notranslate needed while Google Translate will not fix zero-width space issue
        _span$1 || (_span$1 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: "notranslate",
          "aria-hidden": true,
          children: ""
        }))
      )
    })
  }));
}
const useUtilityClasses$q = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    notchedOutline: ["notchedOutline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getOutlinedInputUtilityClass, classes);
  return __spreadValues(__spreadValues({}, classes), composedClasses);
};
const OutlinedInputRoot = styled(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiOutlinedInput",
  slot: "Root",
  overridesResolver: rootOverridesResolver
})(memoTheme(({
  theme: theme2
}) => {
  const borderColor2 = theme2.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    position: "relative",
    borderRadius: (theme2.vars || theme2).shape.borderRadius,
    [`&:hover .${outlinedInputClasses.notchedOutline}`]: {
      borderColor: (theme2.vars || theme2).palette.text.primary
    },
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      [`&:hover .${outlinedInputClasses.notchedOutline}`]: {
        borderColor: theme2.vars ? theme2.alpha(theme2.vars.palette.common.onBackground, 0.23) : borderColor2
      }
    },
    [`&.${outlinedInputClasses.focused} .${outlinedInputClasses.notchedOutline}`]: {
      borderWidth: 2
    },
    variants: [...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
      props: {
        color: color2
      },
      style: {
        [`&.${outlinedInputClasses.focused} .${outlinedInputClasses.notchedOutline}`]: {
          borderColor: (theme2.vars || theme2).palette[color2].main
        }
      }
    })), {
      props: {},
      // to override the above style
      style: {
        [`&.${outlinedInputClasses.error} .${outlinedInputClasses.notchedOutline}`]: {
          borderColor: (theme2.vars || theme2).palette.error.main
        },
        [`&.${outlinedInputClasses.disabled} .${outlinedInputClasses.notchedOutline}`]: {
          borderColor: (theme2.vars || theme2).palette.action.disabled
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.startAdornment,
      style: {
        paddingLeft: 14
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.endAdornment,
      style: {
        paddingRight: 14
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.multiline,
      style: {
        padding: "16.5px 14px"
      }
    }, {
      props: ({
        ownerState,
        size
      }) => ownerState.multiline && size === "small",
      style: {
        padding: "8.5px 14px"
      }
    }]
  };
}));
const NotchedOutlineRoot = styled(NotchedOutline, {
  name: "MuiOutlinedInput",
  slot: "NotchedOutline"
})(memoTheme(({
  theme: theme2
}) => {
  const borderColor2 = theme2.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    borderColor: theme2.vars ? theme2.alpha(theme2.vars.palette.common.onBackground, 0.23) : borderColor2
  };
}));
const OutlinedInputInput = styled(InputBaseInput, {
  name: "MuiOutlinedInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(memoTheme(({
  theme: theme2
}) => __spreadProps(__spreadValues(__spreadValues({
  padding: "16.5px 14px"
}, !theme2.vars && {
  "&:-webkit-autofill": {
    WebkitBoxShadow: theme2.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
    WebkitTextFillColor: theme2.palette.mode === "light" ? null : "#fff",
    caretColor: theme2.palette.mode === "light" ? null : "#fff",
    borderRadius: "inherit"
  }
}), theme2.vars && {
  "&:-webkit-autofill": {
    borderRadius: "inherit"
  },
  [theme2.getColorSchemeSelector("dark")]: {
    "&:-webkit-autofill": {
      WebkitBoxShadow: "0 0 0 100px #266798 inset",
      WebkitTextFillColor: "#fff",
      caretColor: "#fff"
    }
  }
}), {
  variants: [{
    props: {
      size: "small"
    },
    style: {
      padding: "8.5px 14px"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.multiline,
    style: {
      padding: 0
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.endAdornment,
    style: {
      paddingRight: 0
    }
  }]
})));
const OutlinedInput = /* @__PURE__ */ reactExports.forwardRef(function OutlinedInput2(inProps, ref) {
  var _b, _c, _d, _e;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiOutlinedInput"
  });
  const _a2 = props, {
    components = {},
    fullWidth = false,
    inputComponent = "input",
    label,
    multiline = false,
    notched,
    slots = {},
    slotProps = {},
    type = "text"
  } = _a2, other = __objRest(_a2, [
    "components",
    "fullWidth",
    "inputComponent",
    "label",
    "multiline",
    "notched",
    "slots",
    "slotProps",
    "type"
  ]);
  const classes = useUtilityClasses$q(props);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
  });
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: fcs.color || "primary",
    disabled: fcs.disabled,
    error: fcs.error,
    focused: fcs.focused,
    formControl: muiFormControl,
    fullWidth,
    hiddenLabel: fcs.hiddenLabel,
    multiline,
    size: fcs.size,
    type
  });
  const RootSlot = (_c = (_b = slots.root) != null ? _b : components.Root) != null ? _c : OutlinedInputRoot;
  const InputSlot = (_e = (_d = slots.input) != null ? _d : components.Input) != null ? _e : OutlinedInputInput;
  const [NotchedSlot, notchedProps] = useSlot("notchedOutline", {
    elementType: NotchedOutlineRoot,
    className: classes.notchedOutline,
    shouldForwardComponentProp: true,
    ownerState,
    externalForwardedProps: {
      slots,
      slotProps
    },
    additionalProps: {
      label: label != null && label !== "" && fcs.required ? /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [label, "", "*"]
      }) : label
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase, __spreadProps(__spreadValues({
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    slotProps,
    renderSuffix: (state) => /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedSlot, __spreadProps(__spreadValues({}, notchedProps), {
      notched: typeof notched !== "undefined" ? notched : Boolean(state.startAdornment || state.filled || state.focused)
    })),
    fullWidth,
    inputComponent,
    multiline,
    ref,
    type
  }, other), {
    classes: __spreadProps(__spreadValues({}, classes), {
      notchedOutline: null
    })
  }));
});
OutlinedInput.muiName = "Input";
const visuallyHidden = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  whiteSpace: "nowrap",
  width: "1px"
};
const Star = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"
}));
const StarBorder = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M22 9.24l-7.19-.62L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.63-7.03L22 9.24zM12 15.4l-3.76 2.27 1-4.28-3.32-2.88 4.38-.38L12 6.1l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.4z"
}));
function getRatingUtilityClass(slot) {
  return generateUtilityClass("MuiRating", slot);
}
const ratingClasses = generateUtilityClasses("MuiRating", ["root", "sizeSmall", "sizeMedium", "sizeLarge", "readOnly", "disabled", "focusVisible", "visuallyHidden", "pristine", "label", "labelEmptyValueActive", "icon", "iconEmpty", "iconFilled", "iconHover", "iconFocus", "iconActive", "decimal"]);
function getDecimalPrecision$1(num) {
  const decimalPart = num.toString().split(".")[1];
  return decimalPart ? decimalPart.length : 0;
}
function roundValueToPrecision(value, precision) {
  if (value == null) {
    return value;
  }
  const nearest = Math.round(value / precision) * precision;
  return Number(nearest.toFixed(getDecimalPrecision$1(precision)));
}
const useUtilityClasses$p = (ownerState) => {
  const {
    classes,
    size,
    readOnly,
    disabled,
    emptyValueFocused,
    focusVisible
  } = ownerState;
  const slots = {
    root: ["root", `size${capitalize(size)}`, disabled && "disabled", focusVisible && "focusVisible", readOnly && "readOnly"],
    label: ["label", "pristine"],
    labelEmptyValue: [emptyValueFocused && "labelEmptyValueActive"],
    icon: ["icon"],
    iconEmpty: ["iconEmpty"],
    iconFilled: ["iconFilled"],
    iconHover: ["iconHover"],
    iconFocus: ["iconFocus"],
    iconActive: ["iconActive"],
    decimal: ["decimal"],
    visuallyHidden: ["visuallyHidden"]
  };
  return composeClasses(slots, getRatingUtilityClass, classes);
};
const RatingRoot = styled("span", {
  name: "MuiRating",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${ratingClasses.visuallyHidden}`]: styles2.visuallyHidden
    }, styles2.root, styles2[`size${capitalize(ownerState.size)}`], ownerState.readOnly && styles2.readOnly];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  display: "inline-flex",
  // Required to position the pristine input absolutely
  position: "relative",
  fontSize: theme2.typography.pxToRem(24),
  color: "#faaf00",
  cursor: "pointer",
  textAlign: "left",
  width: "min-content",
  WebkitTapHighlightColor: "transparent",
  [`&.${ratingClasses.disabled}`]: {
    opacity: (theme2.vars || theme2).palette.action.disabledOpacity,
    pointerEvents: "none"
  },
  [`&.${ratingClasses.focusVisible} .${ratingClasses.iconActive}`]: {
    outline: "1px solid #999"
  },
  [`& .${ratingClasses.visuallyHidden}`]: visuallyHidden,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      fontSize: theme2.typography.pxToRem(18)
    }
  }, {
    props: {
      size: "large"
    },
    style: {
      fontSize: theme2.typography.pxToRem(30)
    }
  }, {
    // TODO v6: use the .Mui-readOnly global state class
    props: ({
      ownerState
    }) => ownerState.readOnly,
    style: {
      pointerEvents: "none"
    }
  }]
})));
const RatingLabel = styled("label", {
  name: "MuiRating",
  slot: "Label",
  overridesResolver: ({
    ownerState
  }, styles2) => [styles2.label, ownerState.emptyValueFocused && styles2.labelEmptyValueActive]
})({
  cursor: "inherit",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.emptyValueFocused,
    style: {
      top: 0,
      bottom: 0,
      position: "absolute",
      outline: "1px solid #999",
      width: "100%"
    }
  }]
});
const RatingIcon = styled("span", {
  name: "MuiRating",
  slot: "Icon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.icon, ownerState.iconEmpty && styles2.iconEmpty, ownerState.iconFilled && styles2.iconFilled, ownerState.iconHover && styles2.iconHover, ownerState.iconFocus && styles2.iconFocus, ownerState.iconActive && styles2.iconActive];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  // Fit wrapper to actual icon size.
  display: "flex",
  transition: theme2.transitions.create("transform", {
    duration: theme2.transitions.duration.shortest
  }),
  // Fix mouseLeave issue.
  // https://github.com/facebook/react/issues/4492
  pointerEvents: "none",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.iconActive,
    style: {
      transform: "scale(1.2)"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.iconEmpty,
    style: {
      color: (theme2.vars || theme2).palette.action.disabled
    }
  }]
})));
const RatingDecimal = styled("span", {
  name: "MuiRating",
  slot: "Decimal",
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "iconActive",
  overridesResolver: (props, styles2) => {
    const {
      iconActive
    } = props;
    return [styles2.decimal, iconActive && styles2.iconActive];
  }
})({
  position: "relative",
  variants: [{
    props: ({
      iconActive
    }) => iconActive,
    style: {
      transform: "scale(1.2)"
    }
  }]
});
function IconContainer(props) {
  const _a2 = props, {
    value
  } = _a2, other = __objRest(_a2, [
    "value"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", __spreadValues({}, other));
}
function RatingItem(props) {
  const {
    classes,
    disabled,
    emptyIcon,
    focus,
    getLabelText,
    highlightSelectedOnly,
    hover,
    icon,
    IconContainerComponent,
    isActive,
    itemValue,
    labelProps,
    name: name2,
    onBlur,
    onChange,
    onClick,
    onFocus,
    readOnly,
    ownerState,
    ratingValue,
    ratingValueRounded,
    slots = {},
    slotProps = {}
  } = props;
  const isFilled2 = highlightSelectedOnly ? itemValue === ratingValue : itemValue <= ratingValue;
  const isHovered = itemValue <= hover;
  const isFocused = itemValue <= focus;
  const isChecked = itemValue === ratingValueRounded;
  const id = `${name2}-${useId()}`;
  const externalForwardedProps = {
    slots,
    slotProps
  };
  const [IconSlot, iconSlotProps] = useSlot("icon", {
    elementType: RatingIcon,
    className: clsx(classes.icon, isFilled2 ? classes.iconFilled : classes.iconEmpty, isHovered && classes.iconHover, isFocused && classes.iconFocus, isActive && classes.iconActive),
    externalForwardedProps,
    ownerState: __spreadProps(__spreadValues({}, ownerState), {
      iconEmpty: !isFilled2,
      iconFilled: isFilled2,
      iconHover: isHovered,
      iconFocus: isFocused,
      iconActive: isActive
    }),
    additionalProps: {
      value: itemValue
    },
    internalForwardedProps: {
      // TODO: remove this in v7 because `IconContainerComponent` is deprecated
      // only forward if `slots.icon` is NOT provided
      as: IconContainerComponent
    }
  });
  const [LabelSlot, labelSlotProps] = useSlot("label", {
    elementType: RatingLabel,
    externalForwardedProps,
    ownerState: __spreadProps(__spreadValues({}, ownerState), {
      emptyValueFocused: void 0
    }),
    additionalProps: {
      style: labelProps == null ? void 0 : labelProps.style,
      htmlFor: id
    }
  });
  const container = /* @__PURE__ */ jsxRuntimeExports.jsx(IconSlot, __spreadProps(__spreadValues({}, iconSlotProps), {
    children: emptyIcon && !isFilled2 ? emptyIcon : icon
  }));
  if (readOnly) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("span", __spreadProps(__spreadValues({}, labelProps), {
      children: container
    }));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(LabelSlot, __spreadProps(__spreadValues({}, labelSlotProps), {
      children: [container, /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: classes.visuallyHidden,
        children: getLabelText(itemValue)
      })]
    })), /* @__PURE__ */ jsxRuntimeExports.jsx("input", {
      className: classes.visuallyHidden,
      onFocus,
      onBlur,
      onChange,
      onClick,
      disabled,
      value: itemValue,
      id,
      type: "radio",
      name: name2,
      checked: isChecked
    })]
  });
}
const defaultIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(Star, {
  fontSize: "inherit"
});
const defaultEmptyIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(StarBorder, {
  fontSize: "inherit"
});
function defaultLabelText(value) {
  return `${value || "0"} Star${value !== 1 ? "s" : ""}`;
}
const Rating = /* @__PURE__ */ reactExports.forwardRef(function Rating2(inProps, ref) {
  const props = useDefaultProps({
    name: "MuiRating",
    props: inProps
  });
  const _a2 = props, {
    component = "span",
    className,
    defaultValue = null,
    disabled = false,
    emptyIcon = defaultEmptyIcon,
    emptyLabelText = "Empty",
    getLabelText = defaultLabelText,
    highlightSelectedOnly = false,
    icon = defaultIcon,
    IconContainerComponent = IconContainer,
    max: max2 = 5,
    name: nameProp,
    onChange,
    onChangeActive,
    onMouseLeave,
    onMouseMove,
    precision = 1,
    readOnly = false,
    size = "medium",
    value: valueProp,
    slots = {},
    slotProps = {}
  } = _a2, other = __objRest(_a2, [
    "component",
    "className",
    "defaultValue",
    "disabled",
    "emptyIcon",
    "emptyLabelText",
    "getLabelText",
    "highlightSelectedOnly",
    "icon",
    "IconContainerComponent",
    "max",
    "name",
    "onChange",
    "onChangeActive",
    "onMouseLeave",
    "onMouseMove",
    "precision",
    "readOnly",
    "size",
    "value",
    "slots",
    "slotProps"
  ]);
  const name2 = useId(nameProp);
  const [valueDerived, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: "Rating"
  });
  const valueRounded = roundValueToPrecision(valueDerived, precision);
  const isRtl = useRtl();
  const [{
    hover,
    focus
  }, setState] = reactExports.useState({
    hover: -1,
    focus: -1
  });
  let value = valueRounded;
  if (hover !== -1) {
    value = hover;
  }
  if (focus !== -1) {
    value = focus;
  }
  const [focusVisible, setFocusVisible] = reactExports.useState(false);
  const rootRef = reactExports.useRef();
  const handleRef = useForkRef(rootRef, ref);
  const handleMouseMove = (event) => {
    if (onMouseMove) {
      onMouseMove(event);
    }
    const rootNode = rootRef.current;
    const {
      right: right2,
      left: left2,
      width: containerWidth
    } = rootNode.getBoundingClientRect();
    let percent;
    if (isRtl) {
      percent = (right2 - event.clientX) / containerWidth;
    } else {
      percent = (event.clientX - left2) / containerWidth;
    }
    let newHover = roundValueToPrecision(max2 * percent + precision / 2, precision);
    newHover = clamp(newHover, precision, max2);
    setState((prev2) => prev2.hover === newHover && prev2.focus === newHover ? prev2 : {
      hover: newHover,
      focus: newHover
    });
    setFocusVisible(false);
    if (onChangeActive && hover !== newHover) {
      onChangeActive(event, newHover);
    }
  };
  const handleMouseLeave = (event) => {
    if (onMouseLeave) {
      onMouseLeave(event);
    }
    const newHover = -1;
    setState({
      hover: newHover,
      focus: newHover
    });
    if (onChangeActive && hover !== newHover) {
      onChangeActive(event, newHover);
    }
  };
  const handleChange = (event) => {
    let newValue = event.target.value === "" ? null : parseFloat(event.target.value);
    if (hover !== -1) {
      newValue = hover;
    }
    setValueState(newValue);
    if (onChange) {
      onChange(event, newValue);
    }
  };
  const handleClear = (event) => {
    if (event.clientX === 0 && event.clientY === 0) {
      return;
    }
    setState({
      hover: -1,
      focus: -1
    });
    setValueState(null);
    if (onChange && parseFloat(event.target.value) === valueRounded) {
      onChange(event, null);
    }
  };
  const handleFocus = (event) => {
    if (isFocusVisible(event.target)) {
      setFocusVisible(true);
    }
    const newFocus = parseFloat(event.target.value);
    setState((prev2) => ({
      hover: prev2.hover,
      focus: newFocus
    }));
  };
  const handleBlur = (event) => {
    if (hover !== -1) {
      return;
    }
    if (!isFocusVisible(event.target)) {
      setFocusVisible(false);
    }
    const newFocus = -1;
    setState((prev2) => ({
      hover: prev2.hover,
      focus: newFocus
    }));
  };
  const [emptyValueFocused, setEmptyValueFocused] = reactExports.useState(false);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component,
    defaultValue,
    disabled,
    emptyIcon,
    emptyLabelText,
    emptyValueFocused,
    focusVisible,
    getLabelText,
    icon,
    IconContainerComponent,
    max: max2,
    precision,
    readOnly,
    size
  });
  const classes = useUtilityClasses$p(ownerState);
  const externalForwardedProps = {
    slots,
    slotProps
  };
  const [RootSlot, rootSlotProps] = useSlot("root", {
    ref: handleRef,
    className: clsx(classes.root, className),
    elementType: RatingRoot,
    externalForwardedProps: __spreadProps(__spreadValues(__spreadValues({}, externalForwardedProps), other), {
      component
    }),
    getSlotProps: (handlers) => __spreadProps(__spreadValues({}, handlers), {
      onMouseMove: (event) => {
        var _a3;
        handleMouseMove(event);
        (_a3 = handlers.onMouseMove) == null ? void 0 : _a3.call(handlers, event);
      },
      onMouseLeave: (event) => {
        var _a3;
        handleMouseLeave(event);
        (_a3 = handlers.onMouseLeave) == null ? void 0 : _a3.call(handlers, event);
      }
    }),
    ownerState,
    additionalProps: {
      role: readOnly ? "img" : null,
      "aria-label": readOnly ? getLabelText(value) : null
    }
  });
  const [LabelSlot, labelSlotProps] = useSlot("label", {
    className: clsx(classes.label, classes.labelEmptyValue),
    elementType: RatingLabel,
    externalForwardedProps,
    ownerState
  });
  const [DecimalSlot, decimalSlotProps] = useSlot("decimal", {
    className: classes.decimal,
    elementType: RatingDecimal,
    externalForwardedProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, __spreadProps(__spreadValues({}, rootSlotProps), {
    children: [Array.from(new Array(max2)).map((_, index2) => {
      const itemValue = index2 + 1;
      const ratingItemProps = {
        classes,
        disabled,
        emptyIcon,
        focus,
        getLabelText,
        highlightSelectedOnly,
        hover,
        icon,
        IconContainerComponent,
        name: name2,
        onBlur: handleBlur,
        onChange: handleChange,
        onClick: handleClear,
        onFocus: handleFocus,
        ratingValue: value,
        ratingValueRounded: valueRounded,
        readOnly,
        ownerState,
        slots,
        slotProps
      };
      const isActive = itemValue === Math.ceil(value) && (hover !== -1 || focus !== -1);
      if (precision < 1) {
        const items = Array.from(new Array(1 / precision));
        return /* @__PURE__ */ reactExports.createElement(DecimalSlot, __spreadProps(__spreadValues({}, decimalSlotProps), {
          key: itemValue,
          className: clsx(decimalSlotProps.className, isActive && classes.iconActive),
          iconActive: isActive
        }), items.map(($, indexDecimal) => {
          const itemDecimalValue = roundValueToPrecision(itemValue - 1 + (indexDecimal + 1) * precision, precision);
          return /* @__PURE__ */ jsxRuntimeExports.jsx(RatingItem, __spreadProps(__spreadValues({}, ratingItemProps), {
            // The icon is already displayed as active
            isActive: false,
            itemValue: itemDecimalValue,
            labelProps: {
              style: items.length - 1 === indexDecimal ? {} : {
                width: itemDecimalValue === value ? `${(indexDecimal + 1) * precision * 100}%` : "0%",
                overflow: "hidden",
                position: "absolute"
              }
            }
          }), itemDecimalValue);
        }));
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(RatingItem, __spreadProps(__spreadValues({}, ratingItemProps), {
        isActive,
        itemValue
      }), itemValue);
    }), !readOnly && !disabled && /* @__PURE__ */ jsxRuntimeExports.jsxs(LabelSlot, __spreadProps(__spreadValues({}, labelSlotProps), {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx("input", {
        className: classes.visuallyHidden,
        value: "",
        id: `${name2}-empty`,
        type: "radio",
        name: name2,
        checked: valueRounded == null,
        onFocus: () => setEmptyValueFocused(true),
        onBlur: () => setEmptyValueFocused(false),
        onChange: handleChange
      }), /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: classes.visuallyHidden,
        children: emptyLabelText
      })]
    }))]
  }));
});
function getSelectUtilityClasses(slot) {
  return generateUtilityClass("MuiSelect", slot);
}
const selectClasses = generateUtilityClasses("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
var _span;
const SelectSelect = styled(StyledSelectSelect, {
  name: "MuiSelect",
  slot: "Select",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [
      // Win specificity over the input base
      {
        [`&.${selectClasses.select}`]: styles2.select
      },
      {
        [`&.${selectClasses.select}`]: styles2[ownerState.variant]
      },
      {
        [`&.${selectClasses.error}`]: styles2.error
      },
      {
        [`&.${selectClasses.multiple}`]: styles2.multiple
      }
    ];
  }
})({
  // Win specificity over the input base
  [`&.${selectClasses.select}`]: {
    height: "auto",
    // Resets for multiple select with chips
    minHeight: "1.4375em",
    // Required for select\text-field height consistency
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden"
  }
});
const SelectIcon = styled(StyledSelectIcon, {
  name: "MuiSelect",
  slot: "Icon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.icon, ownerState.variant && styles2[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
  }
})({});
const SelectNativeInput = styled("input", {
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "classes",
  name: "MuiSelect",
  slot: "NativeInput"
})({
  bottom: 0,
  left: 0,
  position: "absolute",
  opacity: 0,
  pointerEvents: "none",
  width: "100%",
  boxSizing: "border-box"
});
function areEqualValues(a, b) {
  if (typeof b === "object" && b !== null) {
    return a === b;
  }
  return String(a) === String(b);
}
function isEmpty(display) {
  return display == null || typeof display === "string" && !display.trim();
}
const useUtilityClasses$o = (ownerState) => {
  const {
    classes,
    variant,
    disabled,
    multiple,
    open,
    error: error2
  } = ownerState;
  const slots = {
    select: ["select", variant, disabled && "disabled", multiple && "multiple", error2 && "error"],
    icon: ["icon", `icon${capitalize(variant)}`, open && "iconOpen", disabled && "disabled"],
    nativeInput: ["nativeInput"]
  };
  return composeClasses(slots, getSelectUtilityClasses, classes);
};
const SelectInput = /* @__PURE__ */ reactExports.forwardRef(function SelectInput2(props, ref) {
  var _b, _c, _d, _e;
  const _a2 = props, {
    "aria-describedby": ariaDescribedby,
    "aria-label": ariaLabel,
    autoFocus,
    autoWidth,
    children,
    className,
    defaultOpen,
    defaultValue,
    disabled,
    displayEmpty,
    error: error2 = false,
    IconComponent,
    inputRef: inputRefProp,
    labelId,
    MenuProps = {},
    multiple,
    name: name2,
    onBlur,
    onChange,
    onClose,
    onFocus,
    onOpen,
    open: openProp,
    readOnly,
    renderValue,
    required,
    SelectDisplayProps = {},
    tabIndex: tabIndexProp,
    type: type,
    value: valueProp,
    variant = "standard"
  } = _a2, other = __objRest(_a2, [
    "aria-describedby",
    "aria-label",
    "autoFocus",
    "autoWidth",
    "children",
    "className",
    "defaultOpen",
    "defaultValue",
    "disabled",
    "displayEmpty",
    "error",
    "IconComponent",
    "inputRef",
    "labelId",
    "MenuProps",
    "multiple",
    "name",
    "onBlur",
    "onChange",
    "onClose",
    "onFocus",
    "onOpen",
    "open",
    "readOnly",
    "renderValue",
    "required",
    "SelectDisplayProps",
    "tabIndex",
    // catching `type` from Input which makes no sense for SelectInput
    "type",
    "value",
    "variant"
  ]);
  const [value, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: "Select"
  });
  const [openState, setOpenState] = useControlled({
    controlled: openProp,
    default: defaultOpen,
    name: "Select"
  });
  const inputRef = reactExports.useRef(null);
  const displayRef = reactExports.useRef(null);
  const [displayNode, setDisplayNode] = reactExports.useState(null);
  const {
    current: isOpenControlled
  } = reactExports.useRef(openProp != null);
  const [menuMinWidthState, setMenuMinWidthState] = reactExports.useState();
  const handleRef = useForkRef(ref, inputRefProp);
  const handleDisplayRef = reactExports.useCallback((node2) => {
    displayRef.current = node2;
    if (node2) {
      setDisplayNode(node2);
    }
  }, []);
  const anchorElement = displayNode == null ? void 0 : displayNode.parentNode;
  reactExports.useImperativeHandle(handleRef, () => ({
    focus: () => {
      displayRef.current.focus();
    },
    node: inputRef.current,
    value
  }), [value]);
  reactExports.useEffect(() => {
    if (defaultOpen && openState && displayNode && !isOpenControlled) {
      setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
      displayRef.current.focus();
    }
  }, [displayNode, autoWidth]);
  reactExports.useEffect(() => {
    if (autoFocus) {
      displayRef.current.focus();
    }
  }, [autoFocus]);
  reactExports.useEffect(() => {
    if (!labelId) {
      return void 0;
    }
    const label = ownerDocument(displayRef.current).getElementById(labelId);
    if (label) {
      const handler = () => {
        if (getSelection().isCollapsed) {
          displayRef.current.focus();
        }
      };
      label.addEventListener("click", handler);
      return () => {
        label.removeEventListener("click", handler);
      };
    }
    return void 0;
  }, [labelId]);
  const update = (open2, event) => {
    if (open2) {
      if (onOpen) {
        onOpen(event);
      }
    } else if (onClose) {
      onClose(event);
    }
    if (!isOpenControlled) {
      setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
      setOpenState(open2);
    }
  };
  const handleMouseDown = (event) => {
    if (event.button !== 0) {
      return;
    }
    event.preventDefault();
    displayRef.current.focus();
    update(true, event);
  };
  const handleClose = (event) => {
    update(false, event);
  };
  const childrenArray = reactExports.Children.toArray(children);
  const handleChange = (event) => {
    const child = childrenArray.find((childItem) => childItem.props.value === event.target.value);
    if (child === void 0) {
      return;
    }
    setValueState(child.props.value);
    if (onChange) {
      onChange(event, child);
    }
  };
  const handleItemClick = (child) => (event) => {
    let newValue;
    if (!event.currentTarget.hasAttribute("tabindex")) {
      return;
    }
    if (multiple) {
      newValue = Array.isArray(value) ? value.slice() : [];
      const itemIndex = value.indexOf(child.props.value);
      if (itemIndex === -1) {
        newValue.push(child.props.value);
      } else {
        newValue.splice(itemIndex, 1);
      }
    } else {
      newValue = child.props.value;
    }
    if (child.props.onClick) {
      child.props.onClick(event);
    }
    if (value !== newValue) {
      setValueState(newValue);
      if (onChange) {
        const nativeEvent = event.nativeEvent || event;
        const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
        Object.defineProperty(clonedEvent, "target", {
          writable: true,
          value: {
            value: newValue,
            name: name2
          }
        });
        onChange(clonedEvent, child);
      }
    }
    if (!multiple) {
      update(false, event);
    }
  };
  const handleKeyDown = (event) => {
    if (!readOnly) {
      const validKeys = [
        " ",
        "ArrowUp",
        "ArrowDown",
        // The native select doesn't respond to enter on macOS, but it's recommended by
        // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
        "Enter"
      ];
      if (validKeys.includes(event.key)) {
        event.preventDefault();
        update(true, event);
      }
    }
  };
  const open = displayNode !== null && openState;
  const handleBlur = (event) => {
    if (!open && onBlur) {
      Object.defineProperty(event, "target", {
        writable: true,
        value: {
          value,
          name: name2
        }
      });
      onBlur(event);
    }
  };
  delete other["aria-invalid"];
  let display;
  let displaySingle;
  const displayMultiple = [];
  let computeDisplay = false;
  if (isFilled({
    value
  }) || displayEmpty) {
    if (renderValue) {
      display = renderValue(value);
    } else {
      computeDisplay = true;
    }
  }
  const items = childrenArray.map((child) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      return null;
    }
    let selected;
    if (multiple) {
      if (!Array.isArray(value)) {
        throw new Error(formatMuiErrorMessage(2));
      }
      selected = value.some((v) => areEqualValues(v, child.props.value));
      if (selected && computeDisplay) {
        displayMultiple.push(child.props.children);
      }
    } else {
      selected = areEqualValues(value, child.props.value);
      if (selected && computeDisplay) {
        displaySingle = child.props.children;
      }
    }
    return /* @__PURE__ */ reactExports.cloneElement(child, {
      "aria-selected": selected ? "true" : "false",
      onClick: handleItemClick(child),
      onKeyUp: (event) => {
        if (event.key === " ") {
          event.preventDefault();
        }
        if (child.props.onKeyUp) {
          child.props.onKeyUp(event);
        }
      },
      role: "option",
      selected,
      value: void 0,
      // The value is most likely not a valid HTML attribute.
      "data-value": child.props.value
      // Instead, we provide it as a data attribute.
    });
  });
  if (computeDisplay) {
    if (multiple) {
      if (displayMultiple.length === 0) {
        display = null;
      } else {
        display = displayMultiple.reduce((output, child, index2) => {
          output.push(child);
          if (index2 < displayMultiple.length - 1) {
            output.push(", ");
          }
          return output;
        }, []);
      }
    } else {
      display = displaySingle;
    }
  }
  let menuMinWidth = menuMinWidthState;
  if (!autoWidth && isOpenControlled && displayNode) {
    menuMinWidth = anchorElement.clientWidth;
  }
  let tabIndex;
  if (typeof tabIndexProp !== "undefined") {
    tabIndex = tabIndexProp;
  } else {
    tabIndex = disabled ? null : 0;
  }
  const buttonId = SelectDisplayProps.id || (name2 ? `mui-component-select-${name2}` : void 0);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    variant,
    value,
    open,
    error: error2
  });
  const classes = useUtilityClasses$o(ownerState);
  const paperProps = __spreadValues(__spreadValues({}, MenuProps.PaperProps), typeof ((_b = MenuProps.slotProps) == null ? void 0 : _b.paper) === "function" ? MenuProps.slotProps.paper(ownerState) : (_c = MenuProps.slotProps) == null ? void 0 : _c.paper);
  const listProps = __spreadValues(__spreadValues({}, MenuProps.MenuListProps), typeof ((_d = MenuProps.slotProps) == null ? void 0 : _d.list) === "function" ? MenuProps.slotProps.list(ownerState) : (_e = MenuProps.slotProps) == null ? void 0 : _e.list);
  const listboxId = useId();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SelectSelect, __spreadProps(__spreadValues({
      as: "div",
      ref: handleDisplayRef,
      tabIndex,
      role: "combobox",
      "aria-controls": open ? listboxId : void 0,
      "aria-disabled": disabled ? "true" : void 0,
      "aria-expanded": open ? "true" : "false",
      "aria-haspopup": "listbox",
      "aria-label": ariaLabel,
      "aria-labelledby": [labelId, buttonId].filter(Boolean).join(" ") || void 0,
      "aria-describedby": ariaDescribedby,
      "aria-required": required ? "true" : void 0,
      "aria-invalid": error2 ? "true" : void 0,
      onKeyDown: handleKeyDown,
      onMouseDown: disabled || readOnly ? null : handleMouseDown,
      onBlur: handleBlur,
      onFocus
    }, SelectDisplayProps), {
      ownerState,
      className: clsx(SelectDisplayProps.className, classes.select, className),
      id: buttonId,
      children: isEmpty(display) ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        _span || (_span = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: "notranslate",
          "aria-hidden": true,
          children: ""
        }))
      ) : display
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectNativeInput, __spreadProps(__spreadValues({
      "aria-invalid": error2,
      value: Array.isArray(value) ? value.join(",") : value,
      name: name2,
      ref: inputRef,
      "aria-hidden": true,
      onChange: handleChange,
      tabIndex: -1,
      disabled,
      className: classes.nativeInput,
      autoFocus,
      required
    }, other), {
      ownerState
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectIcon, {
      as: IconComponent,
      className: classes.icon,
      ownerState
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(Menu, __spreadProps(__spreadValues({
      id: `menu-${name2 || ""}`,
      anchorEl: anchorElement,
      open,
      onClose: handleClose,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "center"
      }
    }, MenuProps), {
      slotProps: __spreadProps(__spreadValues({}, MenuProps.slotProps), {
        list: __spreadValues({
          "aria-labelledby": labelId,
          role: "listbox",
          "aria-multiselectable": multiple ? "true" : void 0,
          disableListWrap: true,
          id: listboxId
        }, listProps),
        paper: __spreadProps(__spreadValues({}, paperProps), {
          style: __spreadValues({
            minWidth: menuMinWidth
          }, paperProps != null ? paperProps.style : null)
        })
      }),
      children: items
    }))]
  });
});
const useUtilityClasses$n = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  const composedClasses = composeClasses(slots, getSelectUtilityClasses, classes);
  return __spreadValues(__spreadValues({}, classes), composedClasses);
};
const styledRootConfig = {
  name: "MuiSelect",
  slot: "Root",
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) && prop !== "variant"
};
const StyledInput = styled(Input, styledRootConfig)("");
const StyledOutlinedInput = styled(OutlinedInput, styledRootConfig)("");
const StyledFilledInput = styled(FilledInput, styledRootConfig)("");
const Select = /* @__PURE__ */ reactExports.forwardRef(function Select2(inProps, ref) {
  const props = useDefaultProps({
    name: "MuiSelect",
    props: inProps
  });
  const _a2 = props, {
    autoWidth = false,
    children,
    classes: classesProp = {},
    className,
    defaultOpen = false,
    displayEmpty = false,
    IconComponent = ArrowDropDownIcon,
    id,
    input,
    inputProps,
    label,
    labelId,
    MenuProps,
    multiple = false,
    native = false,
    onClose,
    onOpen,
    open,
    renderValue,
    SelectDisplayProps,
    variant: variantProp = "outlined"
  } = _a2, other = __objRest(_a2, [
    "autoWidth",
    "children",
    "classes",
    "className",
    "defaultOpen",
    "displayEmpty",
    "IconComponent",
    "id",
    "input",
    "inputProps",
    "label",
    "labelId",
    "MenuProps",
    "multiple",
    "native",
    "onClose",
    "onOpen",
    "open",
    "renderValue",
    "SelectDisplayProps",
    "variant"
  ]);
  const inputComponent = native ? NativeSelectInput : SelectInput;
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["variant", "error"]
  });
  const variant = fcs.variant || variantProp;
  const ownerState = __spreadProps(__spreadValues({}, props), {
    variant,
    classes: classesProp
  });
  const classes = useUtilityClasses$n(ownerState);
  const _b = classes, {
    root
  } = _b, restOfClasses = __objRest(_b, [
    "root"
  ]);
  const InputComponent = input || {
    standard: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledInput, {
      ownerState
    }),
    outlined: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledOutlinedInput, {
      label,
      ownerState
    }),
    filled: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledFilledInput, {
      ownerState
    })
  }[variant];
  const inputComponentRef = useForkRef(ref, getReactElementRef(InputComponent));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
    children: /* @__PURE__ */ reactExports.cloneElement(InputComponent, __spreadValues(__spreadValues(__spreadProps(__spreadValues({
      // Most of the logic is implemented in `SelectInput`.
      // The `Select` component is a simple API wrapper to expose something better to play with.
      inputComponent,
      inputProps: __spreadValues(__spreadProps(__spreadValues(__spreadValues({
        children,
        error: fcs.error,
        IconComponent,
        variant,
        type: void 0,
        // We render a select. We can ignore the type provided by the `Input`.
        multiple
      }, native ? {
        id
      } : {
        autoWidth,
        defaultOpen,
        displayEmpty,
        labelId,
        MenuProps,
        onClose,
        onOpen,
        open,
        renderValue,
        SelectDisplayProps: __spreadValues({
          id
        }, SelectDisplayProps)
      }), inputProps), {
        classes: inputProps ? deepmerge(restOfClasses, inputProps.classes) : restOfClasses
      }), input ? input.props.inputProps : {})
    }, (multiple && native || displayEmpty) && variant === "outlined" ? {
      notched: true
    } : {}), {
      ref: inputComponentRef,
      className: clsx(InputComponent.props.className, className, classes.root)
    }), !input && {
      variant
    }), other))
  });
});
Select.muiName = "Select";
function getSkeletonUtilityClass(slot) {
  return generateUtilityClass("MuiSkeleton", slot);
}
generateUtilityClasses("MuiSkeleton", ["root", "text", "rectangular", "rounded", "circular", "pulse", "wave", "withChildren", "fitContent", "heightAuto"]);
const useUtilityClasses$m = (ownerState) => {
  const {
    classes,
    variant,
    animation,
    hasChildren,
    width: width2,
    height: height2
  } = ownerState;
  const slots = {
    root: ["root", variant, animation, hasChildren && "withChildren", hasChildren && !width2 && "fitContent", hasChildren && !height2 && "heightAuto"]
  };
  return composeClasses(slots, getSkeletonUtilityClass, classes);
};
const pulseKeyframe = keyframes`
  0% {
    opacity: 1;
  }

  50% {
    opacity: 0.4;
  }

  100% {
    opacity: 1;
  }
`;
const waveKeyframe = keyframes`
  0% {
    transform: translateX(-100%);
  }

  50% {
    /* +0.5s of delay between each loop */
    transform: translateX(100%);
  }

  100% {
    transform: translateX(100%);
  }
`;
const pulseAnimation = typeof pulseKeyframe !== "string" ? css`
        animation: ${pulseKeyframe} 2s ease-in-out 0.5s infinite;
      ` : null;
const waveAnimation = typeof waveKeyframe !== "string" ? css`
        &::after {
          animation: ${waveKeyframe} 2s linear 0.5s infinite;
        }
      ` : null;
const SkeletonRoot = styled("span", {
  name: "MuiSkeleton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], ownerState.animation !== false && styles2[ownerState.animation], ownerState.hasChildren && styles2.withChildren, ownerState.hasChildren && !ownerState.width && styles2.fitContent, ownerState.hasChildren && !ownerState.height && styles2.heightAuto];
  }
})(memoTheme(({
  theme: theme2
}) => {
  const radiusUnit = getUnit(theme2.shape.borderRadius) || "px";
  const radiusValue = toUnitless(theme2.shape.borderRadius);
  return {
    display: "block",
    // Create a "on paper" color with sufficient contrast retaining the color
    backgroundColor: theme2.vars ? theme2.vars.palette.Skeleton.bg : theme2.alpha(theme2.palette.text.primary, theme2.palette.mode === "light" ? 0.11 : 0.13),
    height: "1.2em",
    variants: [{
      props: {
        variant: "text"
      },
      style: {
        marginTop: 0,
        marginBottom: 0,
        height: "auto",
        transformOrigin: "0 55%",
        transform: "scale(1, 0.60)",
        borderRadius: `${radiusValue}${radiusUnit}/${Math.round(radiusValue / 0.6 * 10) / 10}${radiusUnit}`,
        "&:empty:before": {
          content: '"\\00a0"'
        }
      }
    }, {
      props: {
        variant: "circular"
      },
      style: {
        borderRadius: "50%"
      }
    }, {
      props: {
        variant: "rounded"
      },
      style: {
        borderRadius: (theme2.vars || theme2).shape.borderRadius
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.hasChildren,
      style: {
        "& > *": {
          visibility: "hidden"
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.hasChildren && !ownerState.width,
      style: {
        maxWidth: "fit-content"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.hasChildren && !ownerState.height,
      style: {
        height: "auto"
      }
    }, {
      props: {
        animation: "pulse"
      },
      style: pulseAnimation || {
        animation: `${pulseKeyframe} 2s ease-in-out 0.5s infinite`
      }
    }, {
      props: {
        animation: "wave"
      },
      style: {
        position: "relative",
        overflow: "hidden",
        /* Fix bug in Safari https://bugs.webkit.org/show_bug.cgi?id=68196 */
        WebkitMaskImage: "-webkit-radial-gradient(white, black)",
        "&::after": {
          background: `linear-gradient(
                90deg,
                transparent,
                ${(theme2.vars || theme2).palette.action.hover},
                transparent
              )`,
          content: '""',
          position: "absolute",
          transform: "translateX(-100%)",
          bottom: 0,
          left: 0,
          right: 0,
          top: 0
        }
      }
    }, {
      props: {
        animation: "wave"
      },
      style: waveAnimation || {
        "&::after": {
          animation: `${waveKeyframe} 2s linear 0.5s infinite`
        }
      }
    }]
  };
}));
const Skeleton = /* @__PURE__ */ reactExports.forwardRef(function Skeleton2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSkeleton"
  });
  const _a2 = props, {
    animation = "pulse",
    className,
    component = "span",
    height: height2,
    style: style2,
    variant = "text",
    width: width2
  } = _a2, other = __objRest(_a2, [
    "animation",
    "className",
    "component",
    "height",
    "style",
    "variant",
    "width"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    animation,
    component,
    variant,
    hasChildren: Boolean(other.children)
  });
  const classes = useUtilityClasses$m(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SkeletonRoot, __spreadProps(__spreadValues({
    as: component,
    ref,
    className: clsx(classes.root, className),
    ownerState
  }, other), {
    style: __spreadValues({
      width: width2,
      height: height2
    }, style2)
  }));
});
function areArraysEqual(array1, array2, itemComparer = (a, b) => a === b) {
  return array1.length === array2.length && array1.every((value, index2) => itemComparer(value, array2[index2]));
}
const INTENTIONAL_DRAG_COUNT_THRESHOLD = 2;
function getNewValue(currentValue, step, direction, min2, max2) {
  return direction === 1 ? Math.min(currentValue + step, max2) : Math.max(currentValue - step, min2);
}
function asc(a, b) {
  return a - b;
}
function findClosest(values2, currentValue) {
  var _a2;
  const {
    index: closestIndex
  } = (_a2 = values2.reduce((acc, value, index2) => {
    const distance = Math.abs(currentValue - value);
    if (acc === null || distance < acc.distance || distance === acc.distance) {
      return {
        distance,
        index: index2
      };
    }
    return acc;
  }, null)) != null ? _a2 : {};
  return closestIndex;
}
function trackFinger(event, touchId) {
  if (touchId.current !== void 0 && event.changedTouches) {
    const touchEvent = event;
    for (let i = 0; i < touchEvent.changedTouches.length; i += 1) {
      const touch = touchEvent.changedTouches[i];
      if (touch.identifier === touchId.current) {
        return {
          x: touch.clientX,
          y: touch.clientY
        };
      }
    }
    return false;
  }
  return {
    x: event.clientX,
    y: event.clientY
  };
}
function valueToPercent(value, min2, max2) {
  return (value - min2) * 100 / (max2 - min2);
}
function percentToValue(percent, min2, max2) {
  return (max2 - min2) * percent + min2;
}
function getDecimalPrecision(num) {
  if (Math.abs(num) < 1) {
    const parts = num.toExponential().split("e-");
    const matissaDecimalPart = parts[0].split(".")[1];
    return (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(parts[1], 10);
  }
  const decimalPart = num.toString().split(".")[1];
  return decimalPart ? decimalPart.length : 0;
}
function roundValueToStep(value, step, min2) {
  const nearest = Math.round((value - min2) / step) * step + min2;
  return Number(nearest.toFixed(getDecimalPrecision(step)));
}
function setValueIndex({
  values: values2,
  newValue,
  index: index2
}) {
  const output = values2.slice();
  output[index2] = newValue;
  return output.sort(asc);
}
function focusThumb({
  sliderRef,
  activeIndex,
  setActive
}) {
  var _a2, _b, _c;
  const doc = ownerDocument(sliderRef.current);
  if (!((_a2 = sliderRef.current) == null ? void 0 : _a2.contains(doc.activeElement)) || Number((_b = doc == null ? void 0 : doc.activeElement) == null ? void 0 : _b.getAttribute("data-index")) !== activeIndex) {
    (_c = sliderRef.current) == null ? void 0 : _c.querySelector(`[type="range"][data-index="${activeIndex}"]`).focus();
  }
  if (setActive) {
    setActive(activeIndex);
  }
}
function areValuesEqual(newValue, oldValue) {
  if (typeof newValue === "number" && typeof oldValue === "number") {
    return newValue === oldValue;
  }
  if (typeof newValue === "object" && typeof oldValue === "object") {
    return areArraysEqual(newValue, oldValue);
  }
  return false;
}
const axisProps = {
  horizontal: {
    offset: (percent) => ({
      left: `${percent}%`
    }),
    leap: (percent) => ({
      width: `${percent}%`
    })
  },
  "horizontal-reverse": {
    offset: (percent) => ({
      right: `${percent}%`
    }),
    leap: (percent) => ({
      width: `${percent}%`
    })
  },
  vertical: {
    offset: (percent) => ({
      bottom: `${percent}%`
    }),
    leap: (percent) => ({
      height: `${percent}%`
    })
  }
};
const Identity$1 = (x) => x;
let cachedSupportsTouchActionNone;
function doesSupportTouchActionNone() {
  if (cachedSupportsTouchActionNone === void 0) {
    if (typeof CSS !== "undefined" && typeof CSS.supports === "function") {
      cachedSupportsTouchActionNone = CSS.supports("touch-action", "none");
    } else {
      cachedSupportsTouchActionNone = true;
    }
  }
  return cachedSupportsTouchActionNone;
}
function useSlider(parameters) {
  const {
    "aria-labelledby": ariaLabelledby,
    defaultValue,
    disabled = false,
    disableSwap = false,
    isRtl = false,
    marks: marksProp = false,
    max: max2 = 100,
    min: min2 = 0,
    name: name2,
    onChange,
    onChangeCommitted,
    orientation = "horizontal",
    rootRef: ref,
    scale = Identity$1,
    step = 1,
    shiftStep = 10,
    tabIndex,
    value: valueProp
  } = parameters;
  const touchId = reactExports.useRef(void 0);
  const [active, setActive] = reactExports.useState(-1);
  const [open, setOpen] = reactExports.useState(-1);
  const [dragging, setDragging] = reactExports.useState(false);
  const moveCount = reactExports.useRef(0);
  const lastChangedValue = reactExports.useRef(null);
  const [valueDerived, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue != null ? defaultValue : min2,
    name: "Slider"
  });
  const handleChange = onChange && ((event, value, thumbIndex) => {
    const nativeEvent = event.nativeEvent || event;
    const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
    Object.defineProperty(clonedEvent, "target", {
      writable: true,
      value: {
        value,
        name: name2
      }
    });
    lastChangedValue.current = value;
    onChange(clonedEvent, value, thumbIndex);
  });
  const range = Array.isArray(valueDerived);
  let values2 = range ? valueDerived.slice().sort(asc) : [valueDerived];
  values2 = values2.map((value) => value == null ? min2 : clamp(value, min2, max2));
  const marks = marksProp === true && step !== null ? [...Array(Math.floor((max2 - min2) / step) + 1)].map((_, index2) => ({
    value: min2 + step * index2
  })) : marksProp || [];
  const marksValues = marks.map((mark) => mark.value);
  const [focusedThumbIndex, setFocusedThumbIndex] = reactExports.useState(-1);
  const sliderRef = reactExports.useRef(null);
  const handleRef = useForkRef(ref, sliderRef);
  const createHandleHiddenInputFocus = (otherHandlers) => (event) => {
    var _a2;
    const index2 = Number(event.currentTarget.getAttribute("data-index"));
    if (isFocusVisible(event.target)) {
      setFocusedThumbIndex(index2);
    }
    setOpen(index2);
    (_a2 = otherHandlers == null ? void 0 : otherHandlers.onFocus) == null ? void 0 : _a2.call(otherHandlers, event);
  };
  const createHandleHiddenInputBlur = (otherHandlers) => (event) => {
    var _a2;
    if (!isFocusVisible(event.target)) {
      setFocusedThumbIndex(-1);
    }
    setOpen(-1);
    (_a2 = otherHandlers == null ? void 0 : otherHandlers.onBlur) == null ? void 0 : _a2.call(otherHandlers, event);
  };
  const changeValue = (event, valueInput) => {
    var _a2;
    const index2 = Number(event.currentTarget.getAttribute("data-index"));
    const value = values2[index2];
    const marksIndex = marksValues.indexOf(value);
    let newValue = valueInput;
    if (marks && step == null) {
      const maxMarksValue = marksValues[marksValues.length - 1];
      if (newValue >= maxMarksValue) {
        newValue = maxMarksValue;
      } else if (newValue <= marksValues[0]) {
        newValue = marksValues[0];
      } else {
        newValue = newValue < value ? marksValues[marksIndex - 1] : marksValues[marksIndex + 1];
      }
    }
    newValue = clamp(newValue, min2, max2);
    if (range) {
      if (disableSwap) {
        newValue = clamp(newValue, values2[index2 - 1] || -Infinity, values2[index2 + 1] || Infinity);
      }
      const previousValue = newValue;
      newValue = setValueIndex({
        values: values2,
        newValue,
        index: index2
      });
      let activeIndex = index2;
      if (!disableSwap) {
        activeIndex = newValue.indexOf(previousValue);
      }
      focusThumb({
        sliderRef,
        activeIndex
      });
    }
    setValueState(newValue);
    setFocusedThumbIndex(index2);
    if (handleChange && !areValuesEqual(newValue, valueDerived)) {
      handleChange(event, newValue, index2);
    }
    if (onChangeCommitted) {
      onChangeCommitted(event, (_a2 = lastChangedValue.current) != null ? _a2 : newValue);
    }
  };
  const createHandleHiddenInputKeyDown = (otherHandlers) => (event) => {
    var _a2;
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "PageUp", "PageDown", "Home", "End"].includes(event.key)) {
      event.preventDefault();
      const index2 = Number(event.currentTarget.getAttribute("data-index"));
      const value = values2[index2];
      let newValue = null;
      if (step != null) {
        const stepSize = event.shiftKey ? shiftStep : step;
        switch (event.key) {
          case "ArrowUp":
            newValue = getNewValue(value, stepSize, 1, min2, max2);
            break;
          case "ArrowRight":
            newValue = getNewValue(value, stepSize, isRtl ? -1 : 1, min2, max2);
            break;
          case "ArrowDown":
            newValue = getNewValue(value, stepSize, -1, min2, max2);
            break;
          case "ArrowLeft":
            newValue = getNewValue(value, stepSize, isRtl ? 1 : -1, min2, max2);
            break;
          case "PageUp":
            newValue = getNewValue(value, shiftStep, 1, min2, max2);
            break;
          case "PageDown":
            newValue = getNewValue(value, shiftStep, -1, min2, max2);
            break;
          case "Home":
            newValue = min2;
            break;
          case "End":
            newValue = max2;
            break;
        }
      } else if (marks) {
        const maxMarksValue = marksValues[marksValues.length - 1];
        const currentMarkIndex = marksValues.indexOf(value);
        const decrementKeys = [isRtl ? "ArrowRight" : "ArrowLeft", "ArrowDown", "PageDown", "Home"];
        const incrementKeys = [isRtl ? "ArrowLeft" : "ArrowRight", "ArrowUp", "PageUp", "End"];
        if (decrementKeys.includes(event.key)) {
          if (currentMarkIndex === 0) {
            newValue = marksValues[0];
          } else {
            newValue = marksValues[currentMarkIndex - 1];
          }
        } else if (incrementKeys.includes(event.key)) {
          if (currentMarkIndex === marksValues.length - 1) {
            newValue = maxMarksValue;
          } else {
            newValue = marksValues[currentMarkIndex + 1];
          }
        }
      }
      if (newValue != null) {
        changeValue(event, newValue);
      }
    }
    (_a2 = otherHandlers == null ? void 0 : otherHandlers.onKeyDown) == null ? void 0 : _a2.call(otherHandlers, event);
  };
  useEnhancedEffect(() => {
    var _a2;
    if (disabled && sliderRef.current.contains(document.activeElement)) {
      (_a2 = document.activeElement) == null ? void 0 : _a2.blur();
    }
  }, [disabled]);
  if (disabled && active !== -1) {
    setActive(-1);
  }
  if (disabled && focusedThumbIndex !== -1) {
    setFocusedThumbIndex(-1);
  }
  const createHandleHiddenInputChange = (otherHandlers) => (event) => {
    var _a2;
    (_a2 = otherHandlers.onChange) == null ? void 0 : _a2.call(otherHandlers, event);
    changeValue(event, event.target.valueAsNumber);
  };
  const previousIndex = reactExports.useRef(void 0);
  let axis = orientation;
  if (isRtl && orientation === "horizontal") {
    axis += "-reverse";
  }
  const getFingerNewValue = ({
    finger,
    move = false
  }) => {
    const {
      current: slider
    } = sliderRef;
    const {
      width: width2,
      height: height2,
      bottom: bottom2,
      left: left2
    } = slider.getBoundingClientRect();
    let percent;
    if (axis.startsWith("vertical")) {
      percent = (bottom2 - finger.y) / height2;
    } else {
      percent = (finger.x - left2) / width2;
    }
    if (axis.includes("-reverse")) {
      percent = 1 - percent;
    }
    let newValue;
    newValue = percentToValue(percent, min2, max2);
    if (step) {
      newValue = roundValueToStep(newValue, step, min2);
    } else {
      const closestIndex = findClosest(marksValues, newValue);
      newValue = marksValues[closestIndex];
    }
    newValue = clamp(newValue, min2, max2);
    let activeIndex = 0;
    if (range) {
      if (!move) {
        activeIndex = findClosest(values2, newValue);
      } else {
        activeIndex = previousIndex.current;
      }
      if (disableSwap) {
        newValue = clamp(newValue, values2[activeIndex - 1] || -Infinity, values2[activeIndex + 1] || Infinity);
      }
      const previousValue = newValue;
      newValue = setValueIndex({
        values: values2,
        newValue,
        index: activeIndex
      });
      if (!(disableSwap && move)) {
        activeIndex = newValue.indexOf(previousValue);
        previousIndex.current = activeIndex;
      }
    }
    return {
      newValue,
      activeIndex
    };
  };
  const handleTouchMove = useEventCallback((nativeEvent) => {
    const finger = trackFinger(nativeEvent, touchId);
    if (!finger) {
      return;
    }
    moveCount.current += 1;
    if (nativeEvent.type === "mousemove" && nativeEvent.buttons === 0) {
      handleTouchEnd(nativeEvent);
      return;
    }
    const {
      newValue,
      activeIndex
    } = getFingerNewValue({
      finger,
      move: true
    });
    focusThumb({
      sliderRef,
      activeIndex,
      setActive
    });
    setValueState(newValue);
    if (!dragging && moveCount.current > INTENTIONAL_DRAG_COUNT_THRESHOLD) {
      setDragging(true);
    }
    if (handleChange && !areValuesEqual(newValue, valueDerived)) {
      handleChange(nativeEvent, newValue, activeIndex);
    }
  });
  const handleTouchEnd = useEventCallback((nativeEvent) => {
    var _a2;
    const finger = trackFinger(nativeEvent, touchId);
    setDragging(false);
    if (!finger) {
      return;
    }
    const {
      newValue
    } = getFingerNewValue({
      finger,
      move: true
    });
    setActive(-1);
    if (nativeEvent.type === "touchend") {
      setOpen(-1);
    }
    if (onChangeCommitted) {
      onChangeCommitted(nativeEvent, (_a2 = lastChangedValue.current) != null ? _a2 : newValue);
    }
    touchId.current = void 0;
    stopListening();
  });
  const handleTouchStart = useEventCallback((nativeEvent) => {
    if (disabled) {
      return;
    }
    if (!doesSupportTouchActionNone()) {
      nativeEvent.preventDefault();
    }
    const touch = nativeEvent.changedTouches[0];
    if (touch != null) {
      touchId.current = touch.identifier;
    }
    const finger = trackFinger(nativeEvent, touchId);
    if (finger !== false) {
      const {
        newValue,
        activeIndex
      } = getFingerNewValue({
        finger
      });
      focusThumb({
        sliderRef,
        activeIndex,
        setActive
      });
      setValueState(newValue);
      if (handleChange && !areValuesEqual(newValue, valueDerived)) {
        handleChange(nativeEvent, newValue, activeIndex);
      }
    }
    moveCount.current = 0;
    const doc = ownerDocument(sliderRef.current);
    doc.addEventListener("touchmove", handleTouchMove, {
      passive: true
    });
    doc.addEventListener("touchend", handleTouchEnd, {
      passive: true
    });
  });
  const stopListening = reactExports.useCallback(() => {
    const doc = ownerDocument(sliderRef.current);
    doc.removeEventListener("mousemove", handleTouchMove);
    doc.removeEventListener("mouseup", handleTouchEnd);
    doc.removeEventListener("touchmove", handleTouchMove);
    doc.removeEventListener("touchend", handleTouchEnd);
  }, [handleTouchEnd, handleTouchMove]);
  reactExports.useEffect(() => {
    const {
      current: slider
    } = sliderRef;
    slider.addEventListener("touchstart", handleTouchStart, {
      passive: doesSupportTouchActionNone()
    });
    return () => {
      slider.removeEventListener("touchstart", handleTouchStart);
      stopListening();
    };
  }, [stopListening, handleTouchStart]);
  reactExports.useEffect(() => {
    if (disabled) {
      stopListening();
    }
  }, [disabled, stopListening]);
  const createHandleMouseDown = (otherHandlers) => (event) => {
    var _a2;
    (_a2 = otherHandlers.onMouseDown) == null ? void 0 : _a2.call(otherHandlers, event);
    if (disabled) {
      return;
    }
    if (event.defaultPrevented) {
      return;
    }
    if (event.button !== 0) {
      return;
    }
    event.preventDefault();
    const finger = trackFinger(event, touchId);
    if (finger !== false) {
      const {
        newValue,
        activeIndex
      } = getFingerNewValue({
        finger
      });
      focusThumb({
        sliderRef,
        activeIndex,
        setActive
      });
      setValueState(newValue);
      if (handleChange && !areValuesEqual(newValue, valueDerived)) {
        handleChange(event, newValue, activeIndex);
      }
    }
    moveCount.current = 0;
    const doc = ownerDocument(sliderRef.current);
    doc.addEventListener("mousemove", handleTouchMove, {
      passive: true
    });
    doc.addEventListener("mouseup", handleTouchEnd);
  };
  const trackOffset = valueToPercent(range ? values2[0] : min2, min2, max2);
  const trackLeap = valueToPercent(values2[values2.length - 1], min2, max2) - trackOffset;
  const getRootProps = (externalProps = {}) => {
    const externalHandlers = extractEventHandlers(externalProps);
    const ownEventHandlers = {
      onMouseDown: createHandleMouseDown(externalHandlers || {})
    };
    const mergedEventHandlers = __spreadValues(__spreadValues({}, externalHandlers), ownEventHandlers);
    return __spreadValues(__spreadProps(__spreadValues({}, externalProps), {
      ref: handleRef
    }), mergedEventHandlers);
  };
  const createHandleMouseOver = (otherHandlers) => (event) => {
    var _a2;
    (_a2 = otherHandlers.onMouseOver) == null ? void 0 : _a2.call(otherHandlers, event);
    const index2 = Number(event.currentTarget.getAttribute("data-index"));
    setOpen(index2);
  };
  const createHandleMouseLeave = (otherHandlers) => (event) => {
    var _a2;
    (_a2 = otherHandlers.onMouseLeave) == null ? void 0 : _a2.call(otherHandlers, event);
    setOpen(-1);
  };
  const getThumbProps = (externalProps = {}) => {
    const externalHandlers = extractEventHandlers(externalProps);
    const ownEventHandlers = {
      onMouseOver: createHandleMouseOver(externalHandlers || {}),
      onMouseLeave: createHandleMouseLeave(externalHandlers || {})
    };
    return __spreadValues(__spreadValues(__spreadValues({}, externalProps), externalHandlers), ownEventHandlers);
  };
  const getThumbStyle = (index2) => {
    return {
      // So the non active thumb doesn't show its label on hover.
      pointerEvents: active !== -1 && active !== index2 ? "none" : void 0
    };
  };
  let cssWritingMode;
  if (orientation === "vertical") {
    cssWritingMode = isRtl ? "vertical-rl" : "vertical-lr";
  }
  const getHiddenInputProps = (externalProps = {}) => {
    var _a2;
    const externalHandlers = extractEventHandlers(externalProps);
    const ownEventHandlers = {
      onChange: createHandleHiddenInputChange(externalHandlers || {}),
      onFocus: createHandleHiddenInputFocus(externalHandlers || {}),
      onBlur: createHandleHiddenInputBlur(externalHandlers || {}),
      onKeyDown: createHandleHiddenInputKeyDown(externalHandlers || {})
    };
    const mergedEventHandlers = __spreadValues(__spreadValues({}, externalHandlers), ownEventHandlers);
    return __spreadProps(__spreadValues(__spreadValues({
      tabIndex,
      "aria-labelledby": ariaLabelledby,
      "aria-orientation": orientation,
      "aria-valuemax": scale(max2),
      "aria-valuemin": scale(min2),
      name: name2,
      type: "range",
      min: parameters.min,
      max: parameters.max,
      step: parameters.step === null && parameters.marks ? "any" : (_a2 = parameters.step) != null ? _a2 : void 0,
      disabled
    }, externalProps), mergedEventHandlers), {
      style: __spreadProps(__spreadValues({}, visuallyHidden), {
        direction: isRtl ? "rtl" : "ltr",
        // So that VoiceOver's focus indicator matches the thumb's dimensions
        width: "100%",
        height: "100%",
        writingMode: cssWritingMode
      })
    });
  };
  return {
    active,
    axis,
    axisProps,
    dragging,
    focusedThumbIndex,
    getHiddenInputProps,
    getRootProps,
    getThumbProps,
    marks,
    open,
    range,
    rootRef: handleRef,
    trackLeap,
    trackOffset,
    values: values2,
    getThumbStyle
  };
}
const shouldSpreadAdditionalProps = (Slot) => {
  return !Slot || !isHostComponent(Slot);
};
function getSliderUtilityClass(slot) {
  return generateUtilityClass("MuiSlider", slot);
}
const sliderClasses = generateUtilityClasses("MuiSlider", ["root", "active", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "disabled", "dragging", "focusVisible", "mark", "markActive", "marked", "markLabel", "markLabelActive", "rail", "sizeSmall", "thumb", "thumbColorPrimary", "thumbColorSecondary", "thumbColorError", "thumbColorSuccess", "thumbColorInfo", "thumbColorWarning", "track", "trackInverted", "trackFalse", "thumbSizeSmall", "valueLabel", "valueLabelOpen", "valueLabelCircle", "valueLabelLabel", "vertical"]);
const useValueLabelClasses = (props) => {
  const {
    open
  } = props;
  const utilityClasses = {
    offset: clsx(open && sliderClasses.valueLabelOpen),
    circle: sliderClasses.valueLabelCircle,
    label: sliderClasses.valueLabelLabel
  };
  return utilityClasses;
};
function SliderValueLabel$1(props) {
  const {
    children,
    className,
    value
  } = props;
  const classes = useValueLabelClasses(props);
  if (!children) {
    return null;
  }
  return /* @__PURE__ */ reactExports.cloneElement(children, {
    className: children.props.className
  }, /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [children.props.children, /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: clsx(classes.offset, className),
      "aria-hidden": true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: classes.circle,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: classes.label,
          children: value
        })
      })
    })]
  }));
}
function Identity(x) {
  return x;
}
const SliderRoot = styled("span", {
  name: "MuiSlider",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`color${capitalize(ownerState.color)}`], ownerState.size !== "medium" && styles2[`size${capitalize(ownerState.size)}`], ownerState.marked && styles2.marked, ownerState.orientation === "vertical" && styles2.vertical, ownerState.track === "inverted" && styles2.trackInverted, ownerState.track === false && styles2.trackFalse];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  borderRadius: 12,
  boxSizing: "content-box",
  display: "inline-block",
  position: "relative",
  cursor: "pointer",
  touchAction: "none",
  WebkitTapHighlightColor: "transparent",
  "@media print": {
    colorAdjust: "exact"
  },
  [`&.${sliderClasses.disabled}`]: {
    pointerEvents: "none",
    cursor: "default",
    color: (theme2.vars || theme2).palette.grey[400]
  },
  [`&.${sliderClasses.dragging}`]: {
    [`& .${sliderClasses.thumb}, & .${sliderClasses.track}`]: {
      transition: "none"
    }
  },
  variants: [...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      color: (theme2.vars || theme2).palette[color2].main
    }
  })), {
    props: {
      orientation: "horizontal"
    },
    style: {
      height: 4,
      width: "100%",
      padding: "13px 0",
      // The primary input mechanism of the device includes a pointing device of limited accuracy.
      "@media (pointer: coarse)": {
        // Reach 42px touch target, about ~8mm on screen.
        padding: "20px 0"
      }
    }
  }, {
    props: {
      orientation: "horizontal",
      size: "small"
    },
    style: {
      height: 2
    }
  }, {
    props: {
      orientation: "horizontal",
      marked: true
    },
    style: {
      marginBottom: 20
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      width: 4,
      padding: "0 13px",
      // The primary input mechanism of the device includes a pointing device of limited accuracy.
      "@media (pointer: coarse)": {
        // Reach 42px touch target, about ~8mm on screen.
        padding: "0 20px"
      }
    }
  }, {
    props: {
      orientation: "vertical",
      size: "small"
    },
    style: {
      width: 2
    }
  }, {
    props: {
      orientation: "vertical",
      marked: true
    },
    style: {
      marginRight: 44
    }
  }]
})));
const SliderRail = styled("span", {
  name: "MuiSlider",
  slot: "Rail"
})({
  display: "block",
  position: "absolute",
  borderRadius: "inherit",
  backgroundColor: "currentColor",
  opacity: 0.38,
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      width: "100%",
      height: "inherit",
      top: "50%",
      transform: "translateY(-50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      width: "inherit",
      left: "50%",
      transform: "translateX(-50%)"
    }
  }, {
    props: {
      track: "inverted"
    },
    style: {
      opacity: 1
    }
  }]
});
const SliderTrack = styled("span", {
  name: "MuiSlider",
  slot: "Track"
})(memoTheme(({
  theme: theme2
}) => {
  return {
    display: "block",
    position: "absolute",
    borderRadius: "inherit",
    border: "1px solid currentColor",
    backgroundColor: "currentColor",
    transition: theme2.transitions.create(["left", "width", "bottom", "height"], {
      duration: theme2.transitions.duration.shortest
    }),
    variants: [{
      props: {
        size: "small"
      },
      style: {
        border: "none"
      }
    }, {
      props: {
        orientation: "horizontal"
      },
      style: {
        height: "inherit",
        top: "50%",
        transform: "translateY(-50%)"
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        width: "inherit",
        left: "50%",
        transform: "translateX(-50%)"
      }
    }, {
      props: {
        track: false
      },
      style: {
        display: "none"
      }
    }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
      props: {
        color: color2,
        track: "inverted"
      },
      style: __spreadValues({}, theme2.vars ? {
        backgroundColor: theme2.vars.palette.Slider[`${color2}Track`],
        borderColor: theme2.vars.palette.Slider[`${color2}Track`]
      } : __spreadValues(__spreadValues({
        backgroundColor: theme2.lighten(theme2.palette[color2].main, 0.62),
        borderColor: theme2.lighten(theme2.palette[color2].main, 0.62)
      }, theme2.applyStyles("dark", {
        backgroundColor: theme2.darken(theme2.palette[color2].main, 0.5)
      })), theme2.applyStyles("dark", {
        borderColor: theme2.darken(theme2.palette[color2].main, 0.5)
      })))
    }))]
  };
}));
const SliderThumb = styled("span", {
  name: "MuiSlider",
  slot: "Thumb",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.thumb, styles2[`thumbColor${capitalize(ownerState.color)}`], ownerState.size !== "medium" && styles2[`thumbSize${capitalize(ownerState.size)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  position: "absolute",
  width: 20,
  height: 20,
  boxSizing: "border-box",
  borderRadius: "50%",
  outline: 0,
  backgroundColor: "currentColor",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  transition: theme2.transitions.create(["box-shadow", "left", "bottom"], {
    duration: theme2.transitions.duration.shortest
  }),
  "&::before": {
    position: "absolute",
    content: '""',
    borderRadius: "inherit",
    width: "100%",
    height: "100%",
    boxShadow: (theme2.vars || theme2).shadows[2]
  },
  "&::after": {
    position: "absolute",
    content: '""',
    borderRadius: "50%",
    // 42px is the hit target
    width: 42,
    height: 42,
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)"
  },
  [`&.${sliderClasses.disabled}`]: {
    "&:hover": {
      boxShadow: "none"
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      width: 12,
      height: 12,
      "&::before": {
        boxShadow: "none"
      }
    }
  }, {
    props: {
      orientation: "horizontal"
    },
    style: {
      top: "50%",
      transform: "translate(-50%, -50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: "50%",
      transform: "translate(-50%, 50%)"
    }
  }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      [`&:hover, &.${sliderClasses.focusVisible}`]: {
        boxShadow: `0px 0px 0px 8px ${theme2.alpha((theme2.vars || theme2).palette[color2].main, 0.16)}`,
        "@media (hover: none)": {
          boxShadow: "none"
        }
      },
      [`&.${sliderClasses.active}`]: {
        boxShadow: `0px 0px 0px 14px ${theme2.alpha((theme2.vars || theme2).palette[color2].main, 0.16)}`
      }
    }
  }))]
})));
const SliderValueLabel = styled(SliderValueLabel$1, {
  name: "MuiSlider",
  slot: "ValueLabel"
})(memoTheme(({
  theme: theme2
}) => __spreadProps(__spreadValues({
  zIndex: 1,
  whiteSpace: "nowrap"
}, theme2.typography.body2), {
  fontWeight: 500,
  transition: theme2.transitions.create(["transform"], {
    duration: theme2.transitions.duration.shortest
  }),
  position: "absolute",
  backgroundColor: (theme2.vars || theme2).palette.grey[600],
  borderRadius: 2,
  color: (theme2.vars || theme2).palette.common.white,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  padding: "0.25rem 0.75rem",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      transform: "translateY(-100%) scale(0)",
      top: "-10px",
      transformOrigin: "bottom center",
      "&::before": {
        position: "absolute",
        content: '""',
        width: 8,
        height: 8,
        transform: "translate(-50%, 50%) rotate(45deg)",
        backgroundColor: "inherit",
        bottom: 0,
        left: "50%"
      },
      [`&.${sliderClasses.valueLabelOpen}`]: {
        transform: "translateY(-100%) scale(1)"
      }
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      transform: "translateY(-50%) scale(0)",
      right: "30px",
      top: "50%",
      transformOrigin: "right center",
      "&::before": {
        position: "absolute",
        content: '""',
        width: 8,
        height: 8,
        transform: "translate(-50%, -50%) rotate(45deg)",
        backgroundColor: "inherit",
        right: -8,
        top: "50%"
      },
      [`&.${sliderClasses.valueLabelOpen}`]: {
        transform: "translateY(-50%) scale(1)"
      }
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      fontSize: theme2.typography.pxToRem(12),
      padding: "0.25rem 0.5rem"
    }
  }, {
    props: {
      orientation: "vertical",
      size: "small"
    },
    style: {
      right: "20px"
    }
  }]
})));
const SliderMark = styled("span", {
  name: "MuiSlider",
  slot: "Mark",
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "markActive",
  overridesResolver: (props, styles2) => {
    const {
      markActive
    } = props;
    return [styles2.mark, markActive && styles2.markActive];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  position: "absolute",
  width: 2,
  height: 2,
  borderRadius: 1,
  backgroundColor: "currentColor",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      top: "50%",
      transform: "translate(-1px, -50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: "50%",
      transform: "translate(-50%, 1px)"
    }
  }, {
    props: {
      markActive: true
    },
    style: {
      backgroundColor: (theme2.vars || theme2).palette.background.paper,
      opacity: 0.8
    }
  }]
})));
const SliderMarkLabel = styled("span", {
  name: "MuiSlider",
  slot: "MarkLabel",
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "markLabelActive"
})(memoTheme(({
  theme: theme2
}) => __spreadProps(__spreadValues({}, theme2.typography.body2), {
  color: (theme2.vars || theme2).palette.text.secondary,
  position: "absolute",
  whiteSpace: "nowrap",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      top: 30,
      transform: "translateX(-50%)",
      "@media (pointer: coarse)": {
        top: 40
      }
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: 36,
      transform: "translateY(50%)",
      "@media (pointer: coarse)": {
        left: 44
      }
    }
  }, {
    props: {
      markLabelActive: true
    },
    style: {
      color: (theme2.vars || theme2).palette.text.primary
    }
  }]
})));
const useUtilityClasses$l = (ownerState) => {
  const {
    disabled,
    dragging,
    marked,
    orientation,
    track,
    classes,
    color: color2,
    size
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", dragging && "dragging", marked && "marked", orientation === "vertical" && "vertical", track === "inverted" && "trackInverted", track === false && "trackFalse", color2 && `color${capitalize(color2)}`, size && `size${capitalize(size)}`],
    rail: ["rail"],
    track: ["track"],
    mark: ["mark"],
    markActive: ["markActive"],
    markLabel: ["markLabel"],
    markLabelActive: ["markLabelActive"],
    valueLabel: ["valueLabel"],
    thumb: ["thumb", disabled && "disabled", size && `thumbSize${capitalize(size)}`, color2 && `thumbColor${capitalize(color2)}`],
    active: ["active"],
    disabled: ["disabled"],
    focusVisible: ["focusVisible"]
  };
  return composeClasses(slots, getSliderUtilityClass, classes);
};
const Forward = ({
  children
}) => children;
const Slider = /* @__PURE__ */ reactExports.forwardRef(function Slider2(inputProps, ref) {
  var _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
  const props = useDefaultProps({
    props: inputProps,
    name: "MuiSlider"
  });
  const isRtl = useRtl();
  const _a2 = props, {
    "aria-label": ariaLabel,
    "aria-valuetext": ariaValuetext,
    "aria-labelledby": ariaLabelledby,
    component: component = "span",
    components = {},
    componentsProps = {},
    color: color2 = "primary",
    classes: classesProp,
    className,
    disableSwap = false,
    disabled = false,
    getAriaLabel,
    getAriaValueText,
    marks: marksProp = false,
    max: max2 = 100,
    min: min2 = 0,
    name: name2,
    onChange,
    onChangeCommitted,
    orientation = "horizontal",
    shiftStep = 10,
    size = "medium",
    step = 1,
    scale = Identity,
    slotProps,
    slots,
    tabIndex,
    track = "normal",
    value: valueProp,
    valueLabelDisplay = "off",
    valueLabelFormat = Identity
  } = _a2, other = __objRest(_a2, [
    "aria-label",
    "aria-valuetext",
    "aria-labelledby",
    // eslint-disable-next-line react/prop-types
    "component",
    "components",
    "componentsProps",
    "color",
    "classes",
    "className",
    "disableSwap",
    "disabled",
    "getAriaLabel",
    "getAriaValueText",
    "marks",
    "max",
    "min",
    "name",
    "onChange",
    "onChangeCommitted",
    "orientation",
    "shiftStep",
    "size",
    "step",
    "scale",
    "slotProps",
    "slots",
    "tabIndex",
    "track",
    "value",
    "valueLabelDisplay",
    "valueLabelFormat"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    isRtl,
    max: max2,
    min: min2,
    classes: classesProp,
    disabled,
    disableSwap,
    orientation,
    marks: marksProp,
    color: color2,
    size,
    step,
    shiftStep,
    scale,
    track,
    valueLabelDisplay,
    valueLabelFormat
  });
  const {
    axisProps: axisProps2,
    getRootProps,
    getHiddenInputProps,
    getThumbProps,
    open,
    active,
    axis,
    focusedThumbIndex,
    range,
    dragging,
    marks,
    values: values2,
    trackOffset,
    trackLeap,
    getThumbStyle
  } = useSlider(__spreadProps(__spreadValues({}, ownerState), {
    rootRef: ref
  }));
  ownerState.marked = marks.length > 0 && marks.some((mark) => mark.label);
  ownerState.dragging = dragging;
  ownerState.focusedThumbIndex = focusedThumbIndex;
  const classes = useUtilityClasses$l(ownerState);
  const RootSlot = (_c = (_b = slots == null ? void 0 : slots.root) != null ? _b : components.Root) != null ? _c : SliderRoot;
  const RailSlot = (_e = (_d = slots == null ? void 0 : slots.rail) != null ? _d : components.Rail) != null ? _e : SliderRail;
  const TrackSlot = (_g = (_f = slots == null ? void 0 : slots.track) != null ? _f : components.Track) != null ? _g : SliderTrack;
  const ThumbSlot = (_i = (_h = slots == null ? void 0 : slots.thumb) != null ? _h : components.Thumb) != null ? _i : SliderThumb;
  const ValueLabelSlot = (_k = (_j = slots == null ? void 0 : slots.valueLabel) != null ? _j : components.ValueLabel) != null ? _k : SliderValueLabel;
  const MarkSlot = (_m = (_l = slots == null ? void 0 : slots.mark) != null ? _l : components.Mark) != null ? _m : SliderMark;
  const MarkLabelSlot = (_o = (_n = slots == null ? void 0 : slots.markLabel) != null ? _n : components.MarkLabel) != null ? _o : SliderMarkLabel;
  const InputSlot = (_q = (_p = slots == null ? void 0 : slots.input) != null ? _p : components.Input) != null ? _q : "input";
  const rootSlotProps = (_r = slotProps == null ? void 0 : slotProps.root) != null ? _r : componentsProps.root;
  const railSlotProps = (_s = slotProps == null ? void 0 : slotProps.rail) != null ? _s : componentsProps.rail;
  const trackSlotProps = (_t = slotProps == null ? void 0 : slotProps.track) != null ? _t : componentsProps.track;
  const thumbSlotProps = (_u = slotProps == null ? void 0 : slotProps.thumb) != null ? _u : componentsProps.thumb;
  const valueLabelSlotProps = (_v = slotProps == null ? void 0 : slotProps.valueLabel) != null ? _v : componentsProps.valueLabel;
  const markSlotProps = (_w = slotProps == null ? void 0 : slotProps.mark) != null ? _w : componentsProps.mark;
  const markLabelSlotProps = (_x = slotProps == null ? void 0 : slotProps.markLabel) != null ? _x : componentsProps.markLabel;
  const inputSlotProps = (_y = slotProps == null ? void 0 : slotProps.input) != null ? _y : componentsProps.input;
  const rootProps = useSlotProps({
    elementType: RootSlot,
    getSlotProps: getRootProps,
    externalSlotProps: rootSlotProps,
    externalForwardedProps: other,
    additionalProps: __spreadValues({}, shouldSpreadAdditionalProps(RootSlot) && {
      as: component
    }),
    ownerState: __spreadValues(__spreadValues({}, ownerState), rootSlotProps == null ? void 0 : rootSlotProps.ownerState),
    className: [classes.root, className]
  });
  const railProps = useSlotProps({
    elementType: RailSlot,
    externalSlotProps: railSlotProps,
    ownerState,
    className: classes.rail
  });
  const trackProps = useSlotProps({
    elementType: TrackSlot,
    externalSlotProps: trackSlotProps,
    additionalProps: {
      style: __spreadValues(__spreadValues({}, axisProps2[axis].offset(trackOffset)), axisProps2[axis].leap(trackLeap))
    },
    ownerState: __spreadValues(__spreadValues({}, ownerState), trackSlotProps == null ? void 0 : trackSlotProps.ownerState),
    className: classes.track
  });
  const thumbProps = useSlotProps({
    elementType: ThumbSlot,
    getSlotProps: getThumbProps,
    externalSlotProps: thumbSlotProps,
    ownerState: __spreadValues(__spreadValues({}, ownerState), thumbSlotProps == null ? void 0 : thumbSlotProps.ownerState),
    className: classes.thumb
  });
  const valueLabelProps = useSlotProps({
    elementType: ValueLabelSlot,
    externalSlotProps: valueLabelSlotProps,
    ownerState: __spreadValues(__spreadValues({}, ownerState), valueLabelSlotProps == null ? void 0 : valueLabelSlotProps.ownerState),
    className: classes.valueLabel
  });
  const markProps = useSlotProps({
    elementType: MarkSlot,
    externalSlotProps: markSlotProps,
    ownerState,
    className: classes.mark
  });
  const markLabelProps = useSlotProps({
    elementType: MarkLabelSlot,
    externalSlotProps: markLabelSlotProps,
    ownerState,
    className: classes.markLabel
  });
  const inputSliderProps = useSlotProps({
    elementType: InputSlot,
    getSlotProps: getHiddenInputProps,
    externalSlotProps: inputSlotProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, __spreadProps(__spreadValues({}, rootProps), {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(RailSlot, __spreadValues({}, railProps)), /* @__PURE__ */ jsxRuntimeExports.jsx(TrackSlot, __spreadValues({}, trackProps)), marks.filter((mark) => mark.value >= min2 && mark.value <= max2).map((mark, index2) => {
      const percent = valueToPercent(mark.value, min2, max2);
      const style2 = axisProps2[axis].offset(percent);
      let markActive;
      if (track === false) {
        markActive = values2.includes(mark.value);
      } else {
        markActive = track === "normal" && (range ? mark.value >= values2[0] && mark.value <= values2[values2.length - 1] : mark.value <= values2[0]) || track === "inverted" && (range ? mark.value <= values2[0] || mark.value >= values2[values2.length - 1] : mark.value >= values2[0]);
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(MarkSlot, __spreadProps(__spreadValues(__spreadValues({
          "data-index": index2
        }, markProps), !isHostComponent(MarkSlot) && {
          markActive
        }), {
          style: __spreadValues(__spreadValues({}, style2), markProps.style),
          className: clsx(markProps.className, markActive && classes.markActive)
        })), mark.label != null ? /* @__PURE__ */ jsxRuntimeExports.jsx(MarkLabelSlot, __spreadProps(__spreadValues(__spreadValues({
          "aria-hidden": true,
          "data-index": index2
        }, markLabelProps), !isHostComponent(MarkLabelSlot) && {
          markLabelActive: markActive
        }), {
          style: __spreadValues(__spreadValues({}, style2), markLabelProps.style),
          className: clsx(classes.markLabel, markLabelProps.className, markActive && classes.markLabelActive),
          children: mark.label
        })) : null]
      }, index2);
    }), values2.map((value, index2) => {
      const percent = valueToPercent(value, min2, max2);
      const style2 = axisProps2[axis].offset(percent);
      const ValueLabelComponent = valueLabelDisplay === "off" ? Forward : ValueLabelSlot;
      return (
        /* TODO v6: Change component structure. It will help in avoiding the complicated React.cloneElement API added in SliderValueLabel component. Should be: Thumb -> Input, ValueLabel. Follow Joy UI's Slider structure. */
        /* @__PURE__ */ jsxRuntimeExports.jsx(ValueLabelComponent, __spreadProps(__spreadValues(__spreadValues({}, !isHostComponent(ValueLabelComponent) && {
          valueLabelFormat,
          valueLabelDisplay,
          value: typeof valueLabelFormat === "function" ? valueLabelFormat(scale(value), index2) : valueLabelFormat,
          index: index2,
          open: open === index2 || active === index2 || valueLabelDisplay === "on",
          disabled
        }), valueLabelProps), {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThumbSlot, __spreadProps(__spreadValues({
            "data-index": index2
          }, thumbProps), {
            className: clsx(classes.thumb, thumbProps.className, active === index2 && classes.active, focusedThumbIndex === index2 && classes.focusVisible),
            style: __spreadValues(__spreadValues(__spreadValues({}, style2), getThumbStyle(index2)), thumbProps.style),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(InputSlot, __spreadValues({
              "data-index": index2,
              "aria-label": getAriaLabel ? getAriaLabel(index2) : ariaLabel,
              "aria-valuenow": scale(value),
              "aria-labelledby": ariaLabelledby,
              "aria-valuetext": getAriaValueText ? getAriaValueText(scale(value), index2) : ariaValuetext,
              value: values2[index2]
            }, inputSliderProps))
          }))
        }), index2)
      );
    })]
  }));
});
function useSnackbar(parameters = {}) {
  const {
    autoHideDuration = null,
    disableWindowBlurListener = false,
    onClose,
    open,
    resumeHideDuration
  } = parameters;
  const timerAutoHide = useTimeout();
  reactExports.useEffect(() => {
    if (!open) {
      return void 0;
    }
    function handleKeyDown(nativeEvent) {
      if (!nativeEvent.defaultPrevented) {
        if (nativeEvent.key === "Escape") {
          onClose == null ? void 0 : onClose(nativeEvent, "escapeKeyDown");
        }
      }
    }
    document.addEventListener("keydown", handleKeyDown);
    return () => {
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, [open, onClose]);
  const handleClose = useEventCallback((event, reason) => {
    onClose == null ? void 0 : onClose(event, reason);
  });
  const setAutoHideTimer = useEventCallback((autoHideDurationParam) => {
    if (!onClose || autoHideDurationParam == null) {
      return;
    }
    timerAutoHide.start(autoHideDurationParam, () => {
      handleClose(null, "timeout");
    });
  });
  reactExports.useEffect(() => {
    if (open) {
      setAutoHideTimer(autoHideDuration);
    }
    return timerAutoHide.clear;
  }, [open, autoHideDuration, setAutoHideTimer, timerAutoHide]);
  const handleClickAway = (event) => {
    onClose == null ? void 0 : onClose(event, "clickaway");
  };
  const handlePause = timerAutoHide.clear;
  const handleResume = reactExports.useCallback(() => {
    if (autoHideDuration != null) {
      setAutoHideTimer(resumeHideDuration != null ? resumeHideDuration : autoHideDuration * 0.5);
    }
  }, [autoHideDuration, resumeHideDuration, setAutoHideTimer]);
  const createHandleBlur = (otherHandlers) => (event) => {
    const onBlurCallback = otherHandlers.onBlur;
    onBlurCallback == null ? void 0 : onBlurCallback(event);
    handleResume();
  };
  const createHandleFocus = (otherHandlers) => (event) => {
    const onFocusCallback = otherHandlers.onFocus;
    onFocusCallback == null ? void 0 : onFocusCallback(event);
    handlePause();
  };
  const createMouseEnter = (otherHandlers) => (event) => {
    const onMouseEnterCallback = otherHandlers.onMouseEnter;
    onMouseEnterCallback == null ? void 0 : onMouseEnterCallback(event);
    handlePause();
  };
  const createMouseLeave = (otherHandlers) => (event) => {
    const onMouseLeaveCallback = otherHandlers.onMouseLeave;
    onMouseLeaveCallback == null ? void 0 : onMouseLeaveCallback(event);
    handleResume();
  };
  reactExports.useEffect(() => {
    if (!disableWindowBlurListener && open) {
      window.addEventListener("focus", handleResume);
      window.addEventListener("blur", handlePause);
      return () => {
        window.removeEventListener("focus", handleResume);
        window.removeEventListener("blur", handlePause);
      };
    }
    return void 0;
  }, [disableWindowBlurListener, open, handleResume, handlePause]);
  const getRootProps = (externalProps = {}) => {
    const externalEventHandlers = __spreadValues(__spreadValues({}, extractEventHandlers(parameters)), extractEventHandlers(externalProps));
    return __spreadProps(__spreadValues(__spreadValues({
      // ClickAwayListener adds an `onClick` prop which results in the alert not being announced.
      // See https://github.com/mui/material-ui/issues/29080
      role: "presentation"
    }, externalProps), externalEventHandlers), {
      onBlur: createHandleBlur(externalEventHandlers),
      onFocus: createHandleFocus(externalEventHandlers),
      onMouseEnter: createMouseEnter(externalEventHandlers),
      onMouseLeave: createMouseLeave(externalEventHandlers)
    });
  };
  return {
    getRootProps,
    onClickAway: handleClickAway
  };
}
function getSnackbarContentUtilityClass(slot) {
  return generateUtilityClass("MuiSnackbarContent", slot);
}
generateUtilityClasses("MuiSnackbarContent", ["root", "message", "action"]);
const useUtilityClasses$k = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    action: ["action"],
    message: ["message"]
  };
  return composeClasses(slots, getSnackbarContentUtilityClass, classes);
};
const SnackbarContentRoot = styled(Paper, {
  name: "MuiSnackbarContent",
  slot: "Root"
})(memoTheme(({
  theme: theme2
}) => {
  const emphasis = theme2.palette.mode === "light" ? 0.8 : 0.98;
  return __spreadProps(__spreadValues({}, theme2.typography.body2), {
    color: theme2.vars ? theme2.vars.palette.SnackbarContent.color : theme2.palette.getContrastText(emphasize(theme2.palette.background.default, emphasis)),
    backgroundColor: theme2.vars ? theme2.vars.palette.SnackbarContent.bg : emphasize(theme2.palette.background.default, emphasis),
    display: "flex",
    alignItems: "center",
    flexWrap: "wrap",
    padding: "6px 16px",
    flexGrow: 1,
    [theme2.breakpoints.up("sm")]: {
      flexGrow: "initial",
      minWidth: 288
    }
  });
}));
const SnackbarContentMessage = styled("div", {
  name: "MuiSnackbarContent",
  slot: "Message"
})({
  padding: "8px 0"
});
const SnackbarContentAction = styled("div", {
  name: "MuiSnackbarContent",
  slot: "Action"
})({
  display: "flex",
  alignItems: "center",
  marginLeft: "auto",
  paddingLeft: 16,
  marginRight: -8
});
const SnackbarContent = /* @__PURE__ */ reactExports.forwardRef(function SnackbarContent2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSnackbarContent"
  });
  const _a2 = props, {
    action,
    className,
    message,
    role = "alert"
  } = _a2, other = __objRest(_a2, [
    "action",
    "className",
    "message",
    "role"
  ]);
  const ownerState = props;
  const classes = useUtilityClasses$k(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SnackbarContentRoot, __spreadProps(__spreadValues({
    role,
    elevation: 6,
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other), {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarContentMessage, {
      className: classes.message,
      ownerState,
      children: message
    }), action ? /* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarContentAction, {
      className: classes.action,
      ownerState,
      children: action
    }) : null]
  }));
});
function getSnackbarUtilityClass(slot) {
  return generateUtilityClass("MuiSnackbar", slot);
}
generateUtilityClasses("MuiSnackbar", ["root", "anchorOriginTopCenter", "anchorOriginBottomCenter", "anchorOriginTopRight", "anchorOriginBottomRight", "anchorOriginTopLeft", "anchorOriginBottomLeft"]);
const useUtilityClasses$j = (ownerState) => {
  const {
    classes,
    anchorOrigin
  } = ownerState;
  const slots = {
    root: ["root", `anchorOrigin${capitalize(anchorOrigin.vertical)}${capitalize(anchorOrigin.horizontal)}`]
  };
  return composeClasses(slots, getSnackbarUtilityClass, classes);
};
const SnackbarRoot = styled("div", {
  name: "MuiSnackbar",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`anchorOrigin${capitalize(ownerState.anchorOrigin.vertical)}${capitalize(ownerState.anchorOrigin.horizontal)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  zIndex: (theme2.vars || theme2).zIndex.snackbar,
  position: "fixed",
  display: "flex",
  left: 8,
  right: 8,
  justifyContent: "center",
  alignItems: "center",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "top",
    style: {
      top: 8,
      [theme2.breakpoints.up("sm")]: {
        top: 24
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical !== "top",
    style: {
      bottom: 8,
      [theme2.breakpoints.up("sm")]: {
        bottom: 24
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.horizontal === "left",
    style: {
      justifyContent: "flex-start",
      [theme2.breakpoints.up("sm")]: {
        left: 24,
        right: "auto"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.horizontal === "right",
    style: {
      justifyContent: "flex-end",
      [theme2.breakpoints.up("sm")]: {
        right: 24,
        left: "auto"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.horizontal === "center",
    style: {
      [theme2.breakpoints.up("sm")]: {
        left: "50%",
        right: "auto",
        transform: "translateX(-50%)"
      }
    }
  }]
})));
const Snackbar = /* @__PURE__ */ reactExports.forwardRef(function Snackbar2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSnackbar"
  });
  const theme2 = useTheme();
  const defaultTransitionDuration = {
    enter: theme2.transitions.duration.enteringScreen,
    exit: theme2.transitions.duration.leavingScreen
  };
  const _a2 = props, {
    action,
    anchorOrigin: {
      vertical,
      horizontal
    } = {
      vertical: "bottom",
      horizontal: "left"
    },
    autoHideDuration = null,
    children,
    className,
    ClickAwayListenerProps: ClickAwayListenerPropsProp,
    ContentProps: ContentPropsProp,
    disableWindowBlurListener = false,
    message,
    onBlur,
    onClose,
    onFocus,
    onMouseEnter,
    onMouseLeave,
    open,
    resumeHideDuration,
    slots = {},
    slotProps = {},
    TransitionComponent: TransitionComponentProp,
    transitionDuration = defaultTransitionDuration,
    TransitionProps: _b = {}
  } = _a2, _c = _b, {
    onEnter,
    onExited
  } = _c, TransitionPropsProp = __objRest(_c, [
    "onEnter",
    "onExited"
  ]), other = __objRest(_a2, [
    "action",
    "anchorOrigin",
    "autoHideDuration",
    "children",
    "className",
    "ClickAwayListenerProps",
    "ContentProps",
    "disableWindowBlurListener",
    "message",
    "onBlur",
    "onClose",
    "onFocus",
    "onMouseEnter",
    "onMouseLeave",
    "open",
    "resumeHideDuration",
    "slots",
    "slotProps",
    "TransitionComponent",
    "transitionDuration",
    "TransitionProps"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    anchorOrigin: {
      vertical,
      horizontal
    },
    autoHideDuration,
    disableWindowBlurListener,
    TransitionComponent: TransitionComponentProp,
    transitionDuration
  });
  const classes = useUtilityClasses$j(ownerState);
  const {
    getRootProps,
    onClickAway
  } = useSnackbar(__spreadValues({}, ownerState));
  const [exited, setExited] = reactExports.useState(true);
  const handleExited = (node2) => {
    setExited(true);
    if (onExited) {
      onExited(node2);
    }
  };
  const handleEnter = (node2, isAppearing) => {
    setExited(false);
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  };
  const externalForwardedProps = {
    slots: __spreadValues({
      transition: TransitionComponentProp
    }, slots),
    slotProps: __spreadValues({
      content: ContentPropsProp,
      clickAwayListener: ClickAwayListenerPropsProp,
      transition: TransitionPropsProp
    }, slotProps)
  };
  const [Root, rootProps] = useSlot("root", {
    ref,
    className: [classes.root, className],
    elementType: SnackbarRoot,
    getSlotProps: getRootProps,
    externalForwardedProps: __spreadValues(__spreadValues({}, externalForwardedProps), other),
    ownerState
  });
  const [ClickAwaySlot, _d] = useSlot("clickAwayListener", {
    elementType: ClickAwayListener,
    externalForwardedProps,
    getSlotProps: (handlers) => ({
      onClickAway: (...params) => {
        var _a3;
        const event = params[0];
        (_a3 = handlers.onClickAway) == null ? void 0 : _a3.call(handlers, ...params);
        if (event == null ? void 0 : event.defaultMuiPrevented) {
          return;
        }
        onClickAway(...params);
      }
    }),
    ownerState
  }), _e = _d, {
    ownerState: clickAwayOwnerStateProp
  } = _e, clickAwayListenerProps = __objRest(_e, [
    "ownerState"
  ]);
  const [ContentSlot, contentSlotProps] = useSlot("content", {
    elementType: SnackbarContent,
    shouldForwardComponentProp: true,
    externalForwardedProps,
    additionalProps: {
      message,
      action
    },
    ownerState
  });
  const [TransitionSlot, transitionProps] = useSlot("transition", {
    elementType: Grow,
    externalForwardedProps,
    getSlotProps: (handlers) => ({
      onEnter: (...params) => {
        var _a3;
        (_a3 = handlers.onEnter) == null ? void 0 : _a3.call(handlers, ...params);
        handleEnter(...params);
      },
      onExited: (...params) => {
        var _a3;
        (_a3 = handlers.onExited) == null ? void 0 : _a3.call(handlers, ...params);
        handleExited(...params);
      }
    }),
    additionalProps: {
      appear: true,
      in: open,
      timeout: transitionDuration,
      direction: vertical === "top" ? "down" : "up"
    },
    ownerState
  });
  if (!open && exited) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ClickAwaySlot, __spreadProps(__spreadValues(__spreadValues({}, clickAwayListenerProps), slots.clickAwayListener && {
    ownerState: clickAwayOwnerStateProp
  }), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root, __spreadProps(__spreadValues({}, rootProps), {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionSlot, __spreadProps(__spreadValues({}, transitionProps), {
        children: children || /* @__PURE__ */ jsxRuntimeExports.jsx(ContentSlot, __spreadValues({}, contentSlotProps))
      }))
    }))
  }));
});
function getTooltipUtilityClass(slot) {
  return generateUtilityClass("MuiTooltip", slot);
}
const tooltipClasses = generateUtilityClasses("MuiTooltip", ["popper", "popperInteractive", "popperArrow", "popperClose", "tooltip", "tooltipArrow", "touch", "tooltipPlacementLeft", "tooltipPlacementRight", "tooltipPlacementTop", "tooltipPlacementBottom", "arrow"]);
function round(value) {
  return Math.round(value * 1e5) / 1e5;
}
const useUtilityClasses$i = (ownerState) => {
  const {
    classes,
    disableInteractive,
    arrow: arrow2,
    touch,
    placement
  } = ownerState;
  const slots = {
    popper: ["popper", !disableInteractive && "popperInteractive", arrow2 && "popperArrow"],
    tooltip: ["tooltip", arrow2 && "tooltipArrow", touch && "touch", `tooltipPlacement${capitalize(placement.split("-")[0])}`],
    arrow: ["arrow"]
  };
  return composeClasses(slots, getTooltipUtilityClass, classes);
};
const TooltipPopper = styled(Popper, {
  name: "MuiTooltip",
  slot: "Popper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.popper, !ownerState.disableInteractive && styles2.popperInteractive, ownerState.arrow && styles2.popperArrow, !ownerState.open && styles2.popperClose];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  zIndex: (theme2.vars || theme2).zIndex.tooltip,
  pointerEvents: "none",
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.disableInteractive,
    style: {
      pointerEvents: "auto"
    }
  }, {
    props: ({
      open
    }) => !open,
    style: {
      pointerEvents: "none"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.arrow,
    style: {
      [`&[data-popper-placement*="bottom"] .${tooltipClasses.arrow}`]: {
        top: 0,
        marginTop: "-0.71em",
        "&::before": {
          transformOrigin: "0 100%"
        }
      },
      [`&[data-popper-placement*="top"] .${tooltipClasses.arrow}`]: {
        bottom: 0,
        marginBottom: "-0.71em",
        "&::before": {
          transformOrigin: "100% 0"
        }
      },
      [`&[data-popper-placement*="right"] .${tooltipClasses.arrow}`]: {
        height: "1em",
        width: "0.71em",
        "&::before": {
          transformOrigin: "100% 100%"
        }
      },
      [`&[data-popper-placement*="left"] .${tooltipClasses.arrow}`]: {
        height: "1em",
        width: "0.71em",
        "&::before": {
          transformOrigin: "0 0"
        }
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.arrow && !ownerState.isRtl,
    style: {
      [`&[data-popper-placement*="right"] .${tooltipClasses.arrow}`]: {
        left: 0,
        marginLeft: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.arrow && !!ownerState.isRtl,
    style: {
      [`&[data-popper-placement*="right"] .${tooltipClasses.arrow}`]: {
        right: 0,
        marginRight: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.arrow && !ownerState.isRtl,
    style: {
      [`&[data-popper-placement*="left"] .${tooltipClasses.arrow}`]: {
        right: 0,
        marginRight: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.arrow && !!ownerState.isRtl,
    style: {
      [`&[data-popper-placement*="left"] .${tooltipClasses.arrow}`]: {
        left: 0,
        marginLeft: "-0.71em"
      }
    }
  }]
})));
const TooltipTooltip = styled("div", {
  name: "MuiTooltip",
  slot: "Tooltip",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.tooltip, ownerState.touch && styles2.touch, ownerState.arrow && styles2.tooltipArrow, styles2[`tooltipPlacement${capitalize(ownerState.placement.split("-")[0])}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  backgroundColor: theme2.vars ? theme2.vars.palette.Tooltip.bg : theme2.alpha(theme2.palette.grey[700], 0.92),
  borderRadius: (theme2.vars || theme2).shape.borderRadius,
  color: (theme2.vars || theme2).palette.common.white,
  fontFamily: theme2.typography.fontFamily,
  padding: "4px 8px",
  fontSize: theme2.typography.pxToRem(11),
  maxWidth: 300,
  margin: 2,
  wordWrap: "break-word",
  fontWeight: theme2.typography.fontWeightMedium,
  [`.${tooltipClasses.popper}[data-popper-placement*="left"] &`]: {
    transformOrigin: "right center"
  },
  [`.${tooltipClasses.popper}[data-popper-placement*="right"] &`]: {
    transformOrigin: "left center"
  },
  [`.${tooltipClasses.popper}[data-popper-placement*="top"] &`]: {
    transformOrigin: "center bottom",
    marginBottom: "14px"
  },
  [`.${tooltipClasses.popper}[data-popper-placement*="bottom"] &`]: {
    transformOrigin: "center top",
    marginTop: "14px"
  },
  variants: [{
    props: ({
      ownerState
    }) => ownerState.arrow,
    style: {
      position: "relative",
      margin: 0
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.touch,
    style: {
      padding: "8px 16px",
      fontSize: theme2.typography.pxToRem(14),
      lineHeight: `${round(16 / 14)}em`,
      fontWeight: theme2.typography.fontWeightRegular
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.isRtl,
    style: {
      [`.${tooltipClasses.popper}[data-popper-placement*="left"] &`]: {
        marginRight: "14px"
      },
      [`.${tooltipClasses.popper}[data-popper-placement*="right"] &`]: {
        marginLeft: "14px"
      }
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.isRtl && ownerState.touch,
    style: {
      [`.${tooltipClasses.popper}[data-popper-placement*="left"] &`]: {
        marginRight: "24px"
      },
      [`.${tooltipClasses.popper}[data-popper-placement*="right"] &`]: {
        marginLeft: "24px"
      }
    }
  }, {
    props: ({
      ownerState
    }) => !!ownerState.isRtl,
    style: {
      [`.${tooltipClasses.popper}[data-popper-placement*="left"] &`]: {
        marginLeft: "14px"
      },
      [`.${tooltipClasses.popper}[data-popper-placement*="right"] &`]: {
        marginRight: "14px"
      }
    }
  }, {
    props: ({
      ownerState
    }) => !!ownerState.isRtl && ownerState.touch,
    style: {
      [`.${tooltipClasses.popper}[data-popper-placement*="left"] &`]: {
        marginLeft: "24px"
      },
      [`.${tooltipClasses.popper}[data-popper-placement*="right"] &`]: {
        marginRight: "24px"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.touch,
    style: {
      [`.${tooltipClasses.popper}[data-popper-placement*="top"] &`]: {
        marginBottom: "24px"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.touch,
    style: {
      [`.${tooltipClasses.popper}[data-popper-placement*="bottom"] &`]: {
        marginTop: "24px"
      }
    }
  }]
})));
const TooltipArrow = styled("span", {
  name: "MuiTooltip",
  slot: "Arrow"
})(memoTheme(({
  theme: theme2
}) => ({
  overflow: "hidden",
  position: "absolute",
  width: "1em",
  height: "0.71em",
  boxSizing: "border-box",
  color: theme2.vars ? theme2.vars.palette.Tooltip.bg : theme2.alpha(theme2.palette.grey[700], 0.9),
  "&::before": {
    content: '""',
    margin: "auto",
    display: "block",
    width: "100%",
    height: "100%",
    backgroundColor: "currentColor",
    transform: "rotate(45deg)"
  }
})));
let hystersisOpen = false;
const hystersisTimer = new Timeout();
let cursorPosition = {
  x: 0,
  y: 0
};
function composeEventHandler(handler, eventHandler) {
  return (event, ...params) => {
    if (eventHandler) {
      eventHandler(event, ...params);
    }
    handler(event, ...params);
  };
}
const Tooltip = /* @__PURE__ */ reactExports.forwardRef(function Tooltip2(inProps, ref) {
  var _b, _c, _d;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTooltip"
  });
  const _a2 = props, {
    arrow: arrow2 = false,
    children: childrenProp,
    classes: classesProp,
    components = {},
    componentsProps = {},
    describeChild = false,
    disableFocusListener = false,
    disableHoverListener = false,
    disableInteractive: disableInteractiveProp = false,
    disableTouchListener = false,
    enterDelay = 100,
    enterNextDelay = 0,
    enterTouchDelay = 700,
    followCursor = false,
    id: idProp,
    leaveDelay = 0,
    leaveTouchDelay = 1500,
    onClose,
    onOpen,
    open: openProp,
    placement = "bottom",
    PopperComponent: PopperComponentProp,
    PopperProps = {},
    slotProps = {},
    slots = {},
    title,
    TransitionComponent: TransitionComponentProp,
    TransitionProps
  } = _a2, other = __objRest(_a2, [
    "arrow",
    "children",
    "classes",
    "components",
    "componentsProps",
    "describeChild",
    "disableFocusListener",
    "disableHoverListener",
    "disableInteractive",
    "disableTouchListener",
    "enterDelay",
    "enterNextDelay",
    "enterTouchDelay",
    "followCursor",
    "id",
    "leaveDelay",
    "leaveTouchDelay",
    "onClose",
    "onOpen",
    "open",
    "placement",
    "PopperComponent",
    "PopperProps",
    "slotProps",
    "slots",
    "title",
    "TransitionComponent",
    "TransitionProps"
  ]);
  const children = /* @__PURE__ */ reactExports.isValidElement(childrenProp) ? childrenProp : /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
    children: childrenProp
  });
  const theme2 = useTheme();
  const isRtl = useRtl();
  const [childNode, setChildNode] = reactExports.useState();
  const [arrowRef, setArrowRef] = reactExports.useState(null);
  const ignoreNonTouchEvents = reactExports.useRef(false);
  const disableInteractive = disableInteractiveProp || followCursor;
  const closeTimer = useTimeout();
  const enterTimer = useTimeout();
  const leaveTimer = useTimeout();
  const touchTimer = useTimeout();
  const [openState, setOpenState] = useControlled({
    controlled: openProp,
    default: false,
    name: "Tooltip",
    state: "open"
  });
  let open = openState;
  const id = useId(idProp);
  const prevUserSelect = reactExports.useRef();
  const stopTouchInteraction = useEventCallback(() => {
    if (prevUserSelect.current !== void 0) {
      document.body.style.WebkitUserSelect = prevUserSelect.current;
      prevUserSelect.current = void 0;
    }
    touchTimer.clear();
  });
  reactExports.useEffect(() => stopTouchInteraction, [stopTouchInteraction]);
  const handleOpen = (event) => {
    hystersisTimer.clear();
    hystersisOpen = true;
    setOpenState(true);
    if (onOpen && !open) {
      onOpen(event);
    }
  };
  const handleClose = useEventCallback(
    /**
     * @param {React.SyntheticEvent | Event} event
     */
    (event) => {
      hystersisTimer.start(800 + leaveDelay, () => {
        hystersisOpen = false;
      });
      setOpenState(false);
      if (onClose && open) {
        onClose(event);
      }
      closeTimer.start(theme2.transitions.duration.shortest, () => {
        ignoreNonTouchEvents.current = false;
      });
    }
  );
  const handleMouseOver = (event) => {
    if (ignoreNonTouchEvents.current && event.type !== "touchstart") {
      return;
    }
    if (childNode) {
      childNode.removeAttribute("title");
    }
    enterTimer.clear();
    leaveTimer.clear();
    if (enterDelay || hystersisOpen && enterNextDelay) {
      enterTimer.start(hystersisOpen ? enterNextDelay : enterDelay, () => {
        handleOpen(event);
      });
    } else {
      handleOpen(event);
    }
  };
  const handleMouseLeave = (event) => {
    enterTimer.clear();
    leaveTimer.start(leaveDelay, () => {
      handleClose(event);
    });
  };
  const [, setChildIsFocusVisible] = reactExports.useState(false);
  const handleBlur = (event) => {
    if (!isFocusVisible(event.target)) {
      setChildIsFocusVisible(false);
      handleMouseLeave(event);
    }
  };
  const handleFocus = (event) => {
    if (!childNode) {
      setChildNode(event.currentTarget);
    }
    if (isFocusVisible(event.target)) {
      setChildIsFocusVisible(true);
      handleMouseOver(event);
    }
  };
  const detectTouchStart = (event) => {
    ignoreNonTouchEvents.current = true;
    const childrenProps2 = children.props;
    if (childrenProps2.onTouchStart) {
      childrenProps2.onTouchStart(event);
    }
  };
  const handleTouchStart = (event) => {
    detectTouchStart(event);
    leaveTimer.clear();
    closeTimer.clear();
    stopTouchInteraction();
    prevUserSelect.current = document.body.style.WebkitUserSelect;
    document.body.style.WebkitUserSelect = "none";
    touchTimer.start(enterTouchDelay, () => {
      document.body.style.WebkitUserSelect = prevUserSelect.current;
      handleMouseOver(event);
    });
  };
  const handleTouchEnd = (event) => {
    if (children.props.onTouchEnd) {
      children.props.onTouchEnd(event);
    }
    stopTouchInteraction();
    leaveTimer.start(leaveTouchDelay, () => {
      handleClose(event);
    });
  };
  reactExports.useEffect(() => {
    if (!open) {
      return void 0;
    }
    function handleKeyDown(nativeEvent) {
      if (nativeEvent.key === "Escape") {
        handleClose(nativeEvent);
      }
    }
    document.addEventListener("keydown", handleKeyDown);
    return () => {
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, [handleClose, open]);
  const handleRef = useForkRef(getReactElementRef(children), setChildNode, ref);
  if (!title && title !== 0) {
    open = false;
  }
  const popperRef = reactExports.useRef();
  const handleMouseMove = (event) => {
    const childrenProps2 = children.props;
    if (childrenProps2.onMouseMove) {
      childrenProps2.onMouseMove(event);
    }
    cursorPosition = {
      x: event.clientX,
      y: event.clientY
    };
    if (popperRef.current) {
      popperRef.current.update();
    }
  };
  const nameOrDescProps = {};
  const titleIsString = typeof title === "string";
  if (describeChild) {
    nameOrDescProps.title = !open && titleIsString && !disableHoverListener ? title : null;
    nameOrDescProps["aria-describedby"] = open ? id : null;
  } else {
    nameOrDescProps["aria-label"] = titleIsString ? title : null;
    nameOrDescProps["aria-labelledby"] = open && !titleIsString ? id : null;
  }
  const childrenProps = __spreadValues(__spreadProps(__spreadValues(__spreadValues(__spreadValues({}, nameOrDescProps), other), children.props), {
    className: clsx(other.className, children.props.className),
    onTouchStart: detectTouchStart,
    ref: handleRef
  }), followCursor ? {
    onMouseMove: handleMouseMove
  } : {});
  const interactiveWrapperListeners = {};
  if (!disableTouchListener) {
    childrenProps.onTouchStart = handleTouchStart;
    childrenProps.onTouchEnd = handleTouchEnd;
  }
  if (!disableHoverListener) {
    childrenProps.onMouseOver = composeEventHandler(handleMouseOver, childrenProps.onMouseOver);
    childrenProps.onMouseLeave = composeEventHandler(handleMouseLeave, childrenProps.onMouseLeave);
    if (!disableInteractive) {
      interactiveWrapperListeners.onMouseOver = handleMouseOver;
      interactiveWrapperListeners.onMouseLeave = handleMouseLeave;
    }
  }
  if (!disableFocusListener) {
    childrenProps.onFocus = composeEventHandler(handleFocus, childrenProps.onFocus);
    childrenProps.onBlur = composeEventHandler(handleBlur, childrenProps.onBlur);
    if (!disableInteractive) {
      interactiveWrapperListeners.onFocus = handleFocus;
      interactiveWrapperListeners.onBlur = handleBlur;
    }
  }
  const ownerState = __spreadProps(__spreadValues({}, props), {
    isRtl,
    arrow: arrow2,
    disableInteractive,
    placement,
    PopperComponentProp,
    touch: ignoreNonTouchEvents.current
  });
  const resolvedPopperProps = typeof slotProps.popper === "function" ? slotProps.popper(ownerState) : slotProps.popper;
  const popperOptions = reactExports.useMemo(() => {
    var _a3, _b2;
    let tooltipModifiers = [{
      name: "arrow",
      enabled: Boolean(arrowRef),
      options: {
        element: arrowRef,
        padding: 4
      }
    }];
    if ((_a3 = PopperProps.popperOptions) == null ? void 0 : _a3.modifiers) {
      tooltipModifiers = tooltipModifiers.concat(PopperProps.popperOptions.modifiers);
    }
    if ((_b2 = resolvedPopperProps == null ? void 0 : resolvedPopperProps.popperOptions) == null ? void 0 : _b2.modifiers) {
      tooltipModifiers = tooltipModifiers.concat(resolvedPopperProps.popperOptions.modifiers);
    }
    return __spreadProps(__spreadValues(__spreadValues({}, PopperProps.popperOptions), resolvedPopperProps == null ? void 0 : resolvedPopperProps.popperOptions), {
      modifiers: tooltipModifiers
    });
  }, [arrowRef, PopperProps.popperOptions, resolvedPopperProps == null ? void 0 : resolvedPopperProps.popperOptions]);
  const classes = useUtilityClasses$i(ownerState);
  const resolvedTransitionProps = typeof slotProps.transition === "function" ? slotProps.transition(ownerState) : slotProps.transition;
  const externalForwardedProps = {
    slots: __spreadValues({
      popper: components.Popper,
      transition: (_b = components.Transition) != null ? _b : TransitionComponentProp,
      tooltip: components.Tooltip,
      arrow: components.Arrow
    }, slots),
    slotProps: {
      arrow: (_c = slotProps.arrow) != null ? _c : componentsProps.arrow,
      popper: __spreadValues(__spreadValues({}, PopperProps), resolvedPopperProps != null ? resolvedPopperProps : componentsProps.popper),
      // resolvedPopperProps can be spread because it's already an object
      tooltip: (_d = slotProps.tooltip) != null ? _d : componentsProps.tooltip,
      transition: __spreadValues(__spreadValues({}, TransitionProps), resolvedTransitionProps != null ? resolvedTransitionProps : componentsProps.transition)
    }
  };
  const [PopperSlot, popperSlotProps] = useSlot("popper", {
    elementType: TooltipPopper,
    externalForwardedProps,
    ownerState,
    className: clsx(classes.popper, PopperProps == null ? void 0 : PopperProps.className)
  });
  const [TransitionSlot, transitionSlotProps] = useSlot("transition", {
    elementType: Grow,
    externalForwardedProps,
    ownerState
  });
  const [TooltipSlot, tooltipSlotProps] = useSlot("tooltip", {
    elementType: TooltipTooltip,
    className: classes.tooltip,
    externalForwardedProps,
    ownerState
  });
  const [ArrowSlot, arrowSlotProps] = useSlot("arrow", {
    elementType: TooltipArrow,
    className: classes.arrow,
    externalForwardedProps,
    ownerState,
    ref: setArrowRef
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ reactExports.cloneElement(children, childrenProps), /* @__PURE__ */ jsxRuntimeExports.jsx(PopperSlot, __spreadProps(__spreadValues(__spreadValues({
      as: PopperComponentProp != null ? PopperComponentProp : Popper,
      placement,
      anchorEl: followCursor ? {
        getBoundingClientRect: () => ({
          top: cursorPosition.y,
          left: cursorPosition.x,
          right: cursorPosition.x,
          bottom: cursorPosition.y,
          width: 0,
          height: 0
        })
      } : childNode,
      popperRef,
      open: childNode ? open : false,
      id,
      transition: true
    }, interactiveWrapperListeners), popperSlotProps), {
      popperOptions,
      children: ({
        TransitionProps: TransitionPropsInner
      }) => /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionSlot, __spreadProps(__spreadValues(__spreadValues({
        timeout: theme2.transitions.duration.shorter
      }, TransitionPropsInner), transitionSlotProps), {
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TooltipSlot, __spreadProps(__spreadValues({}, tooltipSlotProps), {
          children: [title, arrow2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowSlot, __spreadValues({}, arrowSlotProps)) : null]
        }))
      }))
    }))]
  });
});
const Stack = createStack({
  createStyledComponent: styled("div", {
    name: "MuiStack",
    slot: "Root"
  }),
  useThemeProps: (inProps) => useDefaultProps({
    props: inProps,
    name: "MuiStack"
  })
});
const StepperContext = /* @__PURE__ */ reactExports.createContext({});
const StepContext = /* @__PURE__ */ reactExports.createContext({});
function getStepUtilityClass(slot) {
  return generateUtilityClass("MuiStep", slot);
}
generateUtilityClasses("MuiStep", ["root", "horizontal", "vertical", "alternativeLabel", "completed"]);
const useUtilityClasses$h = (ownerState) => {
  const {
    classes,
    orientation,
    alternativeLabel,
    completed
  } = ownerState;
  const slots = {
    root: ["root", orientation, alternativeLabel && "alternativeLabel", completed && "completed"]
  };
  return composeClasses(slots, getStepUtilityClass, classes);
};
const StepRoot = styled("div", {
  name: "MuiStep",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.orientation], ownerState.alternativeLabel && styles2.alternativeLabel, ownerState.completed && styles2.completed];
  }
})({
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      paddingLeft: 8,
      paddingRight: 8
    }
  }, {
    props: {
      alternativeLabel: true
    },
    style: {
      flex: 1,
      position: "relative"
    }
  }]
});
const Step = /* @__PURE__ */ reactExports.forwardRef(function Step2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiStep"
  });
  const _a2 = props, {
    active: activeProp,
    children,
    className,
    component = "div",
    completed: completedProp,
    disabled: disabledProp,
    expanded = false,
    index: index2,
    last
  } = _a2, other = __objRest(_a2, [
    "active",
    "children",
    "className",
    "component",
    "completed",
    "disabled",
    "expanded",
    "index",
    "last"
  ]);
  const {
    activeStep,
    connector,
    alternativeLabel,
    orientation,
    nonLinear
  } = reactExports.useContext(StepperContext);
  let [active = false, completed = false, disabled = false] = [activeProp, completedProp, disabledProp];
  if (activeStep === index2) {
    active = activeProp !== void 0 ? activeProp : true;
  } else if (!nonLinear && activeStep > index2) {
    completed = completedProp !== void 0 ? completedProp : true;
  } else if (!nonLinear && activeStep < index2) {
    disabled = disabledProp !== void 0 ? disabledProp : true;
  }
  const contextValue = reactExports.useMemo(() => ({
    index: index2,
    last,
    expanded,
    icon: index2 + 1,
    active,
    completed,
    disabled
  }), [index2, last, expanded, active, completed, disabled]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    active,
    orientation,
    alternativeLabel,
    completed,
    disabled,
    expanded,
    component
  });
  const classes = useUtilityClasses$h(ownerState);
  const newChildren = /* @__PURE__ */ jsxRuntimeExports.jsxs(StepRoot, __spreadProps(__spreadValues({
    as: component,
    className: clsx(classes.root, className),
    ref,
    ownerState
  }, other), {
    children: [connector && alternativeLabel && index2 !== 0 ? connector : null, children]
  }));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(StepContext.Provider, {
    value: contextValue,
    children: connector && !alternativeLabel && index2 !== 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [connector, newChildren]
    }) : newChildren
  });
});
const CheckCircle = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 0a12 12 0 1 0 0 24 12 12 0 0 0 0-24zm-2 17l-5-5 1.4-1.4 3.6 3.6 7.6-7.6L19 8l-9 9z"
}));
const Warning = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"
}));
function getStepIconUtilityClass(slot) {
  return generateUtilityClass("MuiStepIcon", slot);
}
const stepIconClasses = generateUtilityClasses("MuiStepIcon", ["root", "active", "completed", "error", "text"]);
var _circle;
const useUtilityClasses$g = (ownerState) => {
  const {
    classes,
    active,
    completed,
    error: error2
  } = ownerState;
  const slots = {
    root: ["root", active && "active", completed && "completed", error2 && "error"],
    text: ["text"]
  };
  return composeClasses(slots, getStepIconUtilityClass, classes);
};
const StepIconRoot = styled(SvgIcon, {
  name: "MuiStepIcon",
  slot: "Root"
})(memoTheme(({
  theme: theme2
}) => ({
  display: "block",
  transition: theme2.transitions.create("color", {
    duration: theme2.transitions.duration.shortest
  }),
  color: (theme2.vars || theme2).palette.text.disabled,
  [`&.${stepIconClasses.completed}`]: {
    color: (theme2.vars || theme2).palette.primary.main
  },
  [`&.${stepIconClasses.active}`]: {
    color: (theme2.vars || theme2).palette.primary.main
  },
  [`&.${stepIconClasses.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  }
})));
const StepIconText = styled("text", {
  name: "MuiStepIcon",
  slot: "Text"
})(memoTheme(({
  theme: theme2
}) => ({
  fill: (theme2.vars || theme2).palette.primary.contrastText,
  fontSize: theme2.typography.caption.fontSize,
  fontFamily: theme2.typography.fontFamily
})));
const StepIcon = /* @__PURE__ */ reactExports.forwardRef(function StepIcon2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiStepIcon"
  });
  const _a2 = props, {
    active = false,
    className: classNameProp,
    completed = false,
    error: error2 = false,
    icon
  } = _a2, other = __objRest(_a2, [
    "active",
    "className",
    "completed",
    "error",
    "icon"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    active,
    completed,
    error: error2
  });
  const classes = useUtilityClasses$g(ownerState);
  if (typeof icon === "number" || typeof icon === "string") {
    const className = clsx(classNameProp, classes.root);
    if (error2) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(StepIconRoot, __spreadValues({
        as: Warning,
        className,
        ref,
        ownerState
      }, other));
    }
    if (completed) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(StepIconRoot, __spreadValues({
        as: CheckCircle,
        className,
        ref,
        ownerState
      }, other));
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(StepIconRoot, __spreadProps(__spreadValues({
      className,
      ref,
      ownerState
    }, other), {
      children: [_circle || (_circle = /* @__PURE__ */ jsxRuntimeExports.jsx("circle", {
        cx: "12",
        cy: "12",
        r: "12"
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(StepIconText, {
        className: classes.text,
        x: "12",
        y: "12",
        textAnchor: "middle",
        dominantBaseline: "central",
        ownerState,
        children: icon
      })]
    }));
  }
  return icon;
});
function getStepLabelUtilityClass(slot) {
  return generateUtilityClass("MuiStepLabel", slot);
}
const stepLabelClasses = generateUtilityClasses("MuiStepLabel", ["root", "horizontal", "vertical", "label", "active", "completed", "error", "disabled", "iconContainer", "alternativeLabel", "labelContainer"]);
const useUtilityClasses$f = (ownerState) => {
  const {
    classes,
    orientation,
    active,
    completed,
    error: error2,
    disabled,
    alternativeLabel
  } = ownerState;
  const slots = {
    root: ["root", orientation, error2 && "error", disabled && "disabled", alternativeLabel && "alternativeLabel"],
    label: ["label", active && "active", completed && "completed", error2 && "error", disabled && "disabled", alternativeLabel && "alternativeLabel"],
    iconContainer: ["iconContainer", active && "active", completed && "completed", error2 && "error", disabled && "disabled", alternativeLabel && "alternativeLabel"],
    labelContainer: ["labelContainer", alternativeLabel && "alternativeLabel"]
  };
  return composeClasses(slots, getStepLabelUtilityClass, classes);
};
const StepLabelRoot = styled("span", {
  name: "MuiStepLabel",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.orientation]];
  }
})({
  display: "flex",
  alignItems: "center",
  [`&.${stepLabelClasses.alternativeLabel}`]: {
    flexDirection: "column"
  },
  [`&.${stepLabelClasses.disabled}`]: {
    cursor: "default"
  },
  variants: [{
    props: {
      orientation: "vertical"
    },
    style: {
      textAlign: "left",
      padding: "8px 0"
    }
  }]
});
const StepLabelLabel = styled("span", {
  name: "MuiStepLabel",
  slot: "Label"
})(memoTheme(({
  theme: theme2
}) => __spreadProps(__spreadValues({}, theme2.typography.body2), {
  display: "block",
  transition: theme2.transitions.create("color", {
    duration: theme2.transitions.duration.shortest
  }),
  [`&.${stepLabelClasses.active}`]: {
    color: (theme2.vars || theme2).palette.text.primary,
    fontWeight: 500
  },
  [`&.${stepLabelClasses.completed}`]: {
    color: (theme2.vars || theme2).palette.text.primary,
    fontWeight: 500
  },
  [`&.${stepLabelClasses.alternativeLabel}`]: {
    marginTop: 16
  },
  [`&.${stepLabelClasses.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  }
})));
const StepLabelIconContainer = styled("span", {
  name: "MuiStepLabel",
  slot: "IconContainer"
})({
  flexShrink: 0,
  display: "flex",
  paddingRight: 8,
  [`&.${stepLabelClasses.alternativeLabel}`]: {
    paddingRight: 0
  }
});
const StepLabelLabelContainer = styled("span", {
  name: "MuiStepLabel",
  slot: "LabelContainer"
})(memoTheme(({
  theme: theme2
}) => ({
  width: "100%",
  color: (theme2.vars || theme2).palette.text.secondary,
  [`&.${stepLabelClasses.alternativeLabel}`]: {
    textAlign: "center"
  }
})));
const StepLabel = /* @__PURE__ */ reactExports.forwardRef(function StepLabel2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiStepLabel"
  });
  const _a2 = props, {
    children,
    className,
    componentsProps = {},
    error: error2 = false,
    icon: iconProp,
    optional,
    slots = {},
    slotProps = {},
    StepIconComponent: StepIconComponentProp,
    StepIconProps
  } = _a2, other = __objRest(_a2, [
    "children",
    "className",
    "componentsProps",
    "error",
    "icon",
    "optional",
    "slots",
    "slotProps",
    "StepIconComponent",
    "StepIconProps"
  ]);
  const {
    alternativeLabel,
    orientation
  } = reactExports.useContext(StepperContext);
  const {
    active,
    disabled,
    completed,
    icon: iconContext
  } = reactExports.useContext(StepContext);
  const icon = iconProp || iconContext;
  let StepIconComponent = StepIconComponentProp;
  if (icon && !StepIconComponent) {
    StepIconComponent = StepIcon;
  }
  const ownerState = __spreadProps(__spreadValues({}, props), {
    active,
    alternativeLabel,
    completed,
    disabled,
    error: error2,
    orientation
  });
  const classes = useUtilityClasses$f(ownerState);
  const externalForwardedProps = {
    slots,
    slotProps: __spreadValues(__spreadValues({
      stepIcon: StepIconProps
    }, componentsProps), slotProps)
  };
  const [RootSlot, rootProps] = useSlot("root", {
    elementType: StepLabelRoot,
    externalForwardedProps: __spreadValues(__spreadValues({}, externalForwardedProps), other),
    ownerState,
    ref,
    className: clsx(classes.root, className)
  });
  const [LabelSlot, labelProps] = useSlot("label", {
    elementType: StepLabelLabel,
    externalForwardedProps,
    ownerState
  });
  const [StepIconSlot, stepIconProps] = useSlot("stepIcon", {
    elementType: StepIconComponent,
    externalForwardedProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, __spreadProps(__spreadValues({}, rootProps), {
    children: [icon || StepIconSlot ? /* @__PURE__ */ jsxRuntimeExports.jsx(StepLabelIconContainer, {
      className: classes.iconContainer,
      ownerState,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(StepIconSlot, __spreadValues({
        completed,
        active,
        error: error2,
        icon
      }, stepIconProps))
    }) : null, /* @__PURE__ */ jsxRuntimeExports.jsxs(StepLabelLabelContainer, {
      className: classes.labelContainer,
      ownerState,
      children: [children ? /* @__PURE__ */ jsxRuntimeExports.jsx(LabelSlot, __spreadProps(__spreadValues({}, labelProps), {
        className: clsx(classes.label, labelProps == null ? void 0 : labelProps.className),
        children
      })) : null, optional]
    })]
  }));
});
StepLabel.muiName = "StepLabel";
function getStepConnectorUtilityClass(slot) {
  return generateUtilityClass("MuiStepConnector", slot);
}
generateUtilityClasses("MuiStepConnector", ["root", "horizontal", "vertical", "alternativeLabel", "active", "completed", "disabled", "line", "lineHorizontal", "lineVertical"]);
const useUtilityClasses$e = (ownerState) => {
  const {
    classes,
    orientation,
    alternativeLabel,
    active,
    completed,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", orientation, alternativeLabel && "alternativeLabel", active && "active", completed && "completed", disabled && "disabled"],
    line: ["line", `line${capitalize(orientation)}`]
  };
  return composeClasses(slots, getStepConnectorUtilityClass, classes);
};
const StepConnectorRoot = styled("div", {
  name: "MuiStepConnector",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.orientation], ownerState.alternativeLabel && styles2.alternativeLabel, ownerState.completed && styles2.completed];
  }
})({
  flex: "1 1 auto",
  variants: [{
    props: {
      orientation: "vertical"
    },
    style: {
      marginLeft: 12
      // half icon
    }
  }, {
    props: {
      alternativeLabel: true
    },
    style: {
      position: "absolute",
      top: 8 + 4,
      left: "calc(-50% + 20px)",
      right: "calc(50% + 20px)"
    }
  }]
});
const StepConnectorLine = styled("span", {
  name: "MuiStepConnector",
  slot: "Line",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.line, styles2[`line${capitalize(ownerState.orientation)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => {
  const borderColor2 = theme2.palette.mode === "light" ? theme2.palette.grey[400] : theme2.palette.grey[600];
  return {
    display: "block",
    borderColor: theme2.vars ? theme2.vars.palette.StepConnector.border : borderColor2,
    variants: [{
      props: {
        orientation: "horizontal"
      },
      style: {
        borderTopStyle: "solid",
        borderTopWidth: 1
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        borderLeftStyle: "solid",
        borderLeftWidth: 1,
        minHeight: 24
      }
    }]
  };
}));
const StepConnector = /* @__PURE__ */ reactExports.forwardRef(function StepConnector2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiStepConnector"
  });
  const _a2 = props, {
    className
  } = _a2, other = __objRest(_a2, [
    "className"
  ]);
  const {
    alternativeLabel,
    orientation = "horizontal"
  } = reactExports.useContext(StepperContext);
  const {
    active,
    disabled,
    completed
  } = reactExports.useContext(StepContext);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    alternativeLabel,
    orientation,
    active,
    completed,
    disabled
  });
  const classes = useUtilityClasses$e(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(StepConnectorRoot, __spreadProps(__spreadValues({
    className: clsx(classes.root, className),
    ref,
    ownerState
  }, other), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(StepConnectorLine, {
      className: classes.line,
      ownerState
    })
  }));
});
function getStepperUtilityClass(slot) {
  return generateUtilityClass("MuiStepper", slot);
}
generateUtilityClasses("MuiStepper", ["root", "horizontal", "vertical", "nonLinear", "alternativeLabel"]);
const useUtilityClasses$d = (ownerState) => {
  const {
    orientation,
    nonLinear,
    alternativeLabel,
    classes
  } = ownerState;
  const slots = {
    root: ["root", orientation, nonLinear && "nonLinear", alternativeLabel && "alternativeLabel"]
  };
  return composeClasses(slots, getStepperUtilityClass, classes);
};
const StepperRoot = styled("div", {
  name: "MuiStepper",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.orientation], ownerState.alternativeLabel && styles2.alternativeLabel, ownerState.nonLinear && styles2.nonLinear];
  }
})({
  display: "flex",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      flexDirection: "row",
      alignItems: "center"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      flexDirection: "column"
    }
  }, {
    props: {
      alternativeLabel: true
    },
    style: {
      alignItems: "flex-start"
    }
  }]
});
const defaultConnector = /* @__PURE__ */ jsxRuntimeExports.jsx(StepConnector, {});
const Stepper = /* @__PURE__ */ reactExports.forwardRef(function Stepper2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiStepper"
  });
  const _a2 = props, {
    activeStep = 0,
    alternativeLabel = false,
    children,
    className,
    component = "div",
    connector = defaultConnector,
    nonLinear = false,
    orientation = "horizontal"
  } = _a2, other = __objRest(_a2, [
    "activeStep",
    "alternativeLabel",
    "children",
    "className",
    "component",
    "connector",
    "nonLinear",
    "orientation"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    nonLinear,
    alternativeLabel,
    orientation,
    component
  });
  const classes = useUtilityClasses$d(ownerState);
  const childrenArray = reactExports.Children.toArray(children).filter(Boolean);
  const steps = childrenArray.map((step, index2) => {
    return /* @__PURE__ */ reactExports.cloneElement(step, __spreadValues({
      index: index2,
      last: index2 + 1 === childrenArray.length
    }, step.props));
  });
  const contextValue = reactExports.useMemo(() => ({
    activeStep,
    alternativeLabel,
    connector,
    nonLinear,
    orientation
  }), [activeStep, alternativeLabel, connector, nonLinear, orientation]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(StepperContext.Provider, {
    value: contextValue,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(StepperRoot, __spreadProps(__spreadValues({
      as: component,
      ownerState,
      className: clsx(classes.root, className),
      ref
    }, other), {
      children: steps
    }))
  });
});
function getSwitchUtilityClass(slot) {
  return generateUtilityClass("MuiSwitch", slot);
}
const switchClasses = generateUtilityClasses("MuiSwitch", ["root", "edgeStart", "edgeEnd", "switchBase", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium", "checked", "disabled", "input", "thumb", "track"]);
const useUtilityClasses$c = (ownerState) => {
  const {
    classes,
    edge,
    size,
    color: color2,
    checked,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", edge && `edge${capitalize(edge)}`, `size${capitalize(size)}`],
    switchBase: ["switchBase", `color${capitalize(color2)}`, checked && "checked", disabled && "disabled"],
    thumb: ["thumb"],
    track: ["track"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getSwitchUtilityClass, classes);
  return __spreadValues(__spreadValues({}, classes), composedClasses);
};
const SwitchRoot = styled("span", {
  name: "MuiSwitch",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.edge && styles2[`edge${capitalize(ownerState.edge)}`], styles2[`size${capitalize(ownerState.size)}`]];
  }
})({
  display: "inline-flex",
  width: 34 + 12 * 2,
  height: 14 + 12 * 2,
  overflow: "hidden",
  padding: 12,
  boxSizing: "border-box",
  position: "relative",
  flexShrink: 0,
  zIndex: 0,
  // Reset the stacking context.
  verticalAlign: "middle",
  // For correct alignment with the text.
  "@media print": {
    colorAdjust: "exact"
  },
  variants: [{
    props: {
      edge: "start"
    },
    style: {
      marginLeft: -8
    }
  }, {
    props: {
      edge: "end"
    },
    style: {
      marginRight: -8
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      width: 40,
      height: 24,
      padding: 7,
      [`& .${switchClasses.thumb}`]: {
        width: 16,
        height: 16
      },
      [`& .${switchClasses.switchBase}`]: {
        padding: 4,
        [`&.${switchClasses.checked}`]: {
          transform: "translateX(16px)"
        }
      }
    }
  }]
});
const SwitchSwitchBase = styled(SwitchBase, {
  name: "MuiSwitch",
  slot: "SwitchBase",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.switchBase, {
      [`& .${switchClasses.input}`]: styles2.input
    }, ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  position: "absolute",
  top: 0,
  left: 0,
  zIndex: 1,
  // Render above the focus ripple.
  color: theme2.vars ? theme2.vars.palette.Switch.defaultColor : `${theme2.palette.mode === "light" ? theme2.palette.common.white : theme2.palette.grey[300]}`,
  transition: theme2.transitions.create(["left", "transform"], {
    duration: theme2.transitions.duration.shortest
  }),
  [`&.${switchClasses.checked}`]: {
    transform: "translateX(20px)"
  },
  [`&.${switchClasses.disabled}`]: {
    color: theme2.vars ? theme2.vars.palette.Switch.defaultDisabledColor : `${theme2.palette.mode === "light" ? theme2.palette.grey[100] : theme2.palette.grey[600]}`
  },
  [`&.${switchClasses.checked} + .${switchClasses.track}`]: {
    opacity: 0.5
  },
  [`&.${switchClasses.disabled} + .${switchClasses.track}`]: {
    opacity: theme2.vars ? theme2.vars.opacity.switchTrackDisabled : `${theme2.palette.mode === "light" ? 0.12 : 0.2}`
  },
  [`& .${switchClasses.input}`]: {
    left: "-100%",
    width: "300%"
  }
})), memoTheme(({
  theme: theme2
}) => ({
  "&:hover": {
    backgroundColor: theme2.alpha((theme2.vars || theme2).palette.action.active, (theme2.vars || theme2).palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  variants: [...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["light"])).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      [`&.${switchClasses.checked}`]: {
        color: (theme2.vars || theme2).palette[color2].main,
        "&:hover": {
          backgroundColor: theme2.alpha((theme2.vars || theme2).palette[color2].main, (theme2.vars || theme2).palette.action.hoverOpacity),
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        },
        [`&.${switchClasses.disabled}`]: {
          color: theme2.vars ? theme2.vars.palette.Switch[`${color2}DisabledColor`] : `${theme2.palette.mode === "light" ? theme2.lighten(theme2.palette[color2].main, 0.62) : theme2.darken(theme2.palette[color2].main, 0.55)}`
        }
      },
      [`&.${switchClasses.checked} + .${switchClasses.track}`]: {
        backgroundColor: (theme2.vars || theme2).palette[color2].main
      }
    }
  }))]
})));
const SwitchTrack = styled("span", {
  name: "MuiSwitch",
  slot: "Track"
})(memoTheme(({
  theme: theme2
}) => ({
  height: "100%",
  width: "100%",
  borderRadius: 14 / 2,
  zIndex: -1,
  transition: theme2.transitions.create(["opacity", "background-color"], {
    duration: theme2.transitions.duration.shortest
  }),
  backgroundColor: theme2.vars ? theme2.vars.palette.common.onBackground : `${theme2.palette.mode === "light" ? theme2.palette.common.black : theme2.palette.common.white}`,
  opacity: theme2.vars ? theme2.vars.opacity.switchTrack : `${theme2.palette.mode === "light" ? 0.38 : 0.3}`
})));
const SwitchThumb = styled("span", {
  name: "MuiSwitch",
  slot: "Thumb"
})(memoTheme(({
  theme: theme2
}) => ({
  boxShadow: (theme2.vars || theme2).shadows[1],
  backgroundColor: "currentColor",
  width: 20,
  height: 20,
  borderRadius: "50%"
})));
const Switch = /* @__PURE__ */ reactExports.forwardRef(function Switch2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSwitch"
  });
  const _a2 = props, {
    className,
    color: color2 = "primary",
    edge = false,
    size = "medium",
    sx,
    slots = {},
    slotProps = {}
  } = _a2, other = __objRest(_a2, [
    "className",
    "color",
    "edge",
    "size",
    "sx",
    "slots",
    "slotProps"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: color2,
    edge,
    size
  });
  const classes = useUtilityClasses$c(ownerState);
  const externalForwardedProps = {
    slots,
    slotProps
  };
  const [RootSlot, rootSlotProps] = useSlot("root", {
    className: clsx(classes.root, className),
    elementType: SwitchRoot,
    externalForwardedProps,
    ownerState,
    additionalProps: {
      sx
    }
  });
  const [ThumbSlot, thumbSlotProps] = useSlot("thumb", {
    className: classes.thumb,
    elementType: SwitchThumb,
    externalForwardedProps,
    ownerState
  });
  const icon = /* @__PURE__ */ jsxRuntimeExports.jsx(ThumbSlot, __spreadValues({}, thumbSlotProps));
  const [TrackSlot, trackSlotProps] = useSlot("track", {
    className: classes.track,
    elementType: SwitchTrack,
    externalForwardedProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, __spreadProps(__spreadValues({}, rootSlotProps), {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SwitchSwitchBase, __spreadProps(__spreadValues({
      type: "checkbox",
      icon,
      checkedIcon: icon,
      ref,
      ownerState
    }, other), {
      classes: __spreadProps(__spreadValues({}, classes), {
        root: classes.switchBase
      }),
      slots: __spreadValues(__spreadValues({}, slots.switchBase && {
        root: slots.switchBase
      }), slots.input && {
        input: slots.input
      }),
      slotProps: __spreadValues(__spreadProps(__spreadValues({}, slotProps.switchBase && {
        root: typeof slotProps.switchBase === "function" ? slotProps.switchBase(ownerState) : slotProps.switchBase
      }), {
        input: {
          role: "switch"
        }
      }), slotProps.input && {
        input: typeof slotProps.input === "function" ? slotProps.input(ownerState) : slotProps.input
      })
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(TrackSlot, __spreadValues({}, trackSlotProps))]
  }));
});
function getTabUtilityClass(slot) {
  return generateUtilityClass("MuiTab", slot);
}
const tabClasses = generateUtilityClasses("MuiTab", ["root", "labelIcon", "textColorInherit", "textColorPrimary", "textColorSecondary", "selected", "disabled", "fullWidth", "wrapped", "iconWrapper", "icon"]);
const useUtilityClasses$b = (ownerState) => {
  const {
    classes,
    textColor,
    fullWidth,
    wrapped,
    icon,
    label,
    selected,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", icon && label && "labelIcon", `textColor${capitalize(textColor)}`, fullWidth && "fullWidth", wrapped && "wrapped", selected && "selected", disabled && "disabled"],
    icon: ["iconWrapper", "icon"]
  };
  return composeClasses(slots, getTabUtilityClass, classes);
};
const TabRoot = styled(ButtonBase, {
  name: "MuiTab",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.label && ownerState.icon && styles2.labelIcon, styles2[`textColor${capitalize(ownerState.textColor)}`], ownerState.fullWidth && styles2.fullWidth, ownerState.wrapped && styles2.wrapped, {
      [`& .${tabClasses.iconWrapper}`]: styles2.iconWrapper
    }, {
      [`& .${tabClasses.icon}`]: styles2.icon
    }];
  }
})(memoTheme(({
  theme: theme2
}) => __spreadProps(__spreadValues({}, theme2.typography.button), {
  maxWidth: 360,
  minWidth: 90,
  position: "relative",
  minHeight: 48,
  flexShrink: 0,
  padding: "12px 16px",
  overflow: "hidden",
  whiteSpace: "normal",
  textAlign: "center",
  lineHeight: 1.25,
  variants: [{
    props: ({
      ownerState
    }) => ownerState.label && (ownerState.iconPosition === "top" || ownerState.iconPosition === "bottom"),
    style: {
      flexDirection: "column"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.label && ownerState.iconPosition !== "top" && ownerState.iconPosition !== "bottom",
    style: {
      flexDirection: "row"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.icon && ownerState.label,
    style: {
      minHeight: 72,
      paddingTop: 9,
      paddingBottom: 9
    }
  }, {
    props: ({
      ownerState,
      iconPosition
    }) => ownerState.icon && ownerState.label && iconPosition === "top",
    style: {
      [`& > .${tabClasses.icon}`]: {
        marginBottom: 6
      }
    }
  }, {
    props: ({
      ownerState,
      iconPosition
    }) => ownerState.icon && ownerState.label && iconPosition === "bottom",
    style: {
      [`& > .${tabClasses.icon}`]: {
        marginTop: 6
      }
    }
  }, {
    props: ({
      ownerState,
      iconPosition
    }) => ownerState.icon && ownerState.label && iconPosition === "start",
    style: {
      [`& > .${tabClasses.icon}`]: {
        marginRight: theme2.spacing(1)
      }
    }
  }, {
    props: ({
      ownerState,
      iconPosition
    }) => ownerState.icon && ownerState.label && iconPosition === "end",
    style: {
      [`& > .${tabClasses.icon}`]: {
        marginLeft: theme2.spacing(1)
      }
    }
  }, {
    props: {
      textColor: "inherit"
    },
    style: {
      color: "inherit",
      opacity: 0.6,
      // same opacity as theme.palette.text.secondary
      [`&.${tabClasses.selected}`]: {
        opacity: 1
      },
      [`&.${tabClasses.disabled}`]: {
        opacity: (theme2.vars || theme2).palette.action.disabledOpacity
      }
    }
  }, {
    props: {
      textColor: "primary"
    },
    style: {
      color: (theme2.vars || theme2).palette.text.secondary,
      [`&.${tabClasses.selected}`]: {
        color: (theme2.vars || theme2).palette.primary.main
      },
      [`&.${tabClasses.disabled}`]: {
        color: (theme2.vars || theme2).palette.text.disabled
      }
    }
  }, {
    props: {
      textColor: "secondary"
    },
    style: {
      color: (theme2.vars || theme2).palette.text.secondary,
      [`&.${tabClasses.selected}`]: {
        color: (theme2.vars || theme2).palette.secondary.main
      },
      [`&.${tabClasses.disabled}`]: {
        color: (theme2.vars || theme2).palette.text.disabled
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.fullWidth,
    style: {
      flexShrink: 1,
      flexGrow: 1,
      flexBasis: 0,
      maxWidth: "none"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.wrapped,
    style: {
      fontSize: theme2.typography.pxToRem(12)
    }
  }]
})));
const Tab = /* @__PURE__ */ reactExports.forwardRef(function Tab2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTab"
  });
  const _a2 = props, {
    className,
    disabled = false,
    disableFocusRipple = false,
    fullWidth: fullWidth,
    icon: iconProp,
    iconPosition = "top",
    indicator: indicator,
    label,
    onChange,
    onClick,
    onFocus,
    selected: selected,
    selectionFollowsFocus: selectionFollowsFocus,
    textColor: textColor = "inherit",
    value,
    wrapped = false
  } = _a2, other = __objRest(_a2, [
    "className",
    "disabled",
    "disableFocusRipple",
    // eslint-disable-next-line react/prop-types
    "fullWidth",
    "icon",
    "iconPosition",
    // eslint-disable-next-line react/prop-types
    "indicator",
    "label",
    "onChange",
    "onClick",
    "onFocus",
    // eslint-disable-next-line react/prop-types
    "selected",
    // eslint-disable-next-line react/prop-types
    "selectionFollowsFocus",
    // eslint-disable-next-line react/prop-types
    "textColor",
    "value",
    "wrapped"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    disabled,
    disableFocusRipple,
    selected,
    icon: !!iconProp,
    iconPosition,
    label: !!label,
    fullWidth,
    textColor,
    wrapped
  });
  const classes = useUtilityClasses$b(ownerState);
  const icon = iconProp && label && /* @__PURE__ */ reactExports.isValidElement(iconProp) ? /* @__PURE__ */ reactExports.cloneElement(iconProp, {
    className: clsx(classes.icon, iconProp.props.className)
  }) : iconProp;
  const handleClick = (event) => {
    if (!selected && onChange) {
      onChange(event, value);
    }
    if (onClick) {
      onClick(event);
    }
  };
  const handleFocus = (event) => {
    if (selectionFollowsFocus && !selected && onChange) {
      onChange(event, value);
    }
    if (onFocus) {
      onFocus(event);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TabRoot, __spreadProps(__spreadValues({
    focusRipple: !disableFocusRipple,
    className: clsx(classes.root, className),
    ref,
    role: "tab",
    "aria-selected": selected,
    disabled,
    onClick: handleClick,
    onFocus: handleFocus,
    ownerState,
    tabIndex: selected ? 0 : -1
  }, other), {
    children: [iconPosition === "top" || iconPosition === "start" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [icon, label]
    }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [label, icon]
    }), indicator]
  }));
});
const TableContext = /* @__PURE__ */ reactExports.createContext();
function getTableUtilityClass(slot) {
  return generateUtilityClass("MuiTable", slot);
}
generateUtilityClasses("MuiTable", ["root", "stickyHeader"]);
const useUtilityClasses$a = (ownerState) => {
  const {
    classes,
    stickyHeader
  } = ownerState;
  const slots = {
    root: ["root", stickyHeader && "stickyHeader"]
  };
  return composeClasses(slots, getTableUtilityClass, classes);
};
const TableRoot = styled("table", {
  name: "MuiTable",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.stickyHeader && styles2.stickyHeader];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  display: "table",
  width: "100%",
  borderCollapse: "collapse",
  borderSpacing: 0,
  "& caption": __spreadProps(__spreadValues({}, theme2.typography.body2), {
    padding: theme2.spacing(2),
    color: (theme2.vars || theme2).palette.text.secondary,
    textAlign: "left",
    captionSide: "bottom"
  }),
  variants: [{
    props: ({
      ownerState
    }) => ownerState.stickyHeader,
    style: {
      borderCollapse: "separate"
    }
  }]
})));
const defaultComponent$3 = "table";
const Table = /* @__PURE__ */ reactExports.forwardRef(function Table2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTable"
  });
  const _a2 = props, {
    className,
    component = defaultComponent$3,
    padding: padding2 = "normal",
    size = "medium",
    stickyHeader = false
  } = _a2, other = __objRest(_a2, [
    "className",
    "component",
    "padding",
    "size",
    "stickyHeader"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component,
    padding: padding2,
    size,
    stickyHeader
  });
  const classes = useUtilityClasses$a(ownerState);
  const table = reactExports.useMemo(() => ({
    padding: padding2,
    size,
    stickyHeader
  }), [padding2, size, stickyHeader]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableContext.Provider, {
    value: table,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableRoot, __spreadValues({
      as: component,
      role: component === defaultComponent$3 ? null : "table",
      ref,
      className: clsx(classes.root, className),
      ownerState
    }, other))
  });
});
const Tablelvl2Context = /* @__PURE__ */ reactExports.createContext();
function getTableBodyUtilityClass(slot) {
  return generateUtilityClass("MuiTableBody", slot);
}
generateUtilityClasses("MuiTableBody", ["root"]);
const useUtilityClasses$9 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTableBodyUtilityClass, classes);
};
const TableBodyRoot = styled("tbody", {
  name: "MuiTableBody",
  slot: "Root"
})({
  display: "table-row-group"
});
const tablelvl2$1 = {
  variant: "body"
};
const defaultComponent$2 = "tbody";
const TableBody = /* @__PURE__ */ reactExports.forwardRef(function TableBody2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableBody"
  });
  const _a2 = props, {
    className,
    component = defaultComponent$2
  } = _a2, other = __objRest(_a2, [
    "className",
    "component"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component
  });
  const classes = useUtilityClasses$9(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Tablelvl2Context.Provider, {
    value: tablelvl2$1,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableBodyRoot, __spreadValues({
      className: clsx(classes.root, className),
      as: component,
      ref,
      role: component === defaultComponent$2 ? null : "rowgroup",
      ownerState
    }, other))
  });
});
function getTableCellUtilityClass(slot) {
  return generateUtilityClass("MuiTableCell", slot);
}
const tableCellClasses = generateUtilityClasses("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]);
const useUtilityClasses$8 = (ownerState) => {
  const {
    classes,
    variant,
    align,
    padding: padding2,
    size,
    stickyHeader
  } = ownerState;
  const slots = {
    root: ["root", variant, stickyHeader && "stickyHeader", align !== "inherit" && `align${capitalize(align)}`, padding2 !== "normal" && `padding${capitalize(padding2)}`, `size${capitalize(size)}`]
  };
  return composeClasses(slots, getTableCellUtilityClass, classes);
};
const TableCellRoot = styled("td", {
  name: "MuiTableCell",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`size${capitalize(ownerState.size)}`], ownerState.padding !== "normal" && styles2[`padding${capitalize(ownerState.padding)}`], ownerState.align !== "inherit" && styles2[`align${capitalize(ownerState.align)}`], ownerState.stickyHeader && styles2.stickyHeader];
  }
})(memoTheme(({
  theme: theme2
}) => __spreadProps(__spreadValues({}, theme2.typography.body2), {
  display: "table-cell",
  verticalAlign: "inherit",
  // Workaround for a rendering bug with spanned columns in Chrome 62.0.
  // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
  borderBottom: theme2.vars ? `1px solid ${theme2.vars.palette.TableCell.border}` : `1px solid
    ${theme2.palette.mode === "light" ? theme2.lighten(theme2.alpha(theme2.palette.divider, 1), 0.88) : theme2.darken(theme2.alpha(theme2.palette.divider, 1), 0.68)}`,
  textAlign: "left",
  padding: 16,
  variants: [{
    props: {
      variant: "head"
    },
    style: {
      color: (theme2.vars || theme2).palette.text.primary,
      lineHeight: theme2.typography.pxToRem(24),
      fontWeight: theme2.typography.fontWeightMedium
    }
  }, {
    props: {
      variant: "body"
    },
    style: {
      color: (theme2.vars || theme2).palette.text.primary
    }
  }, {
    props: {
      variant: "footer"
    },
    style: {
      color: (theme2.vars || theme2).palette.text.secondary,
      lineHeight: theme2.typography.pxToRem(21),
      fontSize: theme2.typography.pxToRem(12)
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      padding: "6px 16px",
      [`&.${tableCellClasses.paddingCheckbox}`]: {
        width: 24,
        // prevent the checkbox column from growing
        padding: "0 12px 0 16px",
        "& > *": {
          padding: 0
        }
      }
    }
  }, {
    props: {
      padding: "checkbox"
    },
    style: {
      width: 48,
      // prevent the checkbox column from growing
      padding: "0 0 0 4px"
    }
  }, {
    props: {
      padding: "none"
    },
    style: {
      padding: 0
    }
  }, {
    props: {
      align: "left"
    },
    style: {
      textAlign: "left"
    }
  }, {
    props: {
      align: "center"
    },
    style: {
      textAlign: "center"
    }
  }, {
    props: {
      align: "right"
    },
    style: {
      textAlign: "right",
      flexDirection: "row-reverse"
    }
  }, {
    props: {
      align: "justify"
    },
    style: {
      textAlign: "justify"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.stickyHeader,
    style: {
      position: "sticky",
      top: 0,
      zIndex: 2,
      backgroundColor: (theme2.vars || theme2).palette.background.default
    }
  }]
})));
const TableCell = /* @__PURE__ */ reactExports.forwardRef(function TableCell2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableCell"
  });
  const _a2 = props, {
    align = "inherit",
    className,
    component: componentProp,
    padding: paddingProp,
    scope: scopeProp,
    size: sizeProp,
    sortDirection,
    variant: variantProp
  } = _a2, other = __objRest(_a2, [
    "align",
    "className",
    "component",
    "padding",
    "scope",
    "size",
    "sortDirection",
    "variant"
  ]);
  const table = reactExports.useContext(TableContext);
  const tablelvl22 = reactExports.useContext(Tablelvl2Context);
  const isHeadCell = tablelvl22 && tablelvl22.variant === "head";
  let component;
  if (componentProp) {
    component = componentProp;
  } else {
    component = isHeadCell ? "th" : "td";
  }
  let scope = scopeProp;
  if (component === "td") {
    scope = void 0;
  } else if (!scope && isHeadCell) {
    scope = "col";
  }
  const variant = variantProp || tablelvl22 && tablelvl22.variant;
  const ownerState = __spreadProps(__spreadValues({}, props), {
    align,
    component,
    padding: paddingProp || (table && table.padding ? table.padding : "normal"),
    size: sizeProp || (table && table.size ? table.size : "medium"),
    sortDirection,
    stickyHeader: variant === "head" && table && table.stickyHeader,
    variant
  });
  const classes = useUtilityClasses$8(ownerState);
  let ariaSort = null;
  if (sortDirection) {
    ariaSort = sortDirection === "asc" ? "ascending" : "descending";
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableCellRoot, __spreadValues({
    as: component,
    ref,
    className: clsx(classes.root, className),
    "aria-sort": ariaSort,
    scope,
    ownerState
  }, other));
});
function getTableContainerUtilityClass(slot) {
  return generateUtilityClass("MuiTableContainer", slot);
}
generateUtilityClasses("MuiTableContainer", ["root"]);
const useUtilityClasses$7 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTableContainerUtilityClass, classes);
};
const TableContainerRoot = styled("div", {
  name: "MuiTableContainer",
  slot: "Root"
})({
  width: "100%",
  overflowX: "auto"
});
const TableContainer = /* @__PURE__ */ reactExports.forwardRef(function TableContainer2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableContainer"
  });
  const _a2 = props, {
    className,
    component = "div"
  } = _a2, other = __objRest(_a2, [
    "className",
    "component"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component
  });
  const classes = useUtilityClasses$7(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableContainerRoot, __spreadValues({
    ref,
    as: component,
    className: clsx(classes.root, className),
    ownerState
  }, other));
});
function getTableHeadUtilityClass(slot) {
  return generateUtilityClass("MuiTableHead", slot);
}
generateUtilityClasses("MuiTableHead", ["root"]);
const useUtilityClasses$6 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTableHeadUtilityClass, classes);
};
const TableHeadRoot = styled("thead", {
  name: "MuiTableHead",
  slot: "Root"
})({
  display: "table-header-group"
});
const tablelvl2 = {
  variant: "head"
};
const defaultComponent$1 = "thead";
const TableHead = /* @__PURE__ */ reactExports.forwardRef(function TableHead2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableHead"
  });
  const _a2 = props, {
    className,
    component = defaultComponent$1
  } = _a2, other = __objRest(_a2, [
    "className",
    "component"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component
  });
  const classes = useUtilityClasses$6(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Tablelvl2Context.Provider, {
    value: tablelvl2,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableHeadRoot, __spreadValues({
      as: component,
      className: clsx(classes.root, className),
      ref,
      role: component === defaultComponent$1 ? null : "rowgroup",
      ownerState
    }, other))
  });
});
const KeyboardArrowLeft = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
}));
const KeyboardArrowRight = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"
}));
function getTableRowUtilityClass(slot) {
  return generateUtilityClass("MuiTableRow", slot);
}
const tableRowClasses = generateUtilityClasses("MuiTableRow", ["root", "selected", "hover", "head", "footer"]);
const useUtilityClasses$5 = (ownerState) => {
  const {
    classes,
    selected,
    hover,
    head: head2,
    footer
  } = ownerState;
  const slots = {
    root: ["root", selected && "selected", hover && "hover", head2 && "head", footer && "footer"]
  };
  return composeClasses(slots, getTableRowUtilityClass, classes);
};
const TableRowRoot = styled("tr", {
  name: "MuiTableRow",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.head && styles2.head, ownerState.footer && styles2.footer];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  color: "inherit",
  display: "table-row",
  verticalAlign: "middle",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  [`&.${tableRowClasses.hover}:hover`]: {
    backgroundColor: (theme2.vars || theme2).palette.action.hover
  },
  [`&.${tableRowClasses.selected}`]: {
    backgroundColor: theme2.alpha((theme2.vars || theme2).palette.primary.main, (theme2.vars || theme2).palette.action.selectedOpacity),
    "&:hover": {
      backgroundColor: theme2.alpha((theme2.vars || theme2).palette.primary.main, `${(theme2.vars || theme2).palette.action.selectedOpacity} + ${(theme2.vars || theme2).palette.action.hoverOpacity}`)
    }
  }
})));
const defaultComponent = "tr";
const TableRow = /* @__PURE__ */ reactExports.forwardRef(function TableRow2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableRow"
  });
  const _a2 = props, {
    className,
    component = defaultComponent,
    hover = false,
    selected = false
  } = _a2, other = __objRest(_a2, [
    "className",
    "component",
    "hover",
    "selected"
  ]);
  const tablelvl22 = reactExports.useContext(Tablelvl2Context);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component,
    hover,
    selected,
    head: tablelvl22 && tablelvl22.variant === "head",
    footer: tablelvl22 && tablelvl22.variant === "footer"
  });
  const classes = useUtilityClasses$5(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableRowRoot, __spreadValues({
    as: component,
    ref,
    className: clsx(classes.root, className),
    role: component === defaultComponent ? null : "row",
    ownerState
  }, other));
});
function easeInOutSin(time) {
  return (1 + Math.sin(Math.PI * time - Math.PI / 2)) / 2;
}
function animate(property, element, to, options = {}, cb = () => {
}) {
  const {
    ease = easeInOutSin,
    duration: duration2 = 300
    // standard
  } = options;
  let start2 = null;
  const from2 = element[property];
  let cancelled = false;
  const cancel = () => {
    cancelled = true;
  };
  const step = (timestamp) => {
    if (cancelled) {
      cb(new Error("Animation cancelled"));
      return;
    }
    if (start2 === null) {
      start2 = timestamp;
    }
    const time = Math.min(1, (timestamp - start2) / duration2);
    element[property] = ease(time) * (to - from2) + from2;
    if (time >= 1) {
      requestAnimationFrame(() => {
        cb(null);
      });
      return;
    }
    requestAnimationFrame(step);
  };
  if (from2 === to) {
    cb(new Error("Element already at target position"));
    return cancel;
  }
  requestAnimationFrame(step);
  return cancel;
}
const styles = {
  width: 99,
  height: 99,
  position: "absolute",
  top: -9999,
  overflow: "scroll"
};
function ScrollbarSize(props) {
  const _a2 = props, {
    onChange
  } = _a2, other = __objRest(_a2, [
    "onChange"
  ]);
  const scrollbarHeight = reactExports.useRef();
  const nodeRef = reactExports.useRef(null);
  const setMeasurements = () => {
    scrollbarHeight.current = nodeRef.current.offsetHeight - nodeRef.current.clientHeight;
  };
  useEnhancedEffect(() => {
    const handleResize = debounce$1(() => {
      const prevHeight = scrollbarHeight.current;
      setMeasurements();
      if (prevHeight !== scrollbarHeight.current) {
        onChange(scrollbarHeight.current);
      }
    });
    const containerWindow = ownerWindow(nodeRef.current);
    containerWindow.addEventListener("resize", handleResize);
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
    };
  }, [onChange]);
  reactExports.useEffect(() => {
    setMeasurements();
    onChange(scrollbarHeight.current);
  }, [onChange]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", __spreadProps(__spreadValues({
    style: styles
  }, other), {
    ref: nodeRef
  }));
}
function getTabScrollButtonUtilityClass(slot) {
  return generateUtilityClass("MuiTabScrollButton", slot);
}
const tabScrollButtonClasses = generateUtilityClasses("MuiTabScrollButton", ["root", "vertical", "horizontal", "disabled"]);
const useUtilityClasses$4 = (ownerState) => {
  const {
    classes,
    orientation,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", orientation, disabled && "disabled"]
  };
  return composeClasses(slots, getTabScrollButtonUtilityClass, classes);
};
const TabScrollButtonRoot = styled(ButtonBase, {
  name: "MuiTabScrollButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.orientation && styles2[ownerState.orientation]];
  }
})({
  width: 40,
  flexShrink: 0,
  opacity: 0.8,
  [`&.${tabScrollButtonClasses.disabled}`]: {
    opacity: 0
  },
  variants: [{
    props: {
      orientation: "vertical"
    },
    style: {
      width: "100%",
      height: 40,
      "& svg": {
        transform: "var(--TabScrollButton-svgRotate)"
      }
    }
  }]
});
const TabScrollButton = /* @__PURE__ */ reactExports.forwardRef(function TabScrollButton2(inProps, ref) {
  var _b, _c;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTabScrollButton"
  });
  const _a2 = props, {
    className,
    slots = {},
    slotProps = {},
    direction,
    orientation,
    disabled
  } = _a2, other = __objRest(_a2, [
    "className",
    "slots",
    "slotProps",
    "direction",
    "orientation",
    "disabled"
  ]);
  const isRtl = useRtl();
  const ownerState = __spreadValues({
    isRtl
  }, props);
  const classes = useUtilityClasses$4(ownerState);
  const StartButtonIcon = (_b = slots.StartScrollButtonIcon) != null ? _b : KeyboardArrowLeft;
  const EndButtonIcon = (_c = slots.EndScrollButtonIcon) != null ? _c : KeyboardArrowRight;
  const startButtonIconProps = useSlotProps({
    elementType: StartButtonIcon,
    externalSlotProps: slotProps.startScrollButtonIcon,
    additionalProps: {
      fontSize: "small"
    },
    ownerState
  });
  const endButtonIconProps = useSlotProps({
    elementType: EndButtonIcon,
    externalSlotProps: slotProps.endScrollButtonIcon,
    additionalProps: {
      fontSize: "small"
    },
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TabScrollButtonRoot, __spreadProps(__spreadValues({
    component: "div",
    className: clsx(classes.root, className),
    ref,
    role: null,
    ownerState,
    tabIndex: null
  }, other), {
    style: __spreadValues(__spreadValues({}, other.style), orientation === "vertical" && {
      "--TabScrollButton-svgRotate": `rotate(${isRtl ? -90 : 90}deg)`
    }),
    children: direction === "left" ? /* @__PURE__ */ jsxRuntimeExports.jsx(StartButtonIcon, __spreadValues({}, startButtonIconProps)) : /* @__PURE__ */ jsxRuntimeExports.jsx(EndButtonIcon, __spreadValues({}, endButtonIconProps))
  }));
});
function getTabsUtilityClass(slot) {
  return generateUtilityClass("MuiTabs", slot);
}
const tabsClasses = generateUtilityClasses("MuiTabs", ["root", "vertical", "list", "flexContainer", "flexContainerVertical", "centered", "scroller", "fixed", "scrollableX", "scrollableY", "hideScrollbar", "scrollButtons", "scrollButtonsHideMobile", "indicator"]);
const nextItem = (list, item) => {
  if (list === item) {
    return list.firstChild;
  }
  if (item && item.nextElementSibling) {
    return item.nextElementSibling;
  }
  return list.firstChild;
};
const previousItem = (list, item) => {
  if (list === item) {
    return list.lastChild;
  }
  if (item && item.previousElementSibling) {
    return item.previousElementSibling;
  }
  return list.lastChild;
};
const moveFocus = (list, currentFocus, traversalFunction) => {
  let wrappedOnce = false;
  let nextFocus = traversalFunction(list, currentFocus);
  while (nextFocus) {
    if (nextFocus === list.firstChild) {
      if (wrappedOnce) {
        return;
      }
      wrappedOnce = true;
    }
    const nextFocusDisabled = nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
    if (!nextFocus.hasAttribute("tabindex") || nextFocusDisabled) {
      nextFocus = traversalFunction(list, nextFocus);
    } else {
      nextFocus.focus();
      return;
    }
  }
};
const useUtilityClasses$3 = (ownerState) => {
  const {
    vertical,
    fixed,
    hideScrollbar,
    scrollableX,
    scrollableY,
    centered,
    scrollButtonsHideMobile,
    classes
  } = ownerState;
  const slots = {
    root: ["root", vertical && "vertical"],
    scroller: ["scroller", fixed && "fixed", hideScrollbar && "hideScrollbar", scrollableX && "scrollableX", scrollableY && "scrollableY"],
    list: ["list", "flexContainer", vertical && "flexContainerVertical", vertical && "vertical", centered && "centered"],
    indicator: ["indicator"],
    scrollButtons: ["scrollButtons", scrollButtonsHideMobile && "scrollButtonsHideMobile"],
    scrollableX: [scrollableX && "scrollableX"],
    hideScrollbar: [hideScrollbar && "hideScrollbar"]
  };
  return composeClasses(slots, getTabsUtilityClass, classes);
};
const TabsRoot = styled("div", {
  name: "MuiTabs",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${tabsClasses.scrollButtons}`]: styles2.scrollButtons
    }, {
      [`& .${tabsClasses.scrollButtons}`]: ownerState.scrollButtonsHideMobile && styles2.scrollButtonsHideMobile
    }, styles2.root, ownerState.vertical && styles2.vertical];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  overflow: "hidden",
  minHeight: 48,
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch",
  display: "flex",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.vertical,
    style: {
      flexDirection: "column"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.scrollButtonsHideMobile,
    style: {
      [`& .${tabsClasses.scrollButtons}`]: {
        [theme2.breakpoints.down("sm")]: {
          display: "none"
        }
      }
    }
  }]
})));
const TabsScroller = styled("div", {
  name: "MuiTabs",
  slot: "Scroller",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.scroller, ownerState.fixed && styles2.fixed, ownerState.hideScrollbar && styles2.hideScrollbar, ownerState.scrollableX && styles2.scrollableX, ownerState.scrollableY && styles2.scrollableY];
  }
})({
  position: "relative",
  display: "inline-block",
  flex: "1 1 auto",
  whiteSpace: "nowrap",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.fixed,
    style: {
      overflowX: "hidden",
      width: "100%"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.hideScrollbar,
    style: {
      // Hide dimensionless scrollbar on macOS
      scrollbarWidth: "none",
      // Firefox
      "&::-webkit-scrollbar": {
        display: "none"
        // Safari + Chrome
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.scrollableX,
    style: {
      overflowX: "auto",
      overflowY: "hidden"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.scrollableY,
    style: {
      overflowY: "auto",
      overflowX: "hidden"
    }
  }]
});
const List = styled("div", {
  name: "MuiTabs",
  slot: "List",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.list, styles2.flexContainer, ownerState.vertical && styles2.flexContainerVertical, ownerState.centered && styles2.centered];
  }
})({
  display: "flex",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.vertical,
    style: {
      flexDirection: "column"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.centered,
    style: {
      justifyContent: "center"
    }
  }]
});
const TabsIndicator = styled("span", {
  name: "MuiTabs",
  slot: "Indicator"
})(memoTheme(({
  theme: theme2
}) => ({
  position: "absolute",
  height: 2,
  bottom: 0,
  width: "100%",
  transition: theme2.transitions.create(),
  variants: [{
    props: {
      indicatorColor: "primary"
    },
    style: {
      backgroundColor: (theme2.vars || theme2).palette.primary.main
    }
  }, {
    props: {
      indicatorColor: "secondary"
    },
    style: {
      backgroundColor: (theme2.vars || theme2).palette.secondary.main
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.vertical,
    style: {
      height: "100%",
      width: 2,
      right: 0
    }
  }]
})));
const TabsScrollbarSize = styled(ScrollbarSize)({
  overflowX: "auto",
  overflowY: "hidden",
  // Hide dimensionless scrollbar on macOS
  scrollbarWidth: "none",
  // Firefox
  "&::-webkit-scrollbar": {
    display: "none"
    // Safari + Chrome
  }
});
const defaultIndicatorStyle = {};
const Tabs = /* @__PURE__ */ reactExports.forwardRef(function Tabs2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTabs"
  });
  const theme2 = useTheme();
  const isRtl = useRtl();
  const _a2 = props, {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    action,
    centered = false,
    children: childrenProp,
    className,
    component = "div",
    allowScrollButtonsMobile = false,
    indicatorColor = "primary",
    onChange,
    orientation = "horizontal",
    ScrollButtonComponent,
    scrollButtons: scrollButtons = "auto",
    selectionFollowsFocus,
    slots = {},
    slotProps = {},
    TabIndicatorProps = {},
    TabScrollButtonProps: TabScrollButtonProps = {},
    textColor: textColor = "primary",
    value,
    variant = "standard",
    visibleScrollbar = false
  } = _a2, other = __objRest(_a2, [
    "aria-label",
    "aria-labelledby",
    "action",
    "centered",
    "children",
    "className",
    "component",
    "allowScrollButtonsMobile",
    "indicatorColor",
    "onChange",
    "orientation",
    "ScrollButtonComponent",
    // TODO: remove in v7 (deprecated in v6)
    "scrollButtons",
    "selectionFollowsFocus",
    "slots",
    "slotProps",
    "TabIndicatorProps",
    // TODO: remove in v7 (deprecated in v6)
    "TabScrollButtonProps",
    // TODO: remove in v7 (deprecated in v6)
    "textColor",
    "value",
    "variant",
    "visibleScrollbar"
  ]);
  const scrollable = variant === "scrollable";
  const vertical = orientation === "vertical";
  const scrollStart = vertical ? "scrollTop" : "scrollLeft";
  const start2 = vertical ? "top" : "left";
  const end2 = vertical ? "bottom" : "right";
  const clientSize = vertical ? "clientHeight" : "clientWidth";
  const size = vertical ? "height" : "width";
  const ownerState = __spreadProps(__spreadValues({}, props), {
    component,
    allowScrollButtonsMobile,
    indicatorColor,
    orientation,
    vertical,
    scrollButtons,
    textColor,
    variant,
    visibleScrollbar,
    fixed: !scrollable,
    hideScrollbar: scrollable && !visibleScrollbar,
    scrollableX: scrollable && !vertical,
    scrollableY: scrollable && vertical,
    centered: centered && !scrollable,
    scrollButtonsHideMobile: !allowScrollButtonsMobile
  });
  const classes = useUtilityClasses$3(ownerState);
  const startScrollButtonIconProps = useSlotProps({
    elementType: slots.StartScrollButtonIcon,
    externalSlotProps: slotProps.startScrollButtonIcon,
    ownerState
  });
  const endScrollButtonIconProps = useSlotProps({
    elementType: slots.EndScrollButtonIcon,
    externalSlotProps: slotProps.endScrollButtonIcon,
    ownerState
  });
  const [mounted, setMounted] = reactExports.useState(false);
  const [indicatorStyle, setIndicatorStyle] = reactExports.useState(defaultIndicatorStyle);
  const [displayStartScroll, setDisplayStartScroll] = reactExports.useState(false);
  const [displayEndScroll, setDisplayEndScroll] = reactExports.useState(false);
  const [updateScrollObserver, setUpdateScrollObserver] = reactExports.useState(false);
  const [scrollerStyle, setScrollerStyle] = reactExports.useState({
    overflow: "hidden",
    scrollbarWidth: 0
  });
  const valueToIndex = /* @__PURE__ */ new Map();
  const tabsRef = reactExports.useRef(null);
  const tabListRef = reactExports.useRef(null);
  const externalForwardedProps = {
    slots,
    slotProps: __spreadValues({
      indicator: TabIndicatorProps,
      scrollButton: TabScrollButtonProps
    }, slotProps)
  };
  const getTabsMeta = () => {
    const tabsNode = tabsRef.current;
    let tabsMeta;
    if (tabsNode) {
      const rect = tabsNode.getBoundingClientRect();
      tabsMeta = {
        clientWidth: tabsNode.clientWidth,
        scrollLeft: tabsNode.scrollLeft,
        scrollTop: tabsNode.scrollTop,
        scrollWidth: tabsNode.scrollWidth,
        top: rect.top,
        bottom: rect.bottom,
        left: rect.left,
        right: rect.right
      };
    }
    let tabMeta;
    if (tabsNode && value !== false) {
      const children2 = tabListRef.current.children;
      if (children2.length > 0) {
        const tab = children2[valueToIndex.get(value)];
        tabMeta = tab ? tab.getBoundingClientRect() : null;
      }
    }
    return {
      tabsMeta,
      tabMeta
    };
  };
  const updateIndicatorState = useEventCallback(() => {
    const {
      tabsMeta,
      tabMeta
    } = getTabsMeta();
    let startValue = 0;
    let startIndicator;
    if (vertical) {
      startIndicator = "top";
      if (tabMeta && tabsMeta) {
        startValue = tabMeta.top - tabsMeta.top + tabsMeta.scrollTop;
      }
    } else {
      startIndicator = isRtl ? "right" : "left";
      if (tabMeta && tabsMeta) {
        startValue = (isRtl ? -1 : 1) * (tabMeta[startIndicator] - tabsMeta[startIndicator] + tabsMeta.scrollLeft);
      }
    }
    const newIndicatorStyle = {
      [startIndicator]: startValue,
      // May be wrong until the font is loaded.
      [size]: tabMeta ? tabMeta[size] : 0
    };
    if (typeof indicatorStyle[startIndicator] !== "number" || typeof indicatorStyle[size] !== "number") {
      setIndicatorStyle(newIndicatorStyle);
    } else {
      const dStart = Math.abs(indicatorStyle[startIndicator] - newIndicatorStyle[startIndicator]);
      const dSize = Math.abs(indicatorStyle[size] - newIndicatorStyle[size]);
      if (dStart >= 1 || dSize >= 1) {
        setIndicatorStyle(newIndicatorStyle);
      }
    }
  });
  const scroll = (scrollValue, {
    animation = true
  } = {}) => {
    if (animation) {
      animate(scrollStart, tabsRef.current, scrollValue, {
        duration: theme2.transitions.duration.standard
      });
    } else {
      tabsRef.current[scrollStart] = scrollValue;
    }
  };
  const moveTabsScroll = (delta) => {
    let scrollValue = tabsRef.current[scrollStart];
    if (vertical) {
      scrollValue += delta;
    } else {
      scrollValue += delta * (isRtl ? -1 : 1);
    }
    scroll(scrollValue);
  };
  const getScrollSize = () => {
    const containerSize = tabsRef.current[clientSize];
    let totalSize = 0;
    const children2 = Array.from(tabListRef.current.children);
    for (let i = 0; i < children2.length; i += 1) {
      const tab = children2[i];
      if (totalSize + tab[clientSize] > containerSize) {
        if (i === 0) {
          totalSize = containerSize;
        }
        break;
      }
      totalSize += tab[clientSize];
    }
    return totalSize;
  };
  const handleStartScrollClick = () => {
    moveTabsScroll(-1 * getScrollSize());
  };
  const handleEndScrollClick = () => {
    moveTabsScroll(getScrollSize());
  };
  const [ScrollbarSlot, _b] = useSlot("scrollbar", {
    className: clsx(classes.scrollableX, classes.hideScrollbar),
    elementType: TabsScrollbarSize,
    shouldForwardComponentProp: true,
    externalForwardedProps,
    ownerState
  }), _c = _b, {
    onChange: scrollbarOnChange
  } = _c, scrollbarSlotProps = __objRest(_c, [
    "onChange"
  ]);
  const handleScrollbarSizeChange = reactExports.useCallback((scrollbarWidth) => {
    scrollbarOnChange == null ? void 0 : scrollbarOnChange(scrollbarWidth);
    setScrollerStyle({
      overflow: null,
      scrollbarWidth
    });
  }, [scrollbarOnChange]);
  const [ScrollButtonsSlot, scrollButtonSlotProps] = useSlot("scrollButtons", {
    className: clsx(classes.scrollButtons, TabScrollButtonProps.className),
    elementType: TabScrollButton,
    externalForwardedProps,
    ownerState,
    additionalProps: {
      orientation,
      slots: {
        StartScrollButtonIcon: slots.startScrollButtonIcon || slots.StartScrollButtonIcon,
        EndScrollButtonIcon: slots.endScrollButtonIcon || slots.EndScrollButtonIcon
      },
      slotProps: {
        startScrollButtonIcon: startScrollButtonIconProps,
        endScrollButtonIcon: endScrollButtonIconProps
      }
    }
  });
  const getConditionalElements = () => {
    const conditionalElements2 = {};
    conditionalElements2.scrollbarSizeListener = scrollable ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollbarSlot, __spreadProps(__spreadValues({}, scrollbarSlotProps), {
      onChange: handleScrollbarSizeChange
    })) : null;
    const scrollButtonsActive = displayStartScroll || displayEndScroll;
    const showScrollButtons = scrollable && (scrollButtons === "auto" && scrollButtonsActive || scrollButtons === true);
    conditionalElements2.scrollButtonStart = showScrollButtons ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollButtonsSlot, __spreadValues({
      direction: isRtl ? "right" : "left",
      onClick: handleStartScrollClick,
      disabled: !displayStartScroll
    }, scrollButtonSlotProps)) : null;
    conditionalElements2.scrollButtonEnd = showScrollButtons ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollButtonsSlot, __spreadValues({
      direction: isRtl ? "left" : "right",
      onClick: handleEndScrollClick,
      disabled: !displayEndScroll
    }, scrollButtonSlotProps)) : null;
    return conditionalElements2;
  };
  const scrollSelectedIntoView = useEventCallback((animation) => {
    const {
      tabsMeta,
      tabMeta
    } = getTabsMeta();
    if (!tabMeta || !tabsMeta) {
      return;
    }
    if (tabMeta[start2] < tabsMeta[start2]) {
      const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[start2] - tabsMeta[start2]);
      scroll(nextScrollStart, {
        animation
      });
    } else if (tabMeta[end2] > tabsMeta[end2]) {
      const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[end2] - tabsMeta[end2]);
      scroll(nextScrollStart, {
        animation
      });
    }
  });
  const updateScrollButtonState = useEventCallback(() => {
    if (scrollable && scrollButtons !== false) {
      setUpdateScrollObserver(!updateScrollObserver);
    }
  });
  reactExports.useEffect(() => {
    const handleResize = debounce$1(() => {
      if (tabsRef.current) {
        updateIndicatorState();
      }
    });
    let resizeObserver;
    const handleMutation = (records) => {
      records.forEach((record) => {
        record.removedNodes.forEach((item) => {
          resizeObserver == null ? void 0 : resizeObserver.unobserve(item);
        });
        record.addedNodes.forEach((item) => {
          resizeObserver == null ? void 0 : resizeObserver.observe(item);
        });
      });
      handleResize();
      updateScrollButtonState();
    };
    const win = ownerWindow(tabsRef.current);
    win.addEventListener("resize", handleResize);
    let mutationObserver;
    if (typeof ResizeObserver !== "undefined") {
      resizeObserver = new ResizeObserver(handleResize);
      Array.from(tabListRef.current.children).forEach((child) => {
        resizeObserver.observe(child);
      });
    }
    if (typeof MutationObserver !== "undefined") {
      mutationObserver = new MutationObserver(handleMutation);
      mutationObserver.observe(tabListRef.current, {
        childList: true
      });
    }
    return () => {
      handleResize.clear();
      win.removeEventListener("resize", handleResize);
      mutationObserver == null ? void 0 : mutationObserver.disconnect();
      resizeObserver == null ? void 0 : resizeObserver.disconnect();
    };
  }, [updateIndicatorState, updateScrollButtonState]);
  reactExports.useEffect(() => {
    const tabListChildren = Array.from(tabListRef.current.children);
    const length2 = tabListChildren.length;
    if (typeof IntersectionObserver !== "undefined" && length2 > 0 && scrollable && scrollButtons !== false) {
      const firstTab = tabListChildren[0];
      const lastTab = tabListChildren[length2 - 1];
      const observerOptions = {
        root: tabsRef.current,
        threshold: 0.99
      };
      const handleScrollButtonStart = (entries) => {
        setDisplayStartScroll(!entries[0].isIntersecting);
      };
      const firstObserver = new IntersectionObserver(handleScrollButtonStart, observerOptions);
      firstObserver.observe(firstTab);
      const handleScrollButtonEnd = (entries) => {
        setDisplayEndScroll(!entries[0].isIntersecting);
      };
      const lastObserver = new IntersectionObserver(handleScrollButtonEnd, observerOptions);
      lastObserver.observe(lastTab);
      return () => {
        firstObserver.disconnect();
        lastObserver.disconnect();
      };
    }
    return void 0;
  }, [scrollable, scrollButtons, updateScrollObserver, childrenProp == null ? void 0 : childrenProp.length]);
  reactExports.useEffect(() => {
    setMounted(true);
  }, []);
  reactExports.useEffect(() => {
    updateIndicatorState();
  });
  reactExports.useEffect(() => {
    scrollSelectedIntoView(defaultIndicatorStyle !== indicatorStyle);
  }, [scrollSelectedIntoView, indicatorStyle]);
  reactExports.useImperativeHandle(action, () => ({
    updateIndicator: updateIndicatorState,
    updateScrollButtons: updateScrollButtonState
  }), [updateIndicatorState, updateScrollButtonState]);
  const [IndicatorSlot, indicatorSlotProps] = useSlot("indicator", {
    className: clsx(classes.indicator, TabIndicatorProps.className),
    elementType: TabsIndicator,
    externalForwardedProps,
    ownerState,
    additionalProps: {
      style: indicatorStyle
    }
  });
  const indicator = /* @__PURE__ */ jsxRuntimeExports.jsx(IndicatorSlot, __spreadValues({}, indicatorSlotProps));
  let childIndex = 0;
  const children = reactExports.Children.map(childrenProp, (child) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      return null;
    }
    const childValue = child.props.value === void 0 ? childIndex : child.props.value;
    valueToIndex.set(childValue, childIndex);
    const selected = childValue === value;
    childIndex += 1;
    return /* @__PURE__ */ reactExports.cloneElement(child, __spreadValues({
      fullWidth: variant === "fullWidth",
      indicator: selected && !mounted && indicator,
      selected,
      selectionFollowsFocus,
      onChange,
      textColor,
      value: childValue
    }, childIndex === 1 && value === false && !child.props.tabIndex ? {
      tabIndex: 0
    } : {}));
  });
  const handleKeyDown = (event) => {
    if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {
      return;
    }
    const list = tabListRef.current;
    const currentFocus = ownerDocument(list).activeElement;
    const role = currentFocus.getAttribute("role");
    if (role !== "tab") {
      return;
    }
    let previousItemKey = orientation === "horizontal" ? "ArrowLeft" : "ArrowUp";
    let nextItemKey = orientation === "horizontal" ? "ArrowRight" : "ArrowDown";
    if (orientation === "horizontal" && isRtl) {
      previousItemKey = "ArrowRight";
      nextItemKey = "ArrowLeft";
    }
    switch (event.key) {
      case previousItemKey:
        event.preventDefault();
        moveFocus(list, currentFocus, previousItem);
        break;
      case nextItemKey:
        event.preventDefault();
        moveFocus(list, currentFocus, nextItem);
        break;
      case "Home":
        event.preventDefault();
        moveFocus(list, null, nextItem);
        break;
      case "End":
        event.preventDefault();
        moveFocus(list, null, previousItem);
        break;
    }
  };
  const conditionalElements = getConditionalElements();
  const [RootSlot, rootSlotProps] = useSlot("root", {
    ref,
    className: clsx(classes.root, className),
    elementType: TabsRoot,
    externalForwardedProps: __spreadProps(__spreadValues(__spreadValues({}, externalForwardedProps), other), {
      component
    }),
    ownerState
  });
  const [ScrollerSlot, scrollerSlotProps] = useSlot("scroller", {
    ref: tabsRef,
    className: classes.scroller,
    elementType: TabsScroller,
    externalForwardedProps,
    ownerState,
    additionalProps: {
      style: {
        overflow: scrollerStyle.overflow,
        [vertical ? `margin${isRtl ? "Left" : "Right"}` : "marginBottom"]: visibleScrollbar ? void 0 : -scrollerStyle.scrollbarWidth
      }
    }
  });
  const [ListSlot, listSlotProps] = useSlot("list", {
    ref: tabListRef,
    className: clsx(classes.list, classes.flexContainer),
    elementType: List,
    externalForwardedProps,
    ownerState,
    getSlotProps: (handlers) => __spreadProps(__spreadValues({}, handlers), {
      onKeyDown: (event) => {
        var _a3;
        handleKeyDown(event);
        (_a3 = handlers.onKeyDown) == null ? void 0 : _a3.call(handlers, event);
      }
    })
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, __spreadProps(__spreadValues({}, rootSlotProps), {
    children: [conditionalElements.scrollButtonStart, conditionalElements.scrollbarSizeListener, /* @__PURE__ */ jsxRuntimeExports.jsxs(ScrollerSlot, __spreadProps(__spreadValues({}, scrollerSlotProps), {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ListSlot, __spreadProps(__spreadValues({
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-orientation": orientation === "vertical" ? "vertical" : null,
        role: "tablist"
      }, listSlotProps), {
        children
      })), mounted && indicator]
    })), conditionalElements.scrollButtonEnd]
  }));
});
function getTextFieldUtilityClass(slot) {
  return generateUtilityClass("MuiTextField", slot);
}
generateUtilityClasses("MuiTextField", ["root"]);
const variantComponent = {
  standard: Input,
  filled: FilledInput,
  outlined: OutlinedInput
};
const useUtilityClasses$2 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTextFieldUtilityClass, classes);
};
const TextFieldRoot = styled(FormControl, {
  name: "MuiTextField",
  slot: "Root"
})({});
const TextField = /* @__PURE__ */ reactExports.forwardRef(function TextField2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTextField"
  });
  const _a2 = props, {
    autoComplete,
    autoFocus = false,
    children,
    className,
    color: color2 = "primary",
    defaultValue,
    disabled = false,
    error: error2 = false,
    FormHelperTextProps: FormHelperTextPropsProp,
    fullWidth = false,
    helperText,
    id: idOverride,
    InputLabelProps: InputLabelPropsProp,
    inputProps: inputPropsProp,
    InputProps: InputPropsProp,
    inputRef,
    label,
    maxRows,
    minRows,
    multiline = false,
    name: name2,
    onBlur,
    onChange,
    onFocus,
    placeholder,
    required = false,
    rows,
    select = false,
    SelectProps: SelectPropsProp,
    slots = {},
    slotProps = {},
    type,
    value,
    variant = "outlined"
  } = _a2, other = __objRest(_a2, [
    "autoComplete",
    "autoFocus",
    "children",
    "className",
    "color",
    "defaultValue",
    "disabled",
    "error",
    "FormHelperTextProps",
    "fullWidth",
    "helperText",
    "id",
    "InputLabelProps",
    "inputProps",
    "InputProps",
    "inputRef",
    "label",
    "maxRows",
    "minRows",
    "multiline",
    "name",
    "onBlur",
    "onChange",
    "onFocus",
    "placeholder",
    "required",
    "rows",
    "select",
    "SelectProps",
    "slots",
    "slotProps",
    "type",
    "value",
    "variant"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    autoFocus,
    color: color2,
    disabled,
    error: error2,
    fullWidth,
    multiline,
    required,
    select,
    variant
  });
  const classes = useUtilityClasses$2(ownerState);
  const id = useId(idOverride);
  const helperTextId = helperText && id ? `${id}-helper-text` : void 0;
  const inputLabelId = label && id ? `${id}-label` : void 0;
  const InputComponent = variantComponent[variant];
  const externalForwardedProps = {
    slots,
    slotProps: __spreadValues({
      input: InputPropsProp,
      inputLabel: InputLabelPropsProp,
      htmlInput: inputPropsProp,
      formHelperText: FormHelperTextPropsProp,
      select: SelectPropsProp
    }, slotProps)
  };
  const inputAdditionalProps = {};
  const inputLabelSlotProps = externalForwardedProps.slotProps.inputLabel;
  if (variant === "outlined") {
    if (inputLabelSlotProps && typeof inputLabelSlotProps.shrink !== "undefined") {
      inputAdditionalProps.notched = inputLabelSlotProps.shrink;
    }
    inputAdditionalProps.label = label;
  }
  if (select) {
    if (!SelectPropsProp || !SelectPropsProp.native) {
      inputAdditionalProps.id = void 0;
    }
    inputAdditionalProps["aria-describedby"] = void 0;
  }
  const [RootSlot, rootProps] = useSlot("root", {
    elementType: TextFieldRoot,
    shouldForwardComponentProp: true,
    externalForwardedProps: __spreadValues(__spreadValues({}, externalForwardedProps), other),
    ownerState,
    className: clsx(classes.root, className),
    ref,
    additionalProps: {
      disabled,
      error: error2,
      fullWidth,
      required,
      color: color2,
      variant
    }
  });
  const [InputSlot, inputProps] = useSlot("input", {
    elementType: InputComponent,
    externalForwardedProps,
    additionalProps: inputAdditionalProps,
    ownerState
  });
  const [InputLabelSlot, inputLabelProps] = useSlot("inputLabel", {
    elementType: InputLabel,
    externalForwardedProps,
    ownerState
  });
  const [HtmlInputSlot, htmlInputProps] = useSlot("htmlInput", {
    elementType: "input",
    externalForwardedProps,
    ownerState
  });
  const [FormHelperTextSlot, formHelperTextProps] = useSlot("formHelperText", {
    elementType: FormHelperText,
    externalForwardedProps,
    ownerState
  });
  const [SelectSlot, selectProps] = useSlot("select", {
    elementType: Select,
    externalForwardedProps,
    ownerState
  });
  const InputElement = /* @__PURE__ */ jsxRuntimeExports.jsx(InputSlot, __spreadValues({
    "aria-describedby": helperTextId,
    autoComplete,
    autoFocus,
    defaultValue,
    fullWidth,
    multiline,
    name: name2,
    rows,
    maxRows,
    minRows,
    type,
    value,
    id,
    inputRef,
    onBlur,
    onChange,
    onFocus,
    placeholder,
    inputProps: htmlInputProps,
    slots: {
      input: slots.htmlInput ? HtmlInputSlot : void 0
    }
  }, inputProps));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, __spreadProps(__spreadValues({}, rootProps), {
    children: [label != null && label !== "" && /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabelSlot, __spreadProps(__spreadValues({
      htmlFor: id,
      id: inputLabelId
    }, inputLabelProps), {
      children: label
    })), select ? /* @__PURE__ */ jsxRuntimeExports.jsx(SelectSlot, __spreadProps(__spreadValues({
      "aria-describedby": helperTextId,
      id,
      labelId: inputLabelId,
      value,
      input: InputElement
    }, selectProps), {
      children
    })) : InputElement, helperText && /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperTextSlot, __spreadProps(__spreadValues({
      id: helperTextId
    }, formHelperTextProps), {
      children: helperText
    }))]
  }));
});
function getToggleButtonUtilityClass(slot) {
  return generateUtilityClass("MuiToggleButton", slot);
}
const toggleButtonClasses = generateUtilityClasses("MuiToggleButton", ["root", "disabled", "selected", "standard", "primary", "secondary", "sizeSmall", "sizeMedium", "sizeLarge", "fullWidth"]);
const ToggleButtonGroupContext = /* @__PURE__ */ reactExports.createContext({});
const ToggleButtonGroupButtonContext = /* @__PURE__ */ reactExports.createContext(void 0);
function isValueSelected(value, candidate) {
  if (candidate === void 0 || value === void 0) {
    return false;
  }
  if (Array.isArray(candidate)) {
    return candidate.includes(value);
  }
  return value === candidate;
}
const useUtilityClasses$1 = (ownerState) => {
  const {
    classes,
    fullWidth,
    selected,
    disabled,
    size,
    color: color2
  } = ownerState;
  const slots = {
    root: ["root", selected && "selected", disabled && "disabled", fullWidth && "fullWidth", `size${capitalize(size)}`, color2]
  };
  return composeClasses(slots, getToggleButtonUtilityClass, classes);
};
const ToggleButtonRoot = styled(ButtonBase, {
  name: "MuiToggleButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`size${capitalize(ownerState.size)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => __spreadProps(__spreadValues({}, theme2.typography.button), {
  borderRadius: (theme2.vars || theme2).shape.borderRadius,
  padding: 11,
  border: `1px solid ${(theme2.vars || theme2).palette.divider}`,
  color: (theme2.vars || theme2).palette.action.active,
  [`&.${toggleButtonClasses.disabled}`]: {
    color: (theme2.vars || theme2).palette.action.disabled,
    border: `1px solid ${(theme2.vars || theme2).palette.action.disabledBackground}`
  },
  "&:hover": {
    textDecoration: "none",
    // Reset on mouse devices
    backgroundColor: theme2.alpha((theme2.vars || theme2).palette.text.primary, (theme2.vars || theme2).palette.action.hoverOpacity),
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  variants: [{
    props: {
      color: "standard"
    },
    style: {
      [`&.${toggleButtonClasses.selected}`]: {
        color: (theme2.vars || theme2).palette.text.primary,
        backgroundColor: theme2.alpha((theme2.vars || theme2).palette.text.primary, (theme2.vars || theme2).palette.action.selectedOpacity),
        "&:hover": {
          backgroundColor: theme2.alpha((theme2.vars || theme2).palette.text.primary, `${(theme2.vars || theme2).palette.action.selectedOpacity} + ${(theme2.vars || theme2).palette.action.hoverOpacity}`),
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: theme2.alpha((theme2.vars || theme2).palette.text.primary, (theme2.vars || theme2).palette.action.selectedOpacity)
          }
        }
      }
    }
  }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      [`&.${toggleButtonClasses.selected}`]: {
        color: (theme2.vars || theme2).palette[color2].main,
        backgroundColor: theme2.alpha((theme2.vars || theme2).palette[color2].main, (theme2.vars || theme2).palette.action.selectedOpacity),
        "&:hover": {
          backgroundColor: theme2.alpha((theme2.vars || theme2).palette[color2].main, `${(theme2.vars || theme2).palette.action.selectedOpacity} + ${(theme2.vars || theme2).palette.action.hoverOpacity}`),
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: theme2.alpha((theme2.vars || theme2).palette[color2].main, (theme2.vars || theme2).palette.action.selectedOpacity)
          }
        }
      }
    }
  })), {
    props: {
      fullWidth: true
    },
    style: {
      width: "100%"
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      padding: 7,
      fontSize: theme2.typography.pxToRem(13)
    }
  }, {
    props: {
      size: "large"
    },
    style: {
      padding: 15,
      fontSize: theme2.typography.pxToRem(15)
    }
  }]
})));
const ToggleButton = /* @__PURE__ */ reactExports.forwardRef(function ToggleButton2(inProps, ref) {
  const _a2 = reactExports.useContext(ToggleButtonGroupContext), {
    value: contextValue
  } = _a2, contextProps = __objRest(_a2, [
    "value"
  ]);
  const toggleButtonGroupButtonContextPositionClassName = reactExports.useContext(ToggleButtonGroupButtonContext);
  const resolvedProps = resolveProps(__spreadProps(__spreadValues({}, contextProps), {
    selected: isValueSelected(inProps.value, contextValue)
  }), inProps);
  const props = useDefaultProps({
    props: resolvedProps,
    name: "MuiToggleButton"
  });
  const _b = props, {
    children,
    className,
    color: color2 = "standard",
    disabled = false,
    disableFocusRipple = false,
    fullWidth = false,
    onChange,
    onClick,
    selected,
    size = "medium",
    value
  } = _b, other = __objRest(_b, [
    "children",
    "className",
    "color",
    "disabled",
    "disableFocusRipple",
    "fullWidth",
    "onChange",
    "onClick",
    "selected",
    "size",
    "value"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    color: color2,
    disabled,
    disableFocusRipple,
    fullWidth,
    size
  });
  const classes = useUtilityClasses$1(ownerState);
  const handleChange = (event) => {
    if (onClick) {
      onClick(event, value);
      if (event.defaultPrevented) {
        return;
      }
    }
    if (onChange) {
      onChange(event, value);
    }
  };
  const positionClassName = toggleButtonGroupButtonContextPositionClassName || "";
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleButtonRoot, __spreadProps(__spreadValues({
    className: clsx(contextProps.className, classes.root, className, positionClassName),
    disabled,
    focusRipple: !disableFocusRipple,
    ref,
    onClick: handleChange,
    onChange,
    value,
    ownerState,
    "aria-pressed": selected
  }, other), {
    children
  }));
});
function getToggleButtonGroupUtilityClass(slot) {
  return generateUtilityClass("MuiToggleButtonGroup", slot);
}
const toggleButtonGroupClasses = generateUtilityClasses("MuiToggleButtonGroup", ["root", "selected", "horizontal", "vertical", "disabled", "grouped", "groupedHorizontal", "groupedVertical", "fullWidth", "firstButton", "lastButton", "middleButton"]);
const useUtilityClasses = (ownerState) => {
  const {
    classes,
    orientation,
    fullWidth,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", orientation, fullWidth && "fullWidth"],
    grouped: ["grouped", `grouped${capitalize(orientation)}`, disabled && "disabled"],
    firstButton: ["firstButton"],
    lastButton: ["lastButton"],
    middleButton: ["middleButton"]
  };
  return composeClasses(slots, getToggleButtonGroupUtilityClass, classes);
};
const ToggleButtonGroupRoot = styled("div", {
  name: "MuiToggleButtonGroup",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${toggleButtonGroupClasses.grouped}`]: styles2.grouped
    }, {
      [`& .${toggleButtonGroupClasses.grouped}`]: styles2[`grouped${capitalize(ownerState.orientation)}`]
    }, {
      [`& .${toggleButtonGroupClasses.firstButton}`]: styles2.firstButton
    }, {
      [`& .${toggleButtonGroupClasses.lastButton}`]: styles2.lastButton
    }, {
      [`& .${toggleButtonGroupClasses.middleButton}`]: styles2.middleButton
    }, styles2.root, ownerState.orientation === "vertical" && styles2.vertical, ownerState.fullWidth && styles2.fullWidth];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  display: "inline-flex",
  borderRadius: (theme2.vars || theme2).shape.borderRadius,
  variants: [{
    props: {
      orientation: "vertical"
    },
    style: {
      flexDirection: "column",
      [`& .${toggleButtonGroupClasses.grouped}`]: {
        [`&.${toggleButtonGroupClasses.selected} + .${toggleButtonGroupClasses.grouped}.${toggleButtonGroupClasses.selected}`]: {
          borderTop: 0,
          marginTop: 0
        }
      },
      [`& .${toggleButtonGroupClasses.firstButton},& .${toggleButtonGroupClasses.middleButton}`]: {
        borderBottomLeftRadius: 0,
        borderBottomRightRadius: 0
      },
      [`& .${toggleButtonGroupClasses.lastButton},& .${toggleButtonGroupClasses.middleButton}`]: {
        marginTop: -1,
        borderTop: "1px solid transparent",
        borderTopLeftRadius: 0,
        borderTopRightRadius: 0
      },
      [`& .${toggleButtonGroupClasses.lastButton}.${toggleButtonClasses.disabled},& .${toggleButtonGroupClasses.middleButton}.${toggleButtonClasses.disabled}`]: {
        borderTop: "1px solid transparent"
      }
    }
  }, {
    props: {
      fullWidth: true
    },
    style: {
      width: "100%"
    }
  }, {
    props: {
      orientation: "horizontal"
    },
    style: {
      [`& .${toggleButtonGroupClasses.grouped}`]: {
        [`&.${toggleButtonGroupClasses.selected} + .${toggleButtonGroupClasses.grouped}.${toggleButtonGroupClasses.selected}`]: {
          borderLeft: 0,
          marginLeft: 0
        }
      },
      [`& .${toggleButtonGroupClasses.firstButton},& .${toggleButtonGroupClasses.middleButton}`]: {
        borderTopRightRadius: 0,
        borderBottomRightRadius: 0
      },
      [`& .${toggleButtonGroupClasses.lastButton},& .${toggleButtonGroupClasses.middleButton}`]: {
        marginLeft: -1,
        borderLeft: "1px solid transparent",
        borderTopLeftRadius: 0,
        borderBottomLeftRadius: 0
      },
      [`& .${toggleButtonGroupClasses.lastButton}.${toggleButtonClasses.disabled},& .${toggleButtonGroupClasses.middleButton}.${toggleButtonClasses.disabled}`]: {
        borderLeft: "1px solid transparent"
      }
    }
  }]
})));
const ToggleButtonGroup = /* @__PURE__ */ reactExports.forwardRef(function ToggleButtonGroup2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiToggleButtonGroup"
  });
  const _a2 = props, {
    children,
    className,
    color: color2 = "standard",
    disabled = false,
    exclusive = false,
    fullWidth = false,
    onChange,
    orientation = "horizontal",
    size = "medium",
    value
  } = _a2, other = __objRest(_a2, [
    "children",
    "className",
    "color",
    "disabled",
    "exclusive",
    "fullWidth",
    "onChange",
    "orientation",
    "size",
    "value"
  ]);
  const ownerState = __spreadProps(__spreadValues({}, props), {
    disabled,
    fullWidth,
    orientation,
    size
  });
  const classes = useUtilityClasses(ownerState);
  const handleChange = reactExports.useCallback((event, buttonValue) => {
    if (!onChange) {
      return;
    }
    const index2 = value && value.indexOf(buttonValue);
    let newValue;
    if (value && index2 >= 0) {
      newValue = value.slice();
      newValue.splice(index2, 1);
    } else {
      newValue = value ? value.concat(buttonValue) : [buttonValue];
    }
    onChange(event, newValue);
  }, [onChange, value]);
  const handleExclusiveChange = reactExports.useCallback((event, buttonValue) => {
    if (!onChange) {
      return;
    }
    onChange(event, value === buttonValue ? null : buttonValue);
  }, [onChange, value]);
  const context = reactExports.useMemo(() => ({
    className: classes.grouped,
    onChange: exclusive ? handleExclusiveChange : handleChange,
    value,
    size,
    fullWidth,
    color: color2,
    disabled
  }), [classes.grouped, exclusive, handleExclusiveChange, handleChange, value, size, fullWidth, color2, disabled]);
  const validChildren = getValidReactChildren(children);
  const childrenCount = validChildren.length;
  const getButtonPositionClassName = (index2) => {
    const isFirstButton = index2 === 0;
    const isLastButton = index2 === childrenCount - 1;
    if (isFirstButton && isLastButton) {
      return "";
    }
    if (isFirstButton) {
      return classes.firstButton;
    }
    if (isLastButton) {
      return classes.lastButton;
    }
    return classes.middleButton;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleButtonGroupRoot, __spreadProps(__spreadValues({
    role: "group",
    className: clsx(classes.root, className),
    ref,
    ownerState
  }, other), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleButtonGroupContext.Provider, {
      value: context,
      children: validChildren.map((child, index2) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleButtonGroupButtonContext.Provider, {
          value: getButtonPositionClassName(index2),
          children: child
        }, index2);
      })
    })
  }));
});
const useMediaQuery = unstable_createUseMediaQuery({
  themeId: THEME_ID
});
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;
  return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name2, prefix2) {
  if (typeof name2 === "symbol") name2 = name2.description ? "[".concat(name2.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix2 ? "".concat(prefix2, " ", name2) : name2 });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body2) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body2.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
});
function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r2, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done) ar.push(r2.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r2 = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r2[k] = a[j];
  return r2;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++) {
    if (ar || !(i in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
      ar[i] = from2[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};
var ownKeys = function(o) {
  ownKeys = Object.getOwnPropertyNames || function(o2) {
    var ar = [];
    for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
    return ar;
  };
  return ownKeys(o);
};
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error2, e.suppressed = suppressed, e;
};
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r2, s = 0;
  function next2() {
    while (r2 = env.stack.pop()) {
      try {
        if (!r2.async && s === 1) return s = 0, env.stack.push(r2), Promise.resolve().then(next2);
        if (r2.dispose) {
          var result = r2.dispose.call(r2.value);
          if (r2.async) return s |= 2, Promise.resolve(result).then(next2, function(e) {
            fail(e);
            return next2();
          });
        } else s |= 1;
      } catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next2();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
    return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
      return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
    });
  }
  return path;
}
const tslib_es6 = {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension
};
const tslib_es6$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  __addDisposableResource,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldIn,
  __classPrivateFieldSet,
  __createBinding,
  __decorate,
  __disposeResources,
  __esDecorate,
  __exportStar,
  __extends,
  __generator,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __propKey,
  __read,
  __rest,
  __rewriteRelativeImportExtension,
  __runInitializers,
  __setFunctionName,
  __spread,
  __spreadArray,
  __spreadArrays,
  __values,
  default: tslib_es6
}, Symbol.toStringTag, { value: "Module" }));
const resolveFetch$4 = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = (...args) => __vitePreload(() => __async(null, null, function* () {
      const { default: fetch2 } = yield Promise.resolve().then(() => browser);
      return { default: fetch2 };
    }), true ? void 0 : void 0, import.meta.url).then(({ default: fetch2 }) => fetch2(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
class FunctionsError extends Error {
  constructor(message, name2 = "FunctionsError", context) {
    super(message);
    this.name = name2;
    this.context = context;
  }
}
class FunctionsFetchError extends FunctionsError {
  constructor(context) {
    super("Failed to send a request to the Edge Function", "FunctionsFetchError", context);
  }
}
class FunctionsRelayError extends FunctionsError {
  constructor(context) {
    super("Relay Error invoking the Edge Function", "FunctionsRelayError", context);
  }
}
class FunctionsHttpError extends FunctionsError {
  constructor(context) {
    super("Edge Function returned a non-2xx status code", "FunctionsHttpError", context);
  }
}
var FunctionRegion;
(function(FunctionRegion2) {
  FunctionRegion2["Any"] = "any";
  FunctionRegion2["ApNortheast1"] = "ap-northeast-1";
  FunctionRegion2["ApNortheast2"] = "ap-northeast-2";
  FunctionRegion2["ApSouth1"] = "ap-south-1";
  FunctionRegion2["ApSoutheast1"] = "ap-southeast-1";
  FunctionRegion2["ApSoutheast2"] = "ap-southeast-2";
  FunctionRegion2["CaCentral1"] = "ca-central-1";
  FunctionRegion2["EuCentral1"] = "eu-central-1";
  FunctionRegion2["EuWest1"] = "eu-west-1";
  FunctionRegion2["EuWest2"] = "eu-west-2";
  FunctionRegion2["EuWest3"] = "eu-west-3";
  FunctionRegion2["SaEast1"] = "sa-east-1";
  FunctionRegion2["UsEast1"] = "us-east-1";
  FunctionRegion2["UsWest1"] = "us-west-1";
  FunctionRegion2["UsWest2"] = "us-west-2";
})(FunctionRegion || (FunctionRegion = {}));
class FunctionsClient {
  constructor(url, { headers = {}, customFetch, region = FunctionRegion.Any } = {}) {
    this.url = url;
    this.headers = headers;
    this.region = region;
    this.fetch = resolveFetch$4(customFetch);
  }
  /**
   * Updates the authorization header
   * @param token - the new jwt token sent in the authorisation header
   */
  setAuth(token2) {
    this.headers.Authorization = `Bearer ${token2}`;
  }
  /**
   * Invokes a function
   * @param functionName - The name of the Function to invoke.
   * @param options - Options for invoking the Function.
   */
  invoke(functionName_1) {
    return __awaiter(this, arguments, void 0, function* (functionName, options = {}) {
      var _a2;
      try {
        const { headers, method, body: functionArgs, signal } = options;
        let _headers = {};
        let { region } = options;
        if (!region) {
          region = this.region;
        }
        const url = new URL(`${this.url}/${functionName}`);
        if (region && region !== "any") {
          _headers["x-region"] = region;
          url.searchParams.set("forceFunctionRegion", region);
        }
        let body2;
        if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, "Content-Type") || !headers)) {
          if (typeof Blob !== "undefined" && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {
            _headers["Content-Type"] = "application/octet-stream";
            body2 = functionArgs;
          } else if (typeof functionArgs === "string") {
            _headers["Content-Type"] = "text/plain";
            body2 = functionArgs;
          } else if (typeof FormData !== "undefined" && functionArgs instanceof FormData) {
            body2 = functionArgs;
          } else {
            _headers["Content-Type"] = "application/json";
            body2 = JSON.stringify(functionArgs);
          }
        } else {
          body2 = functionArgs;
        }
        const response = yield this.fetch(url.toString(), {
          method: method || "POST",
          // headers priority is (high to low):
          // 1. invoke-level headers
          // 2. client-level headers
          // 3. default Content-Type header
          headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),
          body: body2,
          signal
        }).catch((fetchError) => {
          if (fetchError.name === "AbortError") {
            throw fetchError;
          }
          throw new FunctionsFetchError(fetchError);
        });
        const isRelayError = response.headers.get("x-relay-error");
        if (isRelayError && isRelayError === "true") {
          throw new FunctionsRelayError(response);
        }
        if (!response.ok) {
          throw new FunctionsHttpError(response);
        }
        let responseType = ((_a2 = response.headers.get("Content-Type")) !== null && _a2 !== void 0 ? _a2 : "text/plain").split(";")[0].trim();
        let data;
        if (responseType === "application/json") {
          data = yield response.json();
        } else if (responseType === "application/octet-stream" || responseType === "application/pdf") {
          data = yield response.blob();
        } else if (responseType === "text/event-stream") {
          data = response;
        } else if (responseType === "multipart/form-data") {
          data = yield response.formData();
        } else {
          data = yield response.text();
        }
        return { data, error: null, response };
      } catch (error2) {
        if (error2 instanceof Error && error2.name === "AbortError") {
          return { data: null, error: new FunctionsFetchError(error2) };
        }
        return {
          data: null,
          error: error2,
          response: error2 instanceof FunctionsHttpError || error2 instanceof FunctionsRelayError ? error2.context : void 0
        };
      }
    });
  }
}
var cjs = {};
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6$1);
var PostgrestClient$1 = {};
var PostgrestQueryBuilder$1 = {};
var PostgrestFilterBuilder$1 = {};
var PostgrestTransformBuilder$1 = {};
var PostgrestBuilder$1 = {};
var getGlobal = function() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
};
var globalObject = getGlobal();
const fetch$1 = globalObject.fetch;
const nodeFetch = globalObject.fetch.bind(globalObject);
const Headers$1 = globalObject.Headers;
const Request = globalObject.Request;
const Response$1 = globalObject.Response;
const browser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Headers: Headers$1,
  Request,
  Response: Response$1,
  default: nodeFetch,
  fetch: fetch$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(browser);
var PostgrestError$1 = {};
var hasRequiredPostgrestError;
function requirePostgrestError() {
  if (hasRequiredPostgrestError) return PostgrestError$1;
  hasRequiredPostgrestError = 1;
  Object.defineProperty(PostgrestError$1, "__esModule", { value: true });
  class PostgrestError2 extends Error {
    constructor(context) {
      super(context.message);
      this.name = "PostgrestError";
      this.details = context.details;
      this.hint = context.hint;
      this.code = context.code;
    }
  }
  PostgrestError$1.default = PostgrestError2;
  return PostgrestError$1;
}
var hasRequiredPostgrestBuilder;
function requirePostgrestBuilder() {
  if (hasRequiredPostgrestBuilder) return PostgrestBuilder$1;
  hasRequiredPostgrestBuilder = 1;
  Object.defineProperty(PostgrestBuilder$1, "__esModule", { value: true });
  const tslib_1 = require$$0;
  const node_fetch_1 = tslib_1.__importDefault(require$$1);
  const PostgrestError_1 = tslib_1.__importDefault(requirePostgrestError());
  class PostgrestBuilder2 {
    constructor(builder) {
      var _a2, _b;
      this.shouldThrowOnError = false;
      this.method = builder.method;
      this.url = builder.url;
      this.headers = new Headers(builder.headers);
      this.schema = builder.schema;
      this.body = builder.body;
      this.shouldThrowOnError = (_a2 = builder.shouldThrowOnError) !== null && _a2 !== void 0 ? _a2 : false;
      this.signal = builder.signal;
      this.isMaybeSingle = (_b = builder.isMaybeSingle) !== null && _b !== void 0 ? _b : false;
      if (builder.fetch) {
        this.fetch = builder.fetch;
      } else if (typeof fetch === "undefined") {
        this.fetch = node_fetch_1.default;
      } else {
        this.fetch = fetch;
      }
    }
    /**
     * If there's an error with the query, throwOnError will reject the promise by
     * throwing the error instead of returning it as part of a successful response.
     *
     * {@link https://github.com/supabase/supabase-js/issues/92}
     */
    throwOnError() {
      this.shouldThrowOnError = true;
      return this;
    }
    /**
     * Set an HTTP header for the request.
     */
    setHeader(name2, value) {
      this.headers = new Headers(this.headers);
      this.headers.set(name2, value);
      return this;
    }
    then(onfulfilled, onrejected) {
      if (this.schema === void 0) ;
      else if (["GET", "HEAD"].includes(this.method)) {
        this.headers.set("Accept-Profile", this.schema);
      } else {
        this.headers.set("Content-Profile", this.schema);
      }
      if (this.method !== "GET" && this.method !== "HEAD") {
        this.headers.set("Content-Type", "application/json");
      }
      const _fetch = this.fetch;
      let res = _fetch(this.url.toString(), {
        method: this.method,
        headers: this.headers,
        body: JSON.stringify(this.body),
        signal: this.signal
      }).then((res2) => __async(this, null, function* () {
        var _a2, _b, _c, _d;
        let error2 = null;
        let data = null;
        let count = null;
        let status = res2.status;
        let statusText = res2.statusText;
        if (res2.ok) {
          if (this.method !== "HEAD") {
            const body2 = yield res2.text();
            if (body2 === "") ;
            else if (this.headers.get("Accept") === "text/csv") {
              data = body2;
            } else if (this.headers.get("Accept") && ((_a2 = this.headers.get("Accept")) === null || _a2 === void 0 ? void 0 : _a2.includes("application/vnd.pgrst.plan+text"))) {
              data = body2;
            } else {
              data = JSON.parse(body2);
            }
          }
          const countHeader = (_b = this.headers.get("Prefer")) === null || _b === void 0 ? void 0 : _b.match(/count=(exact|planned|estimated)/);
          const contentRange = (_c = res2.headers.get("content-range")) === null || _c === void 0 ? void 0 : _c.split("/");
          if (countHeader && contentRange && contentRange.length > 1) {
            count = parseInt(contentRange[1]);
          }
          if (this.isMaybeSingle && this.method === "GET" && Array.isArray(data)) {
            if (data.length > 1) {
              error2 = {
                // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553
                code: "PGRST116",
                details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,
                hint: null,
                message: "JSON object requested, multiple (or no) rows returned"
              };
              data = null;
              count = null;
              status = 406;
              statusText = "Not Acceptable";
            } else if (data.length === 1) {
              data = data[0];
            } else {
              data = null;
            }
          }
        } else {
          const body2 = yield res2.text();
          try {
            error2 = JSON.parse(body2);
            if (Array.isArray(error2) && res2.status === 404) {
              data = [];
              error2 = null;
              status = 200;
              statusText = "OK";
            }
          } catch (_e) {
            if (res2.status === 404 && body2 === "") {
              status = 204;
              statusText = "No Content";
            } else {
              error2 = {
                message: body2
              };
            }
          }
          if (error2 && this.isMaybeSingle && ((_d = error2 === null || error2 === void 0 ? void 0 : error2.details) === null || _d === void 0 ? void 0 : _d.includes("0 rows"))) {
            error2 = null;
            status = 200;
            statusText = "OK";
          }
          if (error2 && this.shouldThrowOnError) {
            throw new PostgrestError_1.default(error2);
          }
        }
        const postgrestResponse = {
          error: error2,
          data,
          count,
          status,
          statusText
        };
        return postgrestResponse;
      }));
      if (!this.shouldThrowOnError) {
        res = res.catch((fetchError) => {
          var _a2, _b, _c;
          return {
            error: {
              message: `${(_a2 = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _a2 !== void 0 ? _a2 : "FetchError"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,
              details: `${(_b = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _b !== void 0 ? _b : ""}`,
              hint: "",
              code: `${(_c = fetchError === null || fetchError === void 0 ? void 0 : fetchError.code) !== null && _c !== void 0 ? _c : ""}`
            },
            data: null,
            count: null,
            status: 0,
            statusText: ""
          };
        });
      }
      return res.then(onfulfilled, onrejected);
    }
    /**
     * Override the type of the returned `data`.
     *
     * @typeParam NewResult - The new result type to override with
     * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead
     */
    returns() {
      return this;
    }
    /**
     * Override the type of the returned `data` field in the response.
     *
     * @typeParam NewResult - The new type to cast the response data to
     * @typeParam Options - Optional type configuration (defaults to { merge: true })
     * @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)
     * @example
     * ```typescript
     * // Merge with existing types (default behavior)
     * const query = supabase
     *   .from('users')
     *   .select()
     *   .overrideTypes<{ custom_field: string }>()
     *
     * // Replace existing types completely
     * const replaceQuery = supabase
     *   .from('users')
     *   .select()
     *   .overrideTypes<{ id: number; name: string }, { merge: false }>()
     * ```
     * @returns A PostgrestBuilder instance with the new type
     */
    overrideTypes() {
      return this;
    }
  }
  PostgrestBuilder$1.default = PostgrestBuilder2;
  return PostgrestBuilder$1;
}
var hasRequiredPostgrestTransformBuilder;
function requirePostgrestTransformBuilder() {
  if (hasRequiredPostgrestTransformBuilder) return PostgrestTransformBuilder$1;
  hasRequiredPostgrestTransformBuilder = 1;
  Object.defineProperty(PostgrestTransformBuilder$1, "__esModule", { value: true });
  const tslib_1 = require$$0;
  const PostgrestBuilder_1 = tslib_1.__importDefault(requirePostgrestBuilder());
  class PostgrestTransformBuilder2 extends PostgrestBuilder_1.default {
    /**
     * Perform a SELECT on the query result.
     *
     * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not
     * return modified rows. By calling this method, modified rows are returned in
     * `data`.
     *
     * @param columns - The columns to retrieve, separated by commas
     */
    select(columns) {
      let quoted = false;
      const cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map((c) => {
        if (/\s/.test(c) && !quoted) {
          return "";
        }
        if (c === '"') {
          quoted = !quoted;
        }
        return c;
      }).join("");
      this.url.searchParams.set("select", cleanedColumns);
      this.headers.append("Prefer", "return=representation");
      return this;
    }
    /**
     * Order the query result by `column`.
     *
     * You can call this method multiple times to order by multiple columns.
     *
     * You can order referenced tables, but it only affects the ordering of the
     * parent table if you use `!inner` in the query.
     *
     * @param column - The column to order by
     * @param options - Named parameters
     * @param options.ascending - If `true`, the result will be in ascending order
     * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,
     * `null`s appear last.
     * @param options.referencedTable - Set this to order a referenced table by
     * its columns
     * @param options.foreignTable - Deprecated, use `options.referencedTable`
     * instead
     */
    order(column2, { ascending = true, nullsFirst, foreignTable, referencedTable = foreignTable } = {}) {
      const key = referencedTable ? `${referencedTable}.order` : "order";
      const existingOrder = this.url.searchParams.get(key);
      this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : ""}${column2}.${ascending ? "asc" : "desc"}${nullsFirst === void 0 ? "" : nullsFirst ? ".nullsfirst" : ".nullslast"}`);
      return this;
    }
    /**
     * Limit the query result by `count`.
     *
     * @param count - The maximum number of rows to return
     * @param options - Named parameters
     * @param options.referencedTable - Set this to limit rows of referenced
     * tables instead of the parent table
     * @param options.foreignTable - Deprecated, use `options.referencedTable`
     * instead
     */
    limit(count, { foreignTable, referencedTable = foreignTable } = {}) {
      const key = typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`;
      this.url.searchParams.set(key, `${count}`);
      return this;
    }
    /**
     * Limit the query result by starting at an offset `from` and ending at the offset `to`.
     * Only records within this range are returned.
     * This respects the query order and if there is no order clause the range could behave unexpectedly.
     * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third
     * and fourth rows of the query.
     *
     * @param from - The starting index from which to limit the result
     * @param to - The last index to which to limit the result
     * @param options - Named parameters
     * @param options.referencedTable - Set this to limit rows of referenced
     * tables instead of the parent table
     * @param options.foreignTable - Deprecated, use `options.referencedTable`
     * instead
     */
    range(from2, to, { foreignTable, referencedTable = foreignTable } = {}) {
      const keyOffset = typeof referencedTable === "undefined" ? "offset" : `${referencedTable}.offset`;
      const keyLimit = typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`;
      this.url.searchParams.set(keyOffset, `${from2}`);
      this.url.searchParams.set(keyLimit, `${to - from2 + 1}`);
      return this;
    }
    /**
     * Set the AbortSignal for the fetch request.
     *
     * @param signal - The AbortSignal to use for the fetch request
     */
    abortSignal(signal) {
      this.signal = signal;
      return this;
    }
    /**
     * Return `data` as a single object instead of an array of objects.
     *
     * Query result must be one row (e.g. using `.limit(1)`), otherwise this
     * returns an error.
     */
    single() {
      this.headers.set("Accept", "application/vnd.pgrst.object+json");
      return this;
    }
    /**
     * Return `data` as a single object instead of an array of objects.
     *
     * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise
     * this returns an error.
     */
    maybeSingle() {
      if (this.method === "GET") {
        this.headers.set("Accept", "application/json");
      } else {
        this.headers.set("Accept", "application/vnd.pgrst.object+json");
      }
      this.isMaybeSingle = true;
      return this;
    }
    /**
     * Return `data` as a string in CSV format.
     */
    csv() {
      this.headers.set("Accept", "text/csv");
      return this;
    }
    /**
     * Return `data` as an object in [GeoJSON](https://geojson.org) format.
     */
    geojson() {
      this.headers.set("Accept", "application/geo+json");
      return this;
    }
    /**
     * Return `data` as the EXPLAIN plan for the query.
     *
     * You need to enable the
     * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)
     * setting before using this method.
     *
     * @param options - Named parameters
     *
     * @param options.analyze - If `true`, the query will be executed and the
     * actual run time will be returned
     *
     * @param options.verbose - If `true`, the query identifier will be returned
     * and `data` will include the output columns of the query
     *
     * @param options.settings - If `true`, include information on configuration
     * parameters that affect query planning
     *
     * @param options.buffers - If `true`, include information on buffer usage
     *
     * @param options.wal - If `true`, include information on WAL record generation
     *
     * @param options.format - The format of the output, can be `"text"` (default)
     * or `"json"`
     */
    explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = "text" } = {}) {
      var _a2;
      const options = [
        analyze ? "analyze" : null,
        verbose ? "verbose" : null,
        settings ? "settings" : null,
        buffers ? "buffers" : null,
        wal ? "wal" : null
      ].filter(Boolean).join("|");
      const forMediatype = (_a2 = this.headers.get("Accept")) !== null && _a2 !== void 0 ? _a2 : "application/json";
      this.headers.set("Accept", `application/vnd.pgrst.plan+${format}; for="${forMediatype}"; options=${options};`);
      if (format === "json") {
        return this;
      } else {
        return this;
      }
    }
    /**
     * Rollback the query.
     *
     * `data` will still be returned, but the query is not committed.
     */
    rollback() {
      this.headers.append("Prefer", "tx=rollback");
      return this;
    }
    /**
     * Override the type of the returned `data`.
     *
     * @typeParam NewResult - The new result type to override with
     * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead
     */
    returns() {
      return this;
    }
    /**
     * Set the maximum number of rows that can be affected by the query.
     * Only available in PostgREST v13+ and only works with PATCH and DELETE methods.
     *
     * @param value - The maximum number of rows that can be affected
     */
    maxAffected(value) {
      this.headers.append("Prefer", "handling=strict");
      this.headers.append("Prefer", `max-affected=${value}`);
      return this;
    }
  }
  PostgrestTransformBuilder$1.default = PostgrestTransformBuilder2;
  return PostgrestTransformBuilder$1;
}
var hasRequiredPostgrestFilterBuilder;
function requirePostgrestFilterBuilder() {
  if (hasRequiredPostgrestFilterBuilder) return PostgrestFilterBuilder$1;
  hasRequiredPostgrestFilterBuilder = 1;
  Object.defineProperty(PostgrestFilterBuilder$1, "__esModule", { value: true });
  const tslib_1 = require$$0;
  const PostgrestTransformBuilder_1 = tslib_1.__importDefault(requirePostgrestTransformBuilder());
  class PostgrestFilterBuilder2 extends PostgrestTransformBuilder_1.default {
    /**
     * Match only rows where `column` is equal to `value`.
     *
     * To check if the value of `column` is NULL, you should use `.is()` instead.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    eq(column2, value) {
      this.url.searchParams.append(column2, `eq.${value}`);
      return this;
    }
    /**
     * Match only rows where `column` is not equal to `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    neq(column2, value) {
      this.url.searchParams.append(column2, `neq.${value}`);
      return this;
    }
    /**
     * Match only rows where `column` is greater than `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    gt(column2, value) {
      this.url.searchParams.append(column2, `gt.${value}`);
      return this;
    }
    /**
     * Match only rows where `column` is greater than or equal to `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    gte(column2, value) {
      this.url.searchParams.append(column2, `gte.${value}`);
      return this;
    }
    /**
     * Match only rows where `column` is less than `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    lt(column2, value) {
      this.url.searchParams.append(column2, `lt.${value}`);
      return this;
    }
    /**
     * Match only rows where `column` is less than or equal to `value`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    lte(column2, value) {
      this.url.searchParams.append(column2, `lte.${value}`);
      return this;
    }
    /**
     * Match only rows where `column` matches `pattern` case-sensitively.
     *
     * @param column - The column to filter on
     * @param pattern - The pattern to match with
     */
    like(column2, pattern) {
      this.url.searchParams.append(column2, `like.${pattern}`);
      return this;
    }
    /**
     * Match only rows where `column` matches all of `patterns` case-sensitively.
     *
     * @param column - The column to filter on
     * @param patterns - The patterns to match with
     */
    likeAllOf(column2, patterns) {
      this.url.searchParams.append(column2, `like(all).{${patterns.join(",")}}`);
      return this;
    }
    /**
     * Match only rows where `column` matches any of `patterns` case-sensitively.
     *
     * @param column - The column to filter on
     * @param patterns - The patterns to match with
     */
    likeAnyOf(column2, patterns) {
      this.url.searchParams.append(column2, `like(any).{${patterns.join(",")}}`);
      return this;
    }
    /**
     * Match only rows where `column` matches `pattern` case-insensitively.
     *
     * @param column - The column to filter on
     * @param pattern - The pattern to match with
     */
    ilike(column2, pattern) {
      this.url.searchParams.append(column2, `ilike.${pattern}`);
      return this;
    }
    /**
     * Match only rows where `column` matches all of `patterns` case-insensitively.
     *
     * @param column - The column to filter on
     * @param patterns - The patterns to match with
     */
    ilikeAllOf(column2, patterns) {
      this.url.searchParams.append(column2, `ilike(all).{${patterns.join(",")}}`);
      return this;
    }
    /**
     * Match only rows where `column` matches any of `patterns` case-insensitively.
     *
     * @param column - The column to filter on
     * @param patterns - The patterns to match with
     */
    ilikeAnyOf(column2, patterns) {
      this.url.searchParams.append(column2, `ilike(any).{${patterns.join(",")}}`);
      return this;
    }
    /**
     * Match only rows where `column` IS `value`.
     *
     * For non-boolean columns, this is only relevant for checking if the value of
     * `column` is NULL by setting `value` to `null`.
     *
     * For boolean columns, you can also set `value` to `true` or `false` and it
     * will behave the same way as `.eq()`.
     *
     * @param column - The column to filter on
     * @param value - The value to filter with
     */
    is(column2, value) {
      this.url.searchParams.append(column2, `is.${value}`);
      return this;
    }
    /**
     * Match only rows where `column` is included in the `values` array.
     *
     * @param column - The column to filter on
     * @param values - The values array to filter with
     */
    in(column2, values2) {
      const cleanedValues = Array.from(new Set(values2)).map((s) => {
        if (typeof s === "string" && new RegExp("[,()]").test(s))
          return `"${s}"`;
        else
          return `${s}`;
      }).join(",");
      this.url.searchParams.append(column2, `in.(${cleanedValues})`);
      return this;
    }
    /**
     * Only relevant for jsonb, array, and range columns. Match only rows where
     * `column` contains every element appearing in `value`.
     *
     * @param column - The jsonb, array, or range column to filter on
     * @param value - The jsonb, array, or range value to filter with
     */
    contains(column2, value) {
      if (typeof value === "string") {
        this.url.searchParams.append(column2, `cs.${value}`);
      } else if (Array.isArray(value)) {
        this.url.searchParams.append(column2, `cs.{${value.join(",")}}`);
      } else {
        this.url.searchParams.append(column2, `cs.${JSON.stringify(value)}`);
      }
      return this;
    }
    /**
     * Only relevant for jsonb, array, and range columns. Match only rows where
     * every element appearing in `column` is contained by `value`.
     *
     * @param column - The jsonb, array, or range column to filter on
     * @param value - The jsonb, array, or range value to filter with
     */
    containedBy(column2, value) {
      if (typeof value === "string") {
        this.url.searchParams.append(column2, `cd.${value}`);
      } else if (Array.isArray(value)) {
        this.url.searchParams.append(column2, `cd.{${value.join(",")}}`);
      } else {
        this.url.searchParams.append(column2, `cd.${JSON.stringify(value)}`);
      }
      return this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is greater than any element in `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */
    rangeGt(column2, range) {
      this.url.searchParams.append(column2, `sr.${range}`);
      return this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is either contained in `range` or greater than any element in
     * `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */
    rangeGte(column2, range) {
      this.url.searchParams.append(column2, `nxl.${range}`);
      return this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is less than any element in `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */
    rangeLt(column2, range) {
      this.url.searchParams.append(column2, `sl.${range}`);
      return this;
    }
    /**
     * Only relevant for range columns. Match only rows where every element in
     * `column` is either contained in `range` or less than any element in
     * `range`.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */
    rangeLte(column2, range) {
      this.url.searchParams.append(column2, `nxr.${range}`);
      return this;
    }
    /**
     * Only relevant for range columns. Match only rows where `column` is
     * mutually exclusive to `range` and there can be no element between the two
     * ranges.
     *
     * @param column - The range column to filter on
     * @param range - The range to filter with
     */
    rangeAdjacent(column2, range) {
      this.url.searchParams.append(column2, `adj.${range}`);
      return this;
    }
    /**
     * Only relevant for array and range columns. Match only rows where
     * `column` and `value` have an element in common.
     *
     * @param column - The array or range column to filter on
     * @param value - The array or range value to filter with
     */
    overlaps(column2, value) {
      if (typeof value === "string") {
        this.url.searchParams.append(column2, `ov.${value}`);
      } else {
        this.url.searchParams.append(column2, `ov.{${value.join(",")}}`);
      }
      return this;
    }
    /**
     * Only relevant for text and tsvector columns. Match only rows where
     * `column` matches the query string in `query`.
     *
     * @param column - The text or tsvector column to filter on
     * @param query - The query text to match with
     * @param options - Named parameters
     * @param options.config - The text search configuration to use
     * @param options.type - Change how the `query` text is interpreted
     */
    textSearch(column2, query, { config: config2, type } = {}) {
      let typePart = "";
      if (type === "plain") {
        typePart = "pl";
      } else if (type === "phrase") {
        typePart = "ph";
      } else if (type === "websearch") {
        typePart = "w";
      }
      const configPart = config2 === void 0 ? "" : `(${config2})`;
      this.url.searchParams.append(column2, `${typePart}fts${configPart}.${query}`);
      return this;
    }
    /**
     * Match only rows where each column in `query` keys is equal to its
     * associated value. Shorthand for multiple `.eq()`s.
     *
     * @param query - The object to filter with, with column names as keys mapped
     * to their filter values
     */
    match(query) {
      Object.entries(query).forEach(([column2, value]) => {
        this.url.searchParams.append(column2, `eq.${value}`);
      });
      return this;
    }
    /**
     * Match only rows which doesn't satisfy the filter.
     *
     * Unlike most filters, `opearator` and `value` are used as-is and need to
     * follow [PostgREST
     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
     * to make sure they are properly sanitized.
     *
     * @param column - The column to filter on
     * @param operator - The operator to be negated to filter with, following
     * PostgREST syntax
     * @param value - The value to filter with, following PostgREST syntax
     */
    not(column2, operator, value) {
      this.url.searchParams.append(column2, `not.${operator}.${value}`);
      return this;
    }
    /**
     * Match only rows which satisfy at least one of the filters.
     *
     * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST
     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
     * to make sure it's properly sanitized.
     *
     * It's currently not possible to do an `.or()` filter across multiple tables.
     *
     * @param filters - The filters to use, following PostgREST syntax
     * @param options - Named parameters
     * @param options.referencedTable - Set this to filter on referenced tables
     * instead of the parent table
     * @param options.foreignTable - Deprecated, use `referencedTable` instead
     */
    or(filters, { foreignTable, referencedTable = foreignTable } = {}) {
      const key = referencedTable ? `${referencedTable}.or` : "or";
      this.url.searchParams.append(key, `(${filters})`);
      return this;
    }
    /**
     * Match only rows which satisfy the filter. This is an escape hatch - you
     * should use the specific filter methods wherever possible.
     *
     * Unlike most filters, `opearator` and `value` are used as-is and need to
     * follow [PostgREST
     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
     * to make sure they are properly sanitized.
     *
     * @param column - The column to filter on
     * @param operator - The operator to filter with, following PostgREST syntax
     * @param value - The value to filter with, following PostgREST syntax
     */
    filter(column2, operator, value) {
      this.url.searchParams.append(column2, `${operator}.${value}`);
      return this;
    }
  }
  PostgrestFilterBuilder$1.default = PostgrestFilterBuilder2;
  return PostgrestFilterBuilder$1;
}
var hasRequiredPostgrestQueryBuilder;
function requirePostgrestQueryBuilder() {
  if (hasRequiredPostgrestQueryBuilder) return PostgrestQueryBuilder$1;
  hasRequiredPostgrestQueryBuilder = 1;
  Object.defineProperty(PostgrestQueryBuilder$1, "__esModule", { value: true });
  const tslib_1 = require$$0;
  const PostgrestFilterBuilder_1 = tslib_1.__importDefault(requirePostgrestFilterBuilder());
  class PostgrestQueryBuilder2 {
    constructor(url, { headers = {}, schema, fetch: fetch2 }) {
      this.url = url;
      this.headers = new Headers(headers);
      this.schema = schema;
      this.fetch = fetch2;
    }
    /**
     * Perform a SELECT query on the table or view.
     *
     * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`
     *
     * @param options - Named parameters
     *
     * @param options.head - When set to `true`, `data` will not be returned.
     * Useful if you only need the count.
     *
     * @param options.count - Count algorithm to use to count rows in the table or view.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */
    select(columns, options) {
      const { head: head2 = false, count } = options !== null && options !== void 0 ? options : {};
      const method = head2 ? "HEAD" : "GET";
      let quoted = false;
      const cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map((c) => {
        if (/\s/.test(c) && !quoted) {
          return "";
        }
        if (c === '"') {
          quoted = !quoted;
        }
        return c;
      }).join("");
      this.url.searchParams.set("select", cleanedColumns);
      if (count) {
        this.headers.append("Prefer", `count=${count}`);
      }
      return new PostgrestFilterBuilder_1.default({
        method,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        fetch: this.fetch
      });
    }
    /**
     * Perform an INSERT into the table or view.
     *
     * By default, inserted rows are not returned. To return it, chain the call
     * with `.select()`.
     *
     * @param values - The values to insert. Pass an object to insert a single row
     * or an array to insert multiple rows.
     *
     * @param options - Named parameters
     *
     * @param options.count - Count algorithm to use to count inserted rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     *
     * @param options.defaultToNull - Make missing fields default to `null`.
     * Otherwise, use the default value for the column. Only applies for bulk
     * inserts.
     */
    insert(values2, { count, defaultToNull = true } = {}) {
      var _a2;
      const method = "POST";
      if (count) {
        this.headers.append("Prefer", `count=${count}`);
      }
      if (!defaultToNull) {
        this.headers.append("Prefer", `missing=default`);
      }
      if (Array.isArray(values2)) {
        const columns = values2.reduce((acc, x) => acc.concat(Object.keys(x)), []);
        if (columns.length > 0) {
          const uniqueColumns = [...new Set(columns)].map((column2) => `"${column2}"`);
          this.url.searchParams.set("columns", uniqueColumns.join(","));
        }
      }
      return new PostgrestFilterBuilder_1.default({
        method,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: values2,
        fetch: (_a2 = this.fetch) !== null && _a2 !== void 0 ? _a2 : fetch
      });
    }
    /**
     * Perform an UPSERT on the table or view. Depending on the column(s) passed
     * to `onConflict`, `.upsert()` allows you to perform the equivalent of
     * `.insert()` if a row with the corresponding `onConflict` columns doesn't
     * exist, or if it does exist, perform an alternative action depending on
     * `ignoreDuplicates`.
     *
     * By default, upserted rows are not returned. To return it, chain the call
     * with `.select()`.
     *
     * @param values - The values to upsert with. Pass an object to upsert a
     * single row or an array to upsert multiple rows.
     *
     * @param options - Named parameters
     *
     * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how
     * duplicate rows are determined. Two rows are duplicates if all the
     * `onConflict` columns are equal.
     *
     * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If
     * `false`, duplicate rows are merged with existing rows.
     *
     * @param options.count - Count algorithm to use to count upserted rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     *
     * @param options.defaultToNull - Make missing fields default to `null`.
     * Otherwise, use the default value for the column. This only applies when
     * inserting new rows, not when merging with existing rows under
     * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.
     */
    upsert(values2, { onConflict, ignoreDuplicates = false, count, defaultToNull = true } = {}) {
      var _a2;
      const method = "POST";
      this.headers.append("Prefer", `resolution=${ignoreDuplicates ? "ignore" : "merge"}-duplicates`);
      if (onConflict !== void 0)
        this.url.searchParams.set("on_conflict", onConflict);
      if (count) {
        this.headers.append("Prefer", `count=${count}`);
      }
      if (!defaultToNull) {
        this.headers.append("Prefer", "missing=default");
      }
      if (Array.isArray(values2)) {
        const columns = values2.reduce((acc, x) => acc.concat(Object.keys(x)), []);
        if (columns.length > 0) {
          const uniqueColumns = [...new Set(columns)].map((column2) => `"${column2}"`);
          this.url.searchParams.set("columns", uniqueColumns.join(","));
        }
      }
      return new PostgrestFilterBuilder_1.default({
        method,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: values2,
        fetch: (_a2 = this.fetch) !== null && _a2 !== void 0 ? _a2 : fetch
      });
    }
    /**
     * Perform an UPDATE on the table or view.
     *
     * By default, updated rows are not returned. To return it, chain the call
     * with `.select()` after filters.
     *
     * @param values - The values to update with
     *
     * @param options - Named parameters
     *
     * @param options.count - Count algorithm to use to count updated rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */
    update(values2, { count } = {}) {
      var _a2;
      const method = "PATCH";
      if (count) {
        this.headers.append("Prefer", `count=${count}`);
      }
      return new PostgrestFilterBuilder_1.default({
        method,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: values2,
        fetch: (_a2 = this.fetch) !== null && _a2 !== void 0 ? _a2 : fetch
      });
    }
    /**
     * Perform a DELETE on the table or view.
     *
     * By default, deleted rows are not returned. To return it, chain the call
     * with `.select()` after filters.
     *
     * @param options - Named parameters
     *
     * @param options.count - Count algorithm to use to count deleted rows.
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */
    delete({ count } = {}) {
      var _a2;
      const method = "DELETE";
      if (count) {
        this.headers.append("Prefer", `count=${count}`);
      }
      return new PostgrestFilterBuilder_1.default({
        method,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        fetch: (_a2 = this.fetch) !== null && _a2 !== void 0 ? _a2 : fetch
      });
    }
  }
  PostgrestQueryBuilder$1.default = PostgrestQueryBuilder2;
  return PostgrestQueryBuilder$1;
}
var hasRequiredPostgrestClient;
function requirePostgrestClient() {
  if (hasRequiredPostgrestClient) return PostgrestClient$1;
  hasRequiredPostgrestClient = 1;
  Object.defineProperty(PostgrestClient$1, "__esModule", { value: true });
  const tslib_1 = require$$0;
  const PostgrestQueryBuilder_1 = tslib_1.__importDefault(requirePostgrestQueryBuilder());
  const PostgrestFilterBuilder_1 = tslib_1.__importDefault(requirePostgrestFilterBuilder());
  class PostgrestClient2 {
    // TODO: Add back shouldThrowOnError once we figure out the typings
    /**
     * Creates a PostgREST client.
     *
     * @param url - URL of the PostgREST endpoint
     * @param options - Named parameters
     * @param options.headers - Custom headers
     * @param options.schema - Postgres schema to switch to
     * @param options.fetch - Custom fetch
     */
    constructor(url, { headers = {}, schema, fetch: fetch2 } = {}) {
      this.url = url;
      this.headers = new Headers(headers);
      this.schemaName = schema;
      this.fetch = fetch2;
    }
    /**
     * Perform a query on a table or a view.
     *
     * @param relation - The table or view name to query
     */
    from(relation) {
      const url = new URL(`${this.url}/${relation}`);
      return new PostgrestQueryBuilder_1.default(url, {
        headers: new Headers(this.headers),
        schema: this.schemaName,
        fetch: this.fetch
      });
    }
    /**
     * Select a schema to query or perform an function (rpc) call.
     *
     * The schema needs to be on the list of exposed schemas inside Supabase.
     *
     * @param schema - The schema to query
     */
    schema(schema) {
      return new PostgrestClient2(this.url, {
        headers: this.headers,
        schema,
        fetch: this.fetch
      });
    }
    /**
     * Perform a function call.
     *
     * @param fn - The function name to call
     * @param args - The arguments to pass to the function call
     * @param options - Named parameters
     * @param options.head - When set to `true`, `data` will not be returned.
     * Useful if you only need the count.
     * @param options.get - When set to `true`, the function will be called with
     * read-only access mode.
     * @param options.count - Count algorithm to use to count rows returned by the
     * function. Only applicable for [set-returning
     * functions](https://www.postgresql.org/docs/current/functions-srf.html).
     *
     * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
     * hood.
     *
     * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
     * statistics under the hood.
     *
     * `"estimated"`: Uses exact count for low numbers and planned count for high
     * numbers.
     */
    rpc(fn2, args = {}, { head: head2 = false, get: get2 = false, count } = {}) {
      var _a2;
      let method;
      const url = new URL(`${this.url}/rpc/${fn2}`);
      let body2;
      if (head2 || get2) {
        method = head2 ? "HEAD" : "GET";
        Object.entries(args).filter(([_, value]) => value !== void 0).map(([name2, value]) => [name2, Array.isArray(value) ? `{${value.join(",")}}` : `${value}`]).forEach(([name2, value]) => {
          url.searchParams.append(name2, value);
        });
      } else {
        method = "POST";
        body2 = args;
      }
      const headers = new Headers(this.headers);
      if (count) {
        headers.set("Prefer", `count=${count}`);
      }
      return new PostgrestFilterBuilder_1.default({
        method,
        url,
        headers,
        schema: this.schemaName,
        body: body2,
        fetch: (_a2 = this.fetch) !== null && _a2 !== void 0 ? _a2 : fetch
      });
    }
  }
  PostgrestClient$1.default = PostgrestClient2;
  return PostgrestClient$1;
}
var hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs) return cjs;
  hasRequiredCjs = 1;
  Object.defineProperty(cjs, "__esModule", { value: true });
  cjs.PostgrestError = cjs.PostgrestBuilder = cjs.PostgrestTransformBuilder = cjs.PostgrestFilterBuilder = cjs.PostgrestQueryBuilder = cjs.PostgrestClient = void 0;
  const tslib_1 = require$$0;
  const PostgrestClient_1 = tslib_1.__importDefault(requirePostgrestClient());
  cjs.PostgrestClient = PostgrestClient_1.default;
  const PostgrestQueryBuilder_1 = tslib_1.__importDefault(requirePostgrestQueryBuilder());
  cjs.PostgrestQueryBuilder = PostgrestQueryBuilder_1.default;
  const PostgrestFilterBuilder_1 = tslib_1.__importDefault(requirePostgrestFilterBuilder());
  cjs.PostgrestFilterBuilder = PostgrestFilterBuilder_1.default;
  const PostgrestTransformBuilder_1 = tslib_1.__importDefault(requirePostgrestTransformBuilder());
  cjs.PostgrestTransformBuilder = PostgrestTransformBuilder_1.default;
  const PostgrestBuilder_1 = tslib_1.__importDefault(requirePostgrestBuilder());
  cjs.PostgrestBuilder = PostgrestBuilder_1.default;
  const PostgrestError_1 = tslib_1.__importDefault(requirePostgrestError());
  cjs.PostgrestError = PostgrestError_1.default;
  cjs.default = {
    PostgrestClient: PostgrestClient_1.default,
    PostgrestQueryBuilder: PostgrestQueryBuilder_1.default,
    PostgrestFilterBuilder: PostgrestFilterBuilder_1.default,
    PostgrestTransformBuilder: PostgrestTransformBuilder_1.default,
    PostgrestBuilder: PostgrestBuilder_1.default,
    PostgrestError: PostgrestError_1.default
  };
  return cjs;
}
var cjsExports = requireCjs();
const index = /* @__PURE__ */ getDefaultExportFromCjs(cjsExports);
const {
  PostgrestClient,
  PostgrestQueryBuilder,
  PostgrestFilterBuilder,
  PostgrestTransformBuilder,
  PostgrestBuilder,
  PostgrestError
} = index;
class WebSocketFactory {
  static detectEnvironment() {
    var _a2;
    if (typeof WebSocket !== "undefined") {
      return { type: "native", constructor: WebSocket };
    }
    if (typeof globalThis !== "undefined" && typeof globalThis.WebSocket !== "undefined") {
      return { type: "native", constructor: globalThis.WebSocket };
    }
    if (typeof global !== "undefined" && typeof global.WebSocket !== "undefined") {
      return { type: "native", constructor: global.WebSocket };
    }
    if (typeof globalThis !== "undefined" && typeof globalThis.WebSocketPair !== "undefined" && typeof globalThis.WebSocket === "undefined") {
      return {
        type: "cloudflare",
        error: "Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",
        workaround: "Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."
      };
    }
    if (typeof globalThis !== "undefined" && globalThis.EdgeRuntime || typeof navigator !== "undefined" && ((_a2 = navigator.userAgent) === null || _a2 === void 0 ? void 0 : _a2.includes("Vercel-Edge"))) {
      return {
        type: "unsupported",
        error: "Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",
        workaround: "Use serverless functions or a different deployment target for WebSocket functionality."
      };
    }
    if (typeof process !== "undefined") {
      const processVersions = process["versions"];
      if (processVersions && processVersions["node"]) {
        const versionString = processVersions["node"];
        const nodeVersion = parseInt(versionString.replace(/^v/, "").split(".")[0]);
        if (nodeVersion >= 22) {
          if (typeof globalThis.WebSocket !== "undefined") {
            return { type: "native", constructor: globalThis.WebSocket };
          }
          return {
            type: "unsupported",
            error: `Node.js ${nodeVersion} detected but native WebSocket not found.`,
            workaround: "Provide a WebSocket implementation via the transport option."
          };
        }
        return {
          type: "unsupported",
          error: `Node.js ${nodeVersion} detected without native WebSocket support.`,
          workaround: 'For Node.js < 22, install "ws" package and provide it via the transport option:\nimport ws from "ws"\nnew RealtimeClient(url, { transport: ws })'
        };
      }
    }
    return {
      type: "unsupported",
      error: "Unknown JavaScript runtime without WebSocket support.",
      workaround: "Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."
    };
  }
  static getWebSocketConstructor() {
    const env = this.detectEnvironment();
    if (env.constructor) {
      return env.constructor;
    }
    let errorMessage = env.error || "WebSocket not supported in this environment.";
    if (env.workaround) {
      errorMessage += `

Suggested solution: ${env.workaround}`;
    }
    throw new Error(errorMessage);
  }
  static createWebSocket(url, protocols) {
    const WS = this.getWebSocketConstructor();
    return new WS(url, protocols);
  }
  static isWebSocketSupported() {
    try {
      const env = this.detectEnvironment();
      return env.type === "native" || env.type === "ws";
    } catch (_a2) {
      return false;
    }
  }
}
const version$3 = "2.76.1";
const DEFAULT_VERSION = `realtime-js/${version$3}`;
const VSN = "1.0.0";
const DEFAULT_TIMEOUT = 1e4;
const WS_CLOSE_NORMAL = 1e3;
const MAX_PUSH_BUFFER_SIZE = 100;
var SOCKET_STATES;
(function(SOCKET_STATES2) {
  SOCKET_STATES2[SOCKET_STATES2["connecting"] = 0] = "connecting";
  SOCKET_STATES2[SOCKET_STATES2["open"] = 1] = "open";
  SOCKET_STATES2[SOCKET_STATES2["closing"] = 2] = "closing";
  SOCKET_STATES2[SOCKET_STATES2["closed"] = 3] = "closed";
})(SOCKET_STATES || (SOCKET_STATES = {}));
var CHANNEL_STATES;
(function(CHANNEL_STATES2) {
  CHANNEL_STATES2["closed"] = "closed";
  CHANNEL_STATES2["errored"] = "errored";
  CHANNEL_STATES2["joined"] = "joined";
  CHANNEL_STATES2["joining"] = "joining";
  CHANNEL_STATES2["leaving"] = "leaving";
})(CHANNEL_STATES || (CHANNEL_STATES = {}));
var CHANNEL_EVENTS;
(function(CHANNEL_EVENTS2) {
  CHANNEL_EVENTS2["close"] = "phx_close";
  CHANNEL_EVENTS2["error"] = "phx_error";
  CHANNEL_EVENTS2["join"] = "phx_join";
  CHANNEL_EVENTS2["reply"] = "phx_reply";
  CHANNEL_EVENTS2["leave"] = "phx_leave";
  CHANNEL_EVENTS2["access_token"] = "access_token";
})(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));
var TRANSPORTS;
(function(TRANSPORTS2) {
  TRANSPORTS2["websocket"] = "websocket";
})(TRANSPORTS || (TRANSPORTS = {}));
var CONNECTION_STATE;
(function(CONNECTION_STATE2) {
  CONNECTION_STATE2["Connecting"] = "connecting";
  CONNECTION_STATE2["Open"] = "open";
  CONNECTION_STATE2["Closing"] = "closing";
  CONNECTION_STATE2["Closed"] = "closed";
})(CONNECTION_STATE || (CONNECTION_STATE = {}));
class Serializer {
  constructor() {
    this.HEADER_LENGTH = 1;
  }
  decode(rawPayload, callback) {
    if (rawPayload.constructor === ArrayBuffer) {
      return callback(this._binaryDecode(rawPayload));
    }
    if (typeof rawPayload === "string") {
      return callback(JSON.parse(rawPayload));
    }
    return callback({});
  }
  _binaryDecode(buffer) {
    const view = new DataView(buffer);
    const decoder = new TextDecoder();
    return this._decodeBroadcast(buffer, view, decoder);
  }
  _decodeBroadcast(buffer, view, decoder) {
    const topicSize = view.getUint8(1);
    const eventSize = view.getUint8(2);
    let offset2 = this.HEADER_LENGTH + 2;
    const topic = decoder.decode(buffer.slice(offset2, offset2 + topicSize));
    offset2 = offset2 + topicSize;
    const event = decoder.decode(buffer.slice(offset2, offset2 + eventSize));
    offset2 = offset2 + eventSize;
    const data = JSON.parse(decoder.decode(buffer.slice(offset2, buffer.byteLength)));
    return { ref: null, topic, event, payload: data };
  }
}
class Timer {
  constructor(callback, timerCalc) {
    this.callback = callback;
    this.timerCalc = timerCalc;
    this.timer = void 0;
    this.tries = 0;
    this.callback = callback;
    this.timerCalc = timerCalc;
  }
  reset() {
    this.tries = 0;
    clearTimeout(this.timer);
    this.timer = void 0;
  }
  // Cancels any previous scheduleTimeout and schedules callback
  scheduleTimeout() {
    clearTimeout(this.timer);
    this.timer = setTimeout(() => {
      this.tries = this.tries + 1;
      this.callback();
    }, this.timerCalc(this.tries + 1));
  }
}
var PostgresTypes;
(function(PostgresTypes2) {
  PostgresTypes2["abstime"] = "abstime";
  PostgresTypes2["bool"] = "bool";
  PostgresTypes2["date"] = "date";
  PostgresTypes2["daterange"] = "daterange";
  PostgresTypes2["float4"] = "float4";
  PostgresTypes2["float8"] = "float8";
  PostgresTypes2["int2"] = "int2";
  PostgresTypes2["int4"] = "int4";
  PostgresTypes2["int4range"] = "int4range";
  PostgresTypes2["int8"] = "int8";
  PostgresTypes2["int8range"] = "int8range";
  PostgresTypes2["json"] = "json";
  PostgresTypes2["jsonb"] = "jsonb";
  PostgresTypes2["money"] = "money";
  PostgresTypes2["numeric"] = "numeric";
  PostgresTypes2["oid"] = "oid";
  PostgresTypes2["reltime"] = "reltime";
  PostgresTypes2["text"] = "text";
  PostgresTypes2["time"] = "time";
  PostgresTypes2["timestamp"] = "timestamp";
  PostgresTypes2["timestamptz"] = "timestamptz";
  PostgresTypes2["timetz"] = "timetz";
  PostgresTypes2["tsrange"] = "tsrange";
  PostgresTypes2["tstzrange"] = "tstzrange";
})(PostgresTypes || (PostgresTypes = {}));
const convertChangeData = (columns, record, options = {}) => {
  var _a2;
  const skipTypes = (_a2 = options.skipTypes) !== null && _a2 !== void 0 ? _a2 : [];
  if (!record) {
    return {};
  }
  return Object.keys(record).reduce((acc, rec_key) => {
    acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);
    return acc;
  }, {});
};
const convertColumn = (columnName, columns, record, skipTypes) => {
  const column2 = columns.find((x) => x.name === columnName);
  const colType = column2 === null || column2 === void 0 ? void 0 : column2.type;
  const value = record[columnName];
  if (colType && !skipTypes.includes(colType)) {
    return convertCell(colType, value);
  }
  return noop$1(value);
};
const convertCell = (type, value) => {
  if (type.charAt(0) === "_") {
    const dataType = type.slice(1, type.length);
    return toArray$1(value, dataType);
  }
  switch (type) {
    case PostgresTypes.bool:
      return toBoolean(value);
    case PostgresTypes.float4:
    case PostgresTypes.float8:
    case PostgresTypes.int2:
    case PostgresTypes.int4:
    case PostgresTypes.int8:
    case PostgresTypes.numeric:
    case PostgresTypes.oid:
      return toNumber(value);
    case PostgresTypes.json:
    case PostgresTypes.jsonb:
      return toJson(value);
    case PostgresTypes.timestamp:
      return toTimestampString(value);
    // Format to be consistent with PostgREST
    case PostgresTypes.abstime:
    // To allow users to cast it based on Timezone
    case PostgresTypes.date:
    // To allow users to cast it based on Timezone
    case PostgresTypes.daterange:
    case PostgresTypes.int4range:
    case PostgresTypes.int8range:
    case PostgresTypes.money:
    case PostgresTypes.reltime:
    // To allow users to cast it based on Timezone
    case PostgresTypes.text:
    case PostgresTypes.time:
    // To allow users to cast it based on Timezone
    case PostgresTypes.timestamptz:
    // To allow users to cast it based on Timezone
    case PostgresTypes.timetz:
    // To allow users to cast it based on Timezone
    case PostgresTypes.tsrange:
    case PostgresTypes.tstzrange:
      return noop$1(value);
    default:
      return noop$1(value);
  }
};
const noop$1 = (value) => {
  return value;
};
const toBoolean = (value) => {
  switch (value) {
    case "t":
      return true;
    case "f":
      return false;
    default:
      return value;
  }
};
const toNumber = (value) => {
  if (typeof value === "string") {
    const parsedValue = parseFloat(value);
    if (!Number.isNaN(parsedValue)) {
      return parsedValue;
    }
  }
  return value;
};
const toJson = (value) => {
  if (typeof value === "string") {
    try {
      return JSON.parse(value);
    } catch (error2) {
      console.log(`JSON parse error: ${error2}`);
      return value;
    }
  }
  return value;
};
const toArray$1 = (value, type) => {
  if (typeof value !== "string") {
    return value;
  }
  const lastIdx = value.length - 1;
  const closeBrace = value[lastIdx];
  const openBrace = value[0];
  if (openBrace === "{" && closeBrace === "}") {
    let arr;
    const valTrim = value.slice(1, lastIdx);
    try {
      arr = JSON.parse("[" + valTrim + "]");
    } catch (_) {
      arr = valTrim ? valTrim.split(",") : [];
    }
    return arr.map((val) => convertCell(type, val));
  }
  return value;
};
const toTimestampString = (value) => {
  if (typeof value === "string") {
    return value.replace(" ", "T");
  }
  return value;
};
const httpEndpointURL = (socketUrl) => {
  const wsUrl = new URL(socketUrl);
  wsUrl.protocol = wsUrl.protocol.replace(/^ws/i, "http");
  wsUrl.pathname = wsUrl.pathname.replace(/\/+$/, "").replace(/\/socket\/websocket$/i, "").replace(/\/socket$/i, "").replace(/\/websocket$/i, "");
  if (wsUrl.pathname === "" || wsUrl.pathname === "/") {
    wsUrl.pathname = "/api/broadcast";
  } else {
    wsUrl.pathname = wsUrl.pathname + "/api/broadcast";
  }
  return wsUrl.href;
};
class Push {
  /**
   * Initializes the Push
   *
   * @param channel The Channel
   * @param event The event, for example `"phx_join"`
   * @param payload The payload, for example `{user_id: 123}`
   * @param timeout The push timeout in milliseconds
   */
  constructor(channel, event, payload = {}, timeout = DEFAULT_TIMEOUT) {
    this.channel = channel;
    this.event = event;
    this.payload = payload;
    this.timeout = timeout;
    this.sent = false;
    this.timeoutTimer = void 0;
    this.ref = "";
    this.receivedResp = null;
    this.recHooks = [];
    this.refEvent = null;
  }
  resend(timeout) {
    this.timeout = timeout;
    this._cancelRefEvent();
    this.ref = "";
    this.refEvent = null;
    this.receivedResp = null;
    this.sent = false;
    this.send();
  }
  send() {
    if (this._hasReceived("timeout")) {
      return;
    }
    this.startTimeout();
    this.sent = true;
    this.channel.socket.push({
      topic: this.channel.topic,
      event: this.event,
      payload: this.payload,
      ref: this.ref,
      join_ref: this.channel._joinRef()
    });
  }
  updatePayload(payload) {
    this.payload = Object.assign(Object.assign({}, this.payload), payload);
  }
  receive(status, callback) {
    var _a2;
    if (this._hasReceived(status)) {
      callback((_a2 = this.receivedResp) === null || _a2 === void 0 ? void 0 : _a2.response);
    }
    this.recHooks.push({ status, callback });
    return this;
  }
  startTimeout() {
    if (this.timeoutTimer) {
      return;
    }
    this.ref = this.channel.socket._makeRef();
    this.refEvent = this.channel._replyEventName(this.ref);
    const callback = (payload) => {
      this._cancelRefEvent();
      this._cancelTimeout();
      this.receivedResp = payload;
      this._matchReceive(payload);
    };
    this.channel._on(this.refEvent, {}, callback);
    this.timeoutTimer = setTimeout(() => {
      this.trigger("timeout", {});
    }, this.timeout);
  }
  trigger(status, response) {
    if (this.refEvent)
      this.channel._trigger(this.refEvent, { status, response });
  }
  destroy() {
    this._cancelRefEvent();
    this._cancelTimeout();
  }
  _cancelRefEvent() {
    if (!this.refEvent) {
      return;
    }
    this.channel._off(this.refEvent, {});
  }
  _cancelTimeout() {
    clearTimeout(this.timeoutTimer);
    this.timeoutTimer = void 0;
  }
  _matchReceive({ status, response }) {
    this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));
  }
  _hasReceived(status) {
    return this.receivedResp && this.receivedResp.status === status;
  }
}
var REALTIME_PRESENCE_LISTEN_EVENTS;
(function(REALTIME_PRESENCE_LISTEN_EVENTS2) {
  REALTIME_PRESENCE_LISTEN_EVENTS2["SYNC"] = "sync";
  REALTIME_PRESENCE_LISTEN_EVENTS2["JOIN"] = "join";
  REALTIME_PRESENCE_LISTEN_EVENTS2["LEAVE"] = "leave";
})(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));
class RealtimePresence {
  /**
   * Initializes the Presence.
   *
   * @param channel - The RealtimeChannel
   * @param opts - The options,
   *        for example `{events: {state: 'state', diff: 'diff'}}`
   */
  constructor(channel, opts) {
    this.channel = channel;
    this.state = {};
    this.pendingDiffs = [];
    this.joinRef = null;
    this.enabled = false;
    this.caller = {
      onJoin: () => {
      },
      onLeave: () => {
      },
      onSync: () => {
      }
    };
    const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {
      state: "presence_state",
      diff: "presence_diff"
    };
    this.channel._on(events.state, {}, (newState) => {
      const { onJoin, onLeave, onSync } = this.caller;
      this.joinRef = this.channel._joinRef();
      this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);
      this.pendingDiffs.forEach((diff) => {
        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
      });
      this.pendingDiffs = [];
      onSync();
    });
    this.channel._on(events.diff, {}, (diff) => {
      const { onJoin, onLeave, onSync } = this.caller;
      if (this.inPendingSyncState()) {
        this.pendingDiffs.push(diff);
      } else {
        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
        onSync();
      }
    });
    this.onJoin((key, currentPresences, newPresences) => {
      this.channel._trigger("presence", {
        event: "join",
        key,
        currentPresences,
        newPresences
      });
    });
    this.onLeave((key, currentPresences, leftPresences) => {
      this.channel._trigger("presence", {
        event: "leave",
        key,
        currentPresences,
        leftPresences
      });
    });
    this.onSync(() => {
      this.channel._trigger("presence", { event: "sync" });
    });
  }
  /**
   * Used to sync the list of presences on the server with the
   * client's state.
   *
   * An optional `onJoin` and `onLeave` callback can be provided to
   * react to changes in the client's local presences across
   * disconnects and reconnects with the server.
   *
   * @internal
   */
  static syncState(currentState, newState, onJoin, onLeave) {
    const state = this.cloneDeep(currentState);
    const transformedState = this.transformState(newState);
    const joins = {};
    const leaves = {};
    this.map(state, (key, presences) => {
      if (!transformedState[key]) {
        leaves[key] = presences;
      }
    });
    this.map(transformedState, (key, newPresences) => {
      const currentPresences = state[key];
      if (currentPresences) {
        const newPresenceRefs = newPresences.map((m) => m.presence_ref);
        const curPresenceRefs = currentPresences.map((m) => m.presence_ref);
        const joinedPresences = newPresences.filter((m) => curPresenceRefs.indexOf(m.presence_ref) < 0);
        const leftPresences = currentPresences.filter((m) => newPresenceRefs.indexOf(m.presence_ref) < 0);
        if (joinedPresences.length > 0) {
          joins[key] = joinedPresences;
        }
        if (leftPresences.length > 0) {
          leaves[key] = leftPresences;
        }
      } else {
        joins[key] = newPresences;
      }
    });
    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);
  }
  /**
   * Used to sync a diff of presence join and leave events from the
   * server, as they happen.
   *
   * Like `syncState`, `syncDiff` accepts optional `onJoin` and
   * `onLeave` callbacks to react to a user joining or leaving from a
   * device.
   *
   * @internal
   */
  static syncDiff(state, diff, onJoin, onLeave) {
    const { joins, leaves } = {
      joins: this.transformState(diff.joins),
      leaves: this.transformState(diff.leaves)
    };
    if (!onJoin) {
      onJoin = () => {
      };
    }
    if (!onLeave) {
      onLeave = () => {
      };
    }
    this.map(joins, (key, newPresences) => {
      var _a2;
      const currentPresences = (_a2 = state[key]) !== null && _a2 !== void 0 ? _a2 : [];
      state[key] = this.cloneDeep(newPresences);
      if (currentPresences.length > 0) {
        const joinedPresenceRefs = state[key].map((m) => m.presence_ref);
        const curPresences = currentPresences.filter((m) => joinedPresenceRefs.indexOf(m.presence_ref) < 0);
        state[key].unshift(...curPresences);
      }
      onJoin(key, currentPresences, newPresences);
    });
    this.map(leaves, (key, leftPresences) => {
      let currentPresences = state[key];
      if (!currentPresences)
        return;
      const presenceRefsToRemove = leftPresences.map((m) => m.presence_ref);
      currentPresences = currentPresences.filter((m) => presenceRefsToRemove.indexOf(m.presence_ref) < 0);
      state[key] = currentPresences;
      onLeave(key, currentPresences, leftPresences);
      if (currentPresences.length === 0)
        delete state[key];
    });
    return state;
  }
  /** @internal */
  static map(obj, func) {
    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));
  }
  /**
   * Remove 'metas' key
   * Change 'phx_ref' to 'presence_ref'
   * Remove 'phx_ref' and 'phx_ref_prev'
   *
   * @example
   * // returns {
   *  abc123: [
   *    { presence_ref: '2', user_id: 1 },
   *    { presence_ref: '3', user_id: 2 }
   *  ]
   * }
   * RealtimePresence.transformState({
   *  abc123: {
   *    metas: [
   *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },
   *      { phx_ref: '3', user_id: 2 }
   *    ]
   *  }
   * })
   *
   * @internal
   */
  static transformState(state) {
    state = this.cloneDeep(state);
    return Object.getOwnPropertyNames(state).reduce((newState, key) => {
      const presences = state[key];
      if ("metas" in presences) {
        newState[key] = presences.metas.map((presence) => {
          presence["presence_ref"] = presence["phx_ref"];
          delete presence["phx_ref"];
          delete presence["phx_ref_prev"];
          return presence;
        });
      } else {
        newState[key] = presences;
      }
      return newState;
    }, {});
  }
  /** @internal */
  static cloneDeep(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  /** @internal */
  onJoin(callback) {
    this.caller.onJoin = callback;
  }
  /** @internal */
  onLeave(callback) {
    this.caller.onLeave = callback;
  }
  /** @internal */
  onSync(callback) {
    this.caller.onSync = callback;
  }
  /** @internal */
  inPendingSyncState() {
    return !this.joinRef || this.joinRef !== this.channel._joinRef();
  }
}
var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;
(function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2) {
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["ALL"] = "*";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["INSERT"] = "INSERT";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["UPDATE"] = "UPDATE";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["DELETE"] = "DELETE";
})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));
var REALTIME_LISTEN_TYPES;
(function(REALTIME_LISTEN_TYPES2) {
  REALTIME_LISTEN_TYPES2["BROADCAST"] = "broadcast";
  REALTIME_LISTEN_TYPES2["PRESENCE"] = "presence";
  REALTIME_LISTEN_TYPES2["POSTGRES_CHANGES"] = "postgres_changes";
  REALTIME_LISTEN_TYPES2["SYSTEM"] = "system";
})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));
var REALTIME_SUBSCRIBE_STATES;
(function(REALTIME_SUBSCRIBE_STATES2) {
  REALTIME_SUBSCRIBE_STATES2["SUBSCRIBED"] = "SUBSCRIBED";
  REALTIME_SUBSCRIBE_STATES2["TIMED_OUT"] = "TIMED_OUT";
  REALTIME_SUBSCRIBE_STATES2["CLOSED"] = "CLOSED";
  REALTIME_SUBSCRIBE_STATES2["CHANNEL_ERROR"] = "CHANNEL_ERROR";
})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));
class RealtimeChannel {
  constructor(topic, params = { config: {} }, socket) {
    var _a2, _b;
    this.topic = topic;
    this.params = params;
    this.socket = socket;
    this.bindings = {};
    this.state = CHANNEL_STATES.closed;
    this.joinedOnce = false;
    this.pushBuffer = [];
    this.subTopic = topic.replace(/^realtime:/i, "");
    this.params.config = Object.assign({
      broadcast: { ack: false, self: false },
      presence: { key: "", enabled: false },
      private: false
    }, params.config);
    this.timeout = this.socket.timeout;
    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
    this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);
    this.joinPush.receive("ok", () => {
      this.state = CHANNEL_STATES.joined;
      this.rejoinTimer.reset();
      this.pushBuffer.forEach((pushEvent) => pushEvent.send());
      this.pushBuffer = [];
    });
    this._onClose(() => {
      this.rejoinTimer.reset();
      this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`);
      this.state = CHANNEL_STATES.closed;
      this.socket._remove(this);
    });
    this._onError((reason) => {
      if (this._isLeaving() || this._isClosed()) {
        return;
      }
      this.socket.log("channel", `error ${this.topic}`, reason);
      this.state = CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this.joinPush.receive("timeout", () => {
      if (!this._isJoining()) {
        return;
      }
      this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout);
      this.state = CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this.joinPush.receive("error", (reason) => {
      if (this._isLeaving() || this._isClosed()) {
        return;
      }
      this.socket.log("channel", `error ${this.topic}`, reason);
      this.state = CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {
      this._trigger(this._replyEventName(ref), payload);
    });
    this.presence = new RealtimePresence(this);
    this.broadcastEndpointURL = httpEndpointURL(this.socket.endPoint);
    this.private = this.params.config.private || false;
    if (!this.private && ((_b = (_a2 = this.params.config) === null || _a2 === void 0 ? void 0 : _a2.broadcast) === null || _b === void 0 ? void 0 : _b.replay)) {
      throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`;
    }
  }
  /** Subscribe registers your client with the server */
  subscribe(callback, timeout = this.timeout) {
    var _a2, _b, _c;
    if (!this.socket.isConnected()) {
      this.socket.connect();
    }
    if (this.state == CHANNEL_STATES.closed) {
      const { config: { broadcast, presence, private: isPrivate } } = this.params;
      const postgres_changes = (_b = (_a2 = this.bindings.postgres_changes) === null || _a2 === void 0 ? void 0 : _a2.map((r2) => r2.filter)) !== null && _b !== void 0 ? _b : [];
      const presence_enabled = !!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] && this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0 || ((_c = this.params.config.presence) === null || _c === void 0 ? void 0 : _c.enabled) === true;
      const accessTokenPayload = {};
      const config2 = {
        broadcast,
        presence: Object.assign(Object.assign({}, presence), { enabled: presence_enabled }),
        postgres_changes,
        private: isPrivate
      };
      if (this.socket.accessTokenValue) {
        accessTokenPayload.access_token = this.socket.accessTokenValue;
      }
      this._onError((e) => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));
      this._onClose(() => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));
      this.updateJoinPayload(Object.assign({ config: config2 }, accessTokenPayload));
      this.joinedOnce = true;
      this._rejoin(timeout);
      this.joinPush.receive("ok", (_0) => __async(this, [_0], function* ({ postgres_changes: postgres_changes2 }) {
        var _a3;
        this.socket.setAuth();
        if (postgres_changes2 === void 0) {
          callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
          return;
        } else {
          const clientPostgresBindings = this.bindings.postgres_changes;
          const bindingsLen = (_a3 = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a3 !== void 0 ? _a3 : 0;
          const newPostgresBindings = [];
          for (let i = 0; i < bindingsLen; i++) {
            const clientPostgresBinding = clientPostgresBindings[i];
            const { filter: { event, schema, table, filter } } = clientPostgresBinding;
            const serverPostgresFilter = postgres_changes2 && postgres_changes2[i];
            if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {
              newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));
            } else {
              this.unsubscribe();
              this.state = CHANNEL_STATES.errored;
              callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error("mismatch between server and client bindings for postgres changes"));
              return;
            }
          }
          this.bindings.postgres_changes = newPostgresBindings;
          callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
          return;
        }
      })).receive("error", (error2) => {
        this.state = CHANNEL_STATES.errored;
        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error2).join(", ") || "error")));
        return;
      }).receive("timeout", () => {
        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);
        return;
      });
    }
    return this;
  }
  presenceState() {
    return this.presence.state;
  }
  track(_0) {
    return __async(this, arguments, function* (payload, opts = {}) {
      return yield this.send({
        type: "presence",
        event: "track",
        payload
      }, opts.timeout || this.timeout);
    });
  }
  untrack() {
    return __async(this, arguments, function* (opts = {}) {
      return yield this.send({
        type: "presence",
        event: "untrack"
      }, opts);
    });
  }
  on(type, filter, callback) {
    if (this.state === CHANNEL_STATES.joined && type === REALTIME_LISTEN_TYPES.PRESENCE) {
      this.socket.log("channel", `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`);
      this.unsubscribe().then(() => this.subscribe());
    }
    return this._on(type, filter, callback);
  }
  /**
   * Sends a broadcast message explicitly via REST API.
   *
   * This method always uses the REST API endpoint regardless of WebSocket connection state.
   * Useful when you want to guarantee REST delivery or when gradually migrating from implicit REST fallback.
   *
   * @param event The name of the broadcast event
   * @param payload Payload to be sent (required)
   * @param opts Options including timeout
   * @returns Promise resolving to object with success status, and error details if failed
   */
  httpSend(_0, _1) {
    return __async(this, arguments, function* (event, payload, opts = {}) {
      var _a2;
      const authorization = this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "";
      if (payload === void 0 || payload === null) {
        return Promise.reject("Payload is required for httpSend()");
      }
      const options = {
        method: "POST",
        headers: {
          Authorization: authorization,
          apikey: this.socket.apiKey ? this.socket.apiKey : "",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          messages: [
            {
              topic: this.subTopic,
              event,
              payload,
              private: this.private
            }
          ]
        })
      };
      const response = yield this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a2 = opts.timeout) !== null && _a2 !== void 0 ? _a2 : this.timeout);
      if (response.status === 202) {
        return { success: true };
      }
      let errorMessage = response.statusText;
      try {
        const errorBody = yield response.json();
        errorMessage = errorBody.error || errorBody.message || errorMessage;
      } catch (_b) {
      }
      return Promise.reject(new Error(errorMessage));
    });
  }
  /**
   * Sends a message into the channel.
   *
   * @param args Arguments to send to channel
   * @param args.type The type of event to send
   * @param args.event The name of the event being sent
   * @param args.payload Payload to be sent
   * @param opts Options to be used during the send process
   */
  send(_0) {
    return __async(this, arguments, function* (args, opts = {}) {
      var _a2, _b;
      if (!this._canPush() && args.type === "broadcast") {
        console.warn("Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.");
        const { event, payload: endpoint_payload } = args;
        const authorization = this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "";
        const options = {
          method: "POST",
          headers: {
            Authorization: authorization,
            apikey: this.socket.apiKey ? this.socket.apiKey : "",
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            messages: [
              {
                topic: this.subTopic,
                event,
                payload: endpoint_payload,
                private: this.private
              }
            ]
          })
        };
        try {
          const response = yield this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a2 = opts.timeout) !== null && _a2 !== void 0 ? _a2 : this.timeout);
          yield (_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel();
          return response.ok ? "ok" : "error";
        } catch (error2) {
          if (error2.name === "AbortError") {
            return "timed out";
          } else {
            return "error";
          }
        }
      } else {
        return new Promise((resolve) => {
          var _a3, _b2, _c;
          const push = this._push(args.type, args, opts.timeout || this.timeout);
          if (args.type === "broadcast" && !((_c = (_b2 = (_a3 = this.params) === null || _a3 === void 0 ? void 0 : _a3.config) === null || _b2 === void 0 ? void 0 : _b2.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {
            resolve("ok");
          }
          push.receive("ok", () => resolve("ok"));
          push.receive("error", () => resolve("error"));
          push.receive("timeout", () => resolve("timed out"));
        });
      }
    });
  }
  updateJoinPayload(payload) {
    this.joinPush.updatePayload(payload);
  }
  /**
   * Leaves the channel.
   *
   * Unsubscribes from server events, and instructs channel to terminate on server.
   * Triggers onClose() hooks.
   *
   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:
   * channel.unsubscribe().receive("ok", () => alert("left!") )
   */
  unsubscribe(timeout = this.timeout) {
    this.state = CHANNEL_STATES.leaving;
    const onClose = () => {
      this.socket.log("channel", `leave ${this.topic}`);
      this._trigger(CHANNEL_EVENTS.close, "leave", this._joinRef());
    };
    this.joinPush.destroy();
    let leavePush = null;
    return new Promise((resolve) => {
      leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);
      leavePush.receive("ok", () => {
        onClose();
        resolve("ok");
      }).receive("timeout", () => {
        onClose();
        resolve("timed out");
      }).receive("error", () => {
        resolve("error");
      });
      leavePush.send();
      if (!this._canPush()) {
        leavePush.trigger("ok", {});
      }
    }).finally(() => {
      leavePush === null || leavePush === void 0 ? void 0 : leavePush.destroy();
    });
  }
  /**
   * Teardown the channel.
   *
   * Destroys and stops related timers.
   */
  teardown() {
    this.pushBuffer.forEach((push) => push.destroy());
    this.pushBuffer = [];
    this.rejoinTimer.reset();
    this.joinPush.destroy();
    this.state = CHANNEL_STATES.closed;
    this.bindings = {};
  }
  /** @internal */
  _fetchWithTimeout(url, options, timeout) {
    return __async(this, null, function* () {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeout);
      const response = yield this.socket.fetch(url, Object.assign(Object.assign({}, options), { signal: controller.signal }));
      clearTimeout(id);
      return response;
    });
  }
  /** @internal */
  _push(event, payload, timeout = this.timeout) {
    if (!this.joinedOnce) {
      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
    }
    let pushEvent = new Push(this, event, payload, timeout);
    if (this._canPush()) {
      pushEvent.send();
    } else {
      this._addToPushBuffer(pushEvent);
    }
    return pushEvent;
  }
  /** @internal */
  _addToPushBuffer(pushEvent) {
    pushEvent.startTimeout();
    this.pushBuffer.push(pushEvent);
    if (this.pushBuffer.length > MAX_PUSH_BUFFER_SIZE) {
      const removedPush = this.pushBuffer.shift();
      if (removedPush) {
        removedPush.destroy();
        this.socket.log("channel", `discarded push due to buffer overflow: ${removedPush.event}`, removedPush.payload);
      }
    }
  }
  /**
   * Overridable message hook
   *
   * Receives all events for specialized message handling before dispatching to the channel callbacks.
   * Must return the payload, modified or unmodified.
   *
   * @internal
   */
  _onMessage(_event, payload, _ref) {
    return payload;
  }
  /** @internal */
  _isMember(topic) {
    return this.topic === topic;
  }
  /** @internal */
  _joinRef() {
    return this.joinPush.ref;
  }
  /** @internal */
  _trigger(type, payload, ref) {
    var _a2, _b;
    const typeLower = type.toLocaleLowerCase();
    const { close, error: error2, leave, join } = CHANNEL_EVENTS;
    const events = [close, error2, leave, join];
    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {
      return;
    }
    let handledPayload = this._onMessage(typeLower, payload, ref);
    if (payload && !handledPayload) {
      throw "channel onMessage callbacks must return the payload, modified or unmodified";
    }
    if (["insert", "update", "delete"].includes(typeLower)) {
      (_a2 = this.bindings.postgres_changes) === null || _a2 === void 0 ? void 0 : _a2.filter((bind) => {
        var _a3, _b2, _c;
        return ((_a3 = bind.filter) === null || _a3 === void 0 ? void 0 : _a3.event) === "*" || ((_c = (_b2 = bind.filter) === null || _b2 === void 0 ? void 0 : _b2.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;
      }).map((bind) => bind.callback(handledPayload, ref));
    } else {
      (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind) => {
        var _a3, _b2, _c, _d, _e, _f;
        if (["broadcast", "presence", "postgres_changes"].includes(typeLower)) {
          if ("id" in bind) {
            const bindId = bind.id;
            const bindEvent = (_a3 = bind.filter) === null || _a3 === void 0 ? void 0 : _a3.event;
            return bindId && ((_b2 = payload.ids) === null || _b2 === void 0 ? void 0 : _b2.includes(bindId)) && (bindEvent === "*" || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));
          } else {
            const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();
            return bindEvent === "*" || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());
          }
        } else {
          return bind.type.toLocaleLowerCase() === typeLower;
        }
      }).map((bind) => {
        if (typeof handledPayload === "object" && "ids" in handledPayload) {
          const postgresChanges = handledPayload.data;
          const { schema, table, commit_timestamp, type: type2, errors } = postgresChanges;
          const enrichedPayload = {
            schema,
            table,
            commit_timestamp,
            eventType: type2,
            new: {},
            old: {},
            errors
          };
          handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));
        }
        bind.callback(handledPayload, ref);
      });
    }
  }
  /** @internal */
  _isClosed() {
    return this.state === CHANNEL_STATES.closed;
  }
  /** @internal */
  _isJoined() {
    return this.state === CHANNEL_STATES.joined;
  }
  /** @internal */
  _isJoining() {
    return this.state === CHANNEL_STATES.joining;
  }
  /** @internal */
  _isLeaving() {
    return this.state === CHANNEL_STATES.leaving;
  }
  /** @internal */
  _replyEventName(ref) {
    return `chan_reply_${ref}`;
  }
  /** @internal */
  _on(type, filter, callback) {
    const typeLower = type.toLocaleLowerCase();
    const binding = {
      type: typeLower,
      filter,
      callback
    };
    if (this.bindings[typeLower]) {
      this.bindings[typeLower].push(binding);
    } else {
      this.bindings[typeLower] = [binding];
    }
    return this;
  }
  /** @internal */
  _off(type, filter) {
    const typeLower = type.toLocaleLowerCase();
    if (this.bindings[typeLower]) {
      this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {
        var _a2;
        return !(((_a2 = bind.type) === null || _a2 === void 0 ? void 0 : _a2.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));
      });
    }
    return this;
  }
  /** @internal */
  static isEqual(obj1, obj2) {
    if (Object.keys(obj1).length !== Object.keys(obj2).length) {
      return false;
    }
    for (const k in obj1) {
      if (obj1[k] !== obj2[k]) {
        return false;
      }
    }
    return true;
  }
  /** @internal */
  _rejoinUntilConnected() {
    this.rejoinTimer.scheduleTimeout();
    if (this.socket.isConnected()) {
      this._rejoin();
    }
  }
  /**
   * Registers a callback that will be executed when the channel closes.
   *
   * @internal
   */
  _onClose(callback) {
    this._on(CHANNEL_EVENTS.close, {}, callback);
  }
  /**
   * Registers a callback that will be executed when the channel encounteres an error.
   *
   * @internal
   */
  _onError(callback) {
    this._on(CHANNEL_EVENTS.error, {}, (reason) => callback(reason));
  }
  /**
   * Returns `true` if the socket is connected and the channel has been joined.
   *
   * @internal
   */
  _canPush() {
    return this.socket.isConnected() && this._isJoined();
  }
  /** @internal */
  _rejoin(timeout = this.timeout) {
    if (this._isLeaving()) {
      return;
    }
    this.socket._leaveOpenTopic(this.topic);
    this.state = CHANNEL_STATES.joining;
    this.joinPush.resend(timeout);
  }
  /** @internal */
  _getPayloadRecords(payload) {
    const records = {
      new: {},
      old: {}
    };
    if (payload.type === "INSERT" || payload.type === "UPDATE") {
      records.new = convertChangeData(payload.columns, payload.record);
    }
    if (payload.type === "UPDATE" || payload.type === "DELETE") {
      records.old = convertChangeData(payload.columns, payload.old_record);
    }
    return records;
  }
}
const noop = () => {
};
const CONNECTION_TIMEOUTS = {
  HEARTBEAT_INTERVAL: 25e3,
  RECONNECT_DELAY: 10,
  HEARTBEAT_TIMEOUT_FALLBACK: 100
};
const RECONNECT_INTERVALS = [1e3, 2e3, 5e3, 1e4];
const DEFAULT_RECONNECT_FALLBACK = 1e4;
const WORKER_SCRIPT = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;
class RealtimeClient {
  /**
   * Initializes the Socket.
   *
   * @param endPoint The string WebSocket endpoint, ie, "ws://example.com/socket", "wss://example.com", "/socket" (inherited host & protocol)
   * @param httpEndpoint The string HTTP endpoint, ie, "https://example.com", "/" (inherited host & protocol)
   * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation
   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.
   * @param options.params The optional params to pass when connecting.
   * @param options.headers Deprecated: headers cannot be set on websocket connections and this option will be removed in the future.
   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.
   * @param options.heartbeatCallback The optional function to handle heartbeat status.
   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }
   * @param options.logLevel Sets the log level for Realtime
   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))
   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.
   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.
   * @param options.worker Use Web Worker to set a side flow. Defaults to false.
   * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.
   */
  constructor(endPoint, options) {
    var _a2;
    this.accessTokenValue = null;
    this.apiKey = null;
    this.channels = new Array();
    this.endPoint = "";
    this.httpEndpoint = "";
    this.headers = {};
    this.params = {};
    this.timeout = DEFAULT_TIMEOUT;
    this.transport = null;
    this.heartbeatIntervalMs = CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;
    this.heartbeatTimer = void 0;
    this.pendingHeartbeatRef = null;
    this.heartbeatCallback = noop;
    this.ref = 0;
    this.reconnectTimer = null;
    this.logger = noop;
    this.conn = null;
    this.sendBuffer = [];
    this.serializer = new Serializer();
    this.stateChangeCallbacks = {
      open: [],
      close: [],
      error: [],
      message: []
    };
    this.accessToken = null;
    this._connectionState = "disconnected";
    this._wasManualDisconnect = false;
    this._authPromise = null;
    this._resolveFetch = (customFetch) => {
      let _fetch;
      if (customFetch) {
        _fetch = customFetch;
      } else if (typeof fetch === "undefined") {
        _fetch = (...args) => __vitePreload(() => __async(this, null, function* () {
          const { default: fetch2 } = yield Promise.resolve().then(() => browser);
          return { default: fetch2 };
        }), true ? void 0 : void 0, import.meta.url).then(({ default: fetch2 }) => fetch2(...args)).catch((error2) => {
          throw new Error(`Failed to load @supabase/node-fetch: ${error2.message}. This is required for HTTP requests in Node.js environments without native fetch.`);
        });
      } else {
        _fetch = fetch;
      }
      return (...args) => _fetch(...args);
    };
    if (!((_a2 = options === null || options === void 0 ? void 0 : options.params) === null || _a2 === void 0 ? void 0 : _a2.apikey)) {
      throw new Error("API key is required to connect to Realtime");
    }
    this.apiKey = options.params.apikey;
    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
    this.httpEndpoint = httpEndpointURL(endPoint);
    this._initializeOptions(options);
    this._setupReconnectionTimer();
    this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);
  }
  /**
   * Connects the socket, unless already connected.
   */
  connect() {
    if (this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected()) {
      return;
    }
    this._setConnectionState("connecting");
    this._setAuthSafely("connect");
    if (this.transport) {
      this.conn = new this.transport(this.endpointURL());
    } else {
      try {
        this.conn = WebSocketFactory.createWebSocket(this.endpointURL());
      } catch (error2) {
        this._setConnectionState("disconnected");
        const errorMessage = error2.message;
        if (errorMessage.includes("Node.js")) {
          throw new Error(`${errorMessage}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`);
        }
        throw new Error(`WebSocket not available: ${errorMessage}`);
      }
    }
    this._setupConnectionHandlers();
  }
  /**
   * Returns the URL of the websocket.
   * @returns string The URL of the websocket.
   */
  endpointURL() {
    return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: VSN }));
  }
  /**
   * Disconnects the socket.
   *
   * @param code A numeric status code to send on disconnect.
   * @param reason A custom reason for the disconnect.
   */
  disconnect(code, reason) {
    if (this.isDisconnecting()) {
      return;
    }
    this._setConnectionState("disconnecting", true);
    if (this.conn) {
      const fallbackTimer = setTimeout(() => {
        this._setConnectionState("disconnected");
      }, 100);
      this.conn.onclose = () => {
        clearTimeout(fallbackTimer);
        this._setConnectionState("disconnected");
      };
      if (code) {
        this.conn.close(code, reason !== null && reason !== void 0 ? reason : "");
      } else {
        this.conn.close();
      }
      this._teardownConnection();
    } else {
      this._setConnectionState("disconnected");
    }
  }
  /**
   * Returns all created channels
   */
  getChannels() {
    return this.channels;
  }
  /**
   * Unsubscribes and removes a single channel
   * @param channel A RealtimeChannel instance
   */
  removeChannel(channel) {
    return __async(this, null, function* () {
      const status = yield channel.unsubscribe();
      if (this.channels.length === 0) {
        this.disconnect();
      }
      return status;
    });
  }
  /**
   * Unsubscribes and removes all channels
   */
  removeAllChannels() {
    return __async(this, null, function* () {
      const values_1 = yield Promise.all(this.channels.map((channel) => channel.unsubscribe()));
      this.channels = [];
      this.disconnect();
      return values_1;
    });
  }
  /**
   * Logs the message.
   *
   * For customized logging, `this.logger` can be overridden.
   */
  log(kind, msg, data) {
    this.logger(kind, msg, data);
  }
  /**
   * Returns the current state of the socket.
   */
  connectionState() {
    switch (this.conn && this.conn.readyState) {
      case SOCKET_STATES.connecting:
        return CONNECTION_STATE.Connecting;
      case SOCKET_STATES.open:
        return CONNECTION_STATE.Open;
      case SOCKET_STATES.closing:
        return CONNECTION_STATE.Closing;
      default:
        return CONNECTION_STATE.Closed;
    }
  }
  /**
   * Returns `true` is the connection is open.
   */
  isConnected() {
    return this.connectionState() === CONNECTION_STATE.Open;
  }
  /**
   * Returns `true` if the connection is currently connecting.
   */
  isConnecting() {
    return this._connectionState === "connecting";
  }
  /**
   * Returns `true` if the connection is currently disconnecting.
   */
  isDisconnecting() {
    return this._connectionState === "disconnecting";
  }
  channel(topic, params = { config: {} }) {
    const realtimeTopic = `realtime:${topic}`;
    const exists = this.getChannels().find((c) => c.topic === realtimeTopic);
    if (!exists) {
      const chan = new RealtimeChannel(`realtime:${topic}`, params, this);
      this.channels.push(chan);
      return chan;
    } else {
      return exists;
    }
  }
  /**
   * Push out a message if the socket is connected.
   *
   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.
   */
  push(data) {
    const { topic, event, payload, ref } = data;
    const callback = () => {
      this.encode(data, (result) => {
        var _a2;
        (_a2 = this.conn) === null || _a2 === void 0 ? void 0 : _a2.send(result);
      });
    };
    this.log("push", `${topic} ${event} (${ref})`, payload);
    if (this.isConnected()) {
      callback();
    } else {
      this.sendBuffer.push(callback);
    }
  }
  /**
   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.
   *
   * If param is null it will use the `accessToken` callback function or the token set on the client.
   *
   * On callback used, it will set the value of the token internal to the client.
   *
   * @param token A JWT string to override the token set on the client.
   */
  setAuth(token2 = null) {
    return __async(this, null, function* () {
      this._authPromise = this._performAuth(token2);
      try {
        yield this._authPromise;
      } finally {
        this._authPromise = null;
      }
    });
  }
  /**
   * Sends a heartbeat message if the socket is connected.
   */
  sendHeartbeat() {
    return __async(this, null, function* () {
      var _a2;
      if (!this.isConnected()) {
        try {
          this.heartbeatCallback("disconnected");
        } catch (e) {
          this.log("error", "error in heartbeat callback", e);
        }
        return;
      }
      if (this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null;
        this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
        try {
          this.heartbeatCallback("timeout");
        } catch (e) {
          this.log("error", "error in heartbeat callback", e);
        }
        this._wasManualDisconnect = false;
        (_a2 = this.conn) === null || _a2 === void 0 ? void 0 : _a2.close(WS_CLOSE_NORMAL, "heartbeat timeout");
        setTimeout(() => {
          var _a3;
          if (!this.isConnected()) {
            (_a3 = this.reconnectTimer) === null || _a3 === void 0 ? void 0 : _a3.scheduleTimeout();
          }
        }, CONNECTION_TIMEOUTS.HEARTBEAT_TIMEOUT_FALLBACK);
        return;
      }
      this.pendingHeartbeatRef = this._makeRef();
      this.push({
        topic: "phoenix",
        event: "heartbeat",
        payload: {},
        ref: this.pendingHeartbeatRef
      });
      try {
        this.heartbeatCallback("sent");
      } catch (e) {
        this.log("error", "error in heartbeat callback", e);
      }
      this._setAuthSafely("heartbeat");
    });
  }
  onHeartbeat(callback) {
    this.heartbeatCallback = callback;
  }
  /**
   * Flushes send buffer
   */
  flushSendBuffer() {
    if (this.isConnected() && this.sendBuffer.length > 0) {
      this.sendBuffer.forEach((callback) => callback());
      this.sendBuffer = [];
    }
  }
  /**
   * Return the next message ref, accounting for overflows
   *
   * @internal
   */
  _makeRef() {
    let newRef = this.ref + 1;
    if (newRef === this.ref) {
      this.ref = 0;
    } else {
      this.ref = newRef;
    }
    return this.ref.toString();
  }
  /**
   * Unsubscribe from channels with the specified topic.
   *
   * @internal
   */
  _leaveOpenTopic(topic) {
    let dupChannel = this.channels.find((c) => c.topic === topic && (c._isJoined() || c._isJoining()));
    if (dupChannel) {
      this.log("transport", `leaving duplicate topic "${topic}"`);
      dupChannel.unsubscribe();
    }
  }
  /**
   * Removes a subscription from the socket.
   *
   * @param channel An open subscription.
   *
   * @internal
   */
  _remove(channel) {
    this.channels = this.channels.filter((c) => c.topic !== channel.topic);
  }
  /** @internal */
  _onConnMessage(rawMessage) {
    this.decode(rawMessage.data, (msg) => {
      if (msg.topic === "phoenix" && msg.event === "phx_reply") {
        try {
          this.heartbeatCallback(msg.payload.status === "ok" ? "ok" : "error");
        } catch (e) {
          this.log("error", "error in heartbeat callback", e);
        }
      }
      if (msg.ref && msg.ref === this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null;
      }
      const { topic, event, payload, ref } = msg;
      const refString = ref ? `(${ref})` : "";
      const status = payload.status || "";
      this.log("receive", `${status} ${topic} ${event} ${refString}`.trim(), payload);
      this.channels.filter((channel) => channel._isMember(topic)).forEach((channel) => channel._trigger(event, payload, ref));
      this._triggerStateCallbacks("message", msg);
    });
  }
  /**
   * Clear specific timer
   * @internal
   */
  _clearTimer(timer) {
    var _a2;
    if (timer === "heartbeat" && this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = void 0;
    } else if (timer === "reconnect") {
      (_a2 = this.reconnectTimer) === null || _a2 === void 0 ? void 0 : _a2.reset();
    }
  }
  /**
   * Clear all timers
   * @internal
   */
  _clearAllTimers() {
    this._clearTimer("heartbeat");
    this._clearTimer("reconnect");
  }
  /**
   * Setup connection handlers for WebSocket events
   * @internal
   */
  _setupConnectionHandlers() {
    if (!this.conn)
      return;
    if ("binaryType" in this.conn) {
      this.conn.binaryType = "arraybuffer";
    }
    this.conn.onopen = () => this._onConnOpen();
    this.conn.onerror = (error2) => this._onConnError(error2);
    this.conn.onmessage = (event) => this._onConnMessage(event);
    this.conn.onclose = (event) => this._onConnClose(event);
  }
  /**
   * Teardown connection and cleanup resources
   * @internal
   */
  _teardownConnection() {
    if (this.conn) {
      this.conn.onopen = null;
      this.conn.onerror = null;
      this.conn.onmessage = null;
      this.conn.onclose = null;
      this.conn = null;
    }
    this._clearAllTimers();
    this.channels.forEach((channel) => channel.teardown());
  }
  /** @internal */
  _onConnOpen() {
    this._setConnectionState("connected");
    this.log("transport", `connected to ${this.endpointURL()}`);
    this.flushSendBuffer();
    this._clearTimer("reconnect");
    if (!this.worker) {
      this._startHeartbeat();
    } else {
      if (!this.workerRef) {
        this._startWorkerHeartbeat();
      }
    }
    this._triggerStateCallbacks("open");
  }
  /** @internal */
  _startHeartbeat() {
    this.heartbeatTimer && clearInterval(this.heartbeatTimer);
    this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
  }
  /** @internal */
  _startWorkerHeartbeat() {
    if (this.workerUrl) {
      this.log("worker", `starting worker for from ${this.workerUrl}`);
    } else {
      this.log("worker", `starting default worker`);
    }
    const objectUrl = this._workerObjectUrl(this.workerUrl);
    this.workerRef = new Worker(objectUrl);
    this.workerRef.onerror = (error2) => {
      this.log("worker", "worker error", error2.message);
      this.workerRef.terminate();
    };
    this.workerRef.onmessage = (event) => {
      if (event.data.event === "keepAlive") {
        this.sendHeartbeat();
      }
    };
    this.workerRef.postMessage({
      event: "start",
      interval: this.heartbeatIntervalMs
    });
  }
  /** @internal */
  _onConnClose(event) {
    var _a2;
    this._setConnectionState("disconnected");
    this.log("transport", "close", event);
    this._triggerChanError();
    this._clearTimer("heartbeat");
    if (!this._wasManualDisconnect) {
      (_a2 = this.reconnectTimer) === null || _a2 === void 0 ? void 0 : _a2.scheduleTimeout();
    }
    this._triggerStateCallbacks("close", event);
  }
  /** @internal */
  _onConnError(error2) {
    this._setConnectionState("disconnected");
    this.log("transport", `${error2}`);
    this._triggerChanError();
    this._triggerStateCallbacks("error", error2);
  }
  /** @internal */
  _triggerChanError() {
    this.channels.forEach((channel) => channel._trigger(CHANNEL_EVENTS.error));
  }
  /** @internal */
  _appendParams(url, params) {
    if (Object.keys(params).length === 0) {
      return url;
    }
    const prefix2 = url.match(/\?/) ? "&" : "?";
    const query = new URLSearchParams(params);
    return `${url}${prefix2}${query}`;
  }
  _workerObjectUrl(url) {
    let result_url;
    if (url) {
      result_url = url;
    } else {
      const blob = new Blob([WORKER_SCRIPT], { type: "application/javascript" });
      result_url = URL.createObjectURL(blob);
    }
    return result_url;
  }
  /**
   * Set connection state with proper state management
   * @internal
   */
  _setConnectionState(state, manual = false) {
    this._connectionState = state;
    if (state === "connecting") {
      this._wasManualDisconnect = false;
    } else if (state === "disconnecting") {
      this._wasManualDisconnect = manual;
    }
  }
  /**
   * Perform the actual auth operation
   * @internal
   */
  _performAuth(token2 = null) {
    return __async(this, null, function* () {
      let tokenToSend;
      if (token2) {
        tokenToSend = token2;
      } else if (this.accessToken) {
        tokenToSend = yield this.accessToken();
      } else {
        tokenToSend = this.accessTokenValue;
      }
      if (this.accessTokenValue != tokenToSend) {
        this.accessTokenValue = tokenToSend;
        this.channels.forEach((channel) => {
          const payload = {
            access_token: tokenToSend,
            version: DEFAULT_VERSION
          };
          tokenToSend && channel.updateJoinPayload(payload);
          if (channel.joinedOnce && channel._isJoined()) {
            channel._push(CHANNEL_EVENTS.access_token, {
              access_token: tokenToSend
            });
          }
        });
      }
    });
  }
  /**
   * Wait for any in-flight auth operations to complete
   * @internal
   */
  _waitForAuthIfNeeded() {
    return __async(this, null, function* () {
      if (this._authPromise) {
        yield this._authPromise;
      }
    });
  }
  /**
   * Safely call setAuth with standardized error handling
   * @internal
   */
  _setAuthSafely(context = "general") {
    this.setAuth().catch((e) => {
      this.log("error", `error setting auth in ${context}`, e);
    });
  }
  /**
   * Trigger state change callbacks with proper error handling
   * @internal
   */
  _triggerStateCallbacks(event, data) {
    try {
      this.stateChangeCallbacks[event].forEach((callback) => {
        try {
          callback(data);
        } catch (e) {
          this.log("error", `error in ${event} callback`, e);
        }
      });
    } catch (e) {
      this.log("error", `error triggering ${event} callbacks`, e);
    }
  }
  /**
   * Setup reconnection timer with proper configuration
   * @internal
   */
  _setupReconnectionTimer() {
    this.reconnectTimer = new Timer(() => __async(this, null, function* () {
      setTimeout(() => __async(this, null, function* () {
        yield this._waitForAuthIfNeeded();
        if (!this.isConnected()) {
          this.connect();
        }
      }), CONNECTION_TIMEOUTS.RECONNECT_DELAY);
    }), this.reconnectAfterMs);
  }
  /**
   * Initialize client options with defaults
   * @internal
   */
  _initializeOptions(options) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j;
    this.transport = (_a2 = options === null || options === void 0 ? void 0 : options.transport) !== null && _a2 !== void 0 ? _a2 : null;
    this.timeout = (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : DEFAULT_TIMEOUT;
    this.heartbeatIntervalMs = (_c = options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) !== null && _c !== void 0 ? _c : CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;
    this.worker = (_d = options === null || options === void 0 ? void 0 : options.worker) !== null && _d !== void 0 ? _d : false;
    this.accessToken = (_e = options === null || options === void 0 ? void 0 : options.accessToken) !== null && _e !== void 0 ? _e : null;
    this.heartbeatCallback = (_f = options === null || options === void 0 ? void 0 : options.heartbeatCallback) !== null && _f !== void 0 ? _f : noop;
    if (options === null || options === void 0 ? void 0 : options.params)
      this.params = options.params;
    if (options === null || options === void 0 ? void 0 : options.logger)
      this.logger = options.logger;
    if ((options === null || options === void 0 ? void 0 : options.logLevel) || (options === null || options === void 0 ? void 0 : options.log_level)) {
      this.logLevel = options.logLevel || options.log_level;
      this.params = Object.assign(Object.assign({}, this.params), { log_level: this.logLevel });
    }
    this.reconnectAfterMs = (_g = options === null || options === void 0 ? void 0 : options.reconnectAfterMs) !== null && _g !== void 0 ? _g : ((tries) => {
      return RECONNECT_INTERVALS[tries - 1] || DEFAULT_RECONNECT_FALLBACK;
    });
    this.encode = (_h = options === null || options === void 0 ? void 0 : options.encode) !== null && _h !== void 0 ? _h : ((payload, callback) => {
      return callback(JSON.stringify(payload));
    });
    this.decode = (_j = options === null || options === void 0 ? void 0 : options.decode) !== null && _j !== void 0 ? _j : this.serializer.decode.bind(this.serializer);
    if (this.worker) {
      if (typeof window !== "undefined" && !window.Worker) {
        throw new Error("Web Worker is not supported");
      }
      this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;
    }
  }
}
class StorageError extends Error {
  constructor(message) {
    super(message);
    this.__isStorageError = true;
    this.name = "StorageError";
  }
}
function isStorageError(error2) {
  return typeof error2 === "object" && error2 !== null && "__isStorageError" in error2;
}
class StorageApiError extends StorageError {
  constructor(message, status, statusCode) {
    super(message);
    this.name = "StorageApiError";
    this.status = status;
    this.statusCode = statusCode;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      statusCode: this.statusCode
    };
  }
}
class StorageUnknownError extends StorageError {
  constructor(message, originalError) {
    super(message);
    this.name = "StorageUnknownError";
    this.originalError = originalError;
  }
}
const resolveFetch$3 = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = (...args) => __vitePreload(() => __async(null, null, function* () {
      const { default: fetch2 } = yield Promise.resolve().then(() => browser);
      return { default: fetch2 };
    }), true ? void 0 : void 0, import.meta.url).then(({ default: fetch2 }) => fetch2(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
const resolveResponse = () => __awaiter(void 0, void 0, void 0, function* () {
  if (typeof Response === "undefined") {
    return (yield __vitePreload(() => Promise.resolve().then(() => browser), true ? void 0 : void 0, import.meta.url)).Response;
  }
  return Response;
});
const recursiveToCamel = (item) => {
  if (Array.isArray(item)) {
    return item.map((el) => recursiveToCamel(el));
  } else if (typeof item === "function" || item !== Object(item)) {
    return item;
  }
  const result = {};
  Object.entries(item).forEach(([key, value]) => {
    const newKey = key.replace(/([-_][a-z])/gi, (c) => c.toUpperCase().replace(/[-_]/g, ""));
    result[newKey] = recursiveToCamel(value);
  });
  return result;
};
const isPlainObject$1 = (value) => {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
};
const _getErrorMessage$2 = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
const handleError$2 = (error2, reject, options) => __awaiter(void 0, void 0, void 0, function* () {
  const Res = yield resolveResponse();
  if (error2 instanceof Res && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {
    error2.json().then((err) => {
      const status = error2.status || 500;
      const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || status + "";
      reject(new StorageApiError(_getErrorMessage$2(err), status, statusCode));
    }).catch((err) => {
      reject(new StorageUnknownError(_getErrorMessage$2(err), err));
    });
  } else {
    reject(new StorageUnknownError(_getErrorMessage$2(error2), error2));
  }
});
const _getRequestParams$2 = (method, options, parameters, body2) => {
  const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
  if (method === "GET" || !body2) {
    return params;
  }
  if (isPlainObject$1(body2)) {
    params.headers = Object.assign({ "Content-Type": "application/json" }, options === null || options === void 0 ? void 0 : options.headers);
    params.body = JSON.stringify(body2);
  } else {
    params.body = body2;
  }
  if (options === null || options === void 0 ? void 0 : options.duplex) {
    params.duplex = options.duplex;
  }
  return Object.assign(Object.assign({}, params), parameters);
};
function _handleRequest$2(fetcher, method, url, options, parameters, body2) {
  return __awaiter(this, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
      fetcher(url, _getRequestParams$2(method, options, parameters, body2)).then((result) => {
        if (!result.ok)
          throw result;
        if (options === null || options === void 0 ? void 0 : options.noResolveJson)
          return result;
        return result.json();
      }).then((data) => resolve(data)).catch((error2) => handleError$2(error2, reject, options));
    });
  });
}
function get(fetcher, url, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest$2(fetcher, "GET", url, options, parameters);
  });
}
function post$1(fetcher, url, body2, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest$2(fetcher, "POST", url, options, parameters, body2);
  });
}
function put(fetcher, url, body2, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest$2(fetcher, "PUT", url, options, parameters, body2);
  });
}
function head(fetcher, url, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest$2(fetcher, "HEAD", url, Object.assign(Object.assign({}, options), { noResolveJson: true }), parameters);
  });
}
function remove(fetcher, url, body2, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest$2(fetcher, "DELETE", url, options, parameters, body2);
  });
}
class StreamDownloadBuilder {
  constructor(downloadFn, shouldThrowOnError) {
    this.downloadFn = downloadFn;
    this.shouldThrowOnError = shouldThrowOnError;
  }
  then(onfulfilled, onrejected) {
    return this.execute().then(onfulfilled, onrejected);
  }
  execute() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const result = yield this.downloadFn();
        return {
          data: result.body,
          error: null
        };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
}
var _a;
class BlobDownloadBuilder {
  constructor(downloadFn, shouldThrowOnError) {
    this.downloadFn = downloadFn;
    this.shouldThrowOnError = shouldThrowOnError;
    this[_a] = "BlobDownloadBuilder";
    this.promise = null;
  }
  asStream() {
    return new StreamDownloadBuilder(this.downloadFn, this.shouldThrowOnError);
  }
  then(onfulfilled, onrejected) {
    return this.getPromise().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.getPromise().catch(onrejected);
  }
  finally(onfinally) {
    return this.getPromise().finally(onfinally);
  }
  getPromise() {
    if (!this.promise) {
      this.promise = this.execute();
    }
    return this.promise;
  }
  execute() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const result = yield this.downloadFn();
        return {
          data: yield result.blob(),
          error: null
        };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
}
_a = Symbol.toStringTag;
const DEFAULT_SEARCH_OPTIONS = {
  limit: 100,
  offset: 0,
  sortBy: {
    column: "name",
    order: "asc"
  }
};
const DEFAULT_FILE_OPTIONS = {
  cacheControl: "3600",
  contentType: "text/plain;charset=UTF-8",
  upsert: false
};
class StorageFileApi {
  constructor(url, headers = {}, bucketId, fetch2) {
    this.shouldThrowOnError = false;
    this.url = url;
    this.headers = headers;
    this.bucketId = bucketId;
    this.fetch = resolveFetch$3(fetch2);
  }
  /**
   * Enable throwing errors instead of returning them.
   */
  throwOnError() {
    this.shouldThrowOnError = true;
    return this;
  }
  /**
   * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.
   *
   * @param method HTTP method.
   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  uploadOrUpdate(method, path, fileBody, fileOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        let body2;
        const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);
        let headers = Object.assign(Object.assign({}, this.headers), method === "POST" && { "x-upsert": String(options.upsert) });
        const metadata = options.metadata;
        if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
          body2 = new FormData();
          body2.append("cacheControl", options.cacheControl);
          if (metadata) {
            body2.append("metadata", this.encodeMetadata(metadata));
          }
          body2.append("", fileBody);
        } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
          body2 = fileBody;
          body2.append("cacheControl", options.cacheControl);
          if (metadata) {
            body2.append("metadata", this.encodeMetadata(metadata));
          }
        } else {
          body2 = fileBody;
          headers["cache-control"] = `max-age=${options.cacheControl}`;
          headers["content-type"] = options.contentType;
          if (metadata) {
            headers["x-metadata"] = this.toBase64(this.encodeMetadata(metadata));
          }
        }
        if (fileOptions === null || fileOptions === void 0 ? void 0 : fileOptions.headers) {
          headers = Object.assign(Object.assign({}, headers), fileOptions.headers);
        }
        const cleanPath = this._removeEmptyFolders(path);
        const _path = this._getFinalPath(cleanPath);
        const data = yield (method == "PUT" ? put : post$1)(this.fetch, `${this.url}/object/${_path}`, body2, Object.assign({ headers }, (options === null || options === void 0 ? void 0 : options.duplex) ? { duplex: options.duplex } : {}));
        return {
          data: { path: cleanPath, id: data.Id, fullPath: data.Key },
          error: null
        };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Uploads a file to an existing bucket.
   *
   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  upload(path, fileBody, fileOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("POST", path, fileBody, fileOptions);
    });
  }
  /**
   * Upload a file with a token generated from `createSignedUploadUrl`.
   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param token The token generated from `createSignedUploadUrl`
   * @param fileBody The body of the file to be stored in the bucket.
   */
  uploadToSignedUrl(path, token2, fileBody, fileOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      const cleanPath = this._removeEmptyFolders(path);
      const _path = this._getFinalPath(cleanPath);
      const url = new URL(this.url + `/object/upload/sign/${_path}`);
      url.searchParams.set("token", token2);
      try {
        let body2;
        const options = Object.assign({ upsert: DEFAULT_FILE_OPTIONS.upsert }, fileOptions);
        const headers = Object.assign(Object.assign({}, this.headers), { "x-upsert": String(options.upsert) });
        if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
          body2 = new FormData();
          body2.append("cacheControl", options.cacheControl);
          body2.append("", fileBody);
        } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
          body2 = fileBody;
          body2.append("cacheControl", options.cacheControl);
        } else {
          body2 = fileBody;
          headers["cache-control"] = `max-age=${options.cacheControl}`;
          headers["content-type"] = options.contentType;
        }
        const data = yield put(this.fetch, url.toString(), body2, { headers });
        return {
          data: { path: cleanPath, fullPath: data.Key },
          error: null
        };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Creates a signed upload URL.
   * Signed upload URLs can be used to upload files to the bucket without further authentication.
   * They are valid for 2 hours.
   * @param path The file path, including the current file name. For example `folder/image.png`.
   * @param options.upsert If set to true, allows the file to be overwritten if it already exists.
   */
  createSignedUploadUrl(path, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        let _path = this._getFinalPath(path);
        const headers = Object.assign({}, this.headers);
        if (options === null || options === void 0 ? void 0 : options.upsert) {
          headers["x-upsert"] = "true";
        }
        const data = yield post$1(this.fetch, `${this.url}/object/upload/sign/${_path}`, {}, { headers });
        const url = new URL(this.url + data.url);
        const token2 = url.searchParams.get("token");
        if (!token2) {
          throw new StorageError("No token returned by API");
        }
        return { data: { signedUrl: url.toString(), path, token: token2 }, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Replaces an existing file at the specified path with a new one.
   *
   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  update(path, fileBody, fileOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("PUT", path, fileBody, fileOptions);
    });
  }
  /**
   * Moves an existing file to a new path in the same bucket.
   *
   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
   * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.
   * @param options The destination options.
   */
  move(fromPath, toPath, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post$1(this.fetch, `${this.url}/object/move`, {
          bucketId: this.bucketId,
          sourceKey: fromPath,
          destinationKey: toPath,
          destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
        }, { headers: this.headers });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Copies an existing file to a new path in the same bucket.
   *
   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
   * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.
   * @param options The destination options.
   */
  copy(fromPath, toPath, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post$1(this.fetch, `${this.url}/object/copy`, {
          bucketId: this.bucketId,
          sourceKey: fromPath,
          destinationKey: toPath,
          destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
        }, { headers: this.headers });
        return { data: { path: data.Key }, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.
   *
   * @param path The file path, including the current file name. For example `folder/image.png`.
   * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.
   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   * @param options.transform Transform the asset before serving it to the client.
   */
  createSignedUrl(path, expiresIn, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        let _path = this._getFinalPath(path);
        let data = yield post$1(this.fetch, `${this.url}/object/sign/${_path}`, Object.assign({ expiresIn }, (options === null || options === void 0 ? void 0 : options.transform) ? { transform: options.transform } : {}), { headers: this.headers });
        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
        const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`);
        data = { signedUrl };
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.
   *
   * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.
   * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.
   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   */
  createSignedUrls(paths, expiresIn, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post$1(this.fetch, `${this.url}/object/sign/${this.bucketId}`, { expiresIn, paths }, { headers: this.headers });
        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
        return {
          data: data.map((datum) => Object.assign(Object.assign({}, datum), { signedUrl: datum.signedURL ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`) : null })),
          error: null
        };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.
   *
   * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.
   * @param options.transform Transform the asset before serving it to the client.
   */
  download(path, options) {
    const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined";
    const renderPath = wantsTransformation ? "render/image/authenticated" : "object";
    const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
    const queryString = transformationQuery ? `?${transformationQuery}` : "";
    const _path = this._getFinalPath(path);
    const downloadFn = () => get(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {
      headers: this.headers,
      noResolveJson: true
    });
    return new BlobDownloadBuilder(downloadFn, this.shouldThrowOnError);
  }
  /**
   * Retrieves the details of an existing file.
   * @param path
   */
  info(path) {
    return __awaiter(this, void 0, void 0, function* () {
      const _path = this._getFinalPath(path);
      try {
        const data = yield get(this.fetch, `${this.url}/object/info/${_path}`, {
          headers: this.headers
        });
        return { data: recursiveToCamel(data), error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Checks the existence of a file.
   * @param path
   */
  exists(path) {
    return __awaiter(this, void 0, void 0, function* () {
      const _path = this._getFinalPath(path);
      try {
        yield head(this.fetch, `${this.url}/object/${_path}`, {
          headers: this.headers
        });
        return { data: true, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2) && error2 instanceof StorageUnknownError) {
          const originalError = error2.originalError;
          if ([400, 404].includes(originalError === null || originalError === void 0 ? void 0 : originalError.status)) {
            return { data: false, error: error2 };
          }
        }
        throw error2;
      }
    });
  }
  /**
   * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.
   * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.
   *
   * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.
   * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   * @param options.transform Transform the asset before serving it to the client.
   */
  getPublicUrl(path, options) {
    const _path = this._getFinalPath(path);
    const _queryString = [];
    const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `download=${options.download === true ? "" : options.download}` : "";
    if (downloadQueryParam !== "") {
      _queryString.push(downloadQueryParam);
    }
    const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined";
    const renderPath = wantsTransformation ? "render/image" : "object";
    const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
    if (transformationQuery !== "") {
      _queryString.push(transformationQuery);
    }
    let queryString = _queryString.join("&");
    if (queryString !== "") {
      queryString = `?${queryString}`;
    }
    return {
      data: { publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`) }
    };
  }
  /**
   * Deletes files within the same bucket
   *
   * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].
   */
  remove(paths) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield remove(this.fetch, `${this.url}/object/${this.bucketId}`, { prefixes: paths }, { headers: this.headers });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Get file metadata
   * @param id the file id to retrieve metadata
   */
  // async getMetadata(
  //   id: string
  // ): Promise<
  //   | {
  //       data: Metadata
  //       error: null
  //     }
  //   | {
  //       data: null
  //       error: StorageError
  //     }
  // > {
  //   try {
  //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })
  //     return { data, error: null }
  //   } catch (error) {
  //     if (isStorageError(error)) {
  //       return { data: null, error }
  //     }
  //     throw error
  //   }
  // }
  /**
   * Update file metadata
   * @param id the file id to update metadata
   * @param meta the new file metadata
   */
  // async updateMetadata(
  //   id: string,
  //   meta: Metadata
  // ): Promise<
  //   | {
  //       data: Metadata
  //       error: null
  //     }
  //   | {
  //       data: null
  //       error: StorageError
  //     }
  // > {
  //   try {
  //     const data = await post(
  //       this.fetch,
  //       `${this.url}/metadata/${id}`,
  //       { ...meta },
  //       { headers: this.headers }
  //     )
  //     return { data, error: null }
  //   } catch (error) {
  //     if (isStorageError(error)) {
  //       return { data: null, error }
  //     }
  //     throw error
  //   }
  // }
  /**
   * Lists all the files and folders within a path of the bucket.
   * @param path The folder path.
   * @param options Search options including limit (defaults to 100), offset, sortBy, and search
   */
  list(path, options, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const body2 = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), { prefix: path || "" });
        const data = yield post$1(this.fetch, `${this.url}/object/list/${this.bucketId}`, body2, { headers: this.headers }, parameters);
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * @experimental this method signature might change in the future
   * @param options search options
   * @param parameters
   */
  listV2(options, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const body2 = Object.assign({}, options);
        const data = yield post$1(this.fetch, `${this.url}/object/list-v2/${this.bucketId}`, body2, { headers: this.headers }, parameters);
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  encodeMetadata(metadata) {
    return JSON.stringify(metadata);
  }
  toBase64(data) {
    if (typeof Buffer !== "undefined") {
      return Buffer.from(data).toString("base64");
    }
    return btoa(data);
  }
  _getFinalPath(path) {
    return `${this.bucketId}/${path.replace(/^\/+/, "")}`;
  }
  _removeEmptyFolders(path) {
    return path.replace(/^\/|\/$/g, "").replace(/\/+/g, "/");
  }
  transformOptsToQueryString(transform) {
    const params = [];
    if (transform.width) {
      params.push(`width=${transform.width}`);
    }
    if (transform.height) {
      params.push(`height=${transform.height}`);
    }
    if (transform.resize) {
      params.push(`resize=${transform.resize}`);
    }
    if (transform.format) {
      params.push(`format=${transform.format}`);
    }
    if (transform.quality) {
      params.push(`quality=${transform.quality}`);
    }
    return params.join("&");
  }
}
const version$2 = "2.76.1";
const DEFAULT_HEADERS$3 = {
  "X-Client-Info": `storage-js/${version$2}`
};
class StorageBucketApi {
  constructor(url, headers = {}, fetch2, opts) {
    this.shouldThrowOnError = false;
    const baseUrl = new URL(url);
    if (opts === null || opts === void 0 ? void 0 : opts.useNewHostname) {
      const isSupabaseHost = /supabase\.(co|in|red)$/.test(baseUrl.hostname);
      if (isSupabaseHost && !baseUrl.hostname.includes("storage.supabase.")) {
        baseUrl.hostname = baseUrl.hostname.replace("supabase.", "storage.supabase.");
      }
    }
    this.url = baseUrl.href.replace(/\/$/, "");
    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS$3), headers);
    this.fetch = resolveFetch$3(fetch2);
  }
  /**
   * Enable throwing errors instead of returning them.
   */
  throwOnError() {
    this.shouldThrowOnError = true;
    return this;
  }
  /**
   * Retrieves the details of all Storage buckets within an existing project.
   */
  listBuckets() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield get(this.fetch, `${this.url}/bucket`, { headers: this.headers });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Retrieves the details of an existing Storage bucket.
   *
   * @param id The unique identifier of the bucket you would like to retrieve.
   */
  getBucket(id) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield get(this.fetch, `${this.url}/bucket/${id}`, { headers: this.headers });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Creates a new Storage bucket
   *
   * @param id A unique identifier for the bucket you are creating.
   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.
   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
   * The global file size limit takes precedence over this value.
   * The default value is null, which doesn't set a per bucket file size limit.
   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
   * The default value is null, which allows files with all mime types to be uploaded.
   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
   * @returns newly created bucket id
   * @param options.type (private-beta) specifies the bucket type. see `BucketType` for more details.
   *   - default bucket type is `STANDARD`
   */
  createBucket(id_1) {
    return __awaiter(this, arguments, void 0, function* (id, options = {
      public: false
    }) {
      try {
        const data = yield post$1(this.fetch, `${this.url}/bucket`, {
          id,
          name: id,
          type: options.type,
          public: options.public,
          file_size_limit: options.fileSizeLimit,
          allowed_mime_types: options.allowedMimeTypes
        }, { headers: this.headers });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Updates a Storage bucket
   *
   * @param id A unique identifier for the bucket you are updating.
   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.
   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
   * The global file size limit takes precedence over this value.
   * The default value is null, which doesn't set a per bucket file size limit.
   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
   * The default value is null, which allows files with all mime types to be uploaded.
   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
   */
  updateBucket(id, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield put(this.fetch, `${this.url}/bucket/${id}`, {
          id,
          name: id,
          public: options.public,
          file_size_limit: options.fileSizeLimit,
          allowed_mime_types: options.allowedMimeTypes
        }, { headers: this.headers });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Removes all objects inside a single bucket.
   *
   * @param id The unique identifier of the bucket you would like to empty.
   */
  emptyBucket(id) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post$1(this.fetch, `${this.url}/bucket/${id}/empty`, {}, { headers: this.headers });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.
   * You must first `empty()` the bucket.
   *
   * @param id The unique identifier of the bucket you would like to delete.
   */
  deleteBucket(id) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield remove(this.fetch, `${this.url}/bucket/${id}`, {}, { headers: this.headers });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
}
class StorageAnalyticsApi {
  /**
   * Creates a new StorageAnalyticsApi instance
   * @param url - The base URL for the storage API
   * @param headers - HTTP headers to include in requests
   * @param fetch - Optional custom fetch implementation
   */
  constructor(url, headers = {}, fetch2) {
    this.shouldThrowOnError = false;
    this.url = url.replace(/\/$/, "");
    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS$3), headers);
    this.fetch = resolveFetch$3(fetch2);
  }
  /**
   * Enable throwing errors instead of returning them in the response
   * When enabled, failed operations will throw instead of returning { data: null, error }
   *
   * @returns This instance for method chaining
   */
  throwOnError() {
    this.shouldThrowOnError = true;
    return this;
  }
  /**
   * Creates a new analytics bucket using Iceberg tables
   * Analytics buckets are optimized for analytical queries and data processing
   *
   * @param name A unique name for the bucket you are creating
   * @returns Promise with newly created bucket name or error
   *
   * @example
   * ```typescript
   * const { data, error } = await storage.analytics.createBucket('analytics-data')
   * if (error) {
   *   console.error('Failed to create analytics bucket:', error.message)
   * } else {
   *   console.log('Created bucket:', data.name)
   * }
   * ```
   */
  createBucket(name2) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post$1(this.fetch, `${this.url}/bucket`, { name: name2 }, { headers: this.headers });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Retrieves the details of all Analytics Storage buckets within an existing project
   * Only returns buckets of type 'ANALYTICS'
   *
   * @param options Query parameters for listing buckets
   * @param options.limit Maximum number of buckets to return
   * @param options.offset Number of buckets to skip
   * @param options.sortColumn Column to sort by ('id', 'name', 'created_at', 'updated_at')
   * @param options.sortOrder Sort order ('asc' or 'desc')
   * @param options.search Search term to filter bucket names
   * @returns Promise with list of analytics buckets or error
   *
   * @example
   * ```typescript
   * const { data, error } = await storage.analytics.listBuckets({
   *   limit: 10,
   *   offset: 0,
   *   sortColumn: 'created_at',
   *   sortOrder: 'desc',
   *   search: 'analytics'
   * })
   * if (data) {
   *   console.log('Found analytics buckets:', data.length)
   *   data.forEach(bucket => console.log(`- ${bucket.name}`))
   * }
   * ```
   */
  listBuckets(options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const queryParams = new URLSearchParams();
        if ((options === null || options === void 0 ? void 0 : options.limit) !== void 0)
          queryParams.set("limit", options.limit.toString());
        if ((options === null || options === void 0 ? void 0 : options.offset) !== void 0)
          queryParams.set("offset", options.offset.toString());
        if (options === null || options === void 0 ? void 0 : options.sortColumn)
          queryParams.set("sortColumn", options.sortColumn);
        if (options === null || options === void 0 ? void 0 : options.sortOrder)
          queryParams.set("sortOrder", options.sortOrder);
        if (options === null || options === void 0 ? void 0 : options.search)
          queryParams.set("search", options.search);
        const queryString = queryParams.toString();
        const url = queryString ? `${this.url}/bucket?${queryString}` : `${this.url}/bucket`;
        const data = yield get(this.fetch, url, { headers: this.headers });
        const analyticsBuckets = Array.isArray(data) ? data.filter((bucket) => bucket.type === "ANALYTICS") : [];
        return { data: analyticsBuckets, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Deletes an existing analytics bucket
   * A bucket can't be deleted with existing objects inside it
   * You must first empty the bucket before deletion
   *
   * @param bucketId The unique identifier of the bucket you would like to delete
   * @returns Promise with success message or error
   *
   * @example
   * ```typescript
   * const { data, error } = await analyticsApi.deleteBucket('old-analytics-bucket')
   * if (error) {
   *   console.error('Failed to delete bucket:', error.message)
   * } else {
   *   console.log('Bucket deleted successfully:', data.message)
   * }
   * ```
   */
  deleteBucket(bucketId) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield remove(this.fetch, `${this.url}/bucket/${bucketId}`, {}, { headers: this.headers });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
}
const DEFAULT_HEADERS$2 = {
  "X-Client-Info": `storage-js/${version$2}`,
  "Content-Type": "application/json"
};
class StorageVectorsError extends Error {
  constructor(message) {
    super(message);
    this.__isStorageVectorsError = true;
    this.name = "StorageVectorsError";
  }
}
function isStorageVectorsError(error2) {
  return typeof error2 === "object" && error2 !== null && "__isStorageVectorsError" in error2;
}
class StorageVectorsApiError extends StorageVectorsError {
  constructor(message, status, statusCode) {
    super(message);
    this.name = "StorageVectorsApiError";
    this.status = status;
    this.statusCode = statusCode;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      statusCode: this.statusCode
    };
  }
}
class StorageVectorsUnknownError extends StorageVectorsError {
  constructor(message, originalError) {
    super(message);
    this.name = "StorageVectorsUnknownError";
    this.originalError = originalError;
  }
}
var StorageVectorsErrorCode;
(function(StorageVectorsErrorCode2) {
  StorageVectorsErrorCode2["InternalError"] = "InternalError";
  StorageVectorsErrorCode2["S3VectorConflictException"] = "S3VectorConflictException";
  StorageVectorsErrorCode2["S3VectorNotFoundException"] = "S3VectorNotFoundException";
  StorageVectorsErrorCode2["S3VectorBucketNotEmpty"] = "S3VectorBucketNotEmpty";
  StorageVectorsErrorCode2["S3VectorMaxBucketsExceeded"] = "S3VectorMaxBucketsExceeded";
  StorageVectorsErrorCode2["S3VectorMaxIndexesExceeded"] = "S3VectorMaxIndexesExceeded";
})(StorageVectorsErrorCode || (StorageVectorsErrorCode = {}));
const resolveFetch$2 = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = (...args) => __vitePreload(() => __async(null, null, function* () {
      const { default: fetch2 } = yield Promise.resolve().then(() => browser);
      return { default: fetch2 };
    }), true ? void 0 : void 0, import.meta.url).then(({ default: fetch2 }) => fetch2(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
const isPlainObject = (value) => {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
};
const _getErrorMessage$1 = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
const handleError$1 = (error2, reject, options) => __awaiter(void 0, void 0, void 0, function* () {
  const isResponseLike = error2 && typeof error2 === "object" && "status" in error2 && "ok" in error2 && typeof error2.status === "number";
  if (isResponseLike && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {
    const status = error2.status || 500;
    const responseError = error2;
    if (typeof responseError.json === "function") {
      responseError.json().then((err) => {
        const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || (err === null || err === void 0 ? void 0 : err.code) || status + "";
        reject(new StorageVectorsApiError(_getErrorMessage$1(err), status, statusCode));
      }).catch(() => {
        const statusCode = status + "";
        const message = responseError.statusText || `HTTP ${status} error`;
        reject(new StorageVectorsApiError(message, status, statusCode));
      });
    } else {
      const statusCode = status + "";
      const message = responseError.statusText || `HTTP ${status} error`;
      reject(new StorageVectorsApiError(message, status, statusCode));
    }
  } else {
    reject(new StorageVectorsUnknownError(_getErrorMessage$1(error2), error2));
  }
});
const _getRequestParams$1 = (method, options, parameters, body2) => {
  const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
  if (!body2) {
    return params;
  }
  if (isPlainObject(body2)) {
    params.headers = Object.assign({ "Content-Type": "application/json" }, options === null || options === void 0 ? void 0 : options.headers);
    params.body = JSON.stringify(body2);
  } else {
    params.body = body2;
  }
  return Object.assign(Object.assign({}, params), parameters);
};
function _handleRequest$1(fetcher, method, url, options, parameters, body2) {
  return __awaiter(this, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
      fetcher(url, _getRequestParams$1(method, options, parameters, body2)).then((result) => {
        if (!result.ok)
          throw result;
        if (options === null || options === void 0 ? void 0 : options.noResolveJson)
          return result;
        const contentType = result.headers.get("content-type");
        if (!contentType || !contentType.includes("application/json")) {
          return {};
        }
        return result.json();
      }).then((data) => resolve(data)).catch((error2) => handleError$1(error2, reject, options));
    });
  });
}
function post(fetcher, url, body2, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest$1(fetcher, "POST", url, options, parameters, body2);
  });
}
class VectorIndexApi {
  constructor(url, headers = {}, fetch2) {
    this.shouldThrowOnError = false;
    this.url = url.replace(/\/$/, "");
    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS$2), headers);
    this.fetch = resolveFetch$2(fetch2);
  }
  /**
   * Enable throwing errors instead of returning them in the response
   * When enabled, failed operations will throw instead of returning { data: null, error }
   *
   * @returns This instance for method chaining
   * @example
   * ```typescript
   * const client = new VectorIndexApi(url, headers)
   * client.throwOnError()
   * const { data } = await client.createIndex(options) // throws on error
   * ```
   */
  throwOnError() {
    this.shouldThrowOnError = true;
    return this;
  }
  /**
   * Creates a new vector index within a bucket
   * Defines the schema for vectors including dimensionality, distance metric, and metadata config
   *
   * @param options - Index configuration
   * @param options.vectorBucketName - Name of the parent vector bucket
   * @param options.indexName - Unique name for the index within the bucket
   * @param options.dataType - Data type for vector components (currently only 'float32')
   * @param options.dimension - Dimensionality of vectors (e.g., 384, 768, 1536)
   * @param options.distanceMetric - Similarity metric ('cosine', 'euclidean', 'dotproduct')
   * @param options.metadataConfiguration - Optional config for non-filterable metadata keys
   * @returns Promise with empty response on success or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorConflictException` if index already exists (HTTP 409)
   * - `S3VectorMaxIndexesExceeded` if quota exceeded (HTTP 400)
   * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * const { data, error } = await client.createIndex({
   *   vectorBucketName: 'embeddings-prod',
   *   indexName: 'documents-openai-small',
   *   dataType: 'float32',
   *   dimension: 1536,
   *   distanceMetric: 'cosine',
   *   metadataConfiguration: {
   *     nonFilterableMetadataKeys: ['raw_text', 'internal_id']
   *   }
   * })
   * ```
   */
  createIndex(options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/CreateIndex`, options, {
          headers: this.headers
        });
        return { data: data || {}, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Retrieves metadata for a specific vector index
   * Returns index configuration including dimension, distance metric, and metadata settings
   *
   * @param vectorBucketName - Name of the parent vector bucket
   * @param indexName - Name of the index to retrieve
   * @returns Promise with index metadata or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorNotFoundException` if index or bucket doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * const { data, error } = await client.getIndex('embeddings-prod', 'documents-openai-small')
   * if (data) {
   *   console.log('Index dimension:', data.index.dimension)
   *   console.log('Distance metric:', data.index.distanceMetric)
   * }
   * ```
   */
  getIndex(vectorBucketName, indexName) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/GetIndex`, { vectorBucketName, indexName }, { headers: this.headers });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Lists vector indexes within a bucket with optional filtering and pagination
   * Supports prefix-based filtering and paginated results
   *
   * @param options - Listing options
   * @param options.vectorBucketName - Name of the parent vector bucket
   * @param options.prefix - Filter indexes by name prefix
   * @param options.maxResults - Maximum results per page (default: 100)
   * @param options.nextToken - Pagination token from previous response
   * @returns Promise with list of indexes and pagination token
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * // List all indexes in a bucket
   * const { data, error } = await client.listIndexes({
   *   vectorBucketName: 'embeddings-prod',
   *   prefix: 'documents-'
   * })
   * if (data) {
   *   console.log('Found indexes:', data.indexes.map(i => i.indexName))
   *   // Fetch next page if available
   *   if (data.nextToken) {
   *     const next = await client.listIndexes({
   *       vectorBucketName: 'embeddings-prod',
   *       nextToken: data.nextToken
   *     })
   *   }
   * }
   * ```
   */
  listIndexes(options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/ListIndexes`, options, {
          headers: this.headers
        });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Deletes a vector index and all its data
   * This operation removes the index schema and all vectors stored in the index
   *
   * @param vectorBucketName - Name of the parent vector bucket
   * @param indexName - Name of the index to delete
   * @returns Promise with empty response on success or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorNotFoundException` if index or bucket doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * // Delete an index and all its vectors
   * const { error } = await client.deleteIndex('embeddings-prod', 'old-index')
   * if (!error) {
   *   console.log('Index deleted successfully')
   * }
   * ```
   */
  deleteIndex(vectorBucketName, indexName) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/DeleteIndex`, { vectorBucketName, indexName }, { headers: this.headers });
        return { data: data || {}, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
}
class VectorDataApi {
  constructor(url, headers = {}, fetch2) {
    this.shouldThrowOnError = false;
    this.url = url.replace(/\/$/, "");
    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS$2), headers);
    this.fetch = resolveFetch$2(fetch2);
  }
  /**
   * Enable throwing errors instead of returning them in the response
   * When enabled, failed operations will throw instead of returning { data: null, error }
   *
   * @returns This instance for method chaining
   * @example
   * ```typescript
   * const client = new VectorDataApi(url, headers)
   * client.throwOnError()
   * const { data } = await client.putVectors(options) // throws on error
   * ```
   */
  throwOnError() {
    this.shouldThrowOnError = true;
    return this;
  }
  /**
   * Inserts or updates vectors in batch (upsert operation)
   * Accepts 1-500 vectors per request. Larger batches should be split
   *
   * @param options - Vector insertion options
   * @param options.vectorBucketName - Name of the parent vector bucket
   * @param options.indexName - Name of the target index
   * @param options.vectors - Array of vectors to insert/update (1-500 items)
   * @returns Promise with empty response on success or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorConflictException` if duplicate key conflict occurs (HTTP 409)
   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * const { data, error } = await client.putVectors({
   *   vectorBucketName: 'embeddings-prod',
   *   indexName: 'documents-openai-small',
   *   vectors: [
   *     {
   *       key: 'doc-1',
   *       data: { float32: [0.1, 0.2, 0.3, ...] }, // 1536 dimensions
   *       metadata: { title: 'Introduction', page: 1 }
   *     },
   *     {
   *       key: 'doc-2',
   *       data: { float32: [0.4, 0.5, 0.6, ...] },
   *       metadata: { title: 'Conclusion', page: 42 }
   *     }
   *   ]
   * })
   * ```
   */
  putVectors(options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        if (options.vectors.length < 1 || options.vectors.length > 500) {
          throw new Error("Vector batch size must be between 1 and 500 items");
        }
        const data = yield post(this.fetch, `${this.url}/PutVectors`, options, {
          headers: this.headers
        });
        return { data: data || {}, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Retrieves vectors by their keys in batch
   * Optionally includes vector data and/or metadata in response
   * Additional permissions required when returning data or metadata
   *
   * @param options - Vector retrieval options
   * @param options.vectorBucketName - Name of the parent vector bucket
   * @param options.indexName - Name of the index
   * @param options.keys - Array of vector keys to retrieve
   * @param options.returnData - Whether to include vector embeddings (requires permission)
   * @param options.returnMetadata - Whether to include metadata (requires permission)
   * @returns Promise with array of vectors or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * const { data, error } = await client.getVectors({
   *   vectorBucketName: 'embeddings-prod',
   *   indexName: 'documents-openai-small',
   *   keys: ['doc-1', 'doc-2', 'doc-3'],
   *   returnData: false,     // Don't return embeddings
   *   returnMetadata: true   // Return metadata only
   * })
   * if (data) {
   *   data.vectors.forEach(v => console.log(v.key, v.metadata))
   * }
   * ```
   */
  getVectors(options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/GetVectors`, options, {
          headers: this.headers
        });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Lists/scans vectors in an index with pagination
   * Supports parallel scanning via segment configuration for high-throughput scenarios
   * Additional permissions required when returning data or metadata
   *
   * @param options - Vector listing options
   * @param options.vectorBucketName - Name of the parent vector bucket
   * @param options.indexName - Name of the index
   * @param options.maxResults - Maximum results per page (default: 500, max: 1000)
   * @param options.nextToken - Pagination token from previous response
   * @param options.returnData - Whether to include vector embeddings (requires permission)
   * @param options.returnMetadata - Whether to include metadata (requires permission)
   * @param options.segmentCount - Total parallel segments (1-16) for distributed scanning
   * @param options.segmentIndex - Zero-based segment index (0 to segmentCount-1)
   * @returns Promise with array of vectors, pagination token, or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * // Simple pagination
   * let nextToken: string | undefined
   * do {
   *   const { data, error } = await client.listVectors({
   *     vectorBucketName: 'embeddings-prod',
   *     indexName: 'documents-openai-small',
   *     maxResults: 500,
   *     nextToken,
   *     returnMetadata: true
   *   })
   *   if (error) break
   *   console.log('Batch:', data.vectors.length)
   *   nextToken = data.nextToken
   * } while (nextToken)
   *
   * // Parallel scanning (4 concurrent workers)
   * const workers = [0, 1, 2, 3].map(async (segmentIndex) => {
   *   const { data } = await client.listVectors({
   *     vectorBucketName: 'embeddings-prod',
   *     indexName: 'documents-openai-small',
   *     segmentCount: 4,
   *     segmentIndex,
   *     returnMetadata: true
   *   })
   *   return data?.vectors || []
   * })
   * const results = await Promise.all(workers)
   * ```
   */
  listVectors(options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        if (options.segmentCount !== void 0) {
          if (options.segmentCount < 1 || options.segmentCount > 16) {
            throw new Error("segmentCount must be between 1 and 16");
          }
          if (options.segmentIndex !== void 0) {
            if (options.segmentIndex < 0 || options.segmentIndex >= options.segmentCount) {
              throw new Error(`segmentIndex must be between 0 and ${options.segmentCount - 1}`);
            }
          }
        }
        const data = yield post(this.fetch, `${this.url}/ListVectors`, options, {
          headers: this.headers
        });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Queries for similar vectors using approximate nearest neighbor (ANN) search
   * Returns top-K most similar vectors based on the configured distance metric
   * Supports optional metadata filtering (requires GetVectors permission)
   *
   * @param options - Query options
   * @param options.vectorBucketName - Name of the parent vector bucket
   * @param options.indexName - Name of the index
   * @param options.queryVector - Query embedding to find similar vectors
   * @param options.topK - Number of nearest neighbors to return (default: 10)
   * @param options.filter - Optional JSON filter for metadata (requires GetVectors permission)
   * @param options.returnDistance - Whether to include similarity distances
   * @param options.returnMetadata - Whether to include metadata (requires GetVectors permission)
   * @returns Promise with array of similar vectors ordered by distance
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * // Semantic search with filtering
   * const { data, error } = await client.queryVectors({
   *   vectorBucketName: 'embeddings-prod',
   *   indexName: 'documents-openai-small',
   *   queryVector: { float32: [0.1, 0.2, 0.3, ...] }, // 1536 dimensions
   *   topK: 5,
   *   filter: {
   *     category: 'technical',
   *     published: true
   *   },
   *   returnDistance: true,
   *   returnMetadata: true
   * })
   * if (data) {
   *   data.matches.forEach(match => {
   *     console.log(`${match.key}: distance=${match.distance}`)
   *     console.log('Metadata:', match.metadata)
   *   })
   * }
   * ```
   */
  queryVectors(options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/QueryVectors`, options, {
          headers: this.headers
        });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Deletes vectors by their keys in batch
   * Accepts 1-500 keys per request
   *
   * @param options - Vector deletion options
   * @param options.vectorBucketName - Name of the parent vector bucket
   * @param options.indexName - Name of the index
   * @param options.keys - Array of vector keys to delete (1-500 items)
   * @returns Promise with empty response on success or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * const { error } = await client.deleteVectors({
   *   vectorBucketName: 'embeddings-prod',
   *   indexName: 'documents-openai-small',
   *   keys: ['doc-1', 'doc-2', 'doc-3']
   * })
   * if (!error) {
   *   console.log('Vectors deleted successfully')
   * }
   * ```
   */
  deleteVectors(options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        if (options.keys.length < 1 || options.keys.length > 500) {
          throw new Error("Keys batch size must be between 1 and 500 items");
        }
        const data = yield post(this.fetch, `${this.url}/DeleteVectors`, options, {
          headers: this.headers
        });
        return { data: data || {}, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
}
class VectorBucketApi {
  /**
   * Creates a new VectorBucketApi instance
   * @param url - The base URL for the storage vectors API
   * @param headers - HTTP headers to include in requests
   * @param fetch - Optional custom fetch implementation
   */
  constructor(url, headers = {}, fetch2) {
    this.shouldThrowOnError = false;
    this.url = url.replace(/\/$/, "");
    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS$2), headers);
    this.fetch = resolveFetch$2(fetch2);
  }
  /**
   * Enable throwing errors instead of returning them in the response
   * When enabled, failed operations will throw instead of returning { data: null, error }
   *
   * @returns This instance for method chaining
   * @example
   * ```typescript
   * const client = new VectorBucketApi(url, headers)
   * client.throwOnError()
   * const { data } = await client.createBucket('my-bucket') // throws on error
   * ```
   */
  throwOnError() {
    this.shouldThrowOnError = true;
    return this;
  }
  /**
   * Creates a new vector bucket
   * Vector buckets are containers for vector indexes and their data
   *
   * @param vectorBucketName - Unique name for the vector bucket
   * @returns Promise with empty response on success or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorConflictException` if bucket already exists (HTTP 409)
   * - `S3VectorMaxBucketsExceeded` if quota exceeded (HTTP 400)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * const { data, error } = await client.createBucket('embeddings-prod')
   * if (error) {
   *   console.error('Failed to create bucket:', error.message)
   * }
   * ```
   */
  createBucket(vectorBucketName) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/CreateVectorBucket`, { vectorBucketName }, { headers: this.headers });
        return { data: data || {}, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Retrieves metadata for a specific vector bucket
   * Returns bucket configuration including encryption settings and creation time
   *
   * @param vectorBucketName - Name of the vector bucket to retrieve
   * @returns Promise with bucket metadata or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * const { data, error } = await client.getBucket('embeddings-prod')
   * if (data) {
   *   console.log('Bucket created at:', new Date(data.vectorBucket.creationTime! * 1000))
   * }
   * ```
   */
  getBucket(vectorBucketName) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/GetVectorBucket`, { vectorBucketName }, { headers: this.headers });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Lists vector buckets with optional filtering and pagination
   * Supports prefix-based filtering and paginated results
   *
   * @param options - Listing options
   * @param options.prefix - Filter buckets by name prefix
   * @param options.maxResults - Maximum results per page (default: 100)
   * @param options.nextToken - Pagination token from previous response
   * @returns Promise with list of buckets and pagination token
   *
   * @throws {StorageVectorsApiError} With code:
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * // List all buckets with prefix 'prod-'
   * const { data, error } = await client.listBuckets({ prefix: 'prod-' })
   * if (data) {
   *   console.log('Found buckets:', data.buckets.length)
   *   // Fetch next page if available
   *   if (data.nextToken) {
   *     const next = await client.listBuckets({ nextToken: data.nextToken })
   *   }
   * }
   * ```
   */
  listBuckets() {
    return __awaiter(this, arguments, void 0, function* (options = {}) {
      try {
        const data = yield post(this.fetch, `${this.url}/ListVectorBuckets`, options, {
          headers: this.headers
        });
        return { data, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Deletes a vector bucket
   * Bucket must be empty before deletion (all indexes must be removed first)
   *
   * @param vectorBucketName - Name of the vector bucket to delete
   * @returns Promise with empty response on success or error
   *
   * @throws {StorageVectorsApiError} With code:
   * - `S3VectorBucketNotEmpty` if bucket contains indexes (HTTP 400)
   * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)
   * - `InternalError` for server errors (HTTP 500)
   *
   * @example
   * ```typescript
   * // Delete all indexes first, then delete bucket
   * const { error } = await client.deleteBucket('old-bucket')
   * if (error?.statusCode === 'S3VectorBucketNotEmpty') {
   *   console.error('Must delete all indexes first')
   * }
   * ```
   */
  deleteBucket(vectorBucketName) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/DeleteVectorBucket`, { vectorBucketName }, { headers: this.headers });
        return { data: data || {}, error: null };
      } catch (error2) {
        if (this.shouldThrowOnError) {
          throw error2;
        }
        if (isStorageVectorsError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
}
class StorageVectorsClient extends VectorBucketApi {
  constructor(url, options = {}) {
    super(url, options.headers || {}, options.fetch);
  }
  /**
   * Access operations for a specific vector bucket
   * Returns a scoped client for index and vector operations within the bucket
   *
   * @param vectorBucketName - Name of the vector bucket
   * @returns Bucket-scoped client with index and vector operations
   *
   * @example
   * ```typescript
   * const bucket = client.bucket('embeddings-prod')
   *
   * // Create an index in this bucket
   * await bucket.createIndex({
   *   indexName: 'documents-openai',
   *   dataType: 'float32',
   *   dimension: 1536,
   *   distanceMetric: 'cosine'
   * })
   *
   * // List indexes in this bucket
   * const { data } = await bucket.listIndexes()
   * ```
   */
  from(vectorBucketName) {
    return new VectorBucketScope(this.url, this.headers, vectorBucketName, this.fetch);
  }
}
class VectorBucketScope extends VectorIndexApi {
  constructor(url, headers, vectorBucketName, fetch2) {
    super(url, headers, fetch2);
    this.vectorBucketName = vectorBucketName;
  }
  /**
   * Creates a new vector index in this bucket
   * Convenience method that automatically includes the bucket name
   *
   * @param options - Index configuration (vectorBucketName is automatically set)
   * @returns Promise with empty response on success or error
   *
   * @example
   * ```typescript
   * const bucket = client.bucket('embeddings-prod')
   * await bucket.createIndex({
   *   indexName: 'documents-openai',
   *   dataType: 'float32',
   *   dimension: 1536,
   *   distanceMetric: 'cosine',
   *   metadataConfiguration: {
   *     nonFilterableMetadataKeys: ['raw_text']
   *   }
   * })
   * ```
   */
  createIndex(options) {
    const _super = Object.create(null, {
      createIndex: { get: () => super.createIndex }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.createIndex.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName }));
    });
  }
  /**
   * Lists indexes in this bucket
   * Convenience method that automatically includes the bucket name
   *
   * @param options - Listing options (vectorBucketName is automatically set)
   * @returns Promise with list of indexes or error
   *
   * @example
   * ```typescript
   * const bucket = client.bucket('embeddings-prod')
   * const { data } = await bucket.listIndexes({ prefix: 'documents-' })
   * ```
   */
  listIndexes() {
    const _super = Object.create(null, {
      listIndexes: { get: () => super.listIndexes }
    });
    return __awaiter(this, arguments, void 0, function* (options = {}) {
      return _super.listIndexes.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName }));
    });
  }
  /**
   * Retrieves metadata for a specific index in this bucket
   * Convenience method that automatically includes the bucket name
   *
   * @param indexName - Name of the index to retrieve
   * @returns Promise with index metadata or error
   *
   * @example
   * ```typescript
   * const bucket = client.bucket('embeddings-prod')
   * const { data } = await bucket.getIndex('documents-openai')
   * console.log('Dimension:', data?.index.dimension)
   * ```
   */
  getIndex(indexName) {
    const _super = Object.create(null, {
      getIndex: { get: () => super.getIndex }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.getIndex.call(this, this.vectorBucketName, indexName);
    });
  }
  /**
   * Deletes an index from this bucket
   * Convenience method that automatically includes the bucket name
   *
   * @param indexName - Name of the index to delete
   * @returns Promise with empty response on success or error
   *
   * @example
   * ```typescript
   * const bucket = client.bucket('embeddings-prod')
   * await bucket.deleteIndex('old-index')
   * ```
   */
  deleteIndex(indexName) {
    const _super = Object.create(null, {
      deleteIndex: { get: () => super.deleteIndex }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.deleteIndex.call(this, this.vectorBucketName, indexName);
    });
  }
  /**
   * Access operations for a specific index within this bucket
   * Returns a scoped client for vector data operations
   *
   * @param indexName - Name of the index
   * @returns Index-scoped client with vector data operations
   *
   * @example
   * ```typescript
   * const index = client.bucket('embeddings-prod').index('documents-openai')
   *
   * // Insert vectors
   * await index.putVectors({
   *   vectors: [
   *     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }
   *   ]
   * })
   *
   * // Query similar vectors
   * const { data } = await index.queryVectors({
   *   queryVector: { float32: [...] },
   *   topK: 5
   * })
   * ```
   */
  index(indexName) {
    return new VectorIndexScope(this.url, this.headers, this.vectorBucketName, indexName, this.fetch);
  }
}
class VectorIndexScope extends VectorDataApi {
  constructor(url, headers, vectorBucketName, indexName, fetch2) {
    super(url, headers, fetch2);
    this.vectorBucketName = vectorBucketName;
    this.indexName = indexName;
  }
  /**
   * Inserts or updates vectors in this index
   * Convenience method that automatically includes bucket and index names
   *
   * @param options - Vector insertion options (bucket and index names automatically set)
   * @returns Promise with empty response on success or error
   *
   * @example
   * ```typescript
   * const index = client.bucket('embeddings-prod').index('documents-openai')
   * await index.putVectors({
   *   vectors: [
   *     {
   *       key: 'doc-1',
   *       data: { float32: [0.1, 0.2, ...] },
   *       metadata: { title: 'Introduction', page: 1 }
   *     }
   *   ]
   * })
   * ```
   */
  putVectors(options) {
    const _super = Object.create(null, {
      putVectors: { get: () => super.putVectors }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.putVectors.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
    });
  }
  /**
   * Retrieves vectors by keys from this index
   * Convenience method that automatically includes bucket and index names
   *
   * @param options - Vector retrieval options (bucket and index names automatically set)
   * @returns Promise with array of vectors or error
   *
   * @example
   * ```typescript
   * const index = client.bucket('embeddings-prod').index('documents-openai')
   * const { data } = await index.getVectors({
   *   keys: ['doc-1', 'doc-2'],
   *   returnMetadata: true
   * })
   * ```
   */
  getVectors(options) {
    const _super = Object.create(null, {
      getVectors: { get: () => super.getVectors }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.getVectors.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
    });
  }
  /**
   * Lists vectors in this index with pagination
   * Convenience method that automatically includes bucket and index names
   *
   * @param options - Listing options (bucket and index names automatically set)
   * @returns Promise with array of vectors and pagination token
   *
   * @example
   * ```typescript
   * const index = client.bucket('embeddings-prod').index('documents-openai')
   * const { data } = await index.listVectors({
   *   maxResults: 500,
   *   returnMetadata: true
   * })
   * ```
   */
  listVectors() {
    const _super = Object.create(null, {
      listVectors: { get: () => super.listVectors }
    });
    return __awaiter(this, arguments, void 0, function* (options = {}) {
      return _super.listVectors.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
    });
  }
  /**
   * Queries for similar vectors in this index
   * Convenience method that automatically includes bucket and index names
   *
   * @param options - Query options (bucket and index names automatically set)
   * @returns Promise with array of similar vectors ordered by distance
   *
   * @example
   * ```typescript
   * const index = client.bucket('embeddings-prod').index('documents-openai')
   * const { data } = await index.queryVectors({
   *   queryVector: { float32: [0.1, 0.2, ...] },
   *   topK: 5,
   *   filter: { category: 'technical' },
   *   returnDistance: true,
   *   returnMetadata: true
   * })
   * ```
   */
  queryVectors(options) {
    const _super = Object.create(null, {
      queryVectors: { get: () => super.queryVectors }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.queryVectors.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
    });
  }
  /**
   * Deletes vectors by keys from this index
   * Convenience method that automatically includes bucket and index names
   *
   * @param options - Deletion options (bucket and index names automatically set)
   * @returns Promise with empty response on success or error
   *
   * @example
   * ```typescript
   * const index = client.bucket('embeddings-prod').index('documents-openai')
   * await index.deleteVectors({
   *   keys: ['doc-1', 'doc-2', 'doc-3']
   * })
   * ```
   */
  deleteVectors(options) {
    const _super = Object.create(null, {
      deleteVectors: { get: () => super.deleteVectors }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return _super.deleteVectors.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
    });
  }
}
class StorageClient extends StorageBucketApi {
  constructor(url, headers = {}, fetch2, opts) {
    super(url, headers, fetch2, opts);
  }
  /**
   * Perform file operation in a bucket.
   *
   * @param id The bucket id to operate on.
   */
  from(id) {
    return new StorageFileApi(this.url, this.headers, id, this.fetch);
  }
  /**
   * Access vector storage operations.
   *
   * @returns A StorageVectorsClient instance configured with the current storage settings.
   */
  get vectors() {
    return new StorageVectorsClient(this.url + "/vector", {
      headers: this.headers,
      fetch: this.fetch
    });
  }
  /**
   * Access analytics storage operations using Iceberg tables.
   *
   * @returns A StorageAnalyticsApi instance configured with the current storage settings.
   * @example
   * ```typescript
   * const client = createClient(url, key)
   * const analytics = client.storage.analytics
   *
   * // Create an analytics bucket
   * await analytics.createBucket('my-analytics-bucket')
   *
   * // List all analytics buckets
   * const { data: buckets } = await analytics.listBuckets()
   *
   * // Delete an analytics bucket
   * await analytics.deleteBucket('old-analytics-bucket')
   * ```
   */
  get analytics() {
    return new StorageAnalyticsApi(this.url + "/iceberg", this.headers, this.fetch);
  }
}
const version$1 = "2.76.1";
let JS_ENV = "";
if (typeof Deno !== "undefined") {
  JS_ENV = "deno";
} else if (typeof document !== "undefined") {
  JS_ENV = "web";
} else if (typeof navigator !== "undefined" && navigator.product === "ReactNative") {
  JS_ENV = "react-native";
} else {
  JS_ENV = "node";
}
const DEFAULT_HEADERS$1 = { "X-Client-Info": `supabase-js-${JS_ENV}/${version$1}` };
const DEFAULT_GLOBAL_OPTIONS = {
  headers: DEFAULT_HEADERS$1
};
const DEFAULT_DB_OPTIONS = {
  schema: "public"
};
const DEFAULT_AUTH_OPTIONS = {
  autoRefreshToken: true,
  persistSession: true,
  detectSessionInUrl: true,
  flowType: "implicit"
};
const DEFAULT_REALTIME_OPTIONS = {};
const resolveFetch$1 = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = nodeFetch;
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
const resolveHeadersConstructor = () => {
  if (typeof Headers === "undefined") {
    return Headers$1;
  }
  return Headers;
};
const fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {
  const fetch2 = resolveFetch$1(customFetch);
  const HeadersConstructor = resolveHeadersConstructor();
  return (input, init) => __async(null, null, function* () {
    var _a2;
    const accessToken = (_a2 = yield getAccessToken()) !== null && _a2 !== void 0 ? _a2 : supabaseKey;
    let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);
    if (!headers.has("apikey")) {
      headers.set("apikey", supabaseKey);
    }
    if (!headers.has("Authorization")) {
      headers.set("Authorization", `Bearer ${accessToken}`);
    }
    return fetch2(input, Object.assign(Object.assign({}, init), { headers }));
  });
};
function ensureTrailingSlash(url) {
  return url.endsWith("/") ? url : url + "/";
}
function applySettingDefaults(options, defaults) {
  var _a2, _b;
  const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions } = options;
  const { db: DEFAULT_DB_OPTIONS2, auth: DEFAULT_AUTH_OPTIONS2, realtime: DEFAULT_REALTIME_OPTIONS2, global: DEFAULT_GLOBAL_OPTIONS2 } = defaults;
  const result = {
    db: Object.assign(Object.assign({}, DEFAULT_DB_OPTIONS2), dbOptions),
    auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS2), authOptions),
    realtime: Object.assign(Object.assign({}, DEFAULT_REALTIME_OPTIONS2), realtimeOptions),
    storage: {},
    global: Object.assign(Object.assign(Object.assign({}, DEFAULT_GLOBAL_OPTIONS2), globalOptions), { headers: Object.assign(Object.assign({}, (_a2 = DEFAULT_GLOBAL_OPTIONS2 === null || DEFAULT_GLOBAL_OPTIONS2 === void 0 ? void 0 : DEFAULT_GLOBAL_OPTIONS2.headers) !== null && _a2 !== void 0 ? _a2 : {}), (_b = globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.headers) !== null && _b !== void 0 ? _b : {}) }),
    accessToken: () => __async(null, null, function* () {
      return "";
    })
  };
  if (options.accessToken) {
    result.accessToken = options.accessToken;
  } else {
    delete result.accessToken;
  }
  return result;
}
function validateSupabaseUrl(supabaseUrl) {
  const trimmedUrl = supabaseUrl === null || supabaseUrl === void 0 ? void 0 : supabaseUrl.trim();
  if (!trimmedUrl) {
    throw new Error("supabaseUrl is required.");
  }
  if (!trimmedUrl.match(/^https?:\/\//i)) {
    throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");
  }
  try {
    return new URL(ensureTrailingSlash(trimmedUrl));
  } catch (_a2) {
    throw Error("Invalid supabaseUrl: Provided URL is malformed.");
  }
}
const version = "2.76.1";
const AUTO_REFRESH_TICK_DURATION_MS = 30 * 1e3;
const AUTO_REFRESH_TICK_THRESHOLD = 3;
const EXPIRY_MARGIN_MS = AUTO_REFRESH_TICK_THRESHOLD * AUTO_REFRESH_TICK_DURATION_MS;
const GOTRUE_URL = "http://localhost:9999";
const STORAGE_KEY = "supabase.auth.token";
const DEFAULT_HEADERS = { "X-Client-Info": `gotrue-js/${version}` };
const API_VERSION_HEADER_NAME = "X-Supabase-Api-Version";
const API_VERSIONS = {
  "2024-01-01": {
    timestamp: Date.parse("2024-01-01T00:00:00.0Z"),
    name: "2024-01-01"
  }
};
const BASE64URL_REGEX = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i;
const JWKS_TTL = 10 * 60 * 1e3;
class AuthError extends Error {
  constructor(message, status, code) {
    super(message);
    this.__isAuthError = true;
    this.name = "AuthError";
    this.status = status;
    this.code = code;
  }
}
function isAuthError(error2) {
  return typeof error2 === "object" && error2 !== null && "__isAuthError" in error2;
}
class AuthApiError extends AuthError {
  constructor(message, status, code) {
    super(message, status, code);
    this.name = "AuthApiError";
    this.status = status;
    this.code = code;
  }
}
function isAuthApiError(error2) {
  return isAuthError(error2) && error2.name === "AuthApiError";
}
class AuthUnknownError extends AuthError {
  constructor(message, originalError) {
    super(message);
    this.name = "AuthUnknownError";
    this.originalError = originalError;
  }
}
class CustomAuthError extends AuthError {
  constructor(message, name2, status, code) {
    super(message, status, code);
    this.name = name2;
    this.status = status;
  }
}
class AuthSessionMissingError extends CustomAuthError {
  constructor() {
    super("Auth session missing!", "AuthSessionMissingError", 400, void 0);
  }
}
function isAuthSessionMissingError(error2) {
  return isAuthError(error2) && error2.name === "AuthSessionMissingError";
}
class AuthInvalidTokenResponseError extends CustomAuthError {
  constructor() {
    super("Auth session or user missing", "AuthInvalidTokenResponseError", 500, void 0);
  }
}
class AuthInvalidCredentialsError extends CustomAuthError {
  constructor(message) {
    super(message, "AuthInvalidCredentialsError", 400, void 0);
  }
}
class AuthImplicitGrantRedirectError extends CustomAuthError {
  constructor(message, details = null) {
    super(message, "AuthImplicitGrantRedirectError", 500, void 0);
    this.details = null;
    this.details = details;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
}
function isAuthImplicitGrantRedirectError(error2) {
  return isAuthError(error2) && error2.name === "AuthImplicitGrantRedirectError";
}
class AuthPKCEGrantCodeExchangeError extends CustomAuthError {
  constructor(message, details = null) {
    super(message, "AuthPKCEGrantCodeExchangeError", 500, void 0);
    this.details = null;
    this.details = details;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
}
class AuthRetryableFetchError extends CustomAuthError {
  constructor(message, status) {
    super(message, "AuthRetryableFetchError", status, void 0);
  }
}
function isAuthRetryableFetchError(error2) {
  return isAuthError(error2) && error2.name === "AuthRetryableFetchError";
}
class AuthWeakPasswordError extends CustomAuthError {
  constructor(message, status, reasons) {
    super(message, "AuthWeakPasswordError", status, "weak_password");
    this.reasons = reasons;
  }
}
class AuthInvalidJwtError extends CustomAuthError {
  constructor(message) {
    super(message, "AuthInvalidJwtError", 400, "invalid_jwt");
  }
}
const TO_BASE64URL = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split("");
const IGNORE_BASE64URL = " 	\n\r=".split("");
const FROM_BASE64URL = (() => {
  const charMap = new Array(128);
  for (let i = 0; i < charMap.length; i += 1) {
    charMap[i] = -1;
  }
  for (let i = 0; i < IGNORE_BASE64URL.length; i += 1) {
    charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;
  }
  for (let i = 0; i < TO_BASE64URL.length; i += 1) {
    charMap[TO_BASE64URL[i].charCodeAt(0)] = i;
  }
  return charMap;
})();
function byteToBase64URL(byte, state, emit) {
  if (byte !== null) {
    state.queue = state.queue << 8 | byte;
    state.queuedBits += 8;
    while (state.queuedBits >= 6) {
      const pos = state.queue >> state.queuedBits - 6 & 63;
      emit(TO_BASE64URL[pos]);
      state.queuedBits -= 6;
    }
  } else if (state.queuedBits > 0) {
    state.queue = state.queue << 6 - state.queuedBits;
    state.queuedBits = 6;
    while (state.queuedBits >= 6) {
      const pos = state.queue >> state.queuedBits - 6 & 63;
      emit(TO_BASE64URL[pos]);
      state.queuedBits -= 6;
    }
  }
}
function byteFromBase64URL(charCode, state, emit) {
  const bits = FROM_BASE64URL[charCode];
  if (bits > -1) {
    state.queue = state.queue << 6 | bits;
    state.queuedBits += 6;
    while (state.queuedBits >= 8) {
      emit(state.queue >> state.queuedBits - 8 & 255);
      state.queuedBits -= 8;
    }
  } else if (bits === -2) {
    return;
  } else {
    throw new Error(`Invalid Base64-URL character "${String.fromCharCode(charCode)}"`);
  }
}
function stringFromBase64URL(str) {
  const conv = [];
  const utf8Emit = (codepoint) => {
    conv.push(String.fromCodePoint(codepoint));
  };
  const utf8State = {
    utf8seq: 0,
    codepoint: 0
  };
  const b64State = { queue: 0, queuedBits: 0 };
  const byteEmit = (byte) => {
    stringFromUTF8(byte, utf8State, utf8Emit);
  };
  for (let i = 0; i < str.length; i += 1) {
    byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);
  }
  return conv.join("");
}
function codepointToUTF8(codepoint, emit) {
  if (codepoint <= 127) {
    emit(codepoint);
    return;
  } else if (codepoint <= 2047) {
    emit(192 | codepoint >> 6);
    emit(128 | codepoint & 63);
    return;
  } else if (codepoint <= 65535) {
    emit(224 | codepoint >> 12);
    emit(128 | codepoint >> 6 & 63);
    emit(128 | codepoint & 63);
    return;
  } else if (codepoint <= 1114111) {
    emit(240 | codepoint >> 18);
    emit(128 | codepoint >> 12 & 63);
    emit(128 | codepoint >> 6 & 63);
    emit(128 | codepoint & 63);
    return;
  }
  throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);
}
function stringToUTF8(str, emit) {
  for (let i = 0; i < str.length; i += 1) {
    let codepoint = str.charCodeAt(i);
    if (codepoint > 55295 && codepoint <= 56319) {
      const highSurrogate = (codepoint - 55296) * 1024 & 65535;
      const lowSurrogate = str.charCodeAt(i + 1) - 56320 & 65535;
      codepoint = (lowSurrogate | highSurrogate) + 65536;
      i += 1;
    }
    codepointToUTF8(codepoint, emit);
  }
}
function stringFromUTF8(byte, state, emit) {
  if (state.utf8seq === 0) {
    if (byte <= 127) {
      emit(byte);
      return;
    }
    for (let leadingBit = 1; leadingBit < 6; leadingBit += 1) {
      if ((byte >> 7 - leadingBit & 1) === 0) {
        state.utf8seq = leadingBit;
        break;
      }
    }
    if (state.utf8seq === 2) {
      state.codepoint = byte & 31;
    } else if (state.utf8seq === 3) {
      state.codepoint = byte & 15;
    } else if (state.utf8seq === 4) {
      state.codepoint = byte & 7;
    } else {
      throw new Error("Invalid UTF-8 sequence");
    }
    state.utf8seq -= 1;
  } else if (state.utf8seq > 0) {
    if (byte <= 127) {
      throw new Error("Invalid UTF-8 sequence");
    }
    state.codepoint = state.codepoint << 6 | byte & 63;
    state.utf8seq -= 1;
    if (state.utf8seq === 0) {
      emit(state.codepoint);
    }
  }
}
function base64UrlToUint8Array(str) {
  const result = [];
  const state = { queue: 0, queuedBits: 0 };
  const onByte = (byte) => {
    result.push(byte);
  };
  for (let i = 0; i < str.length; i += 1) {
    byteFromBase64URL(str.charCodeAt(i), state, onByte);
  }
  return new Uint8Array(result);
}
function stringToUint8Array(str) {
  const result = [];
  stringToUTF8(str, (byte) => result.push(byte));
  return new Uint8Array(result);
}
function bytesToBase64URL(bytes) {
  const result = [];
  const state = { queue: 0, queuedBits: 0 };
  const onChar = (char2) => {
    result.push(char2);
  };
  bytes.forEach((byte) => byteToBase64URL(byte, state, onChar));
  byteToBase64URL(null, state, onChar);
  return result.join("");
}
function expiresAt(expiresIn) {
  const timeNow = Math.round(Date.now() / 1e3);
  return timeNow + expiresIn;
}
function uuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    const r2 = Math.random() * 16 | 0, v = c == "x" ? r2 : r2 & 3 | 8;
    return v.toString(16);
  });
}
const isBrowser = () => typeof window !== "undefined" && typeof document !== "undefined";
const localStorageWriteTests = {
  tested: false,
  writable: false
};
const supportsLocalStorage = () => {
  if (!isBrowser()) {
    return false;
  }
  try {
    if (typeof globalThis.localStorage !== "object") {
      return false;
    }
  } catch (e) {
    return false;
  }
  if (localStorageWriteTests.tested) {
    return localStorageWriteTests.writable;
  }
  const randomKey = `lswt-${Math.random()}${Math.random()}`;
  try {
    globalThis.localStorage.setItem(randomKey, randomKey);
    globalThis.localStorage.removeItem(randomKey);
    localStorageWriteTests.tested = true;
    localStorageWriteTests.writable = true;
  } catch (e) {
    localStorageWriteTests.tested = true;
    localStorageWriteTests.writable = false;
  }
  return localStorageWriteTests.writable;
};
function parseParametersFromURL(href) {
  const result = {};
  const url = new URL(href);
  if (url.hash && url.hash[0] === "#") {
    try {
      const hashSearchParams = new URLSearchParams(url.hash.substring(1));
      hashSearchParams.forEach((value, key) => {
        result[key] = value;
      });
    } catch (e) {
    }
  }
  url.searchParams.forEach((value, key) => {
    result[key] = value;
  });
  return result;
}
const resolveFetch = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = (...args) => __vitePreload(() => __async(null, null, function* () {
      const { default: fetch2 } = yield Promise.resolve().then(() => browser);
      return { default: fetch2 };
    }), true ? void 0 : void 0, import.meta.url).then(({ default: fetch2 }) => fetch2(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
const looksLikeFetchResponse = (maybeResponse) => {
  return typeof maybeResponse === "object" && maybeResponse !== null && "status" in maybeResponse && "ok" in maybeResponse && "json" in maybeResponse && typeof maybeResponse.json === "function";
};
const setItemAsync = (storage, key, data) => __async(null, null, function* () {
  yield storage.setItem(key, JSON.stringify(data));
});
const getItemAsync = (storage, key) => __async(null, null, function* () {
  const value = yield storage.getItem(key);
  if (!value) {
    return null;
  }
  try {
    return JSON.parse(value);
  } catch (_a2) {
    return value;
  }
});
const removeItemAsync = (storage, key) => __async(null, null, function* () {
  yield storage.removeItem(key);
});
class Deferred {
  constructor() {
    this.promise = new Deferred.promiseConstructor((res, rej) => {
      this.resolve = res;
      this.reject = rej;
    });
  }
}
Deferred.promiseConstructor = Promise;
function decodeJWT(token2) {
  const parts = token2.split(".");
  if (parts.length !== 3) {
    throw new AuthInvalidJwtError("Invalid JWT structure");
  }
  for (let i = 0; i < parts.length; i++) {
    if (!BASE64URL_REGEX.test(parts[i])) {
      throw new AuthInvalidJwtError("JWT not in base64url format");
    }
  }
  const data = {
    // using base64url lib
    header: JSON.parse(stringFromBase64URL(parts[0])),
    payload: JSON.parse(stringFromBase64URL(parts[1])),
    signature: base64UrlToUint8Array(parts[2]),
    raw: {
      header: parts[0],
      payload: parts[1]
    }
  };
  return data;
}
function sleep(time) {
  return __async(this, null, function* () {
    return yield new Promise((accept) => {
      setTimeout(() => accept(null), time);
    });
  });
}
function retryable(fn2, isRetryable) {
  const promise = new Promise((accept, reject) => {
    (() => __async(null, null, function* () {
      for (let attempt = 0; attempt < Infinity; attempt++) {
        try {
          const result = yield fn2(attempt);
          if (!isRetryable(attempt, null, result)) {
            accept(result);
            return;
          }
        } catch (e) {
          if (!isRetryable(attempt, e)) {
            reject(e);
            return;
          }
        }
      }
    }))();
  });
  return promise;
}
function dec2hex(dec) {
  return ("0" + dec.toString(16)).substr(-2);
}
function generatePKCEVerifier() {
  const verifierLength = 56;
  const array = new Uint32Array(verifierLength);
  if (typeof crypto === "undefined") {
    const charSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
    const charSetLen = charSet.length;
    let verifier = "";
    for (let i = 0; i < verifierLength; i++) {
      verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));
    }
    return verifier;
  }
  crypto.getRandomValues(array);
  return Array.from(array, dec2hex).join("");
}
function sha256(randomString) {
  return __async(this, null, function* () {
    const encoder = new TextEncoder();
    const encodedData = encoder.encode(randomString);
    const hash2 = yield crypto.subtle.digest("SHA-256", encodedData);
    const bytes = new Uint8Array(hash2);
    return Array.from(bytes).map((c) => String.fromCharCode(c)).join("");
  });
}
function generatePKCEChallenge(verifier) {
  return __async(this, null, function* () {
    const hasCryptoSupport = typeof crypto !== "undefined" && typeof crypto.subtle !== "undefined" && typeof TextEncoder !== "undefined";
    if (!hasCryptoSupport) {
      console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.");
      return verifier;
    }
    const hashed = yield sha256(verifier);
    return btoa(hashed).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  });
}
function getCodeChallengeAndMethod(storage, storageKey, isPasswordRecovery = false) {
  return __async(this, null, function* () {
    const codeVerifier = generatePKCEVerifier();
    let storedCodeVerifier = codeVerifier;
    if (isPasswordRecovery) {
      storedCodeVerifier += "/PASSWORD_RECOVERY";
    }
    yield setItemAsync(storage, `${storageKey}-code-verifier`, storedCodeVerifier);
    const codeChallenge = yield generatePKCEChallenge(codeVerifier);
    const codeChallengeMethod = codeVerifier === codeChallenge ? "plain" : "s256";
    return [codeChallenge, codeChallengeMethod];
  });
}
const API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
function parseResponseAPIVersion(response) {
  const apiVersion = response.headers.get(API_VERSION_HEADER_NAME);
  if (!apiVersion) {
    return null;
  }
  if (!apiVersion.match(API_VERSION_REGEX)) {
    return null;
  }
  try {
    const date = /* @__PURE__ */ new Date(`${apiVersion}T00:00:00.0Z`);
    return date;
  } catch (e) {
    return null;
  }
}
function validateExp(exp) {
  if (!exp) {
    throw new Error("Missing exp claim");
  }
  const timeNow = Math.floor(Date.now() / 1e3);
  if (exp <= timeNow) {
    throw new Error("JWT has expired");
  }
}
function getAlgorithm(alg) {
  switch (alg) {
    case "RS256":
      return {
        name: "RSASSA-PKCS1-v1_5",
        hash: { name: "SHA-256" }
      };
    case "ES256":
      return {
        name: "ECDSA",
        namedCurve: "P-256",
        hash: { name: "SHA-256" }
      };
    default:
      throw new Error("Invalid alg claim");
  }
}
const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
function validateUUID(str) {
  if (!UUID_REGEX.test(str)) {
    throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not");
  }
}
function userNotAvailableProxy() {
  const proxyTarget = {};
  return new Proxy(proxyTarget, {
    get: (target, prop) => {
      if (prop === "__isUserNotAvailableProxy") {
        return true;
      }
      if (typeof prop === "symbol") {
        const sProp = prop.toString();
        if (sProp === "Symbol(Symbol.toPrimitive)" || sProp === "Symbol(Symbol.toStringTag)" || sProp === "Symbol(util.inspect.custom)") {
          return void 0;
        }
      }
      throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${prop}" property of the session object is not supported. Please use getUser() instead.`);
    },
    set: (_target, prop) => {
      throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${prop}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);
    },
    deleteProperty: (_target, prop) => {
      throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${prop}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);
    }
  });
}
function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}
const _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
const NETWORK_ERROR_CODES = [502, 503, 504];
function handleError(error2) {
  return __async(this, null, function* () {
    var _a2;
    if (!looksLikeFetchResponse(error2)) {
      throw new AuthRetryableFetchError(_getErrorMessage(error2), 0);
    }
    if (NETWORK_ERROR_CODES.includes(error2.status)) {
      throw new AuthRetryableFetchError(_getErrorMessage(error2), error2.status);
    }
    let data;
    try {
      data = yield error2.json();
    } catch (e) {
      throw new AuthUnknownError(_getErrorMessage(e), e);
    }
    let errorCode = void 0;
    const responseAPIVersion = parseResponseAPIVersion(error2);
    if (responseAPIVersion && responseAPIVersion.getTime() >= API_VERSIONS["2024-01-01"].timestamp && typeof data === "object" && data && typeof data.code === "string") {
      errorCode = data.code;
    } else if (typeof data === "object" && data && typeof data.error_code === "string") {
      errorCode = data.error_code;
    }
    if (!errorCode) {
      if (typeof data === "object" && data && typeof data.weak_password === "object" && data.weak_password && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.reasons.reduce((a, i) => a && typeof i === "string", true)) {
        throw new AuthWeakPasswordError(_getErrorMessage(data), error2.status, data.weak_password.reasons);
      }
    } else if (errorCode === "weak_password") {
      throw new AuthWeakPasswordError(_getErrorMessage(data), error2.status, ((_a2 = data.weak_password) === null || _a2 === void 0 ? void 0 : _a2.reasons) || []);
    } else if (errorCode === "session_not_found") {
      throw new AuthSessionMissingError();
    }
    throw new AuthApiError(_getErrorMessage(data), error2.status || 500, errorCode);
  });
}
const _getRequestParams = (method, options, parameters, body2) => {
  const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
  if (method === "GET") {
    return params;
  }
  params.headers = Object.assign({ "Content-Type": "application/json;charset=UTF-8" }, options === null || options === void 0 ? void 0 : options.headers);
  params.body = JSON.stringify(body2);
  return Object.assign(Object.assign({}, params), parameters);
};
function _request(fetcher, method, url, options) {
  return __async(this, null, function* () {
    var _a2;
    const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);
    if (!headers[API_VERSION_HEADER_NAME]) {
      headers[API_VERSION_HEADER_NAME] = API_VERSIONS["2024-01-01"].name;
    }
    if (options === null || options === void 0 ? void 0 : options.jwt) {
      headers["Authorization"] = `Bearer ${options.jwt}`;
    }
    const qs = (_a2 = options === null || options === void 0 ? void 0 : options.query) !== null && _a2 !== void 0 ? _a2 : {};
    if (options === null || options === void 0 ? void 0 : options.redirectTo) {
      qs["redirect_to"] = options.redirectTo;
    }
    const queryString = Object.keys(qs).length ? "?" + new URLSearchParams(qs).toString() : "";
    const data = yield _handleRequest(fetcher, method, url + queryString, {
      headers,
      noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson
    }, {}, options === null || options === void 0 ? void 0 : options.body);
    return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : { data: Object.assign({}, data), error: null };
  });
}
function _handleRequest(fetcher, method, url, options, parameters, body2) {
  return __async(this, null, function* () {
    const requestParams = _getRequestParams(method, options, parameters, body2);
    let result;
    try {
      result = yield fetcher(url, Object.assign({}, requestParams));
    } catch (e) {
      console.error(e);
      throw new AuthRetryableFetchError(_getErrorMessage(e), 0);
    }
    if (!result.ok) {
      yield handleError(result);
    }
    if (options === null || options === void 0 ? void 0 : options.noResolveJson) {
      return result;
    }
    try {
      return yield result.json();
    } catch (e) {
      yield handleError(e);
    }
  });
}
function _sessionResponse(data) {
  var _a2;
  let session = null;
  if (hasSession(data)) {
    session = Object.assign({}, data);
    if (!data.expires_at) {
      session.expires_at = expiresAt(data.expires_in);
    }
  }
  const user = (_a2 = data.user) !== null && _a2 !== void 0 ? _a2 : data;
  return { data: { session, user }, error: null };
}
function _sessionResponsePassword(data) {
  const response = _sessionResponse(data);
  if (!response.error && data.weak_password && typeof data.weak_password === "object" && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.message && typeof data.weak_password.message === "string" && data.weak_password.reasons.reduce((a, i) => a && typeof i === "string", true)) {
    response.data.weak_password = data.weak_password;
  }
  return response;
}
function _userResponse(data) {
  var _a2;
  const user = (_a2 = data.user) !== null && _a2 !== void 0 ? _a2 : data;
  return { data: { user }, error: null };
}
function _ssoResponse(data) {
  return { data, error: null };
}
function _generateLinkResponse(data) {
  const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = __rest(data, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]);
  const properties2 = {
    action_link,
    email_otp,
    hashed_token,
    redirect_to,
    verification_type
  };
  const user = Object.assign({}, rest);
  return {
    data: {
      properties: properties2,
      user
    },
    error: null
  };
}
function _noResolveJsonResponse(data) {
  return data;
}
function hasSession(data) {
  return data.access_token && data.refresh_token && data.expires_in;
}
const SIGN_OUT_SCOPES = ["global", "local", "others"];
class GoTrueAdminApi {
  constructor({ url = "", headers = {}, fetch: fetch2 }) {
    this.url = url;
    this.headers = headers;
    this.fetch = resolveFetch(fetch2);
    this.mfa = {
      listFactors: this._listFactors.bind(this),
      deleteFactor: this._deleteFactor.bind(this)
    };
    this.oauth = {
      listClients: this._listOAuthClients.bind(this),
      createClient: this._createOAuthClient.bind(this),
      getClient: this._getOAuthClient.bind(this),
      deleteClient: this._deleteOAuthClient.bind(this),
      regenerateClientSecret: this._regenerateOAuthClientSecret.bind(this)
    };
  }
  /**
   * Removes a logged-in session.
   * @param jwt A valid, logged-in JWT.
   * @param scope The logout sope.
   */
  signOut(_0) {
    return __async(this, arguments, function* (jwt, scope = SIGN_OUT_SCOPES[0]) {
      if (SIGN_OUT_SCOPES.indexOf(scope) < 0) {
        throw new Error(`@supabase/auth-js: Parameter scope must be one of ${SIGN_OUT_SCOPES.join(", ")}`);
      }
      try {
        yield _request(this.fetch, "POST", `${this.url}/logout?scope=${scope}`, {
          headers: this.headers,
          jwt,
          noResolveJson: true
        });
        return { data: null, error: null };
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Sends an invite link to an email address.
   * @param email The email address of the user.
   * @param options Additional options to be included when inviting.
   */
  inviteUserByEmail(_0) {
    return __async(this, arguments, function* (email, options = {}) {
      try {
        return yield _request(this.fetch, "POST", `${this.url}/invite`, {
          body: { email, data: options.data },
          headers: this.headers,
          redirectTo: options.redirectTo,
          xform: _userResponse
        });
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: { user: null }, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Generates email links and OTPs to be sent via a custom email provider.
   * @param email The user's email.
   * @param options.password User password. For signup only.
   * @param options.data Optional user metadata. For signup only.
   * @param options.redirectTo The redirect url which should be appended to the generated link
   */
  generateLink(params) {
    return __async(this, null, function* () {
      try {
        const { options } = params, rest = __rest(params, ["options"]);
        const body2 = Object.assign(Object.assign({}, rest), options);
        if ("newEmail" in rest) {
          body2.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;
          delete body2["newEmail"];
        }
        return yield _request(this.fetch, "POST", `${this.url}/admin/generate_link`, {
          body: body2,
          headers: this.headers,
          xform: _generateLinkResponse,
          redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo
        });
      } catch (error2) {
        if (isAuthError(error2)) {
          return {
            data: {
              properties: null,
              user: null
            },
            error: error2
          };
        }
        throw error2;
      }
    });
  }
  // User Admin API
  /**
   * Creates a new user.
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  createUser(attributes) {
    return __async(this, null, function* () {
      try {
        return yield _request(this.fetch, "POST", `${this.url}/admin/users`, {
          body: attributes,
          headers: this.headers,
          xform: _userResponse
        });
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: { user: null }, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Get a list of users.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.
   */
  listUsers(params) {
    return __async(this, null, function* () {
      var _a2, _b, _c, _d, _e, _f, _g;
      try {
        const pagination = { nextPage: null, lastPage: 0, total: 0 };
        const response = yield _request(this.fetch, "GET", `${this.url}/admin/users`, {
          headers: this.headers,
          noResolveJson: true,
          query: {
            page: (_b = (_a2 = params === null || params === void 0 ? void 0 : params.page) === null || _a2 === void 0 ? void 0 : _a2.toString()) !== null && _b !== void 0 ? _b : "",
            per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""
          },
          xform: _noResolveJsonResponse
        });
        if (response.error)
          throw response.error;
        const users = yield response.json();
        const total = (_e = response.headers.get("x-total-count")) !== null && _e !== void 0 ? _e : 0;
        const links = (_g = (_f = response.headers.get("link")) === null || _f === void 0 ? void 0 : _f.split(",")) !== null && _g !== void 0 ? _g : [];
        if (links.length > 0) {
          links.forEach((link) => {
            const page = parseInt(link.split(";")[0].split("=")[1].substring(0, 1));
            const rel = JSON.parse(link.split(";")[1].split("=")[1]);
            pagination[`${rel}Page`] = page;
          });
          pagination.total = parseInt(total);
        }
        return { data: Object.assign(Object.assign({}, users), pagination), error: null };
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: { users: [] }, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Get user by id.
   *
   * @param uid The user's unique identifier
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  getUserById(uid) {
    return __async(this, null, function* () {
      validateUUID(uid);
      try {
        return yield _request(this.fetch, "GET", `${this.url}/admin/users/${uid}`, {
          headers: this.headers,
          xform: _userResponse
        });
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: { user: null }, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Updates the user data.
   *
   * @param attributes The data you want to update.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  updateUserById(uid, attributes) {
    return __async(this, null, function* () {
      validateUUID(uid);
      try {
        return yield _request(this.fetch, "PUT", `${this.url}/admin/users/${uid}`, {
          body: attributes,
          headers: this.headers,
          xform: _userResponse
        });
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: { user: null }, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Delete a user. Requires a `service_role` key.
   *
   * @param id The user id you want to remove.
   * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema. Soft deletion allows user identification from the hashed user ID but is not reversible.
   * Defaults to false for backward compatibility.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  deleteUser(id, shouldSoftDelete = false) {
    return __async(this, null, function* () {
      validateUUID(id);
      try {
        return yield _request(this.fetch, "DELETE", `${this.url}/admin/users/${id}`, {
          headers: this.headers,
          body: {
            should_soft_delete: shouldSoftDelete
          },
          xform: _userResponse
        });
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: { user: null }, error: error2 };
        }
        throw error2;
      }
    });
  }
  _listFactors(params) {
    return __async(this, null, function* () {
      validateUUID(params.userId);
      try {
        const { data, error: error2 } = yield _request(this.fetch, "GET", `${this.url}/admin/users/${params.userId}/factors`, {
          headers: this.headers,
          xform: (factors) => {
            return { data: { factors }, error: null };
          }
        });
        return { data, error: error2 };
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  _deleteFactor(params) {
    return __async(this, null, function* () {
      validateUUID(params.userId);
      validateUUID(params.id);
      try {
        const data = yield _request(this.fetch, "DELETE", `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {
          headers: this.headers
        });
        return { data, error: null };
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Lists all OAuth clients with optional pagination.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  _listOAuthClients(params) {
    return __async(this, null, function* () {
      var _a2, _b, _c, _d, _e, _f, _g;
      try {
        const pagination = { nextPage: null, lastPage: 0, total: 0 };
        const response = yield _request(this.fetch, "GET", `${this.url}/admin/oauth/clients`, {
          headers: this.headers,
          noResolveJson: true,
          query: {
            page: (_b = (_a2 = params === null || params === void 0 ? void 0 : params.page) === null || _a2 === void 0 ? void 0 : _a2.toString()) !== null && _b !== void 0 ? _b : "",
            per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""
          },
          xform: _noResolveJsonResponse
        });
        if (response.error)
          throw response.error;
        const clients = yield response.json();
        const total = (_e = response.headers.get("x-total-count")) !== null && _e !== void 0 ? _e : 0;
        const links = (_g = (_f = response.headers.get("link")) === null || _f === void 0 ? void 0 : _f.split(",")) !== null && _g !== void 0 ? _g : [];
        if (links.length > 0) {
          links.forEach((link) => {
            const page = parseInt(link.split(";")[0].split("=")[1].substring(0, 1));
            const rel = JSON.parse(link.split(";")[1].split("=")[1]);
            pagination[`${rel}Page`] = page;
          });
          pagination.total = parseInt(total);
        }
        return { data: Object.assign(Object.assign({}, clients), pagination), error: null };
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: { clients: [] }, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Creates a new OAuth client.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  _createOAuthClient(params) {
    return __async(this, null, function* () {
      try {
        return yield _request(this.fetch, "POST", `${this.url}/admin/oauth/clients`, {
          body: params,
          headers: this.headers,
          xform: (client2) => {
            return { data: client2, error: null };
          }
        });
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Gets details of a specific OAuth client.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  _getOAuthClient(clientId) {
    return __async(this, null, function* () {
      try {
        return yield _request(this.fetch, "GET", `${this.url}/admin/oauth/clients/${clientId}`, {
          headers: this.headers,
          xform: (client2) => {
            return { data: client2, error: null };
          }
        });
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Deletes an OAuth client.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  _deleteOAuthClient(clientId) {
    return __async(this, null, function* () {
      try {
        return yield _request(this.fetch, "DELETE", `${this.url}/admin/oauth/clients/${clientId}`, {
          headers: this.headers,
          xform: (client2) => {
            return { data: client2, error: null };
          }
        });
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Regenerates the secret for an OAuth client.
   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  _regenerateOAuthClientSecret(clientId) {
    return __async(this, null, function* () {
      try {
        return yield _request(this.fetch, "POST", `${this.url}/admin/oauth/clients/${clientId}/regenerate_secret`, {
          headers: this.headers,
          xform: (client2) => {
            return { data: client2, error: null };
          }
        });
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
}
function memoryLocalStorageAdapter(store = {}) {
  return {
    getItem: (key) => {
      return store[key] || null;
    },
    setItem: (key, value) => {
      store[key] = value;
    },
    removeItem: (key) => {
      delete store[key];
    }
  };
}
const internals = {
  /**
   * @experimental
   */
  debug: !!(globalThis && supportsLocalStorage() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true")
};
class LockAcquireTimeoutError extends Error {
  constructor(message) {
    super(message);
    this.isAcquireTimeout = true;
  }
}
class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {
}
function navigatorLock(name2, acquireTimeout, fn2) {
  return __async(this, null, function* () {
    if (internals.debug) {
      console.log("@supabase/gotrue-js: navigatorLock: acquire lock", name2, acquireTimeout);
    }
    const abortController = new globalThis.AbortController();
    if (acquireTimeout > 0) {
      setTimeout(() => {
        abortController.abort();
        if (internals.debug) {
          console.log("@supabase/gotrue-js: navigatorLock acquire timed out", name2);
        }
      }, acquireTimeout);
    }
    return yield Promise.resolve().then(() => globalThis.navigator.locks.request(name2, acquireTimeout === 0 ? {
      mode: "exclusive",
      ifAvailable: true
    } : {
      mode: "exclusive",
      signal: abortController.signal
    }, (lock) => __async(null, null, function* () {
      if (lock) {
        if (internals.debug) {
          console.log("@supabase/gotrue-js: navigatorLock: acquired", name2, lock.name);
        }
        try {
          return yield fn2();
        } finally {
          if (internals.debug) {
            console.log("@supabase/gotrue-js: navigatorLock: released", name2, lock.name);
          }
        }
      } else {
        if (acquireTimeout === 0) {
          if (internals.debug) {
            console.log("@supabase/gotrue-js: navigatorLock: not immediately available", name2);
          }
          throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock "${name2}" immediately failed`);
        } else {
          if (internals.debug) {
            try {
              const result = yield globalThis.navigator.locks.query();
              console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(result, null, "  "));
            } catch (e) {
              console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", e);
            }
          }
          console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request");
          return yield fn2();
        }
      }
    })));
  });
}
function polyfillGlobalThis() {
  if (typeof globalThis === "object")
    return;
  try {
    Object.defineProperty(Object.prototype, "__magic__", {
      get: function() {
        return this;
      },
      configurable: true
    });
    __magic__.globalThis = __magic__;
    delete Object.prototype.__magic__;
  } catch (e) {
    if (typeof self !== "undefined") {
      self.globalThis = self;
    }
  }
}
function getAddress(address) {
  if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
    throw new Error(`@supabase/auth-js: Address "${address}" is invalid.`);
  }
  return address.toLowerCase();
}
function fromHex(hex) {
  return parseInt(hex, 16);
}
function toHex(value) {
  const bytes = new TextEncoder().encode(value);
  const hex = Array.from(bytes, (byte) => byte.toString(16).padStart(2, "0")).join("");
  return "0x" + hex;
}
function createSiweMessage(parameters) {
  var _a2;
  const { chainId, domain, expirationTime, issuedAt = /* @__PURE__ */ new Date(), nonce, notBefore, requestId, resources, scheme, uri, version: version2 } = parameters;
  {
    if (!Number.isInteger(chainId))
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${chainId}`);
    if (!domain)
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.`);
    if (nonce && nonce.length < 8)
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${nonce}`);
    if (!uri)
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.`);
    if (version2 !== "1")
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${version2}`);
    if ((_a2 = parameters.statement) === null || _a2 === void 0 ? void 0 : _a2.includes("\n"))
      throw new Error(`@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${parameters.statement}`);
  }
  const address = getAddress(parameters.address);
  const origin = scheme ? `${scheme}://${domain}` : domain;
  const statement = parameters.statement ? `${parameters.statement}
` : "";
  const prefix2 = `${origin} wants you to sign in with your Ethereum account:
${address}

${statement}`;
  let suffix = `URI: ${uri}
Version: ${version2}
Chain ID: ${chainId}${nonce ? `
Nonce: ${nonce}` : ""}
Issued At: ${issuedAt.toISOString()}`;
  if (expirationTime)
    suffix += `
Expiration Time: ${expirationTime.toISOString()}`;
  if (notBefore)
    suffix += `
Not Before: ${notBefore.toISOString()}`;
  if (requestId)
    suffix += `
Request ID: ${requestId}`;
  if (resources) {
    let content = "\nResources:";
    for (const resource of resources) {
      if (!resource || typeof resource !== "string")
        throw new Error(`@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${resource}`);
      content += `
- ${resource}`;
    }
    suffix += content;
  }
  return `${prefix2}
${suffix}`;
}
class WebAuthnError extends Error {
  constructor({ message, code, cause, name: name2 }) {
    var _a2;
    super(message, { cause });
    this.__isWebAuthnError = true;
    this.name = (_a2 = name2 !== null && name2 !== void 0 ? name2 : cause instanceof Error ? cause.name : void 0) !== null && _a2 !== void 0 ? _a2 : "Unknown Error";
    this.code = code;
  }
}
class WebAuthnUnknownError extends WebAuthnError {
  constructor(message, originalError) {
    super({
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: originalError,
      message
    });
    this.name = "WebAuthnUnknownError";
    this.originalError = originalError;
  }
}
function identifyRegistrationError({ error: error2, options }) {
  var _a2, _b, _c;
  const { publicKey } = options;
  if (!publicKey) {
    throw Error("options was missing required publicKey property");
  }
  if (error2.name === "AbortError") {
    if (options.signal instanceof AbortSignal) {
      return new WebAuthnError({
        message: "Registration ceremony was sent an abort signal",
        code: "ERROR_CEREMONY_ABORTED",
        cause: error2
      });
    }
  } else if (error2.name === "ConstraintError") {
    if (((_a2 = publicKey.authenticatorSelection) === null || _a2 === void 0 ? void 0 : _a2.requireResidentKey) === true) {
      return new WebAuthnError({
        message: "Discoverable credentials were required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",
        cause: error2
      });
    } else if (
      // @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024
      options.mediation === "conditional" && ((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === "required"
    ) {
      return new WebAuthnError({
        message: "User verification was required during automatic registration but it could not be performed",
        code: "ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",
        cause: error2
      });
    } else if (((_c = publicKey.authenticatorSelection) === null || _c === void 0 ? void 0 : _c.userVerification) === "required") {
      return new WebAuthnError({
        message: "User verification was required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",
        cause: error2
      });
    }
  } else if (error2.name === "InvalidStateError") {
    return new WebAuthnError({
      message: "The authenticator was previously registered",
      code: "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",
      cause: error2
    });
  } else if (error2.name === "NotAllowedError") {
    return new WebAuthnError({
      message: error2.message,
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: error2
    });
  } else if (error2.name === "NotSupportedError") {
    const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param) => param.type === "public-key");
    if (validPubKeyCredParams.length === 0) {
      return new WebAuthnError({
        message: 'No entry in pubKeyCredParams was of type "public-key"',
        code: "ERROR_MALFORMED_PUBKEYCREDPARAMS",
        cause: error2
      });
    }
    return new WebAuthnError({
      message: "No available authenticator supported any of the specified pubKeyCredParams algorithms",
      code: "ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",
      cause: error2
    });
  } else if (error2.name === "SecurityError") {
    const effectiveDomain = window.location.hostname;
    if (!isValidDomain(effectiveDomain)) {
      return new WebAuthnError({
        message: `${window.location.hostname} is an invalid domain`,
        code: "ERROR_INVALID_DOMAIN",
        cause: error2
      });
    } else if (publicKey.rp.id !== effectiveDomain) {
      return new WebAuthnError({
        message: `The RP ID "${publicKey.rp.id}" is invalid for this domain`,
        code: "ERROR_INVALID_RP_ID",
        cause: error2
      });
    }
  } else if (error2.name === "TypeError") {
    if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {
      return new WebAuthnError({
        message: "User ID was not between 1 and 64 characters",
        code: "ERROR_INVALID_USER_ID_LENGTH",
        cause: error2
      });
    }
  } else if (error2.name === "UnknownError") {
    return new WebAuthnError({
      message: "The authenticator was unable to process the specified options, or could not create a new credential",
      code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
      cause: error2
    });
  }
  return new WebAuthnError({
    message: "a Non-Webauthn related error has occurred",
    code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
    cause: error2
  });
}
function identifyAuthenticationError({ error: error2, options }) {
  const { publicKey } = options;
  if (!publicKey) {
    throw Error("options was missing required publicKey property");
  }
  if (error2.name === "AbortError") {
    if (options.signal instanceof AbortSignal) {
      return new WebAuthnError({
        message: "Authentication ceremony was sent an abort signal",
        code: "ERROR_CEREMONY_ABORTED",
        cause: error2
      });
    }
  } else if (error2.name === "NotAllowedError") {
    return new WebAuthnError({
      message: error2.message,
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: error2
    });
  } else if (error2.name === "SecurityError") {
    const effectiveDomain = window.location.hostname;
    if (!isValidDomain(effectiveDomain)) {
      return new WebAuthnError({
        message: `${window.location.hostname} is an invalid domain`,
        code: "ERROR_INVALID_DOMAIN",
        cause: error2
      });
    } else if (publicKey.rpId !== effectiveDomain) {
      return new WebAuthnError({
        message: `The RP ID "${publicKey.rpId}" is invalid for this domain`,
        code: "ERROR_INVALID_RP_ID",
        cause: error2
      });
    }
  } else if (error2.name === "UnknownError") {
    return new WebAuthnError({
      message: "The authenticator was unable to process the specified options, or could not create a new assertion signature",
      code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
      cause: error2
    });
  }
  return new WebAuthnError({
    message: "a Non-Webauthn related error has occurred",
    code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
    cause: error2
  });
}
class WebAuthnAbortService {
  /**
   * Create an abort signal for a new WebAuthn operation.
   * Automatically cancels any existing operation.
   *
   * @returns {AbortSignal} Signal to pass to navigator.credentials.create() or .get()
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal MDN - AbortSignal}
   */
  createNewAbortSignal() {
    if (this.controller) {
      const abortError = new Error("Cancelling existing WebAuthn API call for new one");
      abortError.name = "AbortError";
      this.controller.abort(abortError);
    }
    const newController = new AbortController();
    this.controller = newController;
    return newController.signal;
  }
  /**
   * Manually cancel the current WebAuthn operation.
   * Useful for cleaning up when user cancels or navigates away.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort MDN - AbortController.abort}
   */
  cancelCeremony() {
    if (this.controller) {
      const abortError = new Error("Manually cancelling existing WebAuthn API call");
      abortError.name = "AbortError";
      this.controller.abort(abortError);
      this.controller = void 0;
    }
  }
}
const webAuthnAbortService = new WebAuthnAbortService();
function deserializeCredentialCreationOptions(options) {
  if (!options) {
    throw new Error("Credential creation options are required");
  }
  if (typeof PublicKeyCredential !== "undefined" && "parseCreationOptionsFromJSON" in PublicKeyCredential && typeof PublicKeyCredential.parseCreationOptionsFromJSON === "function") {
    return PublicKeyCredential.parseCreationOptionsFromJSON(
      /** we assert the options here as typescript still doesn't know about future webauthn types */
      options
    );
  }
  const { challenge: challengeStr, user: userOpts, excludeCredentials } = options, restOptions = __rest(
    options,
    ["challenge", "user", "excludeCredentials"]
  );
  const challenge = base64UrlToUint8Array(challengeStr).buffer;
  const user = Object.assign(Object.assign({}, userOpts), { id: base64UrlToUint8Array(userOpts.id).buffer });
  const result = Object.assign(Object.assign({}, restOptions), {
    challenge,
    user
  });
  if (excludeCredentials && excludeCredentials.length > 0) {
    result.excludeCredentials = new Array(excludeCredentials.length);
    for (let i = 0; i < excludeCredentials.length; i++) {
      const cred = excludeCredentials[i];
      result.excludeCredentials[i] = Object.assign(Object.assign({}, cred), {
        id: base64UrlToUint8Array(cred.id).buffer,
        type: cred.type || "public-key",
        // Cast transports to handle future transport types like "cable"
        transports: cred.transports
      });
    }
  }
  return result;
}
function deserializeCredentialRequestOptions(options) {
  if (!options) {
    throw new Error("Credential request options are required");
  }
  if (typeof PublicKeyCredential !== "undefined" && "parseRequestOptionsFromJSON" in PublicKeyCredential && typeof PublicKeyCredential.parseRequestOptionsFromJSON === "function") {
    return PublicKeyCredential.parseRequestOptionsFromJSON(options);
  }
  const { challenge: challengeStr, allowCredentials } = options, restOptions = __rest(
    options,
    ["challenge", "allowCredentials"]
  );
  const challenge = base64UrlToUint8Array(challengeStr).buffer;
  const result = Object.assign(Object.assign({}, restOptions), { challenge });
  if (allowCredentials && allowCredentials.length > 0) {
    result.allowCredentials = new Array(allowCredentials.length);
    for (let i = 0; i < allowCredentials.length; i++) {
      const cred = allowCredentials[i];
      result.allowCredentials[i] = Object.assign(Object.assign({}, cred), {
        id: base64UrlToUint8Array(cred.id).buffer,
        type: cred.type || "public-key",
        // Cast transports to handle future transport types like "cable"
        transports: cred.transports
      });
    }
  }
  return result;
}
function serializeCredentialCreationResponse(credential) {
  var _a2;
  if ("toJSON" in credential && typeof credential.toJSON === "function") {
    return credential.toJSON();
  }
  const credentialWithAttachment = credential;
  return {
    id: credential.id,
    rawId: credential.id,
    response: {
      attestationObject: bytesToBase64URL(new Uint8Array(credential.response.attestationObject)),
      clientDataJSON: bytesToBase64URL(new Uint8Array(credential.response.clientDataJSON))
    },
    type: "public-key",
    clientExtensionResults: credential.getClientExtensionResults(),
    // Convert null to undefined and cast to AuthenticatorAttachment type
    authenticatorAttachment: (_a2 = credentialWithAttachment.authenticatorAttachment) !== null && _a2 !== void 0 ? _a2 : void 0
  };
}
function serializeCredentialRequestResponse(credential) {
  var _a2;
  if ("toJSON" in credential && typeof credential.toJSON === "function") {
    return credential.toJSON();
  }
  const credentialWithAttachment = credential;
  const clientExtensionResults = credential.getClientExtensionResults();
  const assertionResponse = credential.response;
  return {
    id: credential.id,
    rawId: credential.id,
    // W3C spec expects rawId to match id for JSON format
    response: {
      authenticatorData: bytesToBase64URL(new Uint8Array(assertionResponse.authenticatorData)),
      clientDataJSON: bytesToBase64URL(new Uint8Array(assertionResponse.clientDataJSON)),
      signature: bytesToBase64URL(new Uint8Array(assertionResponse.signature)),
      userHandle: assertionResponse.userHandle ? bytesToBase64URL(new Uint8Array(assertionResponse.userHandle)) : void 0
    },
    type: "public-key",
    clientExtensionResults,
    // Convert null to undefined and cast to AuthenticatorAttachment type
    authenticatorAttachment: (_a2 = credentialWithAttachment.authenticatorAttachment) !== null && _a2 !== void 0 ? _a2 : void 0
  };
}
function isValidDomain(hostname) {
  return (
    // Consider localhost valid as well since it's okay wrt Secure Contexts
    hostname === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(hostname)
  );
}
function browserSupportsWebAuthn() {
  var _a2, _b;
  return !!(isBrowser() && "PublicKeyCredential" in window && window.PublicKeyCredential && "credentials" in navigator && typeof ((_a2 = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _a2 === void 0 ? void 0 : _a2.create) === "function" && typeof ((_b = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _b === void 0 ? void 0 : _b.get) === "function");
}
function createCredential(options) {
  return __async(this, null, function* () {
    try {
      const response = yield navigator.credentials.create(
        /** we assert the type here until typescript types are updated */
        options
      );
      if (!response) {
        return {
          data: null,
          error: new WebAuthnUnknownError("Empty credential response", response)
        };
      }
      if (!(response instanceof PublicKeyCredential)) {
        return {
          data: null,
          error: new WebAuthnUnknownError("Browser returned unexpected credential type", response)
        };
      }
      return { data: response, error: null };
    } catch (err) {
      return {
        data: null,
        error: identifyRegistrationError({
          error: err,
          options
        })
      };
    }
  });
}
function getCredential(options) {
  return __async(this, null, function* () {
    try {
      const response = yield navigator.credentials.get(
        /** we assert the type here until typescript types are updated */
        options
      );
      if (!response) {
        return {
          data: null,
          error: new WebAuthnUnknownError("Empty credential response", response)
        };
      }
      if (!(response instanceof PublicKeyCredential)) {
        return {
          data: null,
          error: new WebAuthnUnknownError("Browser returned unexpected credential type", response)
        };
      }
      return { data: response, error: null };
    } catch (err) {
      return {
        data: null,
        error: identifyAuthenticationError({
          error: err,
          options
        })
      };
    }
  });
}
const DEFAULT_CREATION_OPTIONS = {
  hints: ["security-key"],
  authenticatorSelection: {
    authenticatorAttachment: "cross-platform",
    requireResidentKey: false,
    /** set to preferred because older yubikeys don't have PIN/Biometric */
    userVerification: "preferred",
    residentKey: "discouraged"
  },
  attestation: "none"
};
const DEFAULT_REQUEST_OPTIONS = {
  /** set to preferred because older yubikeys don't have PIN/Biometric */
  userVerification: "preferred",
  hints: ["security-key"]
};
function deepMerge(...sources) {
  const isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  const isArrayBufferLike = (val) => val instanceof ArrayBuffer || ArrayBuffer.isView(val);
  const result = {};
  for (const source of sources) {
    if (!source)
      continue;
    for (const key in source) {
      const value = source[key];
      if (value === void 0)
        continue;
      if (Array.isArray(value)) {
        result[key] = value;
      } else if (isArrayBufferLike(value)) {
        result[key] = value;
      } else if (isObject(value)) {
        const existing = result[key];
        if (isObject(existing)) {
          result[key] = deepMerge(existing, value);
        } else {
          result[key] = deepMerge(value);
        }
      } else {
        result[key] = value;
      }
    }
  }
  return result;
}
function mergeCredentialCreationOptions(baseOptions, overrides) {
  return deepMerge(DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {});
}
function mergeCredentialRequestOptions(baseOptions, overrides) {
  return deepMerge(DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {});
}
class WebAuthnApi {
  constructor(client2) {
    this.client = client2;
    this.enroll = this._enroll.bind(this);
    this.challenge = this._challenge.bind(this);
    this.verify = this._verify.bind(this);
    this.authenticate = this._authenticate.bind(this);
    this.register = this._register.bind(this);
  }
  /**
   * Enroll a new WebAuthn factor.
   * Creates an unverified WebAuthn factor that must be verified with a credential.
   *
   * @experimental This method is experimental and may change in future releases
   * @param {Omit<MFAEnrollWebauthnParams, 'factorType'>} params - Enrollment parameters (friendlyName required)
   * @returns {Promise<AuthMFAEnrollWebauthnResponse>} Enrolled factor details or error
   * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}
   */
  _enroll(params) {
    return __async(this, null, function* () {
      return this.client.mfa.enroll(Object.assign(Object.assign({}, params), { factorType: "webauthn" }));
    });
  }
  /**
   * Challenge for WebAuthn credential creation or authentication.
   * Combines server challenge with browser credential operations.
   * Handles both registration (create) and authentication (request) flows.
   *
   * @experimental This method is experimental and may change in future releases
   * @param {MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal }} params - Challenge parameters including factorId
   * @param {Object} overrides - Allows you to override the parameters passed to navigator.credentials
   * @param {PublicKeyCredentialCreationOptionsFuture} overrides.create - Override options for credential creation
   * @param {PublicKeyCredentialRequestOptionsFuture} overrides.request - Override options for credential request
   * @returns {Promise<RequestResult>} Challenge response with credential or error
   * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}
   * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying Assertion}
   */
  _challenge(_0, _1) {
    return __async(this, arguments, function* ({ factorId, webauthn, friendlyName, signal }, overrides) {
      try {
        const { data: challengeResponse, error: challengeError } = yield this.client.mfa.challenge({
          factorId,
          webauthn
        });
        if (!challengeResponse) {
          return { data: null, error: challengeError };
        }
        const abortSignal = signal !== null && signal !== void 0 ? signal : webAuthnAbortService.createNewAbortSignal();
        if (challengeResponse.webauthn.type === "create") {
          const { user } = challengeResponse.webauthn.credential_options.publicKey;
          if (!user.name) {
            user.name = `${user.id}:${friendlyName}`;
          }
          if (!user.displayName) {
            user.displayName = user.name;
          }
        }
        switch (challengeResponse.webauthn.type) {
          case "create": {
            const options = mergeCredentialCreationOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.create);
            const { data, error: error2 } = yield createCredential({
              publicKey: options,
              signal: abortSignal
            });
            if (data) {
              return {
                data: {
                  factorId,
                  challengeId: challengeResponse.id,
                  webauthn: {
                    type: challengeResponse.webauthn.type,
                    credential_response: data
                  }
                },
                error: null
              };
            }
            return { data: null, error: error2 };
          }
          case "request": {
            const options = mergeCredentialRequestOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.request);
            const { data, error: error2 } = yield getCredential(Object.assign(Object.assign({}, challengeResponse.webauthn.credential_options), { publicKey: options, signal: abortSignal }));
            if (data) {
              return {
                data: {
                  factorId,
                  challengeId: challengeResponse.id,
                  webauthn: {
                    type: challengeResponse.webauthn.type,
                    credential_response: data
                  }
                },
                error: null
              };
            }
            return { data: null, error: error2 };
          }
        }
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: null, error: error2 };
        }
        return {
          data: null,
          error: new AuthUnknownError("Unexpected error in challenge", error2)
        };
      }
    });
  }
  /**
   * Verify a WebAuthn credential with the server.
   * Completes the WebAuthn ceremony by sending the credential to the server for verification.
   *
   * @experimental This method is experimental and may change in future releases
   * @param {Object} params - Verification parameters
   * @param {string} params.challengeId - ID of the challenge being verified
   * @param {string} params.factorId - ID of the WebAuthn factor
   * @param {MFAVerifyWebauthnParams<T>['webauthn']} params.webauthn - WebAuthn credential response
   * @returns {Promise<AuthMFAVerifyResponse>} Verification result with session or error
   * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}
   * */
  _verify(_0) {
    return __async(this, arguments, function* ({ challengeId, factorId, webauthn }) {
      return this.client.mfa.verify({
        factorId,
        challengeId,
        webauthn
      });
    });
  }
  /**
   * Complete WebAuthn authentication flow.
   * Performs challenge and verification in a single operation for existing credentials.
   *
   * @experimental This method is experimental and may change in future releases
   * @param {Object} params - Authentication parameters
   * @param {string} params.factorId - ID of the WebAuthn factor to authenticate with
   * @param {Object} params.webauthn - WebAuthn configuration
   * @param {string} params.webauthn.rpId - Relying Party ID (defaults to current hostname)
   * @param {string[]} params.webauthn.rpOrigins - Allowed origins (defaults to current origin)
   * @param {AbortSignal} params.webauthn.signal - Optional abort signal
   * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Override options for navigator.credentials.get
   * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Authentication result
   * @see {@link https://w3c.github.io/webauthn/#sctn-authentication W3C WebAuthn Spec - Authentication Ceremony}
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions MDN - PublicKeyCredentialRequestOptions}
   */
  _authenticate(_0, _1) {
    return __async(this, arguments, function* ({ factorId, webauthn: { rpId = typeof window !== "undefined" ? window.location.hostname : void 0, rpOrigins = typeof window !== "undefined" ? [window.location.origin] : void 0, signal } }, overrides) {
      if (!rpId) {
        return {
          data: null,
          error: new AuthError("rpId is required for WebAuthn authentication")
        };
      }
      try {
        if (!browserSupportsWebAuthn()) {
          return {
            data: null,
            error: new AuthUnknownError("Browser does not support WebAuthn", null)
          };
        }
        const { data: challengeResponse, error: challengeError } = yield this.challenge({
          factorId,
          webauthn: { rpId, rpOrigins },
          signal
        }, { request: overrides });
        if (!challengeResponse) {
          return { data: null, error: challengeError };
        }
        const { webauthn } = challengeResponse;
        return this._verify({
          factorId,
          challengeId: challengeResponse.challengeId,
          webauthn: {
            type: webauthn.type,
            rpId,
            rpOrigins,
            credential_response: webauthn.credential_response
          }
        });
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: null, error: error2 };
        }
        return {
          data: null,
          error: new AuthUnknownError("Unexpected error in authenticate", error2)
        };
      }
    });
  }
  /**
   * Complete WebAuthn registration flow.
   * Performs enrollment, challenge, and verification in a single operation for new credentials.
   *
   * @experimental This method is experimental and may change in future releases
   * @param {Object} params - Registration parameters
   * @param {string} params.friendlyName - User-friendly name for the credential
   * @param {string} params.rpId - Relying Party ID (defaults to current hostname)
   * @param {string[]} params.rpOrigins - Allowed origins (defaults to current origin)
   * @param {AbortSignal} params.signal - Optional abort signal
   * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Override options for navigator.credentials.create
   * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Registration result
   * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registration Ceremony}
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions MDN - PublicKeyCredentialCreationOptions}
   */
  _register(_0, _1) {
    return __async(this, arguments, function* ({ friendlyName, rpId = typeof window !== "undefined" ? window.location.hostname : void 0, rpOrigins = typeof window !== "undefined" ? [window.location.origin] : void 0, signal }, overrides) {
      if (!rpId) {
        return {
          data: null,
          error: new AuthError("rpId is required for WebAuthn registration")
        };
      }
      try {
        if (!browserSupportsWebAuthn()) {
          return {
            data: null,
            error: new AuthUnknownError("Browser does not support WebAuthn", null)
          };
        }
        const { data: factor, error: enrollError } = yield this._enroll({
          friendlyName
        });
        if (!factor) {
          yield this.client.mfa.listFactors().then((factors) => {
            var _a2;
            return (_a2 = factors.data) === null || _a2 === void 0 ? void 0 : _a2.all.find((v) => v.factor_type === "webauthn" && v.friendly_name === friendlyName && v.status !== "unverified");
          }).then((factor2) => factor2 ? this.client.mfa.unenroll({ factorId: factor2 === null || factor2 === void 0 ? void 0 : factor2.id }) : void 0);
          return { data: null, error: enrollError };
        }
        const { data: challengeResponse, error: challengeError } = yield this._challenge({
          factorId: factor.id,
          friendlyName: factor.friendly_name,
          webauthn: { rpId, rpOrigins },
          signal
        }, {
          create: overrides
        });
        if (!challengeResponse) {
          return { data: null, error: challengeError };
        }
        return this._verify({
          factorId: factor.id,
          challengeId: challengeResponse.challengeId,
          webauthn: {
            rpId,
            rpOrigins,
            type: challengeResponse.webauthn.type,
            credential_response: challengeResponse.webauthn.credential_response
          }
        });
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: null, error: error2 };
        }
        return {
          data: null,
          error: new AuthUnknownError("Unexpected error in register", error2)
        };
      }
    });
  }
}
polyfillGlobalThis();
const DEFAULT_OPTIONS = {
  url: GOTRUE_URL,
  storageKey: STORAGE_KEY,
  autoRefreshToken: true,
  persistSession: true,
  detectSessionInUrl: true,
  headers: DEFAULT_HEADERS,
  flowType: "implicit",
  debug: false,
  hasCustomAuthorizationHeader: false
};
function lockNoOp(name2, acquireTimeout, fn2) {
  return __async(this, null, function* () {
    return yield fn2();
  });
}
const GLOBAL_JWKS = {};
class GoTrueClient {
  /**
   * The JWKS used for verifying asymmetric JWTs
   */
  get jwks() {
    var _a2, _b;
    return (_b = (_a2 = GLOBAL_JWKS[this.storageKey]) === null || _a2 === void 0 ? void 0 : _a2.jwks) !== null && _b !== void 0 ? _b : { keys: [] };
  }
  set jwks(value) {
    GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), { jwks: value });
  }
  get jwks_cached_at() {
    var _a2, _b;
    return (_b = (_a2 = GLOBAL_JWKS[this.storageKey]) === null || _a2 === void 0 ? void 0 : _a2.cachedAt) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;
  }
  set jwks_cached_at(value) {
    GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), { cachedAt: value });
  }
  /**
   * Create a new client for use in the browser.
   */
  constructor(options) {
    var _a2, _b;
    this.userStorage = null;
    this.memoryStorage = null;
    this.stateChangeEmitters = /* @__PURE__ */ new Map();
    this.autoRefreshTicker = null;
    this.visibilityChangedCallback = null;
    this.refreshingDeferred = null;
    this.initializePromise = null;
    this.detectSessionInUrl = true;
    this.hasCustomAuthorizationHeader = false;
    this.suppressGetSessionWarning = false;
    this.lockAcquired = false;
    this.pendingInLock = [];
    this.broadcastChannel = null;
    this.logger = console.log;
    this.instanceID = GoTrueClient.nextInstanceID;
    GoTrueClient.nextInstanceID += 1;
    if (this.instanceID > 0 && isBrowser()) {
      console.warn("Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.");
    }
    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
    this.logDebugMessages = !!settings.debug;
    if (typeof settings.debug === "function") {
      this.logger = settings.debug;
    }
    this.persistSession = settings.persistSession;
    this.storageKey = settings.storageKey;
    this.autoRefreshToken = settings.autoRefreshToken;
    this.admin = new GoTrueAdminApi({
      url: settings.url,
      headers: settings.headers,
      fetch: settings.fetch
    });
    this.url = settings.url;
    this.headers = settings.headers;
    this.fetch = resolveFetch(settings.fetch);
    this.lock = settings.lock || lockNoOp;
    this.detectSessionInUrl = settings.detectSessionInUrl;
    this.flowType = settings.flowType;
    this.hasCustomAuthorizationHeader = settings.hasCustomAuthorizationHeader;
    if (settings.lock) {
      this.lock = settings.lock;
    } else if (isBrowser() && ((_a2 = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a2 === void 0 ? void 0 : _a2.locks)) {
      this.lock = navigatorLock;
    } else {
      this.lock = lockNoOp;
    }
    if (!this.jwks) {
      this.jwks = { keys: [] };
      this.jwks_cached_at = Number.MIN_SAFE_INTEGER;
    }
    this.mfa = {
      verify: this._verify.bind(this),
      enroll: this._enroll.bind(this),
      unenroll: this._unenroll.bind(this),
      challenge: this._challenge.bind(this),
      listFactors: this._listFactors.bind(this),
      challengeAndVerify: this._challengeAndVerify.bind(this),
      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),
      webauthn: new WebAuthnApi(this)
    };
    if (this.persistSession) {
      if (settings.storage) {
        this.storage = settings.storage;
      } else {
        if (supportsLocalStorage()) {
          this.storage = globalThis.localStorage;
        } else {
          this.memoryStorage = {};
          this.storage = memoryLocalStorageAdapter(this.memoryStorage);
        }
      }
      if (settings.userStorage) {
        this.userStorage = settings.userStorage;
      }
    } else {
      this.memoryStorage = {};
      this.storage = memoryLocalStorageAdapter(this.memoryStorage);
    }
    if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
      try {
        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);
      } catch (e) {
        console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", e);
      }
      (_b = this.broadcastChannel) === null || _b === void 0 ? void 0 : _b.addEventListener("message", (event) => __async(this, null, function* () {
        this._debug("received broadcast notification from other tab or client", event);
        yield this._notifyAllSubscribers(event.data.event, event.data.session, false);
      }));
    }
    this.initialize();
  }
  _debug(...args) {
    if (this.logDebugMessages) {
      this.logger(`GoTrueClient@${this.instanceID} (${version}) ${(/* @__PURE__ */ new Date()).toISOString()}`, ...args);
    }
    return this;
  }
  /**
   * Initializes the client session either from the url or from storage.
   * This method is automatically called when instantiating the client, but should also be called
   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).
   */
  initialize() {
    return __async(this, null, function* () {
      if (this.initializePromise) {
        return yield this.initializePromise;
      }
      this.initializePromise = (() => __async(this, null, function* () {
        return yield this._acquireLock(-1, () => __async(this, null, function* () {
          return yield this._initialize();
        }));
      }))();
      return yield this.initializePromise;
    });
  }
  /**
   * IMPORTANT:
   * 1. Never throw in this method, as it is called from the constructor
   * 2. Never return a session from this method as it would be cached over
   *    the whole lifetime of the client
   */
  _initialize() {
    return __async(this, null, function* () {
      var _a2;
      try {
        const params = parseParametersFromURL(window.location.href);
        let callbackUrlType = "none";
        if (this._isImplicitGrantCallback(params)) {
          callbackUrlType = "implicit";
        } else if (yield this._isPKCECallback(params)) {
          callbackUrlType = "pkce";
        }
        if (isBrowser() && this.detectSessionInUrl && callbackUrlType !== "none") {
          const { data, error: error2 } = yield this._getSessionFromURL(params, callbackUrlType);
          if (error2) {
            this._debug("#_initialize()", "error detecting session from URL", error2);
            if (isAuthImplicitGrantRedirectError(error2)) {
              const errorCode = (_a2 = error2.details) === null || _a2 === void 0 ? void 0 : _a2.code;
              if (errorCode === "identity_already_exists" || errorCode === "identity_not_found" || errorCode === "single_identity_not_deletable") {
                return { error: error2 };
              }
            }
            yield this._removeSession();
            return { error: error2 };
          }
          const { session, redirectType } = data;
          this._debug("#_initialize()", "detected session in URL", session, "redirect type", redirectType);
          yield this._saveSession(session);
          setTimeout(() => __async(this, null, function* () {
            if (redirectType === "recovery") {
              yield this._notifyAllSubscribers("PASSWORD_RECOVERY", session);
            } else {
              yield this._notifyAllSubscribers("SIGNED_IN", session);
            }
          }), 0);
          return { error: null };
        }
        yield this._recoverAndRefresh();
        return { error: null };
      } catch (error2) {
        if (isAuthError(error2)) {
          return { error: error2 };
        }
        return {
          error: new AuthUnknownError("Unexpected error during initialization", error2)
        };
      } finally {
        yield this._handleVisibilityChange();
        this._debug("#_initialize()", "end");
      }
    });
  }
  /**
   * Creates a new anonymous user.
   *
   * @returns A session where the is_anonymous claim in the access token JWT set to true
   */
  signInAnonymously(credentials) {
    return __async(this, null, function* () {
      var _a2, _b, _c;
      try {
        const res = yield _request(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          body: {
            data: (_b = (_a2 = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _a2 === void 0 ? void 0 : _a2.data) !== null && _b !== void 0 ? _b : {},
            gotrue_meta_security: { captcha_token: (_c = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _c === void 0 ? void 0 : _c.captchaToken }
          },
          xform: _sessionResponse
        });
        const { data, error: error2 } = res;
        if (error2 || !data) {
          return { data: { user: null, session: null }, error: error2 };
        }
        const session = data.session;
        const user = data.user;
        if (data.session) {
          yield this._saveSession(data.session);
          yield this._notifyAllSubscribers("SIGNED_IN", session);
        }
        return { data: { user, session }, error: null };
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: { user: null, session: null }, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Creates a new user.
   *
   * Be aware that if a user account exists in the system you may get back an
   * error message that attempts to hide this information from the user.
   * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.
   *
   * @returns A logged-in session if the server has "autoconfirm" ON
   * @returns A user if the server has "autoconfirm" OFF
   */
  signUp(credentials) {
    return __async(this, null, function* () {
      var _a2, _b, _c;
      try {
        let res;
        if ("email" in credentials) {
          const { email, password, options } = credentials;
          let codeChallenge = null;
          let codeChallengeMethod = null;
          if (this.flowType === "pkce") {
            ;
            [codeChallenge, codeChallengeMethod] = yield getCodeChallengeAndMethod(this.storage, this.storageKey);
          }
          res = yield _request(this.fetch, "POST", `${this.url}/signup`, {
            headers: this.headers,
            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
            body: {
              email,
              password,
              data: (_a2 = options === null || options === void 0 ? void 0 : options.data) !== null && _a2 !== void 0 ? _a2 : {},
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
              code_challenge: codeChallenge,
              code_challenge_method: codeChallengeMethod
            },
            xform: _sessionResponse
          });
        } else if ("phone" in credentials) {
          const { phone, password, options } = credentials;
          res = yield _request(this.fetch, "POST", `${this.url}/signup`, {
            headers: this.headers,
            body: {
              phone,
              password,
              data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},
              channel: (_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : "sms",
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
            },
            xform: _sessionResponse
          });
        } else {
          throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
        }
        const { data, error: error2 } = res;
        if (error2 || !data) {
          return { data: { user: null, session: null }, error: error2 };
        }
        const session = data.session;
        const user = data.user;
        if (data.session) {
          yield this._saveSession(data.session);
          yield this._notifyAllSubscribers("SIGNED_IN", session);
        }
        return { data: { user, session }, error: null };
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: { user: null, session: null }, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Log in an existing user with an email and password or phone and password.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or that the
   * email/phone and password combination is wrong or that the account can only
   * be accessed via social login.
   */
  signInWithPassword(credentials) {
    return __async(this, null, function* () {
      try {
        let res;
        if ("email" in credentials) {
          const { email, password, options } = credentials;
          res = yield _request(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
            headers: this.headers,
            body: {
              email,
              password,
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
            },
            xform: _sessionResponsePassword
          });
        } else if ("phone" in credentials) {
          const { phone, password, options } = credentials;
          res = yield _request(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
            headers: this.headers,
            body: {
              phone,
              password,
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
            },
            xform: _sessionResponsePassword
          });
        } else {
          throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
        }
        const { data, error: error2 } = res;
        if (error2) {
          return { data: { user: null, session: null }, error: error2 };
        } else if (!data || !data.session || !data.user) {
          return { data: { user: null, session: null }, error: new AuthInvalidTokenResponseError() };
        }
        if (data.session) {
          yield this._saveSession(data.session);
          yield this._notifyAllSubscribers("SIGNED_IN", data.session);
        }
        return {
          data: Object.assign({ user: data.user, session: data.session }, data.weak_password ? { weakPassword: data.weak_password } : null),
          error: error2
        };
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: { user: null, session: null }, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Log in an existing user via a third-party provider.
   * This method supports the PKCE flow.
   */
  signInWithOAuth(credentials) {
    return __async(this, null, function* () {
      var _a2, _b, _c, _d;
      return yield this._handleProviderSignIn(credentials.provider, {
        redirectTo: (_a2 = credentials.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo,
        scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
        queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
        skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect
      });
    });
  }
  /**
   * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.
   */
  exchangeCodeForSession(authCode) {
    return __async(this, null, function* () {
      yield this.initializePromise;
      return this._acquireLock(-1, () => __async(this, null, function* () {
        return this._exchangeCodeForSession(authCode);
      }));
    });
  }
  /**
   * Signs in a user by verifying a message signed by the user's private key.
   * Supports Ethereum (via Sign-In-With-Ethereum) & Solana (Sign-In-With-Solana) standards,
   * both of which derive from the EIP-4361 standard
   * With slight variation on Solana's side.
   * @reference https://eips.ethereum.org/EIPS/eip-4361
   */
  signInWithWeb3(credentials) {
    return __async(this, null, function* () {
      const { chain } = credentials;
      switch (chain) {
        case "ethereum":
          return yield this.signInWithEthereum(credentials);
        case "solana":
          return yield this.signInWithSolana(credentials);
        default:
          throw new Error(`@supabase/auth-js: Unsupported chain "${chain}"`);
      }
    });
  }
  signInWithEthereum(credentials) {
    return __async(this, null, function* () {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      let message;
      let signature;
      if ("message" in credentials) {
        message = credentials.message;
        signature = credentials.signature;
      } else {
        const { chain, wallet, statement, options } = credentials;
        let resolvedWallet;
        if (!isBrowser()) {
          if (typeof wallet !== "object" || !(options === null || options === void 0 ? void 0 : options.url)) {
            throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
          }
          resolvedWallet = wallet;
        } else if (typeof wallet === "object") {
          resolvedWallet = wallet;
        } else {
          const windowAny = window;
          if ("ethereum" in windowAny && typeof windowAny.ethereum === "object" && "request" in windowAny.ethereum && typeof windowAny.ethereum.request === "function") {
            resolvedWallet = windowAny.ethereum;
          } else {
            throw new Error(`@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.`);
          }
        }
        const url = new URL((_a2 = options === null || options === void 0 ? void 0 : options.url) !== null && _a2 !== void 0 ? _a2 : window.location.href);
        const accounts = yield resolvedWallet.request({
          method: "eth_requestAccounts"
        }).then((accs) => accs).catch(() => {
          throw new Error(`@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid`);
        });
        if (!accounts || accounts.length === 0) {
          throw new Error(`@supabase/auth-js: No accounts available. Please ensure the wallet is connected.`);
        }
        const address = getAddress(accounts[0]);
        let chainId = (_b = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _b === void 0 ? void 0 : _b.chainId;
        if (!chainId) {
          const chainIdHex = yield resolvedWallet.request({
            method: "eth_chainId"
          });
          chainId = fromHex(chainIdHex);
        }
        const siweMessage = {
          domain: url.host,
          address,
          statement,
          uri: url.href,
          version: "1",
          chainId,
          nonce: (_c = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _c === void 0 ? void 0 : _c.nonce,
          issuedAt: (_e = (_d = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _d === void 0 ? void 0 : _d.issuedAt) !== null && _e !== void 0 ? _e : /* @__PURE__ */ new Date(),
          expirationTime: (_f = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _f === void 0 ? void 0 : _f.expirationTime,
          notBefore: (_g = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _g === void 0 ? void 0 : _g.notBefore,
          requestId: (_h = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _h === void 0 ? void 0 : _h.requestId,
          resources: (_j = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _j === void 0 ? void 0 : _j.resources
        };
        message = createSiweMessage(siweMessage);
        signature = yield resolvedWallet.request({
          method: "personal_sign",
          params: [toHex(message), address]
        });
      }
      try {
        const { data, error: error2 } = yield _request(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
          headers: this.headers,
          body: Object.assign({
            chain: "ethereum",
            message,
            signature
          }, ((_k = credentials.options) === null || _k === void 0 ? void 0 : _k.captchaToken) ? { gotrue_meta_security: { captcha_token: (_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken } } : null),
          xform: _sessionResponse
        });
        if (error2) {
          throw error2;
        }
        if (!data || !data.session || !data.user) {
          return {
            data: { user: null, session: null },
            error: new AuthInvalidTokenResponseError()
          };
        }
        if (data.session) {
          yield this._saveSession(data.session);
          yield this._notifyAllSubscribers("SIGNED_IN", data.session);
        }
        return { data: Object.assign({}, data), error: error2 };
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: { user: null, session: null }, error: error2 };
        }
        throw error2;
      }
    });
  }
  signInWithSolana(credentials) {
    return __async(this, null, function* () {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      let message;
      let signature;
      if ("message" in credentials) {
        message = credentials.message;
        signature = credentials.signature;
      } else {
        const { chain, wallet, statement, options } = credentials;
        let resolvedWallet;
        if (!isBrowser()) {
          if (typeof wallet !== "object" || !(options === null || options === void 0 ? void 0 : options.url)) {
            throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
          }
          resolvedWallet = wallet;
        } else if (typeof wallet === "object") {
          resolvedWallet = wallet;
        } else {
          const windowAny = window;
          if ("solana" in windowAny && typeof windowAny.solana === "object" && ("signIn" in windowAny.solana && typeof windowAny.solana.signIn === "function" || "signMessage" in windowAny.solana && typeof windowAny.solana.signMessage === "function")) {
            resolvedWallet = windowAny.solana;
          } else {
            throw new Error(`@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.`);
          }
        }
        const url = new URL((_a2 = options === null || options === void 0 ? void 0 : options.url) !== null && _a2 !== void 0 ? _a2 : window.location.href);
        if ("signIn" in resolvedWallet && resolvedWallet.signIn) {
          const output = yield resolvedWallet.signIn(Object.assign(Object.assign(Object.assign({ issuedAt: (/* @__PURE__ */ new Date()).toISOString() }, options === null || options === void 0 ? void 0 : options.signInWithSolana), {
            // non-overridable properties
            version: "1",
            domain: url.host,
            uri: url.href
          }), statement ? { statement } : null));
          let outputToProcess;
          if (Array.isArray(output) && output[0] && typeof output[0] === "object") {
            outputToProcess = output[0];
          } else if (output && typeof output === "object" && "signedMessage" in output && "signature" in output) {
            outputToProcess = output;
          } else {
            throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");
          }
          if ("signedMessage" in outputToProcess && "signature" in outputToProcess && (typeof outputToProcess.signedMessage === "string" || outputToProcess.signedMessage instanceof Uint8Array) && outputToProcess.signature instanceof Uint8Array) {
            message = typeof outputToProcess.signedMessage === "string" ? outputToProcess.signedMessage : new TextDecoder().decode(outputToProcess.signedMessage);
            signature = outputToProcess.signature;
          } else {
            throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields");
          }
        } else {
          if (!("signMessage" in resolvedWallet) || typeof resolvedWallet.signMessage !== "function" || !("publicKey" in resolvedWallet) || typeof resolvedWallet !== "object" || !resolvedWallet.publicKey || !("toBase58" in resolvedWallet.publicKey) || typeof resolvedWallet.publicKey.toBase58 !== "function") {
            throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");
          }
          message = [
            `${url.host} wants you to sign in with your Solana account:`,
            resolvedWallet.publicKey.toBase58(),
            ...statement ? ["", statement, ""] : [""],
            "Version: 1",
            `URI: ${url.href}`,
            `Issued At: ${(_c = (_b = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _b === void 0 ? void 0 : _b.issuedAt) !== null && _c !== void 0 ? _c : (/* @__PURE__ */ new Date()).toISOString()}`,
            ...((_d = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _d === void 0 ? void 0 : _d.notBefore) ? [`Not Before: ${options.signInWithSolana.notBefore}`] : [],
            ...((_e = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _e === void 0 ? void 0 : _e.expirationTime) ? [`Expiration Time: ${options.signInWithSolana.expirationTime}`] : [],
            ...((_f = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _f === void 0 ? void 0 : _f.chainId) ? [`Chain ID: ${options.signInWithSolana.chainId}`] : [],
            ...((_g = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _g === void 0 ? void 0 : _g.nonce) ? [`Nonce: ${options.signInWithSolana.nonce}`] : [],
            ...((_h = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _h === void 0 ? void 0 : _h.requestId) ? [`Request ID: ${options.signInWithSolana.requestId}`] : [],
            ...((_k = (_j = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _j === void 0 ? void 0 : _j.resources) === null || _k === void 0 ? void 0 : _k.length) ? [
              "Resources",
              ...options.signInWithSolana.resources.map((resource) => `- ${resource}`)
            ] : []
          ].join("\n");
          const maybeSignature = yield resolvedWallet.signMessage(new TextEncoder().encode(message), "utf8");
          if (!maybeSignature || !(maybeSignature instanceof Uint8Array)) {
            throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");
          }
          signature = maybeSignature;
        }
      }
      try {
        const { data, error: error2 } = yield _request(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
          headers: this.headers,
          body: Object.assign({ chain: "solana", message, signature: bytesToBase64URL(signature) }, ((_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken) ? { gotrue_meta_security: { captcha_token: (_m = credentials.options) === null || _m === void 0 ? void 0 : _m.captchaToken } } : null),
          xform: _sessionResponse
        });
        if (error2) {
          throw error2;
        }
        if (!data || !data.session || !data.user) {
          return {
            data: { user: null, session: null },
            error: new AuthInvalidTokenResponseError()
          };
        }
        if (data.session) {
          yield this._saveSession(data.session);
          yield this._notifyAllSubscribers("SIGNED_IN", data.session);
        }
        return { data: Object.assign({}, data), error: error2 };
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: { user: null, session: null }, error: error2 };
        }
        throw error2;
      }
    });
  }
  _exchangeCodeForSession(authCode) {
    return __async(this, null, function* () {
      const storageItem = yield getItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      const [codeVerifier, redirectType] = (storageItem !== null && storageItem !== void 0 ? storageItem : "").split("/");
      try {
        const { data, error: error2 } = yield _request(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {
          headers: this.headers,
          body: {
            auth_code: authCode,
            code_verifier: codeVerifier
          },
          xform: _sessionResponse
        });
        yield removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
        if (error2) {
          throw error2;
        }
        if (!data || !data.session || !data.user) {
          return {
            data: { user: null, session: null, redirectType: null },
            error: new AuthInvalidTokenResponseError()
          };
        }
        if (data.session) {
          yield this._saveSession(data.session);
          yield this._notifyAllSubscribers("SIGNED_IN", data.session);
        }
        return { data: Object.assign(Object.assign({}, data), { redirectType: redirectType !== null && redirectType !== void 0 ? redirectType : null }), error: error2 };
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: { user: null, session: null, redirectType: null }, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Allows signing in with an OIDC ID token. The authentication provider used
   * should be enabled and configured.
   */
  signInWithIdToken(credentials) {
    return __async(this, null, function* () {
      try {
        const { options, provider, token: token2, access_token, nonce } = credentials;
        const res = yield _request(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
          headers: this.headers,
          body: {
            provider,
            id_token: token2,
            access_token,
            nonce,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponse
        });
        const { data, error: error2 } = res;
        if (error2) {
          return { data: { user: null, session: null }, error: error2 };
        } else if (!data || !data.session || !data.user) {
          return {
            data: { user: null, session: null },
            error: new AuthInvalidTokenResponseError()
          };
        }
        if (data.session) {
          yield this._saveSession(data.session);
          yield this._notifyAllSubscribers("SIGNED_IN", data.session);
        }
        return { data, error: error2 };
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: { user: null, session: null }, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Log in a user using magiclink or a one-time password (OTP).
   *
   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.
   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.
   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or, that the account
   * can only be accessed via social login.
   *
   * Do note that you will need to configure a Whatsapp sender on Twilio
   * if you are using phone sign in with the 'whatsapp' channel. The whatsapp
   * channel is not supported on other providers
   * at this time.
   * This method supports PKCE when an email is passed.
   */
  signInWithOtp(credentials) {
    return __async(this, null, function* () {
      var _a2, _b, _c, _d, _e;
      try {
        if ("email" in credentials) {
          const { email, options } = credentials;
          let codeChallenge = null;
          let codeChallengeMethod = null;
          if (this.flowType === "pkce") {
            ;
            [codeChallenge, codeChallengeMethod] = yield getCodeChallengeAndMethod(this.storage, this.storageKey);
          }
          const { error: error2 } = yield _request(this.fetch, "POST", `${this.url}/otp`, {
            headers: this.headers,
            body: {
              email,
              data: (_a2 = options === null || options === void 0 ? void 0 : options.data) !== null && _a2 !== void 0 ? _a2 : {},
              create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
              code_challenge: codeChallenge,
              code_challenge_method: codeChallengeMethod
            },
            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
          });
          return { data: { user: null, session: null }, error: error2 };
        }
        if ("phone" in credentials) {
          const { phone, options } = credentials;
          const { data, error: error2 } = yield _request(this.fetch, "POST", `${this.url}/otp`, {
            headers: this.headers,
            body: {
              phone,
              data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},
              create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
              channel: (_e = options === null || options === void 0 ? void 0 : options.channel) !== null && _e !== void 0 ? _e : "sms"
            }
          });
          return { data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id }, error: error2 };
        }
        throw new AuthInvalidCredentialsError("You must provide either an email or phone number.");
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: { user: null, session: null }, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Log in a user given a User supplied OTP or TokenHash received through mobile or email.
   */
  verifyOtp(params) {
    return __async(this, null, function* () {
      var _a2, _b;
      try {
        let redirectTo = void 0;
        let captchaToken = void 0;
        if ("options" in params) {
          redirectTo = (_a2 = params.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo;
          captchaToken = (_b = params.options) === null || _b === void 0 ? void 0 : _b.captchaToken;
        }
        const { data, error: error2 } = yield _request(this.fetch, "POST", `${this.url}/verify`, {
          headers: this.headers,
          body: Object.assign(Object.assign({}, params), { gotrue_meta_security: { captcha_token: captchaToken } }),
          redirectTo,
          xform: _sessionResponse
        });
        if (error2) {
          throw error2;
        }
        if (!data) {
          throw new Error("An error occurred on token verification.");
        }
        const session = data.session;
        const user = data.user;
        if (session === null || session === void 0 ? void 0 : session.access_token) {
          yield this._saveSession(session);
          yield this._notifyAllSubscribers(params.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", session);
        }
        return { data: { user, session }, error: null };
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: { user: null, session: null }, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Attempts a single-sign on using an enterprise Identity Provider. A
   * successful SSO attempt will redirect the current page to the identity
   * provider authorization page. The redirect URL is implementation and SSO
   * protocol specific.
   *
   * You can use it by providing a SSO domain. Typically you can extract this
   * domain by asking users for their email address. If this domain is
   * registered on the Auth instance the redirect will use that organization's
   * currently active SSO Identity Provider for the login.
   *
   * If you have built an organization-specific login page, you can use the
   * organization's SSO Identity Provider UUID directly instead.
   */
  signInWithSSO(params) {
    return __async(this, null, function* () {
      var _a2, _b, _c;
      try {
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce") {
          ;
          [codeChallenge, codeChallengeMethod] = yield getCodeChallengeAndMethod(this.storage, this.storageKey);
        }
        return yield _request(this.fetch, "POST", `${this.url}/sso`, {
          body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId" in params ? { provider_id: params.providerId } : null), "domain" in params ? { domain: params.domain } : null), { redirect_to: (_b = (_a2 = params.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo) !== null && _b !== void 0 ? _b : void 0 }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } } : null), { skip_http_redirect: true, code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),
          headers: this.headers,
          xform: _ssoResponse
        });
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Sends a reauthentication OTP to the user's email or phone number.
   * Requires the user to be signed-in.
   */
  reauthenticate() {
    return __async(this, null, function* () {
      yield this.initializePromise;
      return yield this._acquireLock(-1, () => __async(this, null, function* () {
        return yield this._reauthenticate();
      }));
    });
  }
  _reauthenticate() {
    return __async(this, null, function* () {
      try {
        return yield this._useSession((result) => __async(this, null, function* () {
          const { data: { session }, error: sessionError } = result;
          if (sessionError)
            throw sessionError;
          if (!session)
            throw new AuthSessionMissingError();
          const { error: error2 } = yield _request(this.fetch, "GET", `${this.url}/reauthenticate`, {
            headers: this.headers,
            jwt: session.access_token
          });
          return { data: { user: null, session: null }, error: error2 };
        }));
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: { user: null, session: null }, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.
   */
  resend(credentials) {
    return __async(this, null, function* () {
      try {
        const endpoint = `${this.url}/resend`;
        if ("email" in credentials) {
          const { email, type, options } = credentials;
          const { error: error2 } = yield _request(this.fetch, "POST", endpoint, {
            headers: this.headers,
            body: {
              email,
              type,
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
            },
            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
          });
          return { data: { user: null, session: null }, error: error2 };
        } else if ("phone" in credentials) {
          const { phone, type, options } = credentials;
          const { data, error: error2 } = yield _request(this.fetch, "POST", endpoint, {
            headers: this.headers,
            body: {
              phone,
              type,
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
            }
          });
          return { data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id }, error: error2 };
        }
        throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a type");
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: { user: null, session: null }, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Returns the session, refreshing it if necessary.
   *
   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.
   *
   * **IMPORTANT:** This method loads values directly from the storage attached
   * to the client. If that storage is based on request cookies for example,
   * the values in it may not be authentic and therefore it's strongly advised
   * against using this method and its results in such circumstances. A warning
   * will be emitted if this is detected. Use {@link #getUser()} instead.
   */
  getSession() {
    return __async(this, null, function* () {
      yield this.initializePromise;
      const result = yield this._acquireLock(-1, () => __async(this, null, function* () {
        return this._useSession((result2) => __async(this, null, function* () {
          return result2;
        }));
      }));
      return result;
    });
  }
  /**
   * Acquires a global lock based on the storage key.
   */
  _acquireLock(acquireTimeout, fn2) {
    return __async(this, null, function* () {
      this._debug("#_acquireLock", "begin", acquireTimeout);
      try {
        if (this.lockAcquired) {
          const last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve();
          const result = (() => __async(this, null, function* () {
            yield last;
            return yield fn2();
          }))();
          this.pendingInLock.push((() => __async(this, null, function* () {
            try {
              yield result;
            } catch (e) {
            }
          }))());
          return result;
        }
        return yield this.lock(`lock:${this.storageKey}`, acquireTimeout, () => __async(this, null, function* () {
          this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
          try {
            this.lockAcquired = true;
            const result = fn2();
            this.pendingInLock.push((() => __async(this, null, function* () {
              try {
                yield result;
              } catch (e) {
              }
            }))());
            yield result;
            while (this.pendingInLock.length) {
              const waitOn = [...this.pendingInLock];
              yield Promise.all(waitOn);
              this.pendingInLock.splice(0, waitOn.length);
            }
            return yield result;
          } finally {
            this._debug("#_acquireLock", "lock released for storage key", this.storageKey);
            this.lockAcquired = false;
          }
        }));
      } finally {
        this._debug("#_acquireLock", "end");
      }
    });
  }
  /**
   * Use instead of {@link #getSession} inside the library. It is
   * semantically usually what you want, as getting a session involves some
   * processing afterwards that requires only one client operating on the
   * session at once across multiple tabs or processes.
   */
  _useSession(fn2) {
    return __async(this, null, function* () {
      this._debug("#_useSession", "begin");
      try {
        const result = yield this.__loadSession();
        return yield fn2(result);
      } finally {
        this._debug("#_useSession", "end");
      }
    });
  }
  /**
   * NEVER USE DIRECTLY!
   *
   * Always use {@link #_useSession}.
   */
  __loadSession() {
    return __async(this, null, function* () {
      this._debug("#__loadSession()", "begin");
      if (!this.lockAcquired) {
        this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack);
      }
      try {
        let currentSession = null;
        const maybeSession = yield getItemAsync(this.storage, this.storageKey);
        this._debug("#getSession()", "session from storage", maybeSession);
        if (maybeSession !== null) {
          if (this._isValidSession(maybeSession)) {
            currentSession = maybeSession;
          } else {
            this._debug("#getSession()", "session from storage is not valid");
            yield this._removeSession();
          }
        }
        if (!currentSession) {
          return { data: { session: null }, error: null };
        }
        const hasExpired = currentSession.expires_at ? currentSession.expires_at * 1e3 - Date.now() < EXPIRY_MARGIN_MS : false;
        this._debug("#__loadSession()", `session has${hasExpired ? "" : " not"} expired`, "expires_at", currentSession.expires_at);
        if (!hasExpired) {
          if (this.userStorage) {
            const maybeUser = yield getItemAsync(this.userStorage, this.storageKey + "-user");
            if (maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) {
              currentSession.user = maybeUser.user;
            } else {
              currentSession.user = userNotAvailableProxy();
            }
          }
          if (this.storage.isServer && currentSession.user) {
            let suppressWarning = this.suppressGetSessionWarning;
            const proxySession = new Proxy(currentSession, {
              get: (target, prop, receiver) => {
                if (!suppressWarning && prop === "user") {
                  console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.");
                  suppressWarning = true;
                  this.suppressGetSessionWarning = true;
                }
                return Reflect.get(target, prop, receiver);
              }
            });
            currentSession = proxySession;
          }
          return { data: { session: currentSession }, error: null };
        }
        const { data: session, error: error2 } = yield this._callRefreshToken(currentSession.refresh_token);
        if (error2) {
          return { data: { session: null }, error: error2 };
        }
        return { data: { session }, error: null };
      } finally {
        this._debug("#__loadSession()", "end");
      }
    });
  }
  /**
   * Gets the current user details if there is an existing session. This method
   * performs a network request to the Supabase Auth server, so the returned
   * value is authentic and can be used to base authorization rules on.
   *
   * @param jwt Takes in an optional access token JWT. If no JWT is provided, the JWT from the current session is used.
   */
  getUser(jwt) {
    return __async(this, null, function* () {
      if (jwt) {
        return yield this._getUser(jwt);
      }
      yield this.initializePromise;
      const result = yield this._acquireLock(-1, () => __async(this, null, function* () {
        return yield this._getUser();
      }));
      return result;
    });
  }
  _getUser(jwt) {
    return __async(this, null, function* () {
      try {
        if (jwt) {
          return yield _request(this.fetch, "GET", `${this.url}/user`, {
            headers: this.headers,
            jwt,
            xform: _userResponse
          });
        }
        return yield this._useSession((result) => __async(this, null, function* () {
          var _a2, _b, _c;
          const { data, error: error2 } = result;
          if (error2) {
            throw error2;
          }
          if (!((_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) && !this.hasCustomAuthorizationHeader) {
            return { data: { user: null }, error: new AuthSessionMissingError() };
          }
          return yield _request(this.fetch, "GET", `${this.url}/user`, {
            headers: this.headers,
            jwt: (_c = (_b = data.session) === null || _b === void 0 ? void 0 : _b.access_token) !== null && _c !== void 0 ? _c : void 0,
            xform: _userResponse
          });
        }));
      } catch (error2) {
        if (isAuthError(error2)) {
          if (isAuthSessionMissingError(error2)) {
            yield this._removeSession();
            yield removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
          }
          return { data: { user: null }, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Updates user data for a logged in user.
   */
  updateUser(_0) {
    return __async(this, arguments, function* (attributes, options = {}) {
      yield this.initializePromise;
      return yield this._acquireLock(-1, () => __async(this, null, function* () {
        return yield this._updateUser(attributes, options);
      }));
    });
  }
  _updateUser(_0) {
    return __async(this, arguments, function* (attributes, options = {}) {
      try {
        return yield this._useSession((result) => __async(this, null, function* () {
          const { data: sessionData, error: sessionError } = result;
          if (sessionError) {
            throw sessionError;
          }
          if (!sessionData.session) {
            throw new AuthSessionMissingError();
          }
          const session = sessionData.session;
          let codeChallenge = null;
          let codeChallengeMethod = null;
          if (this.flowType === "pkce" && attributes.email != null) {
            ;
            [codeChallenge, codeChallengeMethod] = yield getCodeChallengeAndMethod(this.storage, this.storageKey);
          }
          const { data, error: userError } = yield _request(this.fetch, "PUT", `${this.url}/user`, {
            headers: this.headers,
            redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
            body: Object.assign(Object.assign({}, attributes), { code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),
            jwt: session.access_token,
            xform: _userResponse
          });
          if (userError)
            throw userError;
          session.user = data.user;
          yield this._saveSession(session);
          yield this._notifyAllSubscribers("USER_UPDATED", session);
          return { data: { user: session.user }, error: null };
        }));
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: { user: null }, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.
   * If the refresh token or access token in the current session is invalid, an error will be thrown.
   * @param currentSession The current session that minimally contains an access token and refresh token.
   */
  setSession(currentSession) {
    return __async(this, null, function* () {
      yield this.initializePromise;
      return yield this._acquireLock(-1, () => __async(this, null, function* () {
        return yield this._setSession(currentSession);
      }));
    });
  }
  _setSession(currentSession) {
    return __async(this, null, function* () {
      try {
        if (!currentSession.access_token || !currentSession.refresh_token) {
          throw new AuthSessionMissingError();
        }
        const timeNow = Date.now() / 1e3;
        let expiresAt2 = timeNow;
        let hasExpired = true;
        let session = null;
        const { payload } = decodeJWT(currentSession.access_token);
        if (payload.exp) {
          expiresAt2 = payload.exp;
          hasExpired = expiresAt2 <= timeNow;
        }
        if (hasExpired) {
          const { data: refreshedSession, error: error2 } = yield this._callRefreshToken(currentSession.refresh_token);
          if (error2) {
            return { data: { user: null, session: null }, error: error2 };
          }
          if (!refreshedSession) {
            return { data: { user: null, session: null }, error: null };
          }
          session = refreshedSession;
        } else {
          const { data, error: error2 } = yield this._getUser(currentSession.access_token);
          if (error2) {
            throw error2;
          }
          session = {
            access_token: currentSession.access_token,
            refresh_token: currentSession.refresh_token,
            user: data.user,
            token_type: "bearer",
            expires_in: expiresAt2 - timeNow,
            expires_at: expiresAt2
          };
          yield this._saveSession(session);
          yield this._notifyAllSubscribers("SIGNED_IN", session);
        }
        return { data: { user: session.user, session }, error: null };
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: { session: null, user: null }, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Returns a new session, regardless of expiry status.
   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().
   * If the current session's refresh token is invalid, an error will be thrown.
   * @param currentSession The current session. If passed in, it must contain a refresh token.
   */
  refreshSession(currentSession) {
    return __async(this, null, function* () {
      yield this.initializePromise;
      return yield this._acquireLock(-1, () => __async(this, null, function* () {
        return yield this._refreshSession(currentSession);
      }));
    });
  }
  _refreshSession(currentSession) {
    return __async(this, null, function* () {
      try {
        return yield this._useSession((result) => __async(this, null, function* () {
          var _a2;
          if (!currentSession) {
            const { data, error: error3 } = result;
            if (error3) {
              throw error3;
            }
            currentSession = (_a2 = data.session) !== null && _a2 !== void 0 ? _a2 : void 0;
          }
          if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {
            throw new AuthSessionMissingError();
          }
          const { data: session, error: error2 } = yield this._callRefreshToken(currentSession.refresh_token);
          if (error2) {
            return { data: { user: null, session: null }, error: error2 };
          }
          if (!session) {
            return { data: { user: null, session: null }, error: null };
          }
          return { data: { user: session.user, session }, error: null };
        }));
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: { user: null, session: null }, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Gets the session data from a URL string
   */
  _getSessionFromURL(params, callbackUrlType) {
    return __async(this, null, function* () {
      try {
        if (!isBrowser())
          throw new AuthImplicitGrantRedirectError("No browser detected.");
        if (params.error || params.error_description || params.error_code) {
          throw new AuthImplicitGrantRedirectError(params.error_description || "Error in URL with unspecified error_description", {
            error: params.error || "unspecified_error",
            code: params.error_code || "unspecified_code"
          });
        }
        switch (callbackUrlType) {
          case "implicit":
            if (this.flowType === "pkce") {
              throw new AuthPKCEGrantCodeExchangeError("Not a valid PKCE flow url.");
            }
            break;
          case "pkce":
            if (this.flowType === "implicit") {
              throw new AuthImplicitGrantRedirectError("Not a valid implicit grant flow url.");
            }
            break;
          default:
        }
        if (callbackUrlType === "pkce") {
          this._debug("#_initialize()", "begin", "is PKCE flow", true);
          if (!params.code)
            throw new AuthPKCEGrantCodeExchangeError("No code detected.");
          const { data: data2, error: error3 } = yield this._exchangeCodeForSession(params.code);
          if (error3)
            throw error3;
          const url = new URL(window.location.href);
          url.searchParams.delete("code");
          window.history.replaceState(window.history.state, "", url.toString());
          return { data: { session: data2.session, redirectType: null }, error: null };
        }
        const { provider_token, provider_refresh_token, access_token, refresh_token, expires_in, expires_at, token_type } = params;
        if (!access_token || !expires_in || !refresh_token || !token_type) {
          throw new AuthImplicitGrantRedirectError("No session defined in URL");
        }
        const timeNow = Math.round(Date.now() / 1e3);
        const expiresIn = parseInt(expires_in);
        let expiresAt2 = timeNow + expiresIn;
        if (expires_at) {
          expiresAt2 = parseInt(expires_at);
        }
        const actuallyExpiresIn = expiresAt2 - timeNow;
        if (actuallyExpiresIn * 1e3 <= AUTO_REFRESH_TICK_DURATION_MS) {
          console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${actuallyExpiresIn}s, should have been closer to ${expiresIn}s`);
        }
        const issuedAt = expiresAt2 - expiresIn;
        if (timeNow - issuedAt >= 120) {
          console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", issuedAt, expiresAt2, timeNow);
        } else if (timeNow - issuedAt < 0) {
          console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew", issuedAt, expiresAt2, timeNow);
        }
        const { data, error: error2 } = yield this._getUser(access_token);
        if (error2)
          throw error2;
        const session = {
          provider_token,
          provider_refresh_token,
          access_token,
          expires_in: expiresIn,
          expires_at: expiresAt2,
          refresh_token,
          token_type,
          user: data.user
        };
        window.location.hash = "";
        this._debug("#_getSessionFromURL()", "clearing window.location.hash");
        return { data: { session, redirectType: params.type }, error: null };
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: { session: null, redirectType: null }, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)
   */
  _isImplicitGrantCallback(params) {
    return Boolean(params.access_token || params.error_description);
  }
  /**
   * Checks if the current URL and backing storage contain parameters given by a PKCE flow
   */
  _isPKCECallback(params) {
    return __async(this, null, function* () {
      const currentStorageContent = yield getItemAsync(this.storage, `${this.storageKey}-code-verifier`);
      return !!(params.code && currentStorageContent);
    });
  }
  /**
   * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `"SIGNED_OUT"` event.
   *
   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.
   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.
   *
   * If using `others` scope, no `SIGNED_OUT` event is fired!
   */
  signOut() {
    return __async(this, arguments, function* (options = { scope: "global" }) {
      yield this.initializePromise;
      return yield this._acquireLock(-1, () => __async(this, null, function* () {
        return yield this._signOut(options);
      }));
    });
  }
  _signOut() {
    return __async(this, arguments, function* ({ scope } = { scope: "global" }) {
      return yield this._useSession((result) => __async(this, null, function* () {
        var _a2;
        const { data, error: sessionError } = result;
        if (sessionError) {
          return { error: sessionError };
        }
        const accessToken = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token;
        if (accessToken) {
          const { error: error2 } = yield this.admin.signOut(accessToken, scope);
          if (error2) {
            if (!(isAuthApiError(error2) && (error2.status === 404 || error2.status === 401 || error2.status === 403))) {
              return { error: error2 };
            }
          }
        }
        if (scope !== "others") {
          yield this._removeSession();
          yield removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
        }
        return { error: null };
      }));
    });
  }
  onAuthStateChange(callback) {
    const id = uuid();
    const subscription = {
      id,
      callback,
      unsubscribe: () => {
        this._debug("#unsubscribe()", "state change callback with id removed", id);
        this.stateChangeEmitters.delete(id);
      }
    };
    this._debug("#onAuthStateChange()", "registered callback with id", id);
    this.stateChangeEmitters.set(id, subscription);
    (() => __async(this, null, function* () {
      yield this.initializePromise;
      yield this._acquireLock(-1, () => __async(this, null, function* () {
        this._emitInitialSession(id);
      }));
    }))();
    return { data: { subscription } };
  }
  _emitInitialSession(id) {
    return __async(this, null, function* () {
      return yield this._useSession((result) => __async(this, null, function* () {
        var _a2, _b;
        try {
          const { data: { session }, error: error2 } = result;
          if (error2)
            throw error2;
          yield (_a2 = this.stateChangeEmitters.get(id)) === null || _a2 === void 0 ? void 0 : _a2.callback("INITIAL_SESSION", session);
          this._debug("INITIAL_SESSION", "callback id", id, "session", session);
        } catch (err) {
          yield (_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback("INITIAL_SESSION", null);
          this._debug("INITIAL_SESSION", "callback id", id, "error", err);
          console.error(err);
        }
      }));
    });
  }
  /**
   * Sends a password reset request to an email address. This method supports the PKCE flow.
   *
   * @param email The email address of the user.
   * @param options.redirectTo The URL to send the user to after they click the password reset link.
   * @param options.captchaToken Verification token received when the user completes the captcha on the site.
   */
  resetPasswordForEmail(_0) {
    return __async(this, arguments, function* (email, options = {}) {
      let codeChallenge = null;
      let codeChallengeMethod = null;
      if (this.flowType === "pkce") {
        [codeChallenge, codeChallengeMethod] = yield getCodeChallengeAndMethod(
          this.storage,
          this.storageKey,
          true
          // isPasswordRecovery
        );
      }
      try {
        return yield _request(this.fetch, "POST", `${this.url}/recover`, {
          body: {
            email,
            code_challenge: codeChallenge,
            code_challenge_method: codeChallengeMethod,
            gotrue_meta_security: { captcha_token: options.captchaToken }
          },
          headers: this.headers,
          redirectTo: options.redirectTo
        });
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Gets all the identities linked to a user.
   */
  getUserIdentities() {
    return __async(this, null, function* () {
      var _a2;
      try {
        const { data, error: error2 } = yield this.getUser();
        if (error2)
          throw error2;
        return { data: { identities: (_a2 = data.user.identities) !== null && _a2 !== void 0 ? _a2 : [] }, error: null };
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  linkIdentity(credentials) {
    return __async(this, null, function* () {
      if ("token" in credentials) {
        return this.linkIdentityIdToken(credentials);
      }
      return this.linkIdentityOAuth(credentials);
    });
  }
  linkIdentityOAuth(credentials) {
    return __async(this, null, function* () {
      var _a2;
      try {
        const { data, error: error2 } = yield this._useSession((result) => __async(this, null, function* () {
          var _a3, _b, _c, _d, _e;
          const { data: data2, error: error3 } = result;
          if (error3)
            throw error3;
          const url = yield this._getUrlForProvider(`${this.url}/user/identities/authorize`, credentials.provider, {
            redirectTo: (_a3 = credentials.options) === null || _a3 === void 0 ? void 0 : _a3.redirectTo,
            scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
            queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
            skipBrowserRedirect: true
          });
          return yield _request(this.fetch, "GET", url, {
            headers: this.headers,
            jwt: (_e = (_d = data2.session) === null || _d === void 0 ? void 0 : _d.access_token) !== null && _e !== void 0 ? _e : void 0
          });
        }));
        if (error2)
          throw error2;
        if (isBrowser() && !((_a2 = credentials.options) === null || _a2 === void 0 ? void 0 : _a2.skipBrowserRedirect)) {
          window.location.assign(data === null || data === void 0 ? void 0 : data.url);
        }
        return { data: { provider: credentials.provider, url: data === null || data === void 0 ? void 0 : data.url }, error: null };
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: { provider: credentials.provider, url: null }, error: error2 };
        }
        throw error2;
      }
    });
  }
  linkIdentityIdToken(credentials) {
    return __async(this, null, function* () {
      return yield this._useSession((result) => __async(this, null, function* () {
        var _a2;
        try {
          const { error: sessionError, data: { session } } = result;
          if (sessionError)
            throw sessionError;
          const { options, provider, token: token2, access_token, nonce } = credentials;
          const res = yield _request(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
            headers: this.headers,
            jwt: (_a2 = session === null || session === void 0 ? void 0 : session.access_token) !== null && _a2 !== void 0 ? _a2 : void 0,
            body: {
              provider,
              id_token: token2,
              access_token,
              nonce,
              link_identity: true,
              gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
            },
            xform: _sessionResponse
          });
          const { data, error: error2 } = res;
          if (error2) {
            return { data: { user: null, session: null }, error: error2 };
          } else if (!data || !data.session || !data.user) {
            return {
              data: { user: null, session: null },
              error: new AuthInvalidTokenResponseError()
            };
          }
          if (data.session) {
            yield this._saveSession(data.session);
            yield this._notifyAllSubscribers("USER_UPDATED", data.session);
          }
          return { data, error: error2 };
        } catch (error2) {
          if (isAuthError(error2)) {
            return { data: { user: null, session: null }, error: error2 };
          }
          throw error2;
        }
      }));
    });
  }
  /**
   * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.
   */
  unlinkIdentity(identity) {
    return __async(this, null, function* () {
      try {
        return yield this._useSession((result) => __async(this, null, function* () {
          var _a2, _b;
          const { data, error: error2 } = result;
          if (error2) {
            throw error2;
          }
          return yield _request(this.fetch, "DELETE", `${this.url}/user/identities/${identity.identity_id}`, {
            headers: this.headers,
            jwt: (_b = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) !== null && _b !== void 0 ? _b : void 0
          });
        }));
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  /**
   * Generates a new JWT.
   * @param refreshToken A valid refresh token that was returned on login.
   */
  _refreshAccessToken(refreshToken) {
    return __async(this, null, function* () {
      const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`;
      this._debug(debugName, "begin");
      try {
        const startedAt = Date.now();
        return yield retryable((attempt) => __async(this, null, function* () {
          if (attempt > 0) {
            yield sleep(200 * Math.pow(2, attempt - 1));
          }
          this._debug(debugName, "refreshing attempt", attempt);
          return yield _request(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {
            body: { refresh_token: refreshToken },
            headers: this.headers,
            xform: _sessionResponse
          });
        }), (attempt, error2) => {
          const nextBackOffInterval = 200 * Math.pow(2, attempt);
          return error2 && isAuthRetryableFetchError(error2) && // retryable only if the request can be sent before the backoff overflows the tick duration
          Date.now() + nextBackOffInterval - startedAt < AUTO_REFRESH_TICK_DURATION_MS;
        });
      } catch (error2) {
        this._debug(debugName, "error", error2);
        if (isAuthError(error2)) {
          return { data: { session: null, user: null }, error: error2 };
        }
        throw error2;
      } finally {
        this._debug(debugName, "end");
      }
    });
  }
  _isValidSession(maybeSession) {
    const isValidSession = typeof maybeSession === "object" && maybeSession !== null && "access_token" in maybeSession && "refresh_token" in maybeSession && "expires_at" in maybeSession;
    return isValidSession;
  }
  _handleProviderSignIn(provider, options) {
    return __async(this, null, function* () {
      const url = yield this._getUrlForProvider(`${this.url}/authorize`, provider, {
        redirectTo: options.redirectTo,
        scopes: options.scopes,
        queryParams: options.queryParams
      });
      this._debug("#_handleProviderSignIn()", "provider", provider, "options", options, "url", url);
      if (isBrowser() && !options.skipBrowserRedirect) {
        window.location.assign(url);
      }
      return { data: { provider, url }, error: null };
    });
  }
  /**
   * Recovers the session from LocalStorage and refreshes the token
   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.
   */
  _recoverAndRefresh() {
    return __async(this, null, function* () {
      var _a2, _b;
      const debugName = "#_recoverAndRefresh()";
      this._debug(debugName, "begin");
      try {
        const currentSession = yield getItemAsync(this.storage, this.storageKey);
        if (currentSession && this.userStorage) {
          let maybeUser = yield getItemAsync(this.userStorage, this.storageKey + "-user");
          if (!this.storage.isServer && Object.is(this.storage, this.userStorage) && !maybeUser) {
            maybeUser = { user: currentSession.user };
            yield setItemAsync(this.userStorage, this.storageKey + "-user", maybeUser);
          }
          currentSession.user = (_a2 = maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) !== null && _a2 !== void 0 ? _a2 : userNotAvailableProxy();
        } else if (currentSession && !currentSession.user) {
          if (!currentSession.user) {
            const separateUser = yield getItemAsync(this.storage, this.storageKey + "-user");
            if (separateUser && (separateUser === null || separateUser === void 0 ? void 0 : separateUser.user)) {
              currentSession.user = separateUser.user;
              yield removeItemAsync(this.storage, this.storageKey + "-user");
              yield setItemAsync(this.storage, this.storageKey, currentSession);
            } else {
              currentSession.user = userNotAvailableProxy();
            }
          }
        }
        this._debug(debugName, "session from storage", currentSession);
        if (!this._isValidSession(currentSession)) {
          this._debug(debugName, "session is not valid");
          if (currentSession !== null) {
            yield this._removeSession();
          }
          return;
        }
        const expiresWithMargin = ((_b = currentSession.expires_at) !== null && _b !== void 0 ? _b : Infinity) * 1e3 - Date.now() < EXPIRY_MARGIN_MS;
        this._debug(debugName, `session has${expiresWithMargin ? "" : " not"} expired with margin of ${EXPIRY_MARGIN_MS}s`);
        if (expiresWithMargin) {
          if (this.autoRefreshToken && currentSession.refresh_token) {
            const { error: error2 } = yield this._callRefreshToken(currentSession.refresh_token);
            if (error2) {
              console.error(error2);
              if (!isAuthRetryableFetchError(error2)) {
                this._debug(debugName, "refresh failed with a non-retryable error, removing the session", error2);
                yield this._removeSession();
              }
            }
          }
        } else if (currentSession.user && currentSession.user.__isUserNotAvailableProxy === true) {
          try {
            const { data, error: userError } = yield this._getUser(currentSession.access_token);
            if (!userError && (data === null || data === void 0 ? void 0 : data.user)) {
              currentSession.user = data.user;
              yield this._saveSession(currentSession);
              yield this._notifyAllSubscribers("SIGNED_IN", currentSession);
            } else {
              this._debug(debugName, "could not get user data, skipping SIGNED_IN notification");
            }
          } catch (getUserError) {
            console.error("Error getting user data:", getUserError);
            this._debug(debugName, "error getting user data, skipping SIGNED_IN notification", getUserError);
          }
        } else {
          yield this._notifyAllSubscribers("SIGNED_IN", currentSession);
        }
      } catch (err) {
        this._debug(debugName, "error", err);
        console.error(err);
        return;
      } finally {
        this._debug(debugName, "end");
      }
    });
  }
  _callRefreshToken(refreshToken) {
    return __async(this, null, function* () {
      var _a2, _b;
      if (!refreshToken) {
        throw new AuthSessionMissingError();
      }
      if (this.refreshingDeferred) {
        return this.refreshingDeferred.promise;
      }
      const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`;
      this._debug(debugName, "begin");
      try {
        this.refreshingDeferred = new Deferred();
        const { data, error: error2 } = yield this._refreshAccessToken(refreshToken);
        if (error2)
          throw error2;
        if (!data.session)
          throw new AuthSessionMissingError();
        yield this._saveSession(data.session);
        yield this._notifyAllSubscribers("TOKEN_REFRESHED", data.session);
        const result = { data: data.session, error: null };
        this.refreshingDeferred.resolve(result);
        return result;
      } catch (error2) {
        this._debug(debugName, "error", error2);
        if (isAuthError(error2)) {
          const result = { data: null, error: error2 };
          if (!isAuthRetryableFetchError(error2)) {
            yield this._removeSession();
          }
          (_a2 = this.refreshingDeferred) === null || _a2 === void 0 ? void 0 : _a2.resolve(result);
          return result;
        }
        (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error2);
        throw error2;
      } finally {
        this.refreshingDeferred = null;
        this._debug(debugName, "end");
      }
    });
  }
  _notifyAllSubscribers(event, session, broadcast = true) {
    return __async(this, null, function* () {
      const debugName = `#_notifyAllSubscribers(${event})`;
      this._debug(debugName, "begin", session, `broadcast = ${broadcast}`);
      try {
        if (this.broadcastChannel && broadcast) {
          this.broadcastChannel.postMessage({ event, session });
        }
        const errors = [];
        const promises = Array.from(this.stateChangeEmitters.values()).map((x) => __async(this, null, function* () {
          try {
            yield x.callback(event, session);
          } catch (e) {
            errors.push(e);
          }
        }));
        yield Promise.all(promises);
        if (errors.length > 0) {
          for (let i = 0; i < errors.length; i += 1) {
            console.error(errors[i]);
          }
          throw errors[0];
        }
      } finally {
        this._debug(debugName, "end");
      }
    });
  }
  /**
   * set currentSession and currentUser
   * process to _startAutoRefreshToken if possible
   */
  _saveSession(session) {
    return __async(this, null, function* () {
      this._debug("#_saveSession()", session);
      this.suppressGetSessionWarning = true;
      const sessionToProcess = Object.assign({}, session);
      const userIsProxy = sessionToProcess.user && sessionToProcess.user.__isUserNotAvailableProxy === true;
      if (this.userStorage) {
        if (!userIsProxy && sessionToProcess.user) {
          yield setItemAsync(this.userStorage, this.storageKey + "-user", {
            user: sessionToProcess.user
          });
        }
        const mainSessionData = Object.assign({}, sessionToProcess);
        delete mainSessionData.user;
        const clonedMainSessionData = deepClone(mainSessionData);
        yield setItemAsync(this.storage, this.storageKey, clonedMainSessionData);
      } else {
        const clonedSession = deepClone(sessionToProcess);
        yield setItemAsync(this.storage, this.storageKey, clonedSession);
      }
    });
  }
  _removeSession() {
    return __async(this, null, function* () {
      this._debug("#_removeSession()");
      yield removeItemAsync(this.storage, this.storageKey);
      yield removeItemAsync(this.storage, this.storageKey + "-code-verifier");
      yield removeItemAsync(this.storage, this.storageKey + "-user");
      if (this.userStorage) {
        yield removeItemAsync(this.userStorage, this.storageKey + "-user");
      }
      yield this._notifyAllSubscribers("SIGNED_OUT", null);
    });
  }
  /**
   * Removes any registered visibilitychange callback.
   *
   * {@see #startAutoRefresh}
   * {@see #stopAutoRefresh}
   */
  _removeVisibilityChangedCallback() {
    this._debug("#_removeVisibilityChangedCallback()");
    const callback = this.visibilityChangedCallback;
    this.visibilityChangedCallback = null;
    try {
      if (callback && isBrowser() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {
        window.removeEventListener("visibilitychange", callback);
      }
    } catch (e) {
      console.error("removing visibilitychange callback failed", e);
    }
  }
  /**
   * This is the private implementation of {@link #startAutoRefresh}. Use this
   * within the library.
   */
  _startAutoRefresh() {
    return __async(this, null, function* () {
      yield this._stopAutoRefresh();
      this._debug("#_startAutoRefresh()");
      const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION_MS);
      this.autoRefreshTicker = ticker;
      if (ticker && typeof ticker === "object" && typeof ticker.unref === "function") {
        ticker.unref();
      } else if (typeof Deno !== "undefined" && typeof Deno.unrefTimer === "function") {
        Deno.unrefTimer(ticker);
      }
      setTimeout(() => __async(this, null, function* () {
        yield this.initializePromise;
        yield this._autoRefreshTokenTick();
      }), 0);
    });
  }
  /**
   * This is the private implementation of {@link #stopAutoRefresh}. Use this
   * within the library.
   */
  _stopAutoRefresh() {
    return __async(this, null, function* () {
      this._debug("#_stopAutoRefresh()");
      const ticker = this.autoRefreshTicker;
      this.autoRefreshTicker = null;
      if (ticker) {
        clearInterval(ticker);
      }
    });
  }
  /**
   * Starts an auto-refresh process in the background. The session is checked
   * every few seconds. Close to the time of expiration a process is started to
   * refresh the session. If refreshing fails it will be retried for as long as
   * necessary.
   *
   * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need
   * to call this function, it will be called for you.
   *
   * On browsers the refresh process works only when the tab/window is in the
   * foreground to conserve resources as well as prevent race conditions and
   * flooding auth with requests. If you call this method any managed
   * visibility change callback will be removed and you must manage visibility
   * changes on your own.
   *
   * On non-browser platforms the refresh process works *continuously* in the
   * background, which may not be desirable. You should hook into your
   * platform's foreground indication mechanism and call these methods
   * appropriately to conserve resources.
   *
   * {@see #stopAutoRefresh}
   */
  startAutoRefresh() {
    return __async(this, null, function* () {
      this._removeVisibilityChangedCallback();
      yield this._startAutoRefresh();
    });
  }
  /**
   * Stops an active auto refresh process running in the background (if any).
   *
   * If you call this method any managed visibility change callback will be
   * removed and you must manage visibility changes on your own.
   *
   * See {@link #startAutoRefresh} for more details.
   */
  stopAutoRefresh() {
    return __async(this, null, function* () {
      this._removeVisibilityChangedCallback();
      yield this._stopAutoRefresh();
    });
  }
  /**
   * Runs the auto refresh token tick.
   */
  _autoRefreshTokenTick() {
    return __async(this, null, function* () {
      this._debug("#_autoRefreshTokenTick()", "begin");
      try {
        yield this._acquireLock(0, () => __async(this, null, function* () {
          try {
            const now = Date.now();
            try {
              return yield this._useSession((result) => __async(this, null, function* () {
                const { data: { session } } = result;
                if (!session || !session.refresh_token || !session.expires_at) {
                  this._debug("#_autoRefreshTokenTick()", "no session");
                  return;
                }
                const expiresInTicks = Math.floor((session.expires_at * 1e3 - now) / AUTO_REFRESH_TICK_DURATION_MS);
                this._debug("#_autoRefreshTokenTick()", `access token expires in ${expiresInTicks} ticks, a tick lasts ${AUTO_REFRESH_TICK_DURATION_MS}ms, refresh threshold is ${AUTO_REFRESH_TICK_THRESHOLD} ticks`);
                if (expiresInTicks <= AUTO_REFRESH_TICK_THRESHOLD) {
                  yield this._callRefreshToken(session.refresh_token);
                }
              }));
            } catch (e) {
              console.error("Auto refresh tick failed with error. This is likely a transient error.", e);
            }
          } finally {
            this._debug("#_autoRefreshTokenTick()", "end");
          }
        }));
      } catch (e) {
        if (e.isAcquireTimeout || e instanceof LockAcquireTimeoutError) {
          this._debug("auto refresh token tick lock not available");
        } else {
          throw e;
        }
      }
    });
  }
  /**
   * Registers callbacks on the browser / platform, which in-turn run
   * algorithms when the browser window/tab are in foreground. On non-browser
   * platforms it assumes always foreground.
   */
  _handleVisibilityChange() {
    return __async(this, null, function* () {
      this._debug("#_handleVisibilityChange()");
      if (!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {
        if (this.autoRefreshToken) {
          this.startAutoRefresh();
        }
        return false;
      }
      try {
        this.visibilityChangedCallback = () => __async(this, null, function* () {
          return yield this._onVisibilityChanged(false);
        });
        window === null || window === void 0 ? void 0 : window.addEventListener("visibilitychange", this.visibilityChangedCallback);
        yield this._onVisibilityChanged(true);
      } catch (error2) {
        console.error("_handleVisibilityChange", error2);
      }
    });
  }
  /**
   * Callback registered with `window.addEventListener('visibilitychange')`.
   */
  _onVisibilityChanged(calledFromInitialize) {
    return __async(this, null, function* () {
      const methodName = `#_onVisibilityChanged(${calledFromInitialize})`;
      this._debug(methodName, "visibilityState", document.visibilityState);
      if (document.visibilityState === "visible") {
        if (this.autoRefreshToken) {
          this._startAutoRefresh();
        }
        if (!calledFromInitialize) {
          yield this.initializePromise;
          yield this._acquireLock(-1, () => __async(this, null, function* () {
            if (document.visibilityState !== "visible") {
              this._debug(methodName, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");
              return;
            }
            yield this._recoverAndRefresh();
          }));
        }
      } else if (document.visibilityState === "hidden") {
        if (this.autoRefreshToken) {
          this._stopAutoRefresh();
        }
      }
    });
  }
  /**
   * Generates the relevant login URL for a third-party provider.
   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.
   * @param options.scopes A space-separated list of scopes granted to the OAuth application.
   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.
   */
  _getUrlForProvider(url, provider, options) {
    return __async(this, null, function* () {
      const urlParams = [`provider=${encodeURIComponent(provider)}`];
      if (options === null || options === void 0 ? void 0 : options.redirectTo) {
        urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);
      }
      if (options === null || options === void 0 ? void 0 : options.scopes) {
        urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);
      }
      if (this.flowType === "pkce") {
        const [codeChallenge, codeChallengeMethod] = yield getCodeChallengeAndMethod(this.storage, this.storageKey);
        const flowParams = new URLSearchParams({
          code_challenge: `${encodeURIComponent(codeChallenge)}`,
          code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`
        });
        urlParams.push(flowParams.toString());
      }
      if (options === null || options === void 0 ? void 0 : options.queryParams) {
        const query = new URLSearchParams(options.queryParams);
        urlParams.push(query.toString());
      }
      if (options === null || options === void 0 ? void 0 : options.skipBrowserRedirect) {
        urlParams.push(`skip_http_redirect=${options.skipBrowserRedirect}`);
      }
      return `${url}?${urlParams.join("&")}`;
    });
  }
  _unenroll(params) {
    return __async(this, null, function* () {
      try {
        return yield this._useSession((result) => __async(this, null, function* () {
          var _a2;
          const { data: sessionData, error: sessionError } = result;
          if (sessionError) {
            return { data: null, error: sessionError };
          }
          return yield _request(this.fetch, "DELETE", `${this.url}/factors/${params.factorId}`, {
            headers: this.headers,
            jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
          });
        }));
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  _enroll(params) {
    return __async(this, null, function* () {
      try {
        return yield this._useSession((result) => __async(this, null, function* () {
          var _a2, _b;
          const { data: sessionData, error: sessionError } = result;
          if (sessionError) {
            return { data: null, error: sessionError };
          }
          const body2 = Object.assign({ friendly_name: params.friendlyName, factor_type: params.factorType }, params.factorType === "phone" ? { phone: params.phone } : params.factorType === "totp" ? { issuer: params.issuer } : {});
          const { data, error: error2 } = yield _request(this.fetch, "POST", `${this.url}/factors`, {
            body: body2,
            headers: this.headers,
            jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
          });
          if (error2) {
            return { data: null, error: error2 };
          }
          if (params.factorType === "totp" && data.type === "totp" && ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code)) {
            data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;
          }
          return { data, error: null };
        }));
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
  _verify(params) {
    return __async(this, null, function* () {
      return this._acquireLock(-1, () => __async(this, null, function* () {
        try {
          return yield this._useSession((result) => __async(this, null, function* () {
            var _a2;
            const { data: sessionData, error: sessionError } = result;
            if (sessionError) {
              return { data: null, error: sessionError };
            }
            const body2 = Object.assign({ challenge_id: params.challengeId }, "webauthn" in params ? {
              webauthn: Object.assign(Object.assign({}, params.webauthn), { credential_response: params.webauthn.type === "create" ? serializeCredentialCreationResponse(params.webauthn.credential_response) : serializeCredentialRequestResponse(params.webauthn.credential_response) })
            } : { code: params.code });
            const { data, error: error2 } = yield _request(this.fetch, "POST", `${this.url}/factors/${params.factorId}/verify`, {
              body: body2,
              headers: this.headers,
              jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
            });
            if (error2) {
              return { data: null, error: error2 };
            }
            yield this._saveSession(Object.assign({ expires_at: Math.round(Date.now() / 1e3) + data.expires_in }, data));
            yield this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", data);
            return { data, error: error2 };
          }));
        } catch (error2) {
          if (isAuthError(error2)) {
            return { data: null, error: error2 };
          }
          throw error2;
        }
      }));
    });
  }
  _challenge(params) {
    return __async(this, null, function* () {
      return this._acquireLock(-1, () => __async(this, null, function* () {
        try {
          return yield this._useSession((result) => __async(this, null, function* () {
            var _a2;
            const { data: sessionData, error: sessionError } = result;
            if (sessionError) {
              return { data: null, error: sessionError };
            }
            const response = yield _request(this.fetch, "POST", `${this.url}/factors/${params.factorId}/challenge`, {
              body: params,
              headers: this.headers,
              jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
            });
            if (response.error) {
              return response;
            }
            const { data } = response;
            if (data.type !== "webauthn") {
              return { data, error: null };
            }
            switch (data.webauthn.type) {
              case "create":
                return {
                  data: Object.assign(Object.assign({}, data), { webauthn: Object.assign(Object.assign({}, data.webauthn), { credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), { publicKey: deserializeCredentialCreationOptions(data.webauthn.credential_options.publicKey) }) }) }),
                  error: null
                };
              case "request":
                return {
                  data: Object.assign(Object.assign({}, data), { webauthn: Object.assign(Object.assign({}, data.webauthn), { credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), { publicKey: deserializeCredentialRequestOptions(data.webauthn.credential_options.publicKey) }) }) }),
                  error: null
                };
            }
          }));
        } catch (error2) {
          if (isAuthError(error2)) {
            return { data: null, error: error2 };
          }
          throw error2;
        }
      }));
    });
  }
  /**
   * {@see GoTrueMFAApi#challengeAndVerify}
   */
  _challengeAndVerify(params) {
    return __async(this, null, function* () {
      const { data: challengeData, error: challengeError } = yield this._challenge({
        factorId: params.factorId
      });
      if (challengeError) {
        return { data: null, error: challengeError };
      }
      return yield this._verify({
        factorId: params.factorId,
        challengeId: challengeData.id,
        code: params.code
      });
    });
  }
  /**
   * {@see GoTrueMFAApi#listFactors}
   */
  _listFactors() {
    return __async(this, null, function* () {
      var _a2;
      const { data: { user }, error: userError } = yield this.getUser();
      if (userError) {
        return { data: null, error: userError };
      }
      const data = {
        all: [],
        phone: [],
        totp: [],
        webauthn: []
      };
      for (const factor of (_a2 = user === null || user === void 0 ? void 0 : user.factors) !== null && _a2 !== void 0 ? _a2 : []) {
        data.all.push(factor);
        if (factor.status === "verified") {
          data[factor.factor_type].push(factor);
        }
      }
      return {
        data,
        error: null
      };
    });
  }
  /**
   * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}
   */
  _getAuthenticatorAssuranceLevel() {
    return __async(this, null, function* () {
      return this._acquireLock(-1, () => __async(this, null, function* () {
        return yield this._useSession((result) => __async(this, null, function* () {
          var _a2, _b;
          const { data: { session }, error: sessionError } = result;
          if (sessionError) {
            return { data: null, error: sessionError };
          }
          if (!session) {
            return {
              data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },
              error: null
            };
          }
          const { payload } = decodeJWT(session.access_token);
          let currentLevel = null;
          if (payload.aal) {
            currentLevel = payload.aal;
          }
          let nextLevel = currentLevel;
          const verifiedFactors = (_b = (_a2 = session.user.factors) === null || _a2 === void 0 ? void 0 : _a2.filter((factor) => factor.status === "verified")) !== null && _b !== void 0 ? _b : [];
          if (verifiedFactors.length > 0) {
            nextLevel = "aal2";
          }
          const currentAuthenticationMethods = payload.amr || [];
          return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null };
        }));
      }));
    });
  }
  fetchJwk(_0) {
    return __async(this, arguments, function* (kid, jwks = { keys: [] }) {
      let jwk = jwks.keys.find((key) => key.kid === kid);
      if (jwk) {
        return jwk;
      }
      const now = Date.now();
      jwk = this.jwks.keys.find((key) => key.kid === kid);
      if (jwk && this.jwks_cached_at + JWKS_TTL > now) {
        return jwk;
      }
      const { data, error: error2 } = yield _request(this.fetch, "GET", `${this.url}/.well-known/jwks.json`, {
        headers: this.headers
      });
      if (error2) {
        throw error2;
      }
      if (!data.keys || data.keys.length === 0) {
        return null;
      }
      this.jwks = data;
      this.jwks_cached_at = now;
      jwk = data.keys.find((key) => key.kid === kid);
      if (!jwk) {
        return null;
      }
      return jwk;
    });
  }
  /**
   * Extracts the JWT claims present in the access token by first verifying the
   * JWT against the server's JSON Web Key Set endpoint
   * `/.well-known/jwks.json` which is often cached, resulting in significantly
   * faster responses. Prefer this method over {@link #getUser} which always
   * sends a request to the Auth server for each JWT.
   *
   * If the project is not using an asymmetric JWT signing key (like ECC or
   * RSA) it always sends a request to the Auth server (similar to {@link
   * #getUser}) to verify the JWT.
   *
   * @param jwt An optional specific JWT you wish to verify, not the one you
   *            can obtain from {@link #getSession}.
   * @param options Various additional options that allow you to customize the
   *                behavior of this method.
   */
  getClaims(_0) {
    return __async(this, arguments, function* (jwt, options = {}) {
      try {
        let token2 = jwt;
        if (!token2) {
          const { data, error: error2 } = yield this.getSession();
          if (error2 || !data.session) {
            return { data: null, error: error2 };
          }
          token2 = data.session.access_token;
        }
        const { header, payload, signature, raw: { header: rawHeader, payload: rawPayload } } = decodeJWT(token2);
        if (!(options === null || options === void 0 ? void 0 : options.allowExpired)) {
          validateExp(payload.exp);
        }
        const signingKey = !header.alg || header.alg.startsWith("HS") || !header.kid || !("crypto" in globalThis && "subtle" in globalThis.crypto) ? null : yield this.fetchJwk(header.kid, (options === null || options === void 0 ? void 0 : options.keys) ? { keys: options.keys } : options === null || options === void 0 ? void 0 : options.jwks);
        if (!signingKey) {
          const { error: error2 } = yield this.getUser(token2);
          if (error2) {
            throw error2;
          }
          return {
            data: {
              claims: payload,
              header,
              signature
            },
            error: null
          };
        }
        const algorithm = getAlgorithm(header.alg);
        const publicKey = yield crypto.subtle.importKey("jwk", signingKey, algorithm, true, [
          "verify"
        ]);
        const isValid = yield crypto.subtle.verify(algorithm, publicKey, signature, stringToUint8Array(`${rawHeader}.${rawPayload}`));
        if (!isValid) {
          throw new AuthInvalidJwtError("Invalid JWT signature");
        }
        return {
          data: {
            claims: payload,
            header,
            signature
          },
          error: null
        };
      } catch (error2) {
        if (isAuthError(error2)) {
          return { data: null, error: error2 };
        }
        throw error2;
      }
    });
  }
}
GoTrueClient.nextInstanceID = 0;
const AuthClient = GoTrueClient;
class SupabaseAuthClient extends AuthClient {
  constructor(options) {
    super(options);
  }
}
class SupabaseClient {
  /**
   * Create a new client for use in the browser.
   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.
   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.
   * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.
   * @param options.auth.autoRefreshToken Set to "true" if you want to automatically refresh the token before expiring.
   * @param options.auth.persistSession Set to "true" if you want to automatically save the user session into local storage.
   * @param options.auth.detectSessionInUrl Set to "true" if you want to automatically detects OAuth grants in the URL and signs in the user.
   * @param options.realtime Options passed along to realtime-js constructor.
   * @param options.storage Options passed along to the storage-js constructor.
   * @param options.global.fetch A custom fetch implementation.
   * @param options.global.headers Any additional headers to send with each network request.
   */
  constructor(supabaseUrl, supabaseKey, options) {
    var _a2, _b, _c;
    this.supabaseUrl = supabaseUrl;
    this.supabaseKey = supabaseKey;
    const baseUrl = validateSupabaseUrl(supabaseUrl);
    if (!supabaseKey)
      throw new Error("supabaseKey is required.");
    this.realtimeUrl = new URL("realtime/v1", baseUrl);
    this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace("http", "ws");
    this.authUrl = new URL("auth/v1", baseUrl);
    this.storageUrl = new URL("storage/v1", baseUrl);
    this.functionsUrl = new URL("functions/v1", baseUrl);
    const defaultStorageKey = `sb-${baseUrl.hostname.split(".")[0]}-auth-token`;
    const DEFAULTS = {
      db: DEFAULT_DB_OPTIONS,
      realtime: DEFAULT_REALTIME_OPTIONS,
      auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), { storageKey: defaultStorageKey }),
      global: DEFAULT_GLOBAL_OPTIONS
    };
    const settings = applySettingDefaults(options !== null && options !== void 0 ? options : {}, DEFAULTS);
    this.storageKey = (_a2 = settings.auth.storageKey) !== null && _a2 !== void 0 ? _a2 : "";
    this.headers = (_b = settings.global.headers) !== null && _b !== void 0 ? _b : {};
    if (!settings.accessToken) {
      this.auth = this._initSupabaseAuthClient((_c = settings.auth) !== null && _c !== void 0 ? _c : {}, this.headers, settings.global.fetch);
    } else {
      this.accessToken = settings.accessToken;
      this.auth = new Proxy({}, {
        get: (_, prop) => {
          throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);
        }
      });
    }
    this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);
    this.realtime = this._initRealtimeClient(Object.assign({ headers: this.headers, accessToken: this._getAccessToken.bind(this) }, settings.realtime));
    this.rest = new PostgrestClient(new URL("rest/v1", baseUrl).href, {
      headers: this.headers,
      schema: settings.db.schema,
      fetch: this.fetch
    });
    this.storage = new StorageClient(this.storageUrl.href, this.headers, this.fetch, options === null || options === void 0 ? void 0 : options.storage);
    if (!settings.accessToken) {
      this._listenForAuthEvents();
    }
  }
  /**
   * Supabase Functions allows you to deploy and invoke edge functions.
   */
  get functions() {
    return new FunctionsClient(this.functionsUrl.href, {
      headers: this.headers,
      customFetch: this.fetch
    });
  }
  /**
   * Perform a query on a table or a view.
   *
   * @param relation - The table or view name to query
   */
  from(relation) {
    return this.rest.from(relation);
  }
  // NOTE: signatures must be kept in sync with PostgrestClient.schema
  /**
   * Select a schema to query or perform an function (rpc) call.
   *
   * The schema needs to be on the list of exposed schemas inside Supabase.
   *
   * @param schema - The schema to query
   */
  schema(schema) {
    return this.rest.schema(schema);
  }
  // NOTE: signatures must be kept in sync with PostgrestClient.rpc
  /**
   * Perform a function call.
   *
   * @param fn - The function name to call
   * @param args - The arguments to pass to the function call
   * @param options - Named parameters
   * @param options.head - When set to `true`, `data` will not be returned.
   * Useful if you only need the count.
   * @param options.get - When set to `true`, the function will be called with
   * read-only access mode.
   * @param options.count - Count algorithm to use to count rows returned by the
   * function. Only applicable for [set-returning
   * functions](https://www.postgresql.org/docs/current/functions-srf.html).
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  rpc(fn2, args = {}, options = {
    head: false,
    get: false,
    count: void 0
  }) {
    return this.rest.rpc(fn2, args, options);
  }
  /**
   * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.
   *
   * @param {string} name - The name of the Realtime channel.
   * @param {Object} opts - The options to pass to the Realtime channel.
   *
   */
  channel(name2, opts = { config: {} }) {
    return this.realtime.channel(name2, opts);
  }
  /**
   * Returns all Realtime channels.
   */
  getChannels() {
    return this.realtime.getChannels();
  }
  /**
   * Unsubscribes and removes Realtime channel from Realtime client.
   *
   * @param {RealtimeChannel} channel - The name of the Realtime channel.
   *
   */
  removeChannel(channel) {
    return this.realtime.removeChannel(channel);
  }
  /**
   * Unsubscribes and removes all Realtime channels from Realtime client.
   */
  removeAllChannels() {
    return this.realtime.removeAllChannels();
  }
  _getAccessToken() {
    return __async(this, null, function* () {
      var _a2, _b;
      if (this.accessToken) {
        return yield this.accessToken();
      }
      const { data } = yield this.auth.getSession();
      return (_b = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) !== null && _b !== void 0 ? _b : this.supabaseKey;
    });
  }
  _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage, userStorage, storageKey, flowType, lock, debug }, headers, fetch2) {
    const authHeaders2 = {
      Authorization: `Bearer ${this.supabaseKey}`,
      apikey: `${this.supabaseKey}`
    };
    return new SupabaseAuthClient({
      url: this.authUrl.href,
      headers: Object.assign(Object.assign({}, authHeaders2), headers),
      storageKey,
      autoRefreshToken,
      persistSession,
      detectSessionInUrl,
      storage,
      userStorage,
      flowType,
      lock,
      debug,
      fetch: fetch2,
      // auth checks if there is a custom authorizaiton header using this flag
      // so it knows whether to return an error when getUser is called with no session
      hasCustomAuthorizationHeader: Object.keys(this.headers).some((key) => key.toLowerCase() === "authorization")
    });
  }
  _initRealtimeClient(options) {
    return new RealtimeClient(this.realtimeUrl.href, Object.assign(Object.assign({}, options), { params: Object.assign({ apikey: this.supabaseKey }, options === null || options === void 0 ? void 0 : options.params) }));
  }
  _listenForAuthEvents() {
    const data = this.auth.onAuthStateChange((event, session) => {
      this._handleTokenChanged(event, "CLIENT", session === null || session === void 0 ? void 0 : session.access_token);
    });
    return data;
  }
  _handleTokenChanged(event, source, token2) {
    if ((event === "TOKEN_REFRESHED" || event === "SIGNED_IN") && this.changedAccessToken !== token2) {
      this.changedAccessToken = token2;
      this.realtime.setAuth(token2);
    } else if (event === "SIGNED_OUT") {
      this.realtime.setAuth();
      if (source == "STORAGE")
        this.auth.signOut();
      this.changedAccessToken = void 0;
    }
  }
}
const createClient = (supabaseUrl, supabaseKey, options) => {
  return new SupabaseClient(supabaseUrl, supabaseKey, options);
};
function shouldShowDeprecationWarning() {
  if (typeof window !== "undefined") {
    return false;
  }
  if (typeof process === "undefined") {
    return false;
  }
  const processVersion = process["version"];
  if (processVersion === void 0 || processVersion === null) {
    return false;
  }
  const versionMatch = processVersion.match(/^v(\d+)\./);
  if (!versionMatch) {
    return false;
  }
  const majorVersion = parseInt(versionMatch[1], 10);
  return majorVersion <= 18;
}
if (shouldShowDeprecationWarning()) {
  console.warn(`  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217`);
}
const SUPABASE_URL = "https://rdqpxixsbqcsyfewcmbz.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJkcXB4aXhzYnFjc3lmZXdjbWJ6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAxMjI3NTMsImV4cCI6MjA3NTY5ODc1M30.rTbYZNKNv1szvzjA2D828OVt7qUZVSXgi4G_tUqm3mA";
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
    // Explicitly use localStorage for web to keep users signed in across reloads
    storage: typeof window !== "undefined" ? window.localStorage : void 0
  }
});
function isAuthConfigured() {
  return Boolean(SUPABASE_ANON_KEY);
}
const AuthContext = reactExports.createContext({
  user: null,
  session: null,
  loading: true,
  signOut: () => {
  }
});
const envCandidates = [
  "https://strainspotter.onrender.com",
  void 0,
  "https://strainspotter.onrender.com",
  void 0
].map((value) => typeof value === "string" ? value.trim() : "").filter(Boolean);
const fromEnv = envCandidates.length ? envCandidates[0] : "";
const isLocalhost = typeof window !== "undefined" && /localhost|127\.0\.0\.1/.test(window.location.host);
const isEnvLocal = fromEnv && /localhost|127\.0\.0\.1/.test(fromEnv);
const isCapacitor = typeof window !== "undefined" && window.location.protocol === "capacitor:";
const DEFAULT_REMOTE_API = "https://strainspotter.onrender.com";
const resolvedForLocal = isCapacitor ? !fromEnv || /localhost|127\.0\.0\.1/.test(fromEnv) ? DEFAULT_REMOTE_API : fromEnv : isLocalhost ? isEnvLocal ? fromEnv : "http://localhost:5181" : fromEnv || DEFAULT_REMOTE_API;
const API_BASE = resolvedForLocal.replace(/\/$/, "");
console.log("[Config] API_BASE:", API_BASE);
console.log("[Config] isCapacitor:", isCapacitor);
console.log("[Config] isLocalhost:", isLocalhost);
if (!isLocalhost && !isCapacitor && !fromEnv) {
  console.warn("[Config] VITE_API_BASE not set. Falling back to default remote API.");
}
const functionsFallback = `${API_BASE}/api`;
const FUNCTIONS_BASE = functionsFallback.replace(/\/$/, "");
const FOUNDER_EMAIL = "topher.cook7@gmail.com";
const FOUNDER_UNLIMITED_ENABLED = true;
function isFounderUser(user) {
  var _a2, _b;
  if (!user) return false;
  const email = (_b = (_a2 = user.email) == null ? void 0 : _a2.toLowerCase()) != null ? _b : "";
  if (email === "topher.cook7@gmail.com" || email === "strainspotter25@gmail.com") {
    return true;
  }
  const metadata = user.user_metadata || {};
  if (metadata.role === "founder" || metadata.isFounder === true) {
    return true;
  }
  return false;
}
function isFounderEmail(email) {
  if (!email || typeof email !== "string") return false;
  return email.toLowerCase().trim() === FOUNDER_EMAIL.toLowerCase();
}
function augmentSession(session) {
  var _a2;
  if (!((_a2 = session == null ? void 0 : session.user) == null ? void 0 : _a2.email)) return session;
  const email = session.user.email;
  if (isFounderEmail(email)) {
    return __spreadProps(__spreadValues({}, session), {
      user: __spreadProps(__spreadValues({}, session.user), {
        creditStatus: {
          unlimited: true,
          remainingScans: Number.POSITIVE_INFINITY,
          membershipTier: "founder_unlimited",
          isMember: true,
          canScan: true
        }
      })
    });
  }
  return session;
}
function AuthProvider({ children }) {
  var _a2;
  const [user, setUser] = reactExports.useState(null);
  const [session, setSession] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(true);
  const isFounder = isFounderUser(user || (session == null ? void 0 : session.user));
  const email = (((_a2 = session == null ? void 0 : session.user) == null ? void 0 : _a2.email) || (user == null ? void 0 : user.email) || "").toLowerCase().trim();
  reactExports.useEffect(() => {
    if (email) {
      console.log("[FounderDebug]", {
        email,
        FOUNDER_UNLIMITED_ENABLED,
        isFounder
      });
    }
  }, [email, isFounder]);
  reactExports.useEffect(() => {
    if (!supabase) {
      setLoading(false);
      return;
    }
    supabase.auth.getSession().then(({ data: { session: session2 } }) => {
      var _a3, _b;
      console.log("[AuthContext] Initial session:", ((_a3 = session2 == null ? void 0 : session2.user) == null ? void 0 : _a3.email) || "none");
      const augmentedSession = augmentSession(session2);
      setSession(augmentedSession);
      setUser((_b = augmentedSession == null ? void 0 : augmentedSession.user) != null ? _b : null);
      setLoading(false);
    });
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (event, session2) => __async(null, null, function* () {
        var _a3, _b, _c, _d, _e;
        console.log("[AuthContext] Auth state change:", event, ((_a3 = session2 == null ? void 0 : session2.user) == null ? void 0 : _a3.email) || "none");
        const augmentedSession = augmentSession(session2);
        setSession(augmentedSession);
        setUser((_b = augmentedSession == null ? void 0 : augmentedSession.user) != null ? _b : null);
        setLoading(false);
        if (((_c = session2 == null ? void 0 : session2.user) == null ? void 0 : _c.id) && (event === "SIGNED_IN" || event === "USER_UPDATED")) {
          try {
            yield fetch(`${API_BASE}/api/users/ensure`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                user_id: session2.user.id,
                email: session2.user.email,
                username: ((_d = session2.user.user_metadata) == null ? void 0 : _d.username) || ((_e = session2.user.email) == null ? void 0 : _e.split("@")[0]) || `user_${session2.user.id.substring(0, 8)}`
              })
            });
            console.log("[AuthContext] User record ensured for:", session2.user.email);
          } catch (err) {
            console.error("[AuthContext] Failed to ensure user record:", err);
          }
        }
      })
    );
    return () => subscription.unsubscribe();
  }, []);
  const signOut = () => __async(null, null, function* () {
    if (supabase) {
      yield supabase.auth.signOut();
      console.log("[AuthContext] User signed out");
    }
  });
  const value = {
    user,
    session,
    loading,
    signOut,
    // Founder flags  exposed for hooks to use
    isFounder: Boolean(isFounder),
    FOUNDER_UNLIMITED_ENABLED: Boolean(FOUNDER_UNLIMITED_ENABLED)
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AuthContext.Provider, { value, children });
}
function useAuth() {
  const context = reactExports.useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
}
const ProModeContext = reactExports.createContext(null);
function ProModeProvider({ children }) {
  const { user, session } = useAuth();
  const [proRole, setProRole] = reactExports.useState(null);
  const [proEnabled, setProEnabled] = reactExports.useState(false);
  const [proLoading, setProLoading] = reactExports.useState(false);
  const founderValue = reactExports.useMemo(() => {
    var _a2;
    (user == null ? void 0 : user.email) || ((_a2 = session == null ? void 0 : session.user) == null ? void 0 : _a2.email) || "";
    const isFounder = isFounderUser(user || (session == null ? void 0 : session.user));
    const envFlag = true;
    const founderUnlimitedEnabled = isFounder && envFlag;
    return { isFounder, founderUnlimitedEnabled };
  }, [user, session]);
  reactExports.useEffect(() => {
    try {
      const raw = localStorage.getItem("strainspotter_pro_mode");
      if (!raw) return;
      const parsed = JSON.parse(raw);
      if (parsed && (parsed.proRole === "dispensary" || parsed.proRole === "grower")) {
        setProRole(parsed.proRole);
        setProEnabled(!!parsed.proEnabled);
      }
    } catch (e) {
      console.warn("[ProMode] Failed to parse local storage", e);
    }
  }, []);
  function persist(next2) {
    try {
      localStorage.setItem("strainspotter_pro_mode", JSON.stringify(next2));
    } catch (e) {
      console.warn("[ProMode] Failed to persist", e);
    }
  }
  function activateProWithCode(code) {
    return __async(this, null, function* () {
      setProLoading(true);
      try {
        const res = yield fetch(`${API_BASE}/api/pro/validate-code`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ code })
        });
        if (!res.ok) {
          const text = yield res.text().catch(() => "");
          let errorMessage = "Invalid access code. Please check and try again.";
          try {
            const errorData = JSON.parse(text);
            if (errorData.error) {
              errorMessage = errorData.error;
            }
          } catch (e) {
          }
          throw new Error(errorMessage);
        }
        const data = yield res.json();
        if (!data.ok || !data.role) {
          throw new Error("Invalid response from server.");
        }
        setProRole(data.role);
        setProEnabled(true);
        persist({ proRole: data.role, proEnabled: true });
        return { ok: true, role: data.role };
      } catch (err) {
        console.error("[ProMode] activateProWithCode error", err);
        throw err;
      } finally {
        setProLoading(false);
      }
    });
  }
  function clearProMode() {
    setProRole(null);
    setProEnabled(false);
    persist({ proRole: null, proEnabled: false });
  }
  const value = {
    proRole,
    proEnabled,
    proLoading,
    activateProWithCode,
    clearProMode,
    // Founder flags
    isFounder: founderValue.isFounder,
    founderUnlimitedEnabled: founderValue.founderUnlimitedEnabled
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ProModeContext.Provider, { value, children });
}
function useProMode() {
  const ctx = reactExports.useContext(ProModeContext);
  if (!ctx) throw new Error("useProMode must be used within ProModeProvider");
  return ctx;
}
function MobileOnlyGuard({ children }) {
  const [isMobile, setIsMobile] = reactExports.useState(true);
  const [isProduction, setIsProduction] = reactExports.useState(false);
  const [isWeb, setIsWeb] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const isWebMode = typeof window !== "undefined" && window.location.protocol !== "capacitor:";
    setIsWeb(isWebMode);
    const isProd = true;
    setIsProduction(isProd);
    const checkDevice = () => {
      const userAgent = navigator.userAgent.toLowerCase();
      const isMobileDevice = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini|mobile|tablet/i.test(userAgent);
      const isSmallScreen = window.innerWidth <= 1024;
      setIsMobile(isMobileDevice || isSmallScreen);
    };
    checkDevice();
    window.addEventListener("resize", checkDevice);
    return () => window.removeEventListener("resize", checkDevice);
  }, []);
  if (isWeb) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
  }
  if (!isProduction) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
        position: "fixed",
        top: 0,
        left: 0,
        right: 0,
        bgcolor: "rgba(255, 152, 0, 0.9)",
        color: "#fff",
        py: 0.5,
        px: 2,
        zIndex: 9999,
        textAlign: "center",
        fontSize: "0.75rem",
        fontWeight: 600
      }, children: " DEV MODE - Desktop access enabled for development" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { pt: { xs: 0, sm: 4 } }, children })
    ] });
  }
  if (isProduction && !isMobile) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { maxWidth: "sm", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
      minHeight: "100vh",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center",
      textAlign: "center",
      px: 3,
      background: "linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%)"
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
      bgcolor: "rgba(124, 179, 66, 0.1)",
      border: "2px solid rgba(124, 179, 66, 0.3)",
      borderRadius: 4,
      p: 4,
      maxWidth: 400
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", sx: {
        color: "#9CCC65",
        fontWeight: 700,
        mb: 2,
        fontSize: { xs: "1.5rem", sm: "2rem" }
      }, children: " Mobile Only" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", sx: {
        color: "#fff",
        mb: 3,
        lineHeight: 1.6
      }, children: "StrainSpotter is designed exclusively for mobile devices and tablets." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: {
        color: "rgba(255, 255, 255, 0.7)",
        mb: 2
      }, children: "Please access this app from:" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
        bgcolor: "rgba(0, 0, 0, 0.3)",
        borderRadius: 2,
        p: 2,
        mb: 3
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#9CCC65", mb: 1 }, children: " iPhone or Android phone" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#9CCC65" }, children: " iPad or Android tablet" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: {
        color: "rgba(255, 255, 255, 0.5)",
        display: "block",
        mt: 2
      }, children: "Scan the QR code with your mobile device or visit this URL on your phone" })
    ] }) }) });
  }
  return children;
}
const AccessTimeIcon = createSvgIcon([/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2M12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8"
}, "0"), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
}, "1")]);
const ArrowBackIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20z"
}));
const ArrowBackIosNewIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M17.77 3.77 16 2 6 12l10 10 1.77-1.77L9.54 12z"
}));
const AttachFileIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M16.5 6v11.5c0 2.21-1.79 4-4 4s-4-1.79-4-4V5c0-1.38 1.12-2.5 2.5-2.5s2.5 1.12 2.5 2.5v10.5c0 .55-.45 1-1 1s-1-.45-1-1V6H10v9.5c0 1.38 1.12 2.5 2.5 2.5s2.5-1.12 2.5-2.5V5c0-2.21-1.79-4-4-4S7 2.79 7 5v12.5c0 3.04 2.46 5.5 5.5 5.5s5.5-2.46 5.5-5.5V6z"
}));
const AttachMoneyIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11.8 10.9c-2.27-.59-3-1.2-3-2.15 0-1.09 1.01-1.85 2.7-1.85 1.78 0 2.44.85 2.5 2.1h2.21c-.07-1.72-1.12-3.3-3.21-3.81V3h-3v2.16c-1.94.42-3.5 1.68-3.5 3.61 0 2.31 1.91 3.46 4.7 4.13 2.5.6 3 1.48 3 2.41 0 .69-.49 1.79-2.7 1.79-2.06 0-2.87-.92-2.98-2.1h-2.2c.12 2.19 1.76 3.42 3.68 3.83V21h3v-2.15c1.95-.37 3.5-1.5 3.5-3.55 0-2.84-2.43-3.81-4.7-4.4"
}));
const AutoAwesome = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "m19 9 1.25-2.75L23 5l-2.75-1.25L19 1l-1.25 2.75L15 5l2.75 1.25zm-7.5.5L9 4 6.5 9.5 1 12l5.5 2.5L9 20l2.5-5.5L17 12zM19 15l-1.25 2.75L15 19l2.75 1.25L19 23l1.25-2.75L23 19l-2.75-1.25z"
}));
const BarChartIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M4 9h4v11H4zm12 4h4v7h-4zm-6-9h4v16h-4z"
}));
const BoltIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11 21h-1l1-7H7.5c-.58 0-.57-.32-.38-.66s.05-.08.07-.12C8.48 10.94 10.42 7.54 13 3h1l-1 7h3.5c.49 0 .56.33.47.51l-.07.15C12.96 17.55 11 21 11 21"
}));
const BugReport = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20 8h-2.81c-.45-.78-1.07-1.45-1.82-1.96L17 4.41 15.59 3l-2.17 2.17C12.96 5.06 12.49 5 12 5s-.96.06-1.41.17L8.41 3 7 4.41l1.62 1.63C7.88 6.55 7.26 7.22 6.81 8H4v2h2.09c-.05.33-.09.66-.09 1v1H4v2h2v1c0 .34.04.67.09 1H4v2h2.81c1.04 1.79 2.97 3 5.19 3s4.15-1.21 5.19-3H20v-2h-2.09c.05-.33.09-.66.09-1v-1h2v-2h-2v-1c0-.34-.04-.67-.09-1H20zm-6 8h-4v-2h4zm0-4h-4v-2h4z"
}));
const CameraAltIcon = createSvgIcon([/* @__PURE__ */ jsxRuntimeExports.jsx("circle", {
  cx: "12",
  cy: "12",
  r: "3.2"
}, "0"), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M9 2 7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2h-3.17L15 2zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5"
}, "1")]);
const ChatIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2M6 9h12v2H6zm8 5H6v-2h8zm4-6H6V6h12z"
}));
const CheckCircleIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m-2 15-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8z"
}));
const Checklist = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M22 7h-9v2h9zm0 8h-9v2h9zM5.54 11 2 7.46l1.41-1.41 2.12 2.12 4.24-4.24 1.41 1.41zm0 8L2 15.46l1.41-1.41 2.12 2.12 4.24-4.24 1.41 1.41z"
}));
const CloseIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}));
const CloudUploadIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96M14 13v4h-4v-4H7l5-5 5 5z"
}));
const ContentCopy = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"
}));
const DeleteIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6zM19 4h-3.5l-1-1h-5l-1 1H5v2h14z"
}));
const DirectionsIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "m21.41 10.59-7.99-8c-.78-.78-2.05-.78-2.83 0l-8.01 8c-.78.78-.78 2.05 0 2.83l8.01 8c.78.78 2.05.78 2.83 0l7.99-8c.79-.79.79-2.05 0-2.83M13.5 14.5V12H10v3H8v-4c0-.55.45-1 1-1h4.5V7.5L17 11z"
}));
const EditIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.996.996 0 0 0-1.41 0l-1.83 1.83 3.75 3.75z"
}));
const EmojiEvents = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 5h-2V3H7v2H5c-1.1 0-2 .9-2 2v1c0 2.55 1.92 4.63 4.39 4.94.63 1.5 1.98 2.63 3.61 2.96V19H7v2h10v-2h-4v-3.1c1.63-.33 2.98-1.46 3.61-2.96C19.08 12.63 21 10.55 21 8V7c0-1.1-.9-2-2-2M5 8V7h2v3.82C5.84 10.4 5 9.3 5 8m14 0c0 1.3-.84 2.4-2 2.82V7h2z"
}));
const Engineering = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M9 15c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4m13.1-8.16c.01-.11.02-.22.02-.34s-.01-.23-.03-.34l.74-.58c.07-.05.08-.15.04-.22l-.7-1.21c-.04-.08-.14-.1-.21-.08l-.86.35c-.18-.14-.38-.25-.59-.34l-.13-.93c-.02-.09-.09-.15-.18-.15h-1.4c-.09 0-.16.06-.17.15l-.13.93c-.21.09-.41.21-.59.34l-.87-.35c-.08-.03-.17 0-.21.08l-.7 1.21c-.04.08-.03.17.04.22l.74.58c-.02.11-.03.23-.03.34s.01.23.03.34l-.74.58c-.07.05-.08.15-.04.22l.7 1.21c.04.08.14.1.21.08l.87-.35c.18.14.38.25.59.34l.13.93c.01.09.08.15.17.15h1.4c.09 0 .16-.06.17-.15l.13-.93c.21-.09.41-.21.59-.34l.87.35c.08.03.17 0 .21-.08l.7-1.21c.04-.08.03-.17-.04-.22zm-2.6.91c-.69 0-1.25-.56-1.25-1.25s.56-1.25 1.25-1.25 1.25.56 1.25 1.25-.56 1.25-1.25 1.25m.42 3.93-.5-.87c-.03-.06-.1-.08-.15-.06l-.62.25q-.195-.15-.42-.24l-.09-.66c-.02-.06-.08-.1-.14-.1h-1c-.06 0-.11.04-.12.11l-.09.66c-.15.06-.29.15-.42.24l-.62-.25c-.06-.02-.12 0-.15.06l-.5.87c-.03.06-.02.12.03.16l.53.41c-.01.08-.02.16-.02.24s.01.17.02.24l-.53.41c-.05.04-.06.11-.03.16l.5.87c.03.06.1.08.15.06l.62-.25q.195.15.42.24l.09.66c.01.07.06.11.12.11h1c.06 0 .12-.04.12-.11l.09-.66c.15-.06.29-.15.42-.24l.62.25c.06.02.12 0 .15-.06l.5-.87c.03-.06.02-.12-.03-.16l-.52-.41c.01-.08.02-.16.02-.24s-.01-.17-.02-.24l.53-.41c.05-.04.06-.11.04-.17m-2.42 1.65c-.46 0-.83-.38-.83-.83 0-.46.38-.83.83-.83s.83.38.83.83c0 .46-.37.83-.83.83M4.74 9h8.53c.27 0 .49-.22.49-.49v-.02c0-.27-.22-.49-.49-.49H13c0-1.48-.81-2.75-2-3.45v.95c0 .28-.22.5-.5.5s-.5-.22-.5-.5V4.14C9.68 4.06 9.35 4 9 4s-.68.06-1 .14V5.5c0 .28-.22.5-.5.5S7 5.78 7 5.5v-.95C5.81 5.25 5 6.52 5 8h-.26c-.27 0-.49.22-.49.49v.03c0 .26.22.48.49.48M9 13c1.86 0 3.41-1.28 3.86-3H5.14c.45 1.72 2 3 3.86 3"
}));
const FavoriteIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "m12 21.35-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54z"
}));
const FavoriteBorderIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M16.5 3c-1.74 0-3.41.81-4.5 2.09C10.91 3.81 9.24 3 7.5 3 4.42 3 2 5.42 2 8.5c0 3.78 3.4 6.86 8.55 11.54L12 21.35l1.45-1.32C18.6 15.36 22 12.28 22 8.5 22 5.42 19.58 3 16.5 3m-4.4 15.55-.1.1-.1-.1C7.14 14.24 4 11.39 4 8.5 4 6.5 5.5 5 7.5 5c1.54 0 3.04.99 3.57 2.36h1.87C13.46 5.99 14.96 5 16.5 5c2 0 3.5 1.5 3.5 3.5 0 2.89-3.14 5.74-7.9 10.05"
}));
const FeedbackIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2m-7 12h-2v-2h2zm0-4h-2V6h2z"
}));
const FilterListIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M10 18h4v-2h-4zM3 6v2h18V6zm3 7h12v-2H6z"
}));
const Grain = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M10 12c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2M6 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m0 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m12-8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2m-4 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m4-4c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m-4-4c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m-4-4c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2"
}));
const GrassIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 20H2v-2h5.75c-.73-2.81-2.94-5.01-5.75-5.74.64-.16 1.31-.26 2-.26 4.42 0 8 3.58 8 8m10-7.74c-.64-.16-1.31-.26-2-.26-2.93 0-5.48 1.58-6.88 3.93.29.66.53 1.35.67 2.07.13.65.2 1.32.2 2h8v-2h-5.75c.74-2.81 2.95-5.01 5.76-5.74m-6.36-1.24c.78-2.09 2.23-3.84 4.09-5C15.44 6.16 12 9.67 12 14v.02c.95-1.27 2.2-2.3 3.64-3m-4.22-2.17C10.58 6.66 8.88 4.89 6.7 4 8.14 5.86 9 8.18 9 10.71c0 .21-.03.41-.04.61.43.24.83.52 1.22.82.21-1.18.65-2.29 1.24-3.29"
}));
const GroupsIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 12.75c1.63 0 3.07.39 4.24.9 1.08.48 1.76 1.56 1.76 2.73V18H6v-1.61c0-1.18.68-2.26 1.76-2.73 1.17-.52 2.61-.91 4.24-.91M4 13c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2m1.13 1.1c-.37-.06-.74-.1-1.13-.1-.99 0-1.93.21-2.78.58C.48 14.9 0 15.62 0 16.43V18h4.5v-1.61c0-.83.23-1.61.63-2.29M20 13c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2m4 3.43c0-.81-.48-1.53-1.22-1.85-.85-.37-1.79-.58-2.78-.58-.39 0-.76.04-1.13.1.4.68.63 1.46.63 2.29V18H24zM12 6c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3"
}));
const HealthAndSafetyIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M10.5 13H8v-3h2.5V7.5h3V10H16v3h-2.5v2.5h-3zM12 2 4 5v6.09c0 5.05 3.41 9.76 8 10.91 4.59-1.15 8-5.86 8-10.91V5z"
}));
const ImageIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2M8.5 13.5l2.5 3.01L14.5 12l4.5 6H5z"
}));
const LanguageIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2m6.93 6h-2.95c-.32-1.25-.78-2.45-1.38-3.56 1.84.63 3.37 1.91 4.33 3.56M12 4.04c.83 1.2 1.48 2.53 1.91 3.96h-3.82c.43-1.43 1.08-2.76 1.91-3.96M4.26 14C4.1 13.36 4 12.69 4 12s.1-1.36.26-2h3.38c-.08.66-.14 1.32-.14 2s.06 1.34.14 2zm.82 2h2.95c.32 1.25.78 2.45 1.38 3.56-1.84-.63-3.37-1.9-4.33-3.56m2.95-8H5.08c.96-1.66 2.49-2.93 4.33-3.56C8.81 5.55 8.35 6.75 8.03 8M12 19.96c-.83-1.2-1.48-2.53-1.91-3.96h3.82c-.43 1.43-1.08 2.76-1.91 3.96M14.34 14H9.66c-.09-.66-.16-1.32-.16-2s.07-1.35.16-2h4.68c.09.65.16 1.32.16 2s-.07 1.34-.16 2m.25 5.56c.6-1.11 1.06-2.31 1.38-3.56h2.95c-.96 1.65-2.49 2.93-4.33 3.56M16.36 14c.08-.66.14-1.32.14-2s-.06-1.34-.14-2h3.38c.16.64.26 1.31.26 2s-.1 1.36-.26 2z"
}));
const LibraryBooksIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M4 6H2v14c0 1.1.9 2 2 2h14v-2H4zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2m-1 9H9V9h10zm-4 4H9v-2h6zm4-8H9V5h10z"
}));
const LinkIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1M8 13h8v-2H8zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5"
}));
const LocalFloristIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 22c4.97 0 9-4.03 9-9-4.97 0-9 4.03-9 9M5.6 10.25c0 1.38 1.12 2.5 2.5 2.5.53 0 1.01-.16 1.42-.44l-.02.19c0 1.38 1.12 2.5 2.5 2.5s2.5-1.12 2.5-2.5l-.02-.19c.4.28.89.44 1.42.44 1.38 0 2.5-1.12 2.5-2.5 0-1-.59-1.85-1.43-2.25.84-.4 1.43-1.25 1.43-2.25 0-1.38-1.12-2.5-2.5-2.5-.53 0-1.01.16-1.42.44l.02-.19C14.5 2.12 13.38 1 12 1S9.5 2.12 9.5 3.5l.02.19c-.4-.28-.89-.44-1.42-.44-1.38 0-2.5 1.12-2.5 2.5 0 1 .59 1.85 1.43 2.25-.84.4-1.43 1.25-1.43 2.25M12 5.5c1.38 0 2.5 1.12 2.5 2.5s-1.12 2.5-2.5 2.5S9.5 9.38 9.5 8s1.12-2.5 2.5-2.5M3 13c0 4.97 4.03 9 9 9 0-4.97-4.03-9-9-9"
}));
const OfferIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "m21.41 11.58-9-9C12.05 2.22 11.55 2 11 2H4c-1.1 0-2 .9-2 2v7c0 .55.22 1.05.59 1.42l9 9c.36.36.86.58 1.41.58s1.05-.22 1.41-.59l7-7c.37-.36.59-.86.59-1.41s-.23-1.06-.59-1.42M5.5 7C4.67 7 4 6.33 4 5.5S4.67 4 5.5 4 7 4.67 7 5.5 6.33 7 5.5 7"
}));
const LocalShippingIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20 8h-3V4H3c-1.1 0-2 .9-2 2v11h2c0 1.66 1.34 3 3 3s3-1.34 3-3h6c0 1.66 1.34 3 3 3s3-1.34 3-3h2v-5zM6 18.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5m13.5-9 1.96 2.5H17V9.5zm-1.5 9c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5"
}));
const LocationOnIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7m0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5"
}));
const LogoutIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "m17 7-1.41 1.41L18.17 11H8v2h10.17l-2.58 2.58L17 17l5-5zM4 5h8V3H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h8v-2H4z"
}));
const MenuBookIcon = createSvgIcon([/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M21 5c-1.11-.35-2.33-.5-3.5-.5-1.95 0-4.05.4-5.5 1.5-1.45-1.1-3.55-1.5-5.5-1.5S2.45 4.9 1 6v14.65c0 .25.25.5.5.5.1 0 .15-.05.25-.05C3.1 20.45 5.05 20 6.5 20c1.95 0 4.05.4 5.5 1.5 1.35-.85 3.8-1.5 5.5-1.5 1.65 0 3.35.3 4.75 1.05.1.05.15.05.25.05.25 0 .5-.25.5-.5V6c-.6-.45-1.25-.75-2-1m0 13.5c-1.1-.35-2.3-.5-3.5-.5-1.7 0-4.15.65-5.5 1.5V8c1.35-.85 3.8-1.5 5.5-1.5 1.2 0 2.4.15 3.5.5z"
}, "0"), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M17.5 10.5c.88 0 1.73.09 2.5.26V9.24c-.79-.15-1.64-.24-2.5-.24-1.7 0-3.24.29-4.5.83v1.66c1.13-.64 2.7-.99 4.5-.99M13 12.49v1.66c1.13-.64 2.7-.99 4.5-.99.88 0 1.73.09 2.5.26V11.9c-.79-.15-1.64-.24-2.5-.24-1.7 0-3.24.3-4.5.83m4.5 1.84c-1.7 0-3.24.29-4.5.83v1.66c1.13-.64 2.7-.99 4.5-.99.88 0 1.73.09 2.5.26v-1.52c-.79-.16-1.64-.24-2.5-.24"
}, "1")]);
const MonitorHeart = createSvgIcon([/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M15.11 12.45 14 10.24l-3.11 6.21c-.16.34-.51.55-.89.55s-.73-.21-.89-.55L7.38 13H2v5c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-5h-6c-.38 0-.73-.21-.89-.55"
}, "0"), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20 4H4c-1.1 0-2 .9-2 2v5h6c.38 0 .73.21.89.55L10 13.76l3.11-6.21c.34-.68 1.45-.68 1.79 0L16.62 11H22V6c0-1.1-.9-2-2-2"
}, "1")]);
const MoreVertIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2m0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2"
}));
const MyLocationIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4m8.94 3c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7"
}));
const NoteAdd = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8zm2 14h-3v3h-2v-3H8v-2h3v-3h2v3h3zm-3-7V3.5L18.5 9z"
}));
const NoteAltIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 3h-4.18C14.4 1.84 13.3 1 12 1s-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m-7-.25c.41 0 .75.34.75.75s-.34.75-.75.75-.75-.34-.75-.75.34-.75.75-.75M9.1 17H7v-2.14l5.96-5.96 2.12 2.12zm7.75-7.73-1.06 1.06-2.12-2.12 1.06-1.06c.2-.2.51-.2.71 0l1.41 1.41c.2.2.2.51 0 .71"
}));
const Opacity = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M17.66 8 12 2.35 6.34 8C4.78 9.56 4 11.64 4 13.64s.78 4.11 2.34 5.67 3.61 2.35 5.66 2.35 4.1-.79 5.66-2.35S20 15.64 20 13.64 19.22 9.56 17.66 8M6 14c.01-2 .62-3.27 1.76-4.4L12 5.27l4.24 4.38C17.38 10.77 17.99 12 18 14z"
}));
const OpenInNewIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3z"
}));
const PaymentIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2m0 14H4v-6h16zm0-10H4V6h16z"
}));
const PeopleIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5s-3 1.34-3 3 1.34 3 3 3m-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5 5 6.34 5 8s1.34 3 3 3m0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5m8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5"
}));
const PersonIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4m0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4"
}));
const PhoneIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M6.62 10.79c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.27-.27.67-.36 1.02-.24 1.12.37 2.33.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.03.74-.25 1.02z"
}));
const PlaylistAddCheckIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M3 10h11v2H3zm0-4h11v2H3zm0 8h7v2H3zm17.59-2.07-4.25 4.24-2.12-2.12-1.41 1.41L16.34 19 22 13.34z"
}));
const RateReviewIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2M6 14v-2.47l6.88-6.88c.2-.2.51-.2.71 0l1.77 1.77c.2.2.2.51 0 .71L8.47 14zm12 0h-7.5l2-2H18z"
}));
const RefreshIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4z"
}));
const Save = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3m3-10H5V5h10z"
}));
const ScienceIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19.8 18.4 14 10.67V6.5l1.35-1.69c.26-.33.03-.81-.39-.81H9.04c-.42 0-.65.48-.39.81L10 6.5v4.17L4.2 18.4c-.49.66-.02 1.6.8 1.6h14c.82 0 1.29-.94.8-1.6"
}));
const SearchIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"
}));
const SendIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M2.01 21 23 12 2.01 3 2 10l15 2-15 2z"
}));
const Share = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92"
}));
const SpaIcon = createSvgIcon([/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M8.55 12c-1.07-.71-2.25-1.27-3.53-1.61 1.28.34 2.46.9 3.53 1.61m10.43-1.61c-1.29.34-2.49.91-3.57 1.64 1.08-.73 2.28-1.3 3.57-1.64"
}, "0"), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M15.49 9.63c-.18-2.79-1.31-5.51-3.43-7.63-2.14 2.14-3.32 4.86-3.55 7.63 1.28.68 2.46 1.56 3.49 2.63 1.03-1.06 2.21-1.94 3.49-2.63m-6.5 2.65c-.14-.1-.3-.19-.45-.29.15.11.31.19.45.29m6.42-.25c-.13.09-.27.16-.4.26.13-.1.27-.17.4-.26M12 15.45C9.85 12.17 6.18 10 2 10c0 5.32 3.36 9.82 8.03 11.49.63.23 1.29.4 1.97.51.68-.12 1.33-.29 1.97-.51C18.64 19.82 22 15.32 22 10c-4.18 0-7.85 2.17-10 5.45"
}, "1")]);
const StarIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 17.27 18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"
}));
const StoreIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20 4H4v2h16zm1 10v-2l-1-5H4l-1 5v2h1v6h10v-6h4v6h2v-6zm-9 4H6v-4h6z"
}));
const Timeline = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M23 8c0 1.1-.9 2-2 2-.18 0-.35-.02-.51-.07l-3.56 3.55c.05.16.07.34.07.52 0 1.1-.9 2-2 2s-2-.9-2-2c0-.18.02-.36.07-.52l-2.55-2.55c-.16.05-.34.07-.52.07s-.36-.02-.52-.07l-4.55 4.56c.05.16.07.33.07.51 0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2c.18 0 .35.02.51.07l4.56-4.55C8.02 9.36 8 9.18 8 9c0-1.1.9-2 2-2s2 .9 2 2c0 .18-.02.36-.07.52l2.55 2.55c.16-.05.34-.07.52-.07s.36.02.52.07l3.55-3.56C19.02 8.35 19 8.18 19 8c0-1.1.9-2 2-2s2 .9 2 2"
}));
const TrendingUpIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "m16 6 2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z"
}));
const TroubleshootIcon = createSvgIcon([/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "m22 20.59-4.69-4.69C18.37 14.55 19 12.85 19 11c0-4.42-3.58-8-8-8-4.08 0-7.44 3.05-7.93 7h2.02C5.57 7.17 8.03 5 11 5c3.31 0 6 2.69 6 6s-2.69 6-6 6c-2.42 0-4.5-1.44-5.45-3.5H3.4C4.45 16.69 7.46 19 11 19c1.85 0 3.55-.63 4.9-1.69L20.59 22z"
}, "0"), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M8.43 9.69 9.65 15h1.64l1.26-3.78.95 2.28h2V12h-1l-1.25-3h-1.54l-1.12 3.37L9.35 7H7.7l-1.25 4H1v1.5h6.55z"
}, "1")]);
const VerifiedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "m23 12-2.44-2.79.34-3.69-3.61-.82-1.89-3.2L12 2.96 8.6 1.5 6.71 4.69 3.1 5.5l.34 3.7L1 12l2.44 2.79-.34 3.7 3.61.82L8.6 22.5l3.4-1.47 3.4 1.46 1.89-3.19 3.61-.82-.34-3.69zm-12.91 4.72-3.8-3.81 1.48-1.48 2.32 2.33 5.85-5.87 1.48 1.48z"
}));
const WarningIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M1 21h22L12 2zm12-3h-2v-2h2zm0-4h-2v-4h2z"
}));
const WaterDrop = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 2c-5.33 4.55-8 8.48-8 11.8 0 4.98 3.8 8.2 8 8.2s8-3.22 8-8.2c0-3.32-2.67-7.25-8-11.8M7.83 14c.37 0 .67.26.74.62.41 2.22 2.28 2.98 3.64 2.87.43-.02.79.32.79.75 0 .4-.32.73-.72.75-2.13.13-4.62-1.09-5.19-4.12-.08-.45.28-.87.74-.87"
}));
const WbSunny = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "m6.76 4.84-1.8-1.79-1.41 1.41 1.79 1.79zM4 10.5H1v2h3zm9-9.95h-2V3.5h2zm7.45 3.91-1.41-1.41-1.79 1.79 1.41 1.41zm-3.21 13.7 1.79 1.8 1.41-1.41-1.8-1.79zM20 10.5v2h3v-2zm-8-5c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6m-1 16.95h2V19.5h-2zm-7.45-3.91 1.41 1.41 1.79-1.8-1.41-1.41z"
}));
function AgeGate({ onVerify }) {
  const [show, setShow] = reactExports.useState(false);
  reactExports.useEffect(() => {
    setShow(true);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      sx: {
        minHeight: "100vh",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        background: "linear-gradient(135deg, #0a1f0a 0%, #1a3a1a 25%, #2d5a2d 50%, #1a3a1a 75%, #0a1f0a 100%)",
        position: "relative",
        overflow: "hidden",
        "&::before": {
          content: '""',
          position: "absolute",
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          backgroundImage: `
            radial-gradient(circle at 20% 30%, rgba(76, 175, 80, 0.15) 0%, transparent 50%),
            radial-gradient(circle at 80% 70%, rgba(139, 195, 74, 0.15) 0%, transparent 50%),
            radial-gradient(circle at 50% 50%, rgba(124, 179, 66, 0.1) 0%, transparent 70%)
          `,
          animation: "pulse 8s ease-in-out infinite",
          "@keyframes pulse": {
            "0%, 100%": { opacity: 0.5 },
            "50%": { opacity: 1 }
          }
        },
        "&::after": {
          content: '""',
          position: "absolute",
          top: "-50%",
          left: "-50%",
          width: "200%",
          height: "200%",
          background: `
            repeating-linear-gradient(
              0deg,
              transparent,
              transparent 2px,
              rgba(76, 175, 80, 0.03) 2px,
              rgba(76, 175, 80, 0.03) 4px
            )
          `,
          animation: "scan 20s linear infinite",
          "@keyframes scan": {
            "0%": { transform: "translateY(0)" },
            "100%": { transform: "translateY(50px)" }
          }
        }
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { maxWidth: "sm", sx: { position: "relative", zIndex: 1 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Fade, { in: show, timeout: 1e3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Card,
        {
          elevation: 24,
          sx: {
            background: "linear-gradient(135deg, rgba(28, 28, 28, 0.95) 0%, rgba(31, 58, 31, 0.95) 100%)",
            backdropFilter: "blur(20px)",
            border: "2px solid transparent",
            backgroundClip: "padding-box",
            position: "relative",
            "&::before": {
              content: '""',
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              borderRadius: "inherit",
              padding: "2px",
              background: "linear-gradient(135deg, #4caf50, #8bc34a, #4caf50)",
              WebkitMask: "linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0)",
              WebkitMaskComposite: "xor",
              maskComposite: "exclude",
              animation: "borderGlow 3s ease-in-out infinite",
              "@keyframes borderGlow": {
                "0%, 100%": { opacity: 0.5 },
                "50%": { opacity: 1 }
              }
            }
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { sx: { p: 5, textAlign: "center" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grow, { in: show, timeout: 1200, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { position: "relative", display: "inline-block", mb: 2 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                LocalFloristIcon,
                {
                  sx: {
                    fontSize: 120,
                    color: "#4caf50",
                    filter: "drop-shadow(0 0 30px rgba(76, 175, 80, 0.8))",
                    animation: "float 3s ease-in-out infinite",
                    "@keyframes float": {
                      "0%, 100%": { transform: "translateY(0px) rotate(0deg)" },
                      "50%": { transform: "translateY(-10px) rotate(5deg)" }
                    }
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Box,
                {
                  sx: {
                    position: "absolute",
                    top: "50%",
                    left: "50%",
                    transform: "translate(-50%, -50%)",
                    width: "140px",
                    height: "140px",
                    border: "2px solid rgba(76, 175, 80, 0.3)",
                    borderRadius: "50%",
                    animation: "ripple 2s ease-out infinite",
                    "@keyframes ripple": {
                      "0%": {
                        transform: "translate(-50%, -50%) scale(0.8)",
                        opacity: 1
                      },
                      "100%": {
                        transform: "translate(-50%, -50%) scale(1.5)",
                        opacity: 0
                      }
                    }
                  }
                }
              )
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Typography,
              {
                variant: "h2",
                gutterBottom: true,
                fontWeight: "900",
                sx: {
                  background: "linear-gradient(135deg, #4caf50 0%, #8bc34a 50%, #4caf50 100%)",
                  backgroundSize: "200% auto",
                  WebkitBackgroundClip: "text",
                  WebkitTextFillColor: "transparent",
                  animation: "shimmer 3s linear infinite",
                  letterSpacing: "2px",
                  textShadow: "0 0 40px rgba(76, 175, 80, 0.5)",
                  "@keyframes shimmer": {
                    "0%": { backgroundPosition: "0% center" },
                    "100%": { backgroundPosition: "200% center" }
                  }
                },
                children: "StrainSpotter"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Typography,
              {
                variant: "h6",
                sx: {
                  color: "#8bc34a",
                  fontWeight: 500,
                  mb: 4,
                  textShadow: "0 0 20px rgba(139, 195, 74, 0.3)"
                },
                children: "AI-Powered Cannabis Strain Identification"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Box,
              {
                sx: {
                  my: 4,
                  p: 4,
                  background: "linear-gradient(135deg, rgba(76, 175, 80, 0.15) 0%, rgba(139, 195, 74, 0.15) 100%)",
                  borderRadius: 3,
                  border: "1px solid rgba(76, 175, 80, 0.4)",
                  boxShadow: "inset 0 0 20px rgba(76, 175, 80, 0.1)",
                  position: "relative",
                  overflow: "hidden",
                  "&::before": {
                    content: '""',
                    position: "absolute",
                    top: 0,
                    left: "-100%",
                    width: "100%",
                    height: "100%",
                    background: "linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent)",
                    animation: "shine 3s infinite",
                    "@keyframes shine": {
                      "0%": { left: "-100%" },
                      "100%": { left: "100%" }
                    }
                  }
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", justifyContent: "center", spacing: 1, mb: 2, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(VerifiedIcon, { sx: { color: "#4caf50", fontSize: 32 } }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: "bold", sx: { color: "#4caf50" }, children: "Age Verification" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(VerifiedIcon, { sx: { color: "#4caf50", fontSize: 32 } })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", paragraph: true, sx: { color: "#fff", fontWeight: 500 }, children: "You must be 21 years or older" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", sx: { color: "rgba(255, 255, 255, 0.8)", lineHeight: 1.8 }, children: 'By clicking "I am 21+", you confirm that you meet the age requirement for cannabis-related content in your jurisdiction.' })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "contained",
                size: "large",
                fullWidth: true,
                onClick: onVerify,
                sx: {
                  py: 3,
                  fontSize: "1.3rem",
                  fontWeight: "bold",
                  background: "linear-gradient(135deg, #4caf50 0%, #66bb6a 50%, #4caf50 100%)",
                  backgroundSize: "200% auto",
                  boxShadow: "0 8px 30px rgba(76, 175, 80, .4)",
                  borderRadius: 3,
                  position: "relative",
                  overflow: "hidden",
                  transition: "all 0.3s ease",
                  "&::before": {
                    content: '""',
                    position: "absolute",
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    background: "linear-gradient(135deg, transparent 0%, rgba(255, 255, 255, 0.2) 50%, transparent 100%)",
                    transform: "translateX(-100%)",
                    transition: "transform 0.6s"
                  },
                  "&:hover": {
                    background: "linear-gradient(135deg, #388e3c 0%, #4caf50 50%, #388e3c 100%)",
                    backgroundSize: "200% auto",
                    boxShadow: "0 12px 40px rgba(76, 175, 80, .6)",
                    transform: "translateY(-2px)",
                    "&::before": {
                      transform: "translateX(100%)"
                    }
                  },
                  "&:active": {
                    transform: "translateY(0px)"
                  }
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 2, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Box,
                    {
                      component: "img",
                      src: "/hero.png?v=13",
                      alt: "",
                      sx: {
                        width: 28,
                        height: 28,
                        borderRadius: "50%",
                        filter: "drop-shadow(0 0 8px rgba(255, 255, 255, 0.8))",
                        animation: "spin 10s linear infinite",
                        "@keyframes spin": {
                          "0%": { transform: "rotate(0deg)" },
                          "100%": { transform: "rotate(360deg)" }
                        }
                      }
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "I am 21 or Older" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Box,
                    {
                      component: "img",
                      src: "/hero.png?v=13",
                      alt: "",
                      sx: {
                        width: 28,
                        height: 28,
                        borderRadius: "50%",
                        filter: "drop-shadow(0 0 8px rgba(255, 255, 255, 0.8))",
                        animation: "spin 10s linear infinite reverse"
                      }
                    }
                  )
                ] })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Typography,
              {
                variant: "caption",
                display: "block",
                sx: {
                  mt: 4,
                  color: "rgba(255, 255, 255, 0.5)",
                  lineHeight: 1.6,
                  fontSize: "0.85rem"
                },
                children: [
                  "Cannabis is for medical and recreational use in accordance with state laws.",
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  "Please consume responsibly and know your local regulations."
                ]
              }
            )
          ] })
        }
      ) }) })
    }
  );
}
function Auth({ onBack }) {
  const [email, setEmail] = reactExports.useState("");
  const [password, setPassword] = reactExports.useState("");
  const [mode, setMode] = reactExports.useState("signin");
  const [loading, setLoading] = reactExports.useState(false);
  const [error2, setError] = reactExports.useState(null);
  const [user, setUser] = reactExports.useState(null);
  const [info, setInfo] = reactExports.useState(null);
  reactExports.useEffect(() => {
    if (!supabase) return;
    const { data: authListener } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser((session == null ? void 0 : session.user) || null);
    });
    supabase.auth.getSession().then(({ data }) => {
      var _a2;
      return setUser(((_a2 = data.session) == null ? void 0 : _a2.user) || null);
    });
    return () => {
      var _a2;
      return (_a2 = authListener == null ? void 0 : authListener.subscription) == null ? void 0 : _a2.unsubscribe();
    };
  }, []);
  function signIn() {
    return __async(this, null, function* () {
      var _a2, _b, _c, _d;
      if (!isAuthConfigured()) {
        setError("Auth not configured. Set VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY.");
        return;
      }
      setLoading(true);
      setError(null);
      setInfo(null);
      const { data, error: error22 } = yield supabase.auth.signInWithPassword({ email, password });
      if (error22) {
        setError(error22.message);
      } else {
        const confirmedAt = ((_a2 = data == null ? void 0 : data.user) == null ? void 0 : _a2.email_confirmed_at) || ((_c = (_b = data == null ? void 0 : data.session) == null ? void 0 : _b.user) == null ? void 0 : _c.email_confirmed_at);
        if (!confirmedAt) {
          yield supabase.auth.signOut();
          setError("Please verify your email before signing in. Check your inbox for the confirmation link.");
          setInfo(null);
          return;
        }
        try {
          const { data: data2 } = yield supabase.auth.getSession();
          const user2 = (_d = data2 == null ? void 0 : data2.session) == null ? void 0 : _d.user;
          if (user2 == null ? void 0 : user2.id) {
            const { data: profile } = yield supabase.from("profiles").select("username, avatar_url").eq("user_id", user2.id).single();
            if (!(profile == null ? void 0 : profile.username) || !(profile == null ? void 0 : profile.avatar_url)) {
              try {
                yield fetch(`${API_BASE}/api/profile-generator/generate`, {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    email: user2.email,
                    userId: user2.id
                  })
                });
              } catch (e) {
                console.warn("[auth] Failed to generate profile:", e);
              }
            } else {
              yield fetch(`${API_BASE}/api/users/ensure`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ user_id: user2.id, email: user2.email, username: profile.username })
              });
            }
          }
        } catch (e) {
          console.warn("[auth] ensure user after sign-in failed:", e);
        }
        if (onBack) {
          setTimeout(() => onBack(), 500);
        }
      }
      setLoading(false);
    });
  }
  function signUp() {
    return __async(this, null, function* () {
      var _a2, _b;
      if (!isAuthConfigured()) {
        setError("Auth not configured. Set VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY.");
        return;
      }
      setLoading(true);
      setError(null);
      setInfo(null);
      const redirectTo = typeof window !== "undefined" ? `${window.location.origin}/#/` : void 0;
      const { data, error: error22 } = yield supabase.auth.signUp({
        email,
        password,
        options: {
          emailRedirectTo: redirectTo
        }
      });
      setLoading(false);
      if (error22) {
        setError(error22.message);
      } else if (((_b = (_a2 = data == null ? void 0 : data.user) == null ? void 0 : _a2.identities) == null ? void 0 : _b.length) === 0) {
        setError('This email is already registered. Please sign in, or use "Forgot password" to reset.');
      } else {
        setError(null);
        setInfo("Check your inbox to verify your email. You can sign in once you confirm.");
        setMode("signin");
      }
    });
  }
  function signOut() {
    return __async(this, null, function* () {
      yield supabase == null ? void 0 : supabase.auth.signOut();
    });
  }
  function sendMagicLink() {
    return __async(this, null, function* () {
      if (!isAuthConfigured()) {
        setError("Auth not configured.");
        return;
      }
      setLoading(true);
      setError(null);
      setInfo(null);
      try {
        const redirectTo = typeof window !== "undefined" ? window.location.origin : void 0;
        const { error: error22 } = yield supabase.auth.signInWithOtp({ email, options: { emailRedirectTo: redirectTo } });
        if (error22) setError(error22.message);
        else setInfo("Magic link sent. Check your email and click the link to sign in.");
      } finally {
        setLoading(false);
      }
    });
  }
  function forgotPassword() {
    return __async(this, null, function* () {
      if (!isAuthConfigured()) {
        setError("Auth not configured.");
        return;
      }
      setLoading(true);
      setError(null);
      setInfo(null);
      try {
        const redirectTo = typeof window !== "undefined" ? `${window.location.origin}/#/` : void 0;
        const { error: error22 } = yield supabase.auth.resetPasswordForEmail(email, { redirectTo });
        if (error22) setError(error22.message);
        else setInfo("Password reset email sent. Check your email and click the link to reset your password. The link expires in 1 hour.");
      } finally {
        setLoading(false);
      }
    });
  }
  const ALLOWLIST = [
    "your@email.com",
    // <-- add your email(s) here
    "friend1@email.com",
    "friend2@email.com",
    "andrewbeck209@gmail.com"
    // Add more emails as needed
  ];
  if (!isAuthConfigured()) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "info", children: "Auth is not configured. You can still browse features." });
  }
  const isDev = typeof window !== "undefined" && (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1");
  if (user && !isDev && !ALLOWLIST.includes(user.email)) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", children: "This app is restricted. Only select users can access StrainSpotter web. Please use the mobile app." });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { maxWidth: 420, mx: "auto", py: 4, background: "transparent" }, children: [
    onBack && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        onClick: onBack,
        size: "small",
        variant: "contained",
        sx: {
          mb: 2,
          bgcolor: "#7CB342",
          color: "white",
          textTransform: "none",
          fontWeight: 700,
          borderRadius: 999,
          "&:hover": { bgcolor: "#689f38" }
        },
        children: " Home"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { background: "rgba(255,255,255,0.15)", backdropFilter: "blur(12px)", border: "2px solid rgba(0,0,0,0.12)", boxShadow: "none" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", justifyContent: "center", mb: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Box,
        {
          sx: {
            width: 80,
            height: 80,
            borderRadius: "50%",
            background: "transparent",
            border: "2px solid rgba(124, 179, 66, 0.5)",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            boxShadow: "0 0 30px rgba(124, 179, 66, 0.4)",
            overflow: "hidden"
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: "/hero.png?v=13",
              alt: "StrainSpotter",
              style: { width: "100%", height: "100%", objectFit: "cover" }
            }
          )
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h5", sx: { color: "black", fontSize: "2rem", fontWeight: 700, textAlign: "center" }, children: "Account" }),
      user ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", children: [
          "Signed in as ",
          user.email
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outlined", onClick: signOut, children: "Sign Out" })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Tabs, { value: mode === "reset" ? false : mode, onChange: (_e, v) => setMode(v), "aria-label": "auth mode", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { label: "Sign In", value: "signin" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { label: "Sign Up", value: "signup" })
        ] }),
        mode !== "reset" && /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { label: "Email", type: "email", value: email, onChange: (e) => setEmail(e.target.value), fullWidth: true, sx: { background: "rgba(255,255,255,0.10)", color: "black", fontSize: "1.15rem", borderRadius: 2, input: { color: "black" } }, InputLabelProps: { style: { color: "black", fontWeight: 600 } } }),
        mode === "signin" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { label: "Password", type: "password", value: password, onChange: (e) => setPassword(e.target.value), fullWidth: true, sx: { background: "rgba(255,255,255,0.10)", color: "black", fontSize: "1.15rem", borderRadius: 2, input: { color: "black" } }, InputLabelProps: { style: { color: "black", fontWeight: 600 } } }),
          error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { fontSize: "1.1rem", color: "black", background: "rgba(255,255,255,0.10)" }, children: error2 }),
          info && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "info", sx: { fontSize: "1.1rem", color: "black", background: "rgba(255,255,255,0.10)" }, children: info }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: { xs: "column", sm: "row" }, spacing: 1, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "contained", onClick: signIn, disabled: loading, sx: { fontSize: "1.1rem", color: "black", background: "rgba(255,255,255,0.20)", border: "1.5px solid black", boxShadow: "none", fontWeight: 700 }, children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 20 }) : "Sign In" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outlined", onClick: sendMagicLink, disabled: loading, sx: { fontSize: "1.1rem", color: "black", border: "1.5px solid black", fontWeight: 700 }, children: "Send Magic Link" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "text", onClick: () => {
              setMode("reset");
              setInfo(null);
              setError(null);
            }, disabled: loading, sx: { fontSize: "1.1rem", color: "black", fontWeight: 700 }, children: "Forgot Password?" })
          ] })
        ] }),
        mode === "signup" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { label: "Password", type: "password", value: password, onChange: (e) => setPassword(e.target.value), fullWidth: true, sx: { background: "rgba(255,255,255,0.10)", color: "black", fontSize: "1.15rem", borderRadius: 2, input: { color: "black" } }, InputLabelProps: { style: { color: "black", fontWeight: 600 } } }),
          error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { fontSize: "1.1rem", color: "black", background: "rgba(255,255,255,0.10)" }, children: error2 }),
          info && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "info", sx: { fontSize: "1.1rem", color: "black", background: "rgba(255,255,255,0.10)" }, children: info }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: { xs: "column", sm: "row" }, spacing: 1, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "contained", onClick: signUp, disabled: loading, sx: { fontSize: "1.1rem", color: "black", background: "rgba(255,255,255,0.20)", border: "1.5px solid black", boxShadow: "none", fontWeight: 700 }, children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 20 }) : "Create Account" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { component: "button", onClick: () => setMode("signin"), sx: { alignSelf: "center", color: "black", fontWeight: 700 }, children: "Already registered? Sign in" })
          ] })
        ] }),
        mode === "reset" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "black" }, children: "Enter your account email and well send you a reset link." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextField,
            {
              label: "Account Email",
              type: "email",
              value: email,
              onChange: (e) => setEmail(e.target.value),
              fullWidth: true,
              sx: { background: "rgba(255,255,255,0.10)", color: "black", fontSize: "1.15rem", borderRadius: 2, input: { color: "black" } },
              InputLabelProps: { style: { color: "black", fontWeight: 600 } }
            }
          ),
          error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { fontSize: "1.1rem", color: "black", background: "rgba(255,255,255,0.10)" }, children: error2 }),
          info && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "info", sx: { fontSize: "1.1rem", color: "black", background: "rgba(255,255,255,0.10)" }, children: info }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: { xs: "column", sm: "row" }, spacing: 1, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "contained", onClick: forgotPassword, disabled: loading || !email, sx: { fontSize: "1.1rem", color: "black", background: "rgba(255,255,255,0.20)", border: "1.5px solid black", boxShadow: "none", fontWeight: 700 }, children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 20 }) : "Send Reset Email" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "text", onClick: () => {
              setMode("signin");
              setInfo(null);
              setError(null);
            }, sx: { fontSize: "1.1rem", color: "black", fontWeight: 700 }, children: "Back to Sign In" })
          ] })
        ] })
      ] })
    ] }) }) })
  ] });
}
const cannabisTheme = {
  colors: {
    // Primary greens (muted sage/olive green - less vivid)
    primary: {
      main: "#7CB342",
      // Muted olive green
      light: "#9CCC65",
      // Soft sage
      dark: "#558B2F"
    },
    // Secondary (earth tones)
    secondary: {
      main: "#9E9D24",
      // Muted earth yellow
      light: "#C5E1A5",
      dark: "#827717"
    },
    // Text
    text: {
      primary: "#9CCC65",
      // Soft sage green for main text
      secondary: "#7CB342"
    }
  },
  // Cannabis leaf icon SVG path
  leafIcon: {
    viewBox: "0 0 64 64",
    path: "M32 6c2.8 8.2 9.6 14 18 16-8.4 2-15.2 7.8-18 16-2.8-8.2-9.6-14-18-16 8.4-2 15.2-7.8 18-16ZM32 44c-3.5-6.5-9.9-10.7-18-12 4 5.3 7.1 11.1 8.5 17.3 3.1 1.5 6.2 2.7 9.5 3.7v-9ZM32 44c3.5-6.5 9.9-10.7 18-12-4 5.3-7.1 11.1-8.5 17.3-3.1 1.5-6.2 2.7-9.5 3.7v-9Z"
  },
  // Border styles
  borders: {
    primary: "2px solid #7CB342",
    subtle: "1px solid rgba(124, 179, 66, 0.3)"
  },
  // Shadows
  shadows: {
    card: "0 4px 20px rgba(0, 0, 0, 0.5)",
    elevated: "0 8px 30px rgba(0, 0, 0, 0.7)"
  }
};
const muiThemeOverrides = {
  palette: {
    mode: "dark",
    primary: {
      main: cannabisTheme.colors.primary.main,
      light: cannabisTheme.colors.primary.light,
      dark: cannabisTheme.colors.primary.dark
    },
    secondary: {
      main: cannabisTheme.colors.secondary.main,
      light: cannabisTheme.colors.secondary.light,
      dark: cannabisTheme.colors.secondary.dark
    },
    background: {
      default: "#1a1a1a",
      // Use a valid dark color for background
      paper: "#2c2c2c"
      // Use a valid card color for paper
    },
    text: {
      primary: cannabisTheme.colors.text.primary,
      secondary: cannabisTheme.colors.text.secondary
    }
  },
  components: {
    MuiCard: {
      styleOverrides: {
        root: {
          backgroundColor: "none",
          border: cannabisTheme.borders.subtle,
          boxShadow: cannabisTheme.shadows.card
        }
      }
    },
    MuiButton: {
      styleOverrides: {
        root: {
          borderRadius: 10,
          textTransform: "none",
          // Disable hover on touch devices to prevent double-tap issue
          "@media (hover: none)": {
            "&:hover": {
              backgroundColor: "inherit"
            }
          }
        },
        contained: {
          backgroundColor: "rgba(124, 179, 66, 0.3)",
          border: "2px solid rgba(124, 179, 66, 0.6)",
          backdropFilter: "blur(10px)",
          boxShadow: "0 6px 20px rgba(124, 179, 66, 0.2)",
          // Only apply hover on devices with hover capability (desktop)
          "@media (hover: hover)": {
            "&:hover": {
              backgroundColor: "rgba(124, 179, 66, 0.5)",
              border: "2px solid rgba(124, 179, 66, 0.8)"
            }
          },
          // Active state for touch devices
          "&:active": {
            backgroundColor: "rgba(124, 179, 66, 0.5)",
            transform: "scale(0.98)"
          }
        },
        outlined: {
          backgroundColor: "rgba(124, 179, 66, 0.2)",
          border: "2px solid rgba(124, 179, 66, 0.5)",
          backdropFilter: "blur(10px)",
          // Only apply hover on devices with hover capability (desktop)
          "@media (hover: hover)": {
            "&:hover": {
              backgroundColor: "rgba(124, 179, 66, 0.3)",
              border: "2px solid rgba(124, 179, 66, 0.7)"
            }
          },
          // Active state for touch devices
          "&:active": {
            backgroundColor: "rgba(124, 179, 66, 0.3)",
            transform: "scale(0.98)"
          }
        },
        text: {
          backgroundColor: "rgba(124, 179, 66, 0.15)",
          backdropFilter: "blur(10px)",
          // Only apply hover on devices with hover capability (desktop)
          "@media (hover: hover)": {
            "&:hover": {
              backgroundColor: "rgba(124, 179, 66, 0.25)"
            }
          },
          // Active state for touch devices
          "&:active": {
            backgroundColor: "rgba(124, 179, 66, 0.25)",
            transform: "scale(0.98)"
          }
        }
      }
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          backgroundColor: "#1a1a1a",
          borderBottom: cannabisTheme.borders.primary
        }
      }
    },
    MuiDrawer: {
      styleOverrides: {
        paper: {
          backgroundColor: "#2c2c2c",
          borderRight: cannabisTheme.borders.subtle
        }
      }
    },
    MuiDialog: {
      styleOverrides: {
        paper: {
          backgroundColor: "#2c2c2c",
          border: cannabisTheme.borders.subtle,
          boxShadow: cannabisTheme.shadows.elevated
        }
      }
    }
  },
  typography: {
    fontFamily: '"Inter", "Roboto", "Helvetica", "Arial", sans-serif',
    h1: { fontWeight: 700 },
    h2: { fontWeight: 700 },
    h3: { fontWeight: 600 },
    h4: { fontWeight: 600 },
    h5: { fontWeight: 600 },
    h6: { fontWeight: 600 }
  }
};
function CannabisLeafIcon(_q) {
  var _r = _q, { size = 28, color: color2, sx } = _r, props = __objRest(_r, ["size", "color", "sx"]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    __spreadProps(__spreadValues({
      component: "svg",
      width: size,
      height: size,
      viewBox: cannabisTheme.leafIcon.viewBox,
      fill: "none",
      sx: __spreadValues({
        color: color2 || cannabisTheme.colors.primary.main
      }, sx)
    }, props), {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: cannabisTheme.leafIcon.path,
          fill: "currentColor"
        }
      )
    })
  );
}
function EmptyStateCard({ title, description, actionLabel, onAction, secondaryActionLabel, onSecondaryAction, icon }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Card,
    {
      variant: "outlined",
      sx: {
        borderRadius: 3,
        borderColor: "rgba(255,255,255,0.2)",
        background: "rgba(0,0,0,0.35)",
        color: "#fff",
        textAlign: "center",
        p: 2
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, alignItems: "center", children: [
        icon,
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", fontWeight: 700, children: title }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "rgba(255,255,255,0.8)", children: description }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: { xs: "column", sm: "row" }, spacing: 1, children: [
          actionLabel && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "contained", color: "success", onClick: onAction, children: actionLabel }),
          secondaryActionLabel && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outlined", color: "inherit", onClick: onSecondaryAction, children: secondaryActionLabel })
        ] })
      ] }) })
    }
  );
}
function ScanHistory({ onBack, onSelectScan }) {
  const navigate = useNavigate();
  const [scans, setScans] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [error2, setError] = reactExports.useState(null);
  const [selectedScan, setSelectedScan] = reactExports.useState(null);
  const [strainDetails, setStrainDetails] = reactExports.useState(null);
  const [loadingDetails, setLoadingDetails] = reactExports.useState(false);
  const fetchScans = reactExports.useCallback(() => __async(null, null, function* () {
    var _a2, _b, _c;
    try {
      setLoading(true);
      let userId = null;
      try {
        const session = yield supabase == null ? void 0 : supabase.auth.getSession();
        userId = ((_c = (_b = (_a2 = session == null ? void 0 : session.data) == null ? void 0 : _a2.session) == null ? void 0 : _b.user) == null ? void 0 : _c.id) || null;
      } catch (sessionError) {
        console.debug("[ScanHistory] getSession failed", sessionError);
      }
      const url = userId ? `${API_BASE}/api/scans?user_id=${encodeURIComponent(userId)}` : `${API_BASE}/api/scans`;
      const response = yield fetch(url);
      if (!response.ok) throw new Error("Failed to fetch scans");
      const data = yield response.json();
      setScans(data.scans || []);
      setError(null);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }), []);
  reactExports.useEffect(() => {
    fetchScans();
  }, [fetchScans]);
  const handleViewStrain = (scan) => __async(null, null, function* () {
    if (onSelectScan && typeof onSelectScan === "function") {
      onSelectScan(scan);
      return;
    }
    if (!scan.matched_strain_slug) return;
    setSelectedScan(scan);
    setLoadingDetails(true);
    try {
      const response = yield fetch(`${API_BASE}/api/strains/${scan.matched_strain_slug}`);
      if (response.ok) {
        const data = yield response.json();
        setStrainDetails(data);
      } else {
        setStrainDetails(null);
      }
    } catch (err) {
      console.error("Failed to load strain details:", err);
      setStrainDetails(null);
    } finally {
      setLoadingDetails(false);
    }
  });
  const handleCloseDialog = () => {
    setSelectedScan(null);
    setStrainDetails(null);
  };
  const isCapacitor2 = typeof window !== "undefined" && (window.Capacitor || window.location.protocol === "capacitor:" || /iPhone|iPad|iPod|Android/i.test(window.navigator.userAgent));
  const GARDEN_TOP_PAD = isCapacitor2 ? "calc(env(safe-area-inset-top) + 20px)" : "20px";
  const handleBack = () => {
    if (onBack) {
      onBack();
    } else if (navigate) {
      navigate("/garden");
    } else {
      window.history.back();
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        display: "flex",
        flexDirection: "column",
        height: "100vh",
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            sx: {
              flexShrink: 0,
              pt: GARDEN_TOP_PAD,
              px: 2,
              pb: 1,
              borderBottom: "1px solid rgba(255,255,255,0.08)",
              bgcolor: "rgba(0,0,0,0.7)",
              backdropFilter: "blur(10px)",
              zIndex: 1
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { maxWidth: "md", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "space-between", alignItems: "center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, alignItems: "center", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IconButton,
                  {
                    edge: "start",
                    onClick: handleBack,
                    sx: { color: "#fff", mr: 1 },
                    "aria-label": "Go back",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowBackIcon, {})
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(CannabisLeafIcon, { style: { height: 28, color: "#7cb342" } }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h5", fontWeight: 700, sx: { color: "#fff" }, children: "Scan History" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { direction: "row", spacing: 1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "contained",
                  color: "success",
                  startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(CannabisLeafIcon, { style: { height: 20 } }),
                  onClick: () => navigate("/garden"),
                  sx: { textTransform: "none" },
                  children: "Garden"
                }
              ) })
            ] }) })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            sx: {
              flex: 1,
              minHeight: 0,
              overflowY: "auto",
              WebkitOverflowScrolling: "touch"
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { maxWidth: "md", sx: { py: 4 }, children: [
              loading && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", justifyContent: "center", py: 6 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {}) }),
              !loading && error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mb: 3 }, children: error2 }),
              !loading && !error2 && scans.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                EmptyStateCard,
                {
                  title: "No scans yet",
                  description: "Upload your first bud photo to see AI matches and build your history.",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CameraAltIcon, { sx: { fontSize: 56, color: "#7cb342" } }),
                  actionLabel: "Start a scan",
                  onAction: () => window.dispatchEvent(new CustomEvent("nav:set-view", { detail: "scanner" })),
                  secondaryActionLabel: "Back to home",
                  onSecondaryAction: onBack
                }
              ),
              !loading && !error2 && scans.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 2, children: scans.map((scan) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                Card,
                {
                  variant: "outlined",
                  sx: { borderRadius: 3, background: "rgba(255,255,255,0.08)" },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "space-between", alignItems: "center", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", fontWeight: 600, children: scan.matched_strain_name || "Unknown Strain" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", color: "text.secondary", children: [
                          "Scanned on ",
                          new Date(scan.created_at).toLocaleString()
                        ] })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { direction: "row", spacing: 1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Button,
                        {
                          size: "small",
                          variant: "contained",
                          color: "success",
                          onClick: () => handleViewStrain(scan),
                          disabled: !scan.matched_strain_slug,
                          children: "View Details"
                        }
                      ) })
                    ] }),
                    scan.notes && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { mt: 1 }, children: scan.notes })
                  ] })
                },
                scan.id
              )) })
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Dialog,
          {
            open: Boolean(selectedScan),
            onClose: handleCloseDialog,
            maxWidth: "sm",
            fullWidth: true,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "space-between", alignItems: "center", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 1, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(LocalFloristIcon, { color: "success" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", fontWeight: 600, children: "Strain Details" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    onClick: handleCloseDialog,
                    size: "small",
                    color: "inherit",
                    startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, { fontSize: "small" }),
                    children: "Close"
                  }
                )
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { dividers: true, children: [
                loadingDetails && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", justifyContent: "center", py: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {}) }),
                !loadingDetails && strainDetails && /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", children: strainDetails.name }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: strainDetails.description || "No description available." }),
                  Array.isArray(strainDetails.effects) && strainDetails.effects.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", gutterBottom: true, children: "Effects" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: strainDetails.effects.join(", ") })
                  ] }),
                  Array.isArray(strainDetails.flavors) && strainDetails.flavors.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", gutterBottom: true, children: "Flavors" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: strainDetails.flavors.join(", ") })
                  ] })
                ] }),
                !loadingDetails && !strainDetails && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "info", children: "Strain details not available." })
              ] }),
              selectedScan && /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActions, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", color: "text.secondary", sx: { px: 2, pb: 1 }, children: [
                "Scan ID: ",
                selectedScan.id
              ] }) })
            ]
          }
        )
      ]
    }
  );
}
function MembershipLogin({ onSuccess }) {
  const [email, setEmail] = reactExports.useState("");
  const [name2, setName] = reactExports.useState("");
  const [loading, setLoading] = reactExports.useState(false);
  const [error2, setError] = reactExports.useState("");
  const [applied, setApplied] = reactExports.useState(false);
  const handleApply = () => __async(null, null, function* () {
    setLoading(true);
    setError("");
    try {
      const resp = yield fetch(`${API_BASE}/api/membership/apply`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email, full_name: name2 })
      });
      const data = yield resp.json();
      if (!resp.ok || !data.success) throw new Error(data.error || "Application failed");
      setApplied(true);
    } catch (e) {
      setError(e.message);
    }
    setLoading(false);
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { minHeight: "100vh", display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", background: "none" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper, { sx: { p: 4, borderRadius: 6, minWidth: 340, maxWidth: 400, textAlign: "center", background: "rgba(255,255,255,0.15)", backdropFilter: "blur(20px)", border: "2px solid rgba(124, 179, 66, 0.3)" }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", sx: { mb: 2, color: "#fff", fontWeight: 900 }, children: "Enter the Garden" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", sx: { mb: 3, color: "#e0e0e0" }, children: "Welcome! Please apply for membership to access the full app." }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextField,
      {
        label: "Full Name",
        value: name2,
        onChange: (e) => setName(e.target.value),
        fullWidth: true,
        sx: { mb: 2 }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextField,
      {
        label: "Email Address",
        value: email,
        onChange: (e) => setEmail(e.target.value),
        fullWidth: true,
        sx: { mb: 2 }
      }
    ),
    error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { color: "error", sx: { mb: 2 }, children: error2 }),
    !applied ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "contained",
          color: "success",
          sx: {
            fontWeight: 700,
            borderRadius: 999,
            px: 4,
            py: 1,
            fontSize: 18,
            boxShadow: "none",
            bgcolor: "rgba(124, 179, 66, 0.3)",
            border: "2px solid rgba(124, 179, 66, 0.6)",
            backdropFilter: "blur(10px)",
            color: "#fff",
            textTransform: "none",
            mb: 2,
            "&:hover": {
              bgcolor: "rgba(124, 179, 66, 0.5)",
              border: "2px solid rgba(124, 179, 66, 0.8)"
            }
          },
          onClick: handleApply,
          disabled: loading || !email || !name2,
          children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 24, color: "inherit" }) : "Apply for Membership"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "text",
          sx: {
            fontWeight: 600,
            color: "#fff",
            textTransform: "none",
            bgcolor: "rgba(124, 179, 66, 0.15)",
            backdropFilter: "blur(10px)",
            "&:hover": {
              bgcolor: "rgba(124, 179, 66, 0.25)"
            }
          },
          onClick: () => onSuccess && onSuccess(),
          children: "Skip for now (Browse only)"
        }
      )
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { mt: 3, color: "#fff", mb: 2 }, children: "Membership application complete! You may now enter the garden." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "contained",
          color: "success",
          sx: {
            fontWeight: 700,
            borderRadius: 999,
            px: 4,
            py: 1,
            fontSize: 18,
            boxShadow: "none",
            bgcolor: "rgba(124, 179, 66, 0.3)",
            border: "2px solid rgba(124, 179, 66, 0.6)",
            backdropFilter: "blur(10px)",
            color: "#fff",
            textTransform: "none",
            "&:hover": {
              bgcolor: "rgba(124, 179, 66, 0.5)",
              border: "2px solid rgba(124, 179, 66, 0.8)"
            }
          },
          onClick: () => onSuccess && onSuccess(),
          children: "Continue"
        }
      )
    ] })
  ] }) });
}
class ErrorBoundary2 extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }
  static getDerivedStateFromError() {
    return { hasError: true };
  }
  componentDidCatch(error2, errorInfo) {
    this.setState({ error: error2, errorInfo });
    console.error("\n FRONTEND ERROR CAUGHT BY BOUNDARY ");
    console.error("");
    console.error("Time:", (/* @__PURE__ */ new Date()).toISOString());
    console.error("Error Message:", (error2 == null ? void 0 : error2.message) || "Unknown error");
    console.error("Error Stack:", (error2 == null ? void 0 : error2.stack) || "No stack trace");
    console.error("Error String:", (error2 == null ? void 0 : error2.toString()) || String(error2));
    console.error("Component Stack:", (errorInfo == null ? void 0 : errorInfo.componentStack) || "No component stack");
    console.error("Full Error Object:", error2);
    console.error("Full Error Info:", errorInfo);
    console.error("\n");
    this.sendClientError(error2, errorInfo);
  }
  sendClientError(error2, errorInfo) {
    return __async(this, null, function* () {
      try {
        const { data: { session } } = yield supabase.auth.getSession();
        const headers = { "Content-Type": "application/json" };
        if (session == null ? void 0 : session.access_token) {
          headers.Authorization = `Bearer ${session.access_token}`;
        }
        yield fetch(`${API_BASE}/api/admin/errors/client`, {
          method: "POST",
          headers,
          body: JSON.stringify({
            message: (error2 == null ? void 0 : error2.message) || (error2 == null ? void 0 : error2.toString()) || "Unknown error",
            stack: (error2 == null ? void 0 : error2.stack) || "No stack trace",
            componentStack: (errorInfo == null ? void 0 : errorInfo.componentStack) || "No component stack",
            errorString: (error2 == null ? void 0 : error2.toString()) || String(error2),
            location: window.location.href,
            currentView: window.location.pathname,
            platform: (navigator == null ? void 0 : navigator.platform) || null,
            userAgent: (navigator == null ? void 0 : navigator.userAgent) || null,
            fullError: error2 ? {
              name: error2.name,
              message: error2.message,
              stack: error2.stack
            } : null
          })
        });
      } catch (e) {
        console.warn("[ErrorBoundary] Failed to report client error:", e);
      }
    });
  }
  render() {
    if (this.state.hasError) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { maxWidth: "md", sx: { py: 8 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { bgcolor: "rgba(211, 47, 47, 0.05)", border: "2px solid #d32f2f44" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", gutterBottom: true, color: "error", children: " Something went wrong" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mb: 3 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", fontWeight: "bold", children: this.state.error && this.state.error.toString() }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", sx: { mb: 2 }, children: "The application encountered an error. This has been logged to the console." }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 3 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", sx: { display: "block", mb: 1 }, children: "Component Stack:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Box,
            {
              component: "pre",
              sx: {
                bgcolor: "rgba(0,0,0,0.05)",
                p: 2,
                borderRadius: 1,
                fontSize: "0.75rem",
                overflow: "auto",
                maxHeight: 300
              },
              children: this.state.errorInfo && this.state.errorInfo.componentStack
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "contained",
            onClick: () => window.location.reload(),
            sx: { mr: 2 },
            children: "Reload Page"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "outlined",
            onClick: () => {
              this.setState({ hasError: false, error: null, errorInfo: null });
              window.history.back();
            },
            children: "Go Back"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Alert, { severity: "info", sx: { mt: 3 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", fontWeight: "bold", children: " For developers:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", display: "block", children: " Open browser DevTools (F12)  Console tab for full error details" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", display: "block", children: [
            " Check backend errors at: ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: "http://localhost:5173/errors" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", display: "block", children: [
            " PM2 logs: ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: "pm2 logs strainspotter-backend" })
          ] })
        ] })
      ] }) }) });
    }
    return this.props.children;
  }
}
const STATIC_SEED_VENDORS = [
  {
    id: "ilgm",
    name: "ILGM - I Love Growing Marijuana",
    url: "https://ilgm.com",
    tagline: "Beginner-friendly, classic strains, strong grow guides.",
    verified: true,
    country: "USA"
  },
  {
    id: "seedsman",
    name: "Seedsman",
    url: "https://www.seedsman.com/",
    tagline: "Huge catalog of breeders and genetics.",
    verified: true,
    country: "UK"
  },
  {
    id: "attitude",
    name: "Attitude Seed Bank",
    url: "https://www.cannabis-seeds-bank.co.uk/",
    tagline: "Global shipping, many European breeders.",
    verified: true,
    country: "UK"
  },
  {
    id: "north-atlantic",
    name: "North Atlantic Seed Company",
    url: "https://northatlanticseed.com/",
    tagline: "US-based, fast shipping, trusted breeders.",
    verified: true,
    country: "USA"
  },
  {
    id: "herbies",
    name: "Herbies Seeds",
    url: "https://herbiesheadshop.com/",
    tagline: "European seed bank with worldwide shipping.",
    verified: true,
    country: "Spain"
  }
];
function SeedVendorFinder({ onBack, strainName, strainSlug }) {
  const [vendors, setVendors] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(false);
  const [error2, setError] = reactExports.useState(null);
  const [searchStrain, setSearchStrain] = reactExports.useState(strainName || "");
  const [country, setCountry] = reactExports.useState("all");
  const [showPopular, setShowPopular] = reactExports.useState(false);
  const [useStaticList, setUseStaticList] = reactExports.useState(false);
  const searchVendors = reactExports.useCallback((strain) => __async(null, null, function* () {
    setLoading(true);
    setError(null);
    setShowPopular(false);
    try {
      let url = `${API_BASE}/api/seeds-live?`;
      if (strain) url += `strain=${encodeURIComponent(strain)}&`;
      if (country !== "all") url += `country=${country}&`;
      url += `include_google=true`;
      const response = yield fetch(url);
      if (!response.ok) throw new Error("Search failed");
      const data = yield response.json();
      setVendors(data.results || []);
    } catch (err) {
      console.error("Seed vendor search failed:", err);
      setError("Failed to find seed vendors. Please try again.");
    } finally {
      setLoading(false);
    }
  }), [country]);
  const loadPopularVendors = reactExports.useCallback(() => __async(null, null, function* () {
    var _a2;
    setLoading(true);
    setError(null);
    setShowPopular(true);
    try {
      const url = `${API_BASE}/api/seeds-live/popular`;
      console.log("[SeedVendorFinder] Fetching from:", url);
      const response = yield fetch(url);
      console.log("[SeedVendorFinder] Response status:", response.status, response.statusText);
      if (!response.ok) throw new Error("Failed to load popular vendors");
      const data = yield response.json();
      console.log("[SeedVendorFinder] Received vendors:", ((_a2 = data == null ? void 0 : data.results) == null ? void 0 : _a2.length) || 0);
      setVendors(data.results || []);
    } catch (err) {
      console.error("[SeedVendorFinder] Failed to load popular vendors:", err);
      setError("Failed to load seed vendors. Please try again.");
    } finally {
      setLoading(false);
    }
  }), []);
  reactExports.useEffect(() => {
    setVendors(STATIC_SEED_VENDORS);
    setUseStaticList(true);
    setLoading(false);
    if (strainName || strainSlug) {
      searchVendors(strainSlug || strainName);
    }
  }, [strainName, strainSlug, searchVendors]);
  const handleSearch = () => {
    if (searchStrain.trim()) {
      searchVendors(searchStrain.trim());
    } else {
      loadPopularVendors();
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        display: "flex",
        flexDirection: "column",
        height: "100vh",
        overflow: "hidden",
        backgroundColor: "#050705",
        backgroundImage: "url(/strainspotter-bg.jpg)",
        backgroundSize: "cover",
        backgroundPosition: "center",
        position: "relative"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(BackHeader, { title: "Seed Vendors", onBack }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
          flex: 1,
          minHeight: 0,
          overflowY: "auto",
          WebkitOverflowScrolling: "touch",
          px: 2,
          pb: 2,
          pt: 1
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Paper, { sx: {
            p: 2,
            mb: 2,
            background: "rgba(255,255,255,0.1)",
            backdropFilter: "blur(20px)",
            border: "1px solid rgba(124, 179, 66, 0.3)",
            borderRadius: 2
          }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { container: true, spacing: 2, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                fullWidth: true,
                size: "small",
                label: "Strain Name",
                value: searchStrain,
                onChange: (e) => setSearchStrain(e.target.value),
                placeholder: "e.g., Blue Dream, OG Kush",
                onKeyPress: (e) => e.key === "Enter" && handleSearch(),
                sx: {
                  "& .MuiOutlinedInput-root": {
                    color: "#fff",
                    "& fieldset": { borderColor: "rgba(124, 179, 66, 0.5)" },
                    "&:hover fieldset": { borderColor: "rgba(124, 179, 66, 0.7)" },
                    "&.Mui-focused fieldset": { borderColor: "#7cb342" }
                  },
                  "& .MuiInputLabel-root": { color: "#fff" }
                }
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl, { fullWidth: true, size: "small", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, { sx: { color: "#fff" }, children: "Country" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Select,
                {
                  value: country,
                  onChange: (e) => setCountry(e.target.value),
                  label: "Country",
                  sx: {
                    color: "#fff",
                    "& .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.5)" },
                    "&:hover .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.7)" },
                    "&.Mui-focused .MuiOutlinedInput-notchedOutline": { borderColor: "#7cb342" }
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "all", children: "All Countries" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "USA", children: "USA" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "Canada", children: "Canada" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "Netherlands", children: "Netherlands" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "Spain", children: "Spain" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "UK", children: "UK" })
                  ]
                }
              )
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                fullWidth: true,
                variant: "contained",
                onClick: handleSearch,
                disabled: loading,
                sx: {
                  bgcolor: "#7cb342",
                  "&:hover": { bgcolor: "#689f38" },
                  height: "40px"
                },
                children: loading ? "Searching..." : "Search"
              }
            ) })
          ] }) }),
          error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mb: 2 }, children: error2 }),
          loading && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", justifyContent: "center", py: 8 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { sx: { color: "#7cb342" } }) }),
          !loading && vendors.length === 0 && !useStaticList && /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper, { sx: {
            p: 4,
            textAlign: "center",
            background: "rgba(255,255,255,0.1)",
            backdropFilter: "blur(20px)",
            border: "1px solid rgba(124, 179, 66, 0.3)",
            borderRadius: 2
          }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#fff", mb: 2 }, children: "No seed vendors found" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#e0e0e0", mb: 2 }, children: "Try a different strain or browse trusted seed banks below." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "outlined",
                onClick: () => {
                  setVendors(STATIC_SEED_VENDORS);
                  setUseStaticList(true);
                },
                sx: {
                  color: "#fff",
                  borderColor: "rgba(124, 179, 66, 0.6)",
                  "&:hover": { borderColor: "#7cb342", bgcolor: "rgba(124, 179, 66, 0.1)" }
                },
                children: "View Trusted Seed Banks"
              }
            )
          ] }),
          !loading && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#e0e0e0", mb: 2 }, children: "Trusted Seed Banks" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { container: true, spacing: 2, children: STATIC_SEED_VENDORS.map((vendor) => /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: {
              background: "rgba(255,255,255,0.1)",
              backdropFilter: "blur(20px)",
              border: "1px solid rgba(124, 179, 66, 0.3)",
              borderRadius: 2,
              height: "100%"
            }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { direction: "row", justifyContent: "space-between", alignItems: "flex-start", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { flex: 1, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 1, mb: 1, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#fff", fontWeight: 600 }, children: vendor.name }),
                  vendor.verified && /* @__PURE__ */ jsxRuntimeExports.jsx(VerifiedIcon, { sx: { fontSize: 20, color: "#7cb342" } })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, flexWrap: "wrap", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Chip,
                    {
                      label: "Trusted",
                      size: "small",
                      sx: { bgcolor: "rgba(124, 179, 66, 0.3)", color: "#fff", fontSize: "0.65rem", height: 18 }
                    }
                  ),
                  vendor.country && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Chip,
                    {
                      label: vendor.country,
                      size: "small",
                      sx: { bgcolor: "rgba(255,255,255,0.2)", color: "#fff", fontSize: "0.65rem", height: 18 }
                    }
                  )
                ] })
              ] }) }),
              vendor.tagline && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#e0e0e0" }, children: vendor.tagline }),
              vendor.url && /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  fullWidth: true,
                  variant: "contained",
                  component: "a",
                  href: vendor.url,
                  target: "_blank",
                  sx: {
                    bgcolor: "#7cb342",
                    "&:hover": { bgcolor: "#689f38" }
                  },
                  children: "Visit Store "
                }
              )
            ] }) }) }) }, vendor.id)) })
          ] }),
          !loading && vendors.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#e0e0e0", mb: 2 }, children: showPopular ? "Popular Seed Banks" : `Found ${vendors.length} seed vendors` }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { container: true, spacing: 2, children: vendors.map((vendor) => /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: {
              background: "rgba(255,255,255,0.1)",
              backdropFilter: "blur(20px)",
              border: "1px solid rgba(124, 179, 66, 0.3)",
              borderRadius: 2,
              height: "100%"
            }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "space-between", alignItems: "flex-start", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { flex: 1, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 1, mb: 1, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#fff", fontWeight: 600 }, children: vendor.name }),
                    vendor.verified && /* @__PURE__ */ jsxRuntimeExports.jsx(VerifiedIcon, { sx: { fontSize: 20, color: "#7cb342" } })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, flexWrap: "wrap", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Chip,
                      {
                        label: vendor.source,
                        size: "small",
                        sx: { bgcolor: "rgba(255,255,255,0.2)", color: "#fff", fontSize: "0.65rem", height: 18 }
                      }
                    ),
                    vendor.country && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Chip,
                      {
                        label: vendor.country,
                        size: "small",
                        sx: { bgcolor: "rgba(124, 179, 66, 0.3)", color: "#fff", fontSize: "0.65rem", height: 18 }
                      }
                    )
                  ] })
                ] }),
                (vendor.website || vendor.product_url) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IconButton$1,
                  {
                    size: "small",
                    component: "a",
                    href: vendor.website || vendor.product_url,
                    target: "_blank",
                    sx: { color: "#7cb342" },
                    title: "Visit Website",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageIcon, {})
                  }
                )
              ] }),
              vendor.description && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#e0e0e0" }, children: vendor.description }),
              vendor.price && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h6", sx: { color: "#7cb342", fontWeight: 600 }, children: [
                  "$",
                  vendor.price,
                  " ",
                  vendor.currency || "USD"
                ] }),
                vendor.seed_count && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", sx: { color: "#e0e0e0" }, children: [
                  vendor.seed_count,
                  " seeds"
                ] })
              ] }),
              vendor.rating > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 0.5, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(StarIcon, { sx: { fontSize: 16, color: "#ffd600" } }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#fff" }, children: [
                  vendor.rating,
                  " ",
                  vendor.review_count > 0 && `(${vendor.review_count} reviews)`
                ] })
              ] }),
              vendor.shipping_regions && vendor.shipping_regions.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 1, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(LocalShippingIcon, { sx: { fontSize: 16, color: "#7cb342" } }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", sx: { color: "#e0e0e0" }, children: [
                  "Ships to: ",
                  vendor.shipping_regions.join(", ")
                ] })
              ] }),
              vendor.payment_methods && vendor.payment_methods.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 1, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(PaymentIcon, { sx: { fontSize: 16, color: "#7cb342" } }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { color: "#e0e0e0" }, children: vendor.payment_methods.join(", ") })
              ] }),
              vendor.in_stock !== void 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                Chip,
                {
                  label: vendor.in_stock ? "In Stock" : "Out of Stock",
                  size: "small",
                  sx: {
                    bgcolor: vendor.in_stock ? "rgba(76, 175, 80, 0.3)" : "rgba(244, 67, 54, 0.3)",
                    color: "#fff",
                    fontSize: "0.75rem",
                    width: "fit-content"
                  }
                }
              ),
              (vendor.website || vendor.product_url) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  fullWidth: true,
                  variant: "contained",
                  component: "a",
                  href: vendor.website || vendor.product_url,
                  target: "_blank",
                  sx: {
                    bgcolor: "#7cb342",
                    "&:hover": { bgcolor: "#689f38" }
                  },
                  children: "Visit Store "
                }
              )
            ] }) }) }) }, vendor.id)) })
          ] })
        ] })
      ]
    }
  );
}
function BackHeader$1({ title, onBack }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        display: "flex",
        alignItems: "center",
        paddingTop: "calc(env(safe-area-inset-top) + 8px)",
        paddingBottom: 1,
        px: 1.5,
        gap: 1,
        flexShrink: 0,
        borderBottom: "1px solid rgba(255,255,255,0.08)",
        backgroundColor: "rgba(0,0,0,0.2)",
        backdropFilter: "blur(8px)"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton$1,
          {
            edge: "start",
            onClick: onBack,
            sx: {
              color: "#fff",
              "&:hover": {
                backgroundColor: "rgba(124, 179, 66, 0.2)"
              }
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowBackIcon, {})
          }
        ),
        title && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", fontWeight: 600, sx: { color: "#fff", flex: 1 }, children: title })
      ]
    }
  );
}
function DispensaryFinder({ onBack, strainSlug }) {
  const [dispensaries, setDispensaries] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(false);
  const [error2, setError] = reactExports.useState(null);
  const [userLocation, setUserLocation] = reactExports.useState(null);
  const [radius, setRadius] = reactExports.useState(10);
  const [locationStatus, setLocationStatus] = reactExports.useState("detecting");
  const initialRadiusRef = reactExports.useRef(10);
  const searchDispensaries = reactExports.useCallback((lat, lng, searchRadius) => __async(null, null, function* () {
    setLoading(true);
    setError(null);
    try {
      let url = `${API_BASE}/api/dispensaries-live?lat=${lat}&lng=${lng}&radius=${searchRadius}&limit=100`;
      if (strainSlug) {
        url += `&strain=${strainSlug}`;
      }
      const response = yield fetch(url);
      if (!response.ok) throw new Error("Search failed");
      const data = yield response.json();
      setDispensaries(data.results || []);
    } catch (err) {
      console.error("Dispensary search failed:", err);
      setError("Failed to find dispensaries. Please try again.");
    } finally {
      setLoading(false);
    }
  }), [strainSlug]);
  reactExports.useEffect(() => {
    let timeoutId;
    function requestLocation() {
      return __async(this, null, function* () {
        if (!navigator.geolocation) {
          setLocationStatus("unsupported");
          setError("Geolocation is not supported by your browser. Please search manually.");
          return;
        }
        try {
          setLocationStatus("detecting");
          setError(null);
          timeoutId = setTimeout(() => {
            setLocationStatus("timeout");
            setError("Location request timed out. Please try again.");
          }, 8e3);
          const pos = yield new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, {
              enableHighAccuracy: true,
              timeout: 7e3,
              maximumAge: 0
            });
          });
          clearTimeout(timeoutId);
          const location = {
            lat: pos.coords.latitude,
            lng: pos.coords.longitude
          };
          console.log("[DispensaryFinder] Location obtained:", location);
          setUserLocation(location);
          setLocationStatus("success");
          searchDispensaries(location.lat, location.lng, initialRadiusRef.current);
        } catch (err) {
          clearTimeout(timeoutId);
          console.error("[DispensaryFinder] Geolocation error", err);
          if (err.code === 1) {
            setLocationStatus("denied");
            setError("Location access denied. Please enable location services in your device settings.");
          } else {
            setLocationStatus("timeout");
            setError("Unable to get your location. Please try again or enable location services.");
          }
        }
      });
    }
    requestLocation();
    return () => {
      if (timeoutId) clearTimeout(timeoutId);
    };
  }, [searchDispensaries]);
  const handleRadiusChange = (_event, newValue) => {
    setRadius(newValue);
    if (userLocation) {
      searchDispensaries(userLocation.lat, userLocation.lng, newValue);
    }
  };
  const handleSearch = () => {
    if (userLocation) {
      searchDispensaries(userLocation.lat, userLocation.lng, radius);
    }
  };
  const openPlaceOnMaps = (dispensary) => {
    if (dispensary.place_id) {
      window.open(`https://www.google.com/maps/place/?q=place_id:${dispensary.place_id}`, "_blank");
      return;
    }
    const name2 = dispensary.name || dispensary.business_name || dispensary.legal_name || dispensary.title;
    const parts = [];
    if (name2) parts.push(name2);
    if (dispensary.address) parts.push(dispensary.address);
    if (dispensary.formatted_address) parts.push(dispensary.formatted_address);
    const cityState = [dispensary.city, dispensary.state].filter(Boolean).join(", ").trim();
    if (cityState) parts.push(cityState);
    if (dispensary.postal_code) parts.push(dispensary.postal_code);
    if (!dispensary.address && !dispensary.city && !dispensary.state && dispensary.latitude !== void 0 && dispensary.longitude !== void 0) {
      parts.push(`${dispensary.latitude}, ${dispensary.longitude}`);
    }
    if (parts.length > 0) {
      const query = encodeURIComponent(parts.join(", "));
      window.open(`https://www.google.com/maps/search/?api=1&query=${query}`, "_blank");
      return;
    }
    if (dispensary.latitude !== void 0 && dispensary.longitude !== void 0) {
      window.open(`https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(`${dispensary.latitude},${dispensary.longitude}`)}`, "_blank");
    }
  };
  const getDirections = (lat, lng) => {
    window.open(`https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`, "_blank");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
    display: "flex",
    flexDirection: "column",
    height: "100vh",
    overflow: "hidden",
    background: "none"
  }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(BackHeader$1, { title: "Dispensary Finder", onBack }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
      flex: 1,
      minHeight: 0,
      overflowY: "auto",
      WebkitOverflowScrolling: "touch",
      px: 2,
      pb: 2,
      pt: 1
    }, children: [
      locationStatus === "detecting" && !error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", justifyContent: "center", py: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, alignItems: "center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { sx: { color: "#7cb342" } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#e0e0e0" }, children: "Getting your location" })
      ] }) }),
      error2 && locationStatus !== "success" && /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper, { sx: {
        p: 3,
        mb: 2,
        background: "rgba(255,255,255,0.1)",
        backdropFilter: "blur(20px)",
        border: "1px solid rgba(124, 179, 66, 0.3)",
        borderRadius: 2
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "warning", sx: { mb: 2, bgcolor: "rgba(255, 193, 7, 0.15)", color: "#fff", border: "1px solid rgba(255, 193, 7, 0.4)" }, children: error2 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "contained",
            fullWidth: true,
            onClick: () => {
              setError(null);
              setLocationStatus("detecting");
              setUserLocation(null);
              setTimeout(() => {
                if (navigator.geolocation) {
                  navigator.geolocation.getCurrentPosition(
                    (position2) => {
                      const location = {
                        lat: position2.coords.latitude,
                        lng: position2.coords.longitude
                      };
                      setUserLocation(location);
                      setLocationStatus("success");
                      searchDispensaries(location.lat, location.lng, initialRadiusRef.current);
                    },
                    (err) => {
                      if (err.code === 1) {
                        setLocationStatus("denied");
                        setError("Location access denied. Please enable location services in your device settings.");
                      } else {
                        setLocationStatus("timeout");
                        setError("Unable to get your location. Please try again.");
                      }
                    },
                    {
                      enableHighAccuracy: true,
                      timeout: 7e3,
                      maximumAge: 0
                    }
                  );
                }
              }, 100);
            },
            sx: {
              bgcolor: "#7cb342",
              "&:hover": { bgcolor: "#689f38" }
            },
            children: "Try Again"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Paper, { sx: {
        p: 2,
        mb: 2,
        background: "rgba(255,255,255,0.1)",
        backdropFilter: "blur(20px)",
        border: "1px solid rgba(124, 179, 66, 0.3)",
        borderRadius: 2
      }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#fff", mb: 1 }, children: [
            "Search Radius: ",
            radius,
            " miles"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Slider,
            {
              value: radius,
              onChange: handleRadiusChange,
              min: 1,
              max: 100,
              step: 1,
              marks: [
                { value: 1, label: "1mi" },
                { value: 25, label: "25mi" },
                { value: 50, label: "50mi" },
                { value: 100, label: "100mi" }
              ],
              sx: {
                color: "#7cb342",
                "& .MuiSlider-markLabel": { color: "#fff", fontSize: "0.75rem" }
              }
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "contained",
            onClick: handleSearch,
            disabled: !userLocation || loading,
            sx: {
              bgcolor: "#7cb342",
              "&:hover": { bgcolor: "#689f38" }
            },
            children: loading ? "Searching..." : "Search Dispensaries"
          }
        )
      ] }) }),
      error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mb: 2 }, children: error2 }),
      loading && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", justifyContent: "center", py: 8 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { sx: { color: "#7cb342" } }) }),
      !loading && dispensaries.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper, { sx: {
        p: 4,
        textAlign: "center",
        background: "rgba(255,255,255,0.1)",
        backdropFilter: "blur(20px)",
        border: "1px solid rgba(124, 179, 66, 0.3)",
        borderRadius: 2
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#fff", mb: 2 }, children: "No dispensaries found" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#e0e0e0" }, children: "Try increasing the search radius or check back later." })
      ] }),
      !loading && dispensaries.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#e0e0e0", mb: 2 }, children: [
          "Found ",
          dispensaries.length,
          " dispensaries within ",
          radius,
          " miles"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 2, children: dispensaries.map((dispensary) => /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: {
          background: "rgba(255,255,255,0.1)",
          backdropFilter: "blur(20px)",
          border: "1px solid rgba(124, 179, 66, 0.3)",
          borderRadius: 2
        }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardActionArea, { onClick: () => openPlaceOnMaps(dispensary), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "space-between", alignItems: "flex-start", mb: 2, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { flex: 1, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 1, mb: 1, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#fff", fontWeight: 600 }, children: dispensary.name }),
                dispensary.verified && /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: "Verified", size: "small", sx: { bgcolor: "#7cb342", color: "#fff", fontSize: "0.7rem", height: 20 } }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Chip,
                  {
                    label: dispensary.source,
                    size: "small",
                    sx: { bgcolor: "rgba(255,255,255,0.2)", color: "#fff", fontSize: "0.65rem", height: 18 }
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 0.5, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 1, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(LocationOnIcon, { sx: { fontSize: 16, color: "#7cb342" } }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#e0e0e0" }, children: dispensary.address || `${dispensary.city}, ${dispensary.state}` })
                ] }),
                dispensary.distance !== void 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#7cb342", fontWeight: 600 }, children: [
                  " ",
                  dispensary.distance.toFixed(1),
                  " miles away"
                ] }),
                dispensary.rating > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 0.5, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(StarIcon, { sx: { fontSize: 16, color: "#ffd600" } }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#fff" }, children: [
                    dispensary.rating,
                    " (",
                    dispensary.review_count,
                    " reviews)"
                  ] })
                ] }),
                dispensary.open_now !== void 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Chip,
                  {
                    label: dispensary.open_now ? "Open Now" : "Closed",
                    size: "small",
                    sx: {
                      bgcolor: dispensary.open_now ? "rgba(76, 175, 80, 0.3)" : "rgba(244, 67, 54, 0.3)",
                      color: "#fff",
                      fontSize: "0.75rem",
                      width: "fit-content"
                    }
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 1, children: [
              dispensary.latitude && dispensary.longitude && /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton$1,
                {
                  size: "small",
                  onClick: (event) => {
                    event.stopPropagation();
                    getDirections(dispensary.latitude, dispensary.longitude);
                  },
                  sx: { color: "#7cb342" },
                  title: "Get Directions",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(DirectionsIcon, {})
                }
              ),
              dispensary.phone && /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton$1,
                {
                  size: "small",
                  component: "a",
                  href: `tel:${dispensary.phone}`,
                  onClick: (event) => event.stopPropagation(),
                  sx: { color: "#7cb342" },
                  title: "Call",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(PhoneIcon, {})
                }
              ),
              dispensary.website && /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton$1,
                {
                  size: "small",
                  component: "a",
                  href: dispensary.website,
                  target: "_blank",
                  onClick: (event) => event.stopPropagation(),
                  sx: { color: "#7cb342" },
                  title: "Visit Website",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageIcon, {})
                }
              )
            ] })
          ] }),
          dispensary.description && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#e0e0e0", mt: 1 }, children: dispensary.description })
        ] }) }) }, dispensary.id)) })
      ] })
    ] })
  ] });
}
function FeedbackModal({ open, onClose, user }) {
  const [input, setInput] = reactExports.useState("");
  const [submitting, setSubmitting] = reactExports.useState(false);
  const [success, setSuccess] = reactExports.useState(false);
  const [error2, setError] = reactExports.useState(null);
  const handleSubmit = () => __async(null, null, function* () {
    if (!input.trim()) return;
    if (!user || !user.id) {
      setError("Please log in to submit feedback.");
      return;
    }
    setSubmitting(true);
    setError(null);
    try {
      const res = yield fetch(`${API_BASE}/api/feedback/messages`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ content: input, user_id: user.id })
      });
      if (res.ok) {
        setSuccess(true);
        setInput("");
        setTimeout(() => {
          setSuccess(false);
          onClose();
        }, 2e3);
      } else {
        const data = yield res.json();
        setError(data.error || "Failed to send feedback.");
      }
    } catch (err) {
      setError("Network error. Please try again.");
    }
    setSubmitting(false);
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Modal, { open, onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
    position: "absolute",
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)",
    width: 380,
    bgcolor: "rgba(255,255,255,0.15)",
    backdropFilter: "blur(12px)",
    border: "2px solid #4caf50",
    boxShadow: 24,
    p: 4,
    borderRadius: 3
  }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { mb: 2, color: "black", fontWeight: 700 }, children: "Send Feedback" }),
    !user || !user.id ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: { mb: 2, color: "black" }, children: "Please log in to submit feedback. This helps us follow up with you if needed." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outlined", onClick: onClose, sx: { fontWeight: 700, color: "black", borderColor: "#4caf50" }, children: "Close" })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextField,
        {
          multiline: true,
          minRows: 3,
          maxRows: 6,
          fullWidth: true,
          placeholder: "Share your thoughts, suggestions, or issues...",
          value: input,
          onChange: (e) => setInput(e.target.value),
          sx: { mb: 2, background: "rgba(255,255,255,0.10)", borderRadius: 2, input: { color: "black" } }
        }
      ),
      error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { color: "error", sx: { mb: 1 }, children: error2 }),
      success && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { color: "success.main", sx: { mb: 1 }, children: "Thank you for your feedback!" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "contained", onClick: handleSubmit, disabled: submitting || !input.trim(), sx: { fontWeight: 700, background: "#4caf50", color: "black" }, children: submitting ? "Sending" : "Send" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outlined", onClick: onClose, sx: { fontWeight: 700, color: "black", borderColor: "#4caf50" }, children: "Cancel" })
      ] })
    ] })
  ] }) });
}
const BANNED_NAME_FRAGMENTS = [
  "set the",
  "set the experience",
  "set the vape",
  "set the full spectrum",
  "full spectrum vape cartridge",
  "full spectrum cartridge",
  "full spectrum totals",
  "total cannabinoids",
  "activation time",
  "activation approx",
  "activation approx.",
  "for use by",
  "not approved",
  "keep out of reach",
  "testing lab",
  "lab:",
  "coa",
  "batch",
  "date made",
  "test date",
  "exp. date",
  "suite",
  "tel",
  "ocked the rich te",
  "rm. our full-spectrum",
  "rm. our full-spectre",
  "r full spectrum prode"
];
function cleanCandidateName(raw) {
  if (!raw) return null;
  let s = String(raw).trim().replace(/\s+/g, " ");
  if (s.length < 3) return null;
  const lower = s.toLowerCase();
  if (BANNED_NAME_FRAGMENTS.some((f) => lower.includes(f))) {
    return null;
  }
  return s;
}
function transformScanResult(scan) {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _i;
  if (!scan) return null;
  const ai = scan.ai_summary || {};
  const pkg = scan.packaging_insights || {};
  const label = scan.label_insights || {};
  const visual = ((_b = (_a2 = scan.result) == null ? void 0 : _a2.visualMatches) == null ? void 0 : _b[0]) || null;
  const result = scan.result || {};
  const canonicalStrain = scan.canonicalStrain || result.canonicalStrain || null;
  const seedBank = result.seedBank || null;
  const growProfile = result.growProfile || null;
  const isPackaged = !!pkg.strainName || !!label.strainName || (canonicalStrain == null ? void 0 : canonicalStrain.source) === "packaging";
  let finalStrain = null;
  if (canonicalStrain && canonicalStrain.name && canonicalStrain.name !== "Cannabis (strain unknown)") {
    finalStrain = canonicalStrain.name;
  } else {
    const packagingStrain = pkg.strainName || label.strainName || null;
    const visualStrain = (visual == null ? void 0 : visual.name) && visual.confidence >= 0.8 ? visual.name : null;
    finalStrain = isPackaged ? packagingStrain : visualStrain;
  }
  const isPackagedKnown = isPackaged && (canonicalStrain && canonicalStrain.confidence === 1 || !!pkg.strainName || !!label.strainName);
  const isBudUnknown = !isPackaged && !finalStrain;
  const potency = pkg.potency || {};
  const thc = (_e = (_d = (_c = potency.thc_percent) != null ? _c : potency.thc_total_percent) != null ? _d : label.thc) != null ? _e : null;
  const cbd = (_h = (_g = (_f = potency.cbd_percent) != null ? _f : potency.cbd_total_percent) != null ? _g : label.cbd) != null ? _h : null;
  const aiIntensity = ai.intensity || null;
  const aiEffects = Array.isArray(ai.effects) ? ai.effects : Array.isArray(ai.effectsAndUseCases) ? ai.effectsAndUseCases : [];
  const aiFlavors = Array.isArray(ai.flavors) ? ai.flavors : [];
  const aiAromas = Array.isArray(ai.aromas) ? ai.aromas : [];
  const aiSummaryText = typeof ai.summary === "string" ? ai.summary : typeof ai.userFacingSummary === "string" ? ai.userFacingSummary : "";
  const aiDispensaryNotes = Array.isArray(ai.dispensaryNotes) ? ai.dispensaryNotes : typeof ai.dispensaryNotes === "string" && ai.dispensaryNotes.trim() ? [ai.dispensaryNotes.trim()] : typeof ai.dispensary_notes === "string" && ai.dispensary_notes.trim() ? [ai.dispensary_notes.trim()] : Array.isArray(ai.dispensary_notes) ? ai.dispensary_notes : [];
  const aiGrowerNotes = Array.isArray(ai.growerNotes) ? ai.growerNotes : typeof ai.growerNotes === "string" && ai.growerNotes.trim() ? [ai.growerNotes.trim()] : typeof ai.grower_notes === "string" && ai.grower_notes.trim() ? [ai.grower_notes.trim()] : Array.isArray(ai.grower_notes) ? ai.grower_notes : [];
  const aiWarnings = Array.isArray(ai.warnings) ? ai.warnings : Array.isArray(ai.risksAndWarnings) ? ai.risksAndWarnings : [];
  let effectsTags = [];
  let flavorTags = [];
  const visualConfidence = (visual == null ? void 0 : visual.confidence) || scan.match_confidence || 0;
  if (isPackaged) {
    effectsTags = aiEffects || [];
    flavorTags = aiFlavors || [];
  } else {
    if (visualConfidence >= 0.8) {
      effectsTags = aiEffects || [];
      flavorTags = aiFlavors || [];
    } else {
      effectsTags = [];
      flavorTags = [];
    }
  }
  let displayStrainName = finalStrain || "Cannabis (strain unknown)";
  if (isPackaged && canonicalStrain && canonicalStrain.confidence === 1 && canonicalStrain.name) {
    displayStrainName = canonicalStrain.name;
  }
  const strainHeroImageUrl = result.strainHeroImageUrl || (canonicalStrain == null ? void 0 : canonicalStrain.heroImageUrl) || (canonicalStrain == null ? void 0 : canonicalStrain.image_url) || null;
  const scanImageUrl = scan.image_url || null;
  const heroImageUrl = strainHeroImageUrl || scanImageUrl || null;
  return {
    strainName: displayStrainName,
    canonicalStrain,
    // Include canonical strain object
    seedBank,
    // Include seedBank data
    growProfile,
    // Include growProfile data
    isPackagedProduct: isPackaged,
    isPackagedKnown,
    isBudUnknown,
    matchConfidence: (_i = canonicalStrain == null ? void 0 : canonicalStrain.confidence) != null ? _i : visualConfidence,
    thc,
    cbd,
    effectsTags,
    flavorTags,
    intensity: aiIntensity,
    dispensaryNotes: aiDispensaryNotes,
    growerNotes: aiGrowerNotes,
    warnings: aiWarnings,
    summary: aiSummaryText,
    aromaTags: aiAromas,
    // New field for aromas
    heroImageUrl,
    // Hero image URL (strain hero or scan image)
    scanImageUrl,
    // Original scan image URL
    // Keep old field names for backward compatibility
    aiIntensity,
    aiSummaryText,
    aiDispensaryNotes,
    aiGrowerNotes,
    aiWarnings,
    // Preserve original fields for backward compatibility
    packaging_insights: pkg,
    label_insights: label,
    ai_summary: ai,
    result: scan.result
  };
}
function normalizeScanResult(scan) {
  var _a2, _b, _c;
  if (!scan || !scan.result) return null;
  const result = (scan == null ? void 0 : scan.result) || {};
  const transformed = transformScanResult(scan);
  if (!transformed) return null;
  let matchesFromVisual = [];
  if (result.visualMatches) {
    const topMatch = result.visualMatches.match;
    const candidates = Array.isArray(result.visualMatches.candidates) ? result.visualMatches.candidates : [];
    if (topMatch) {
      matchesFromVisual = [topMatch, ...candidates];
    } else if (candidates.length > 0) {
      matchesFromVisual = candidates;
    }
  }
  let matchesFromFlat = [];
  if (Array.isArray(result.matches)) {
    matchesFromFlat = result.matches;
  } else if (result.match) {
    matchesFromFlat = [result.match];
  }
  const allMatches = matchesFromVisual.length > 0 ? matchesFromVisual : matchesFromFlat;
  const toItem = (candidate) => {
    var _a3, _b2, _c2;
    const strainObj = candidate.strain || candidate;
    const confidence = (_c2 = (_b2 = (_a3 = candidate.confidence) != null ? _a3 : candidate.score) != null ? _b2 : candidate.probability) != null ? _c2 : 0;
    const slug = strainObj.strain_slug || strainObj.slug || strainObj.id || null;
    return {
      id: slug || strainObj.name || "unknown",
      slug,
      name: strainObj.name || "Unknown strain",
      type: strainObj.type || strainObj.category || "Hybrid",
      description: strainObj.description || strainObj.summary || "",
      confidence,
      dbMeta: strainObj
    };
  };
  const [first, ...rest] = allMatches.length > 0 ? allMatches : [null];
  const labelInsights = result.labelInsights || ((_a2 = result.visualMatches) == null ? void 0 : _a2.labelInsights) || transformed.label_insights || null;
  if (labelInsights && !labelInsights.rawText) {
    labelInsights.rawText = result.rawText || result.detectedText || "";
  }
  const matched_strain_slug = result.matched_strain_slug || (scan == null ? void 0 : scan.matched_strain_slug) || ((_b = first == null ? void 0 : first.strain) == null ? void 0 : _b.strain_slug) || ((_c = first == null ? void 0 : first.strain) == null ? void 0 : _c.slug) || (first == null ? void 0 : first.strain_slug) || (first == null ? void 0 : first.slug) || transformed.matched_strain_slug || null;
  const packagingInsights = result.packagingInsights || transformed.packaging_insights || null;
  return {
    topMatch: first ? toItem(first) : null,
    otherMatches: rest.map(toItem),
    matches: allMatches.map(toItem),
    matched_strain_slug,
    labelInsights,
    aiSummary: (labelInsights == null ? void 0 : labelInsights.aiSummary) || transformed.ai_summary || null,
    isPackagedProduct: transformed.isPackagedProduct || false,
    packagingInsights,
    visionRaw: result.vision_raw || null,
    // CRITICAL: Include transformed fields for UI components
    strainName: transformed.strainName,
    strainSource: transformed.strainSource,
    effectsTags: transformed.effectsTags,
    flavorTags: transformed.flavorTags,
    matchConfidence: transformed.matchConfidence
  };
}
function getScanKindLabel({ isPackagedProduct, category, productType }) {
  if (isPackagedProduct) {
    const lowerCategory = (category || "").toLowerCase();
    const lowerProductType = (productType || "").toLowerCase();
    if (lowerCategory === "vape" || lowerProductType.includes("vape") || lowerProductType.includes("cartridge")) {
      return "Vape cartridge";
    }
    if (lowerCategory === "concentrate" || lowerProductType.includes("concentrate") || lowerProductType.includes("sauce") || lowerProductType.includes("rosin") || lowerProductType.includes("wax") || lowerProductType.includes("shatter")) {
      return "Concentrate";
    }
    if (lowerProductType.includes("pre-roll") || lowerProductType.includes("preroll")) {
      return "Pre-roll";
    }
    if (lowerCategory === "edible" || lowerProductType.includes("edible")) {
      return "Edible";
    }
    if (lowerCategory === "flower" || lowerProductType.includes("flower")) {
      return "Flower";
    }
    return "Packaged product";
  }
  if (category === "flower") {
    return "Flower strain";
  }
  return "Plant";
}
function AIStrainDetailsPanel({
  intensity,
  effects,
  flavors,
  dispensaryNotes,
  growerNotes,
  warnings,
  summary
}) {
  if (!intensity && (!effects || effects.length === 0) && (!flavors || flavors.length === 0) && (!dispensaryNotes || dispensaryNotes.length === 0) && (!growerNotes || growerNotes.length === 0) && (!warnings || warnings.length === 0) && !summary) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        mt: 3,
        p: 3,
        borderRadius: 2,
        background: "rgba(0, 0, 0, 0.35)",
        backdropFilter: "blur(12px)",
        border: "1px solid rgba(124, 179, 66, 0.2)"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Typography,
          {
            variant: "overline",
            sx: {
              color: "rgba(200, 230, 201, 0.7)",
              textTransform: "uppercase",
              letterSpacing: 1,
              fontSize: "0.75rem",
              fontWeight: 600
            },
            children: "AI STRAIN DETAILS"
          }
        ),
        intensity != null && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mt: 1 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Typography,
            {
              variant: "caption",
              sx: {
                color: "rgba(200, 230, 201, 0.7)",
                display: "block",
                mb: 0.5
              },
              children: [
                "Intensity",
                typeof intensity === "string" && `: ${intensity}`
              ]
            }
          ),
          (() => {
            let intensityValue = 0;
            if (typeof intensity === "number") {
              intensityValue = intensity;
            } else if (typeof intensity === "string") {
              const upper = intensity.toUpperCase();
              if (upper === "HIGH") intensityValue = 0.9;
              else if (upper === "MEDIUM") intensityValue = 0.6;
              else if (upper === "LOW") intensityValue = 0.3;
            }
            return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mt: 0.5, display: "flex", gap: 0.5 }, children: Array.from({ length: 5 }).map((_, i) => {
              const filled = intensityValue >= (i + 1) / 5;
              return /* @__PURE__ */ jsxRuntimeExports.jsx(
                Box,
                {
                  sx: {
                    width: 10,
                    height: 10,
                    borderRadius: "50%",
                    opacity: filled ? 1 : 0.3,
                    backgroundColor: "#9AE66E"
                  }
                },
                i
              );
            }) });
          })()
        ] }),
        effects && effects.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mt: 2 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "caption",
              sx: {
                color: "rgba(200, 230, 201, 0.7)",
                display: "block",
                mb: 0.5
              },
              children: "Likely effects"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mt: 0.5, display: "flex", flexWrap: "wrap", gap: 0.5 }, children: Array.isArray(effects) && effects.map((effect2, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            Chip,
            {
              size: "small",
              label: typeof effect2 === "string" ? effect2 : effect2.name || String(effect2),
              sx: {
                bgcolor: "rgba(178, 255, 89, 0.08)",
                border: "1px solid rgba(200, 255, 140, 0.85)",
                color: "#e8ffca",
                fontSize: "0.75rem"
              }
            },
            idx
          )) })
        ] }),
        flavors && flavors.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mt: 2 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "caption",
              sx: {
                color: "rgba(200, 230, 201, 0.7)",
                display: "block",
                mb: 0.5
              },
              children: "Aroma & flavor"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mt: 0.5, display: "flex", flexWrap: "wrap", gap: 0.5 }, children: Array.isArray(flavors) && flavors.map((flavor, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            Chip,
            {
              size: "small",
              label: typeof flavor === "string" ? flavor : flavor.name || String(flavor),
              sx: {
                bgcolor: "rgba(255, 248, 225, 0.06)",
                border: "1px solid rgba(255, 236, 179, 0.7)",
                color: "#fff8e1",
                fontSize: "0.75rem"
              }
            },
            idx
          )) })
        ] }),
        summary && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mt: 2 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "caption",
              sx: {
                color: "rgba(200, 230, 201, 0.7)",
                display: "block",
                mb: 0.5
              },
              children: "Overview"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "body2",
              sx: {
                color: "rgba(224, 242, 241, 0.85)",
                lineHeight: 1.6,
                mt: 0.5
              },
              children: summary
            }
          )
        ] }),
        dispensaryNotes && dispensaryNotes.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mt: 2 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "caption",
              sx: {
                color: "rgba(200, 230, 201, 0.7)",
                display: "block",
                mb: 0.5
              },
              children: "For dispensaries"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { component: "ul", sx: { marginTop: 0.5, paddingLeft: 2.25, marginBottom: 0 }, children: Array.isArray(dispensaryNotes) && dispensaryNotes.map((note, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { component: "li", sx: { mb: 0.5 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "rgba(224, 242, 241, 0.85)" }, children: note }) }, idx)) })
        ] }),
        growerNotes && growerNotes.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mt: 2 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "caption",
              sx: {
                color: "rgba(200, 230, 201, 0.7)",
                display: "block",
                mb: 0.5
              },
              children: "For growers"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { component: "ul", sx: { marginTop: 0.5, paddingLeft: 2.25, marginBottom: 0 }, children: Array.isArray(growerNotes) && growerNotes.map((note, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { component: "li", sx: { mb: 0.5 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "rgba(224, 242, 241, 0.85)" }, children: note }) }, idx)) })
        ] }),
        warnings && warnings.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mt: 2 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "caption",
              sx: {
                color: "rgba(200, 230, 201, 0.7)",
                display: "block",
                mb: 0.5
              },
              children: "Warnings"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { component: "ul", sx: { marginTop: 0.5, paddingLeft: 2.25, marginBottom: 0 }, children: Array.isArray(warnings) && warnings.map((w, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { component: "li", sx: { mb: 0.5 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "rgba(255, 152, 152, 0.9)" }, children: w }) }, idx)) })
        ] })
      ]
    }
  );
}
function PackagedProductCard({
  strainName,
  thc,
  cbd,
  summary,
  effects,
  flavors,
  intensity,
  dispensaryNotes,
  growerNotes,
  warnings,
  result,
  scan,
  proRole,
  proEnabled,
  seedBank,
  growProfile,
  canonicalStrain,
  heroImageUrl,
  onViewSeeds
}) {
  const packagingInsights = (result == null ? void 0 : result.packaging_insights) || (scan == null ? void 0 : scan.packaging_insights) || null;
  const labelInsights = (result == null ? void 0 : result.label_insights) || (scan == null ? void 0 : scan.label_insights) || null;
  const lineage = (packagingInsights == null ? void 0 : packagingInsights.lineage) || (labelInsights == null ? void 0 : labelInsights.lineage) || null;
  const basic = (packagingInsights == null ? void 0 : packagingInsights.basic) || {};
  const details = (packagingInsights == null ? void 0 : packagingInsights.package_details) || {};
  const brandName = basic.brand_name || details.brand || (labelInsights == null ? void 0 : labelInsights.brandName) || null;
  const showTHCCBD = thc != null || cbd != null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    heroImageUrl && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        sx: {
          mb: 2,
          borderRadius: 2,
          overflow: "hidden",
          border: "1px solid",
          borderColor: "rgba(124, 179, 66, 0.3)"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            component: "img",
            src: heroImageUrl,
            alt: strainName || "Strain photo",
            sx: {
              width: "100%",
              height: 220,
              objectFit: "cover",
              display: "block"
            },
            onError: (e) => {
              e.currentTarget.style.display = "none";
            }
          }
        )
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Card,
      {
        variant: "outlined",
        sx: {
          mb: 2,
          borderColor: "rgba(165, 214, 167, 0.35)",
          background: "radial-gradient(circle at top left, rgba(129, 199, 132, 0.12), transparent 55%), #0b100a"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", justifyContent: "space-between", alignItems: "flex-start", mb: 1 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { flex: 1 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", gap: 1, mb: 0.5 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Typography,
                  {
                    variant: "overline",
                    sx: {
                      color: "rgba(200, 230, 201, 0.7)",
                      letterSpacing: 1
                    },
                    children: "Label-based match"
                  }
                ),
                proEnabled && proRole && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Chip,
                  {
                    label: proRole === "dispensary" ? "Dispensary" : "Grower",
                    size: "small",
                    sx: {
                      height: "20px",
                      fontSize: "0.65rem",
                      bgcolor: "rgba(124, 179, 66, 0.2)",
                      color: "#9AE66E",
                      border: "1px solid rgba(124, 179, 66, 0.4)"
                    }
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Typography,
                {
                  variant: "h6",
                  sx: { fontWeight: 700, color: "#E8F5E9", mb: 0.5 },
                  children: strainName
                }
              ),
              lineage && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Typography,
                {
                  variant: "body2",
                  sx: { color: "rgba(200, 230, 201, 0.75)", fontSize: "0.875rem", mb: 0.5 },
                  children: [
                    "Lineage: ",
                    lineage
                  ]
                }
              ),
              brandName && /* @__PURE__ */ jsxRuntimeExports.jsx(
                Typography,
                {
                  variant: "body2",
                  sx: { color: "rgba(200, 230, 201, 0.85)", mb: 1 },
                  children: brandName
                }
              )
            ] }),
            showTHCCBD && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { ml: 2, textAlign: "right" }, children: [
              thc != null && /* @__PURE__ */ jsxRuntimeExports.jsx(
                Chip,
                {
                  label: `THC ${thc}%`,
                  size: "small",
                  sx: {
                    bgcolor: "rgba(255, 204, 128, 0.15)",
                    color: "#FFCC80",
                    border: "1px solid rgba(255, 204, 128, 0.3)",
                    mb: 0.5,
                    display: "block"
                  }
                }
              ),
              cbd != null && /* @__PURE__ */ jsxRuntimeExports.jsx(
                Chip,
                {
                  label: `CBD ${cbd}%`,
                  size: "small",
                  sx: {
                    bgcolor: "rgba(179, 229, 252, 0.15)",
                    color: "#B3E5FC",
                    border: "1px solid rgba(179, 229, 252, 0.3)"
                  }
                }
              )
            ] })
          ] }),
          details.net_weight_label || details.net_weight ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Typography,
            {
              variant: "caption",
              sx: { color: "rgba(200, 230, 201, 0.7)", display: "block", mt: 1 },
              children: [
                "Package size: ",
                details.net_weight_label || details.net_weight
              ]
            }
          ) : null
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AIStrainDetailsPanel,
      {
        intensity,
        effects,
        flavors,
        dispensaryNotes,
        growerNotes,
        warnings,
        summary
      }
    ),
    (seedBank || growProfile) && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box,
      {
        sx: {
          mt: 3,
          p: 3,
          borderRadius: 2,
          background: "rgba(0, 0, 0, 0.35)",
          backdropFilter: "blur(12px)",
          border: "1px solid rgba(124, 179, 66, 0.2)"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "overline",
              sx: {
                color: "rgba(200, 230, 201, 0.7)",
                textTransform: "uppercase",
                letterSpacing: 1,
                fontSize: "0.75rem",
                fontWeight: 600,
                display: "block",
                mb: 2
              },
              children: "Seed Info & Grow Profile"
            }
          ),
          seedBank && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 2 }, children: [
            (seedBank == null ? void 0 : seedBank.breeder) ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Typography,
              {
                variant: "body2",
                sx: {
                  color: "rgba(200, 230, 201, 0.85)",
                  mb: 0.5
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Breeder:" }),
                  " ",
                  seedBank.breeder
                ]
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Typography,
              {
                variant: "body2",
                sx: {
                  color: "rgba(200, 230, 201, 0.6)",
                  mb: 0.5
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Breeder:" }),
                  " Unknown breeder"
                ]
              }
            ),
            (seedBank == null ? void 0 : seedBank.type) && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Typography,
              {
                variant: "body2",
                sx: {
                  color: "rgba(200, 230, 201, 0.85)",
                  mb: 0.5
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Type:" }),
                  " ",
                  seedBank.type
                ]
              }
            ),
            (seedBank == null ? void 0 : seedBank.seedBankUrl) && /* @__PURE__ */ jsxRuntimeExports.jsx(
              Typography,
              {
                variant: "body2",
                component: "a",
                href: seedBank.seedBankUrl,
                target: "_blank",
                rel: "noopener noreferrer",
                sx: {
                  color: "#9AE66E",
                  textDecoration: "underline",
                  display: "block",
                  mt: 1
                },
                children: "View seed vendors "
              }
            )
          ] }),
          growProfile && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
            growProfile.vigor && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Typography,
              {
                variant: "body2",
                sx: {
                  color: "rgba(200, 230, 201, 0.85)",
                  mb: 0.5
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Vigor:" }),
                  " ",
                  growProfile.vigor
                ]
              }
            ),
            growProfile.harvestWeeks && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Typography,
              {
                variant: "body2",
                sx: {
                  color: "rgba(200, 230, 201, 0.85)",
                  mb: 0.5
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Harvest:" }),
                  " ~",
                  growProfile.harvestWeeks,
                  " weeks"
                ]
              }
            ),
            growProfile.yield && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Typography,
              {
                variant: "body2",
                sx: {
                  color: "rgba(200, 230, 201, 0.85)",
                  mb: 0.5
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Yield:" }),
                  " ",
                  growProfile.yield
                ]
              }
            )
          ] })
        ]
      }
    ),
    onViewSeeds && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box,
      {
        sx: {
          mt: 3,
          p: 2,
          borderRadius: 2,
          background: "rgba(124, 179, 66, 0.1)",
          border: "1px solid rgba(124, 179, 66, 0.3)"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "overline",
              sx: {
                color: "rgba(200, 230, 201, 0.7)",
                textTransform: "uppercase",
                letterSpacing: 1,
                fontSize: "0.75rem",
                fontWeight: 600,
                display: "block",
                mb: 1.5
              },
              children: "Find Seeds"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "column", spacing: 1.5, children: [
            (canonicalStrain == null ? void 0 : canonicalStrain.name) || strainName ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Button,
              {
                variant: "contained",
                fullWidth: true,
                onClick: () => onViewSeeds({
                  strainName: (canonicalStrain == null ? void 0 : canonicalStrain.name) || strainName,
                  strainSlug: canonicalStrain == null ? void 0 : canonicalStrain.slug,
                  scan,
                  result
                }),
                sx: {
                  py: 1.5,
                  fontSize: "0.95rem",
                  fontWeight: 600,
                  borderRadius: "8px",
                  background: "linear-gradient(135deg, #7CB342 0%, #9CCC65 100%)",
                  boxShadow: "0 4px 12px rgba(124, 179, 66, 0.3)",
                  textTransform: "none",
                  "&:hover": {
                    background: "linear-gradient(135deg, #9CCC65 0%, #AED581 100%)",
                    boxShadow: "0 6px 16px rgba(124, 179, 66, 0.4)"
                  }
                },
                children: [
                  " View Seeds for ",
                  (canonicalStrain == null ? void 0 : canonicalStrain.name) || strainName
                ]
              }
            ) : null,
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "outlined",
                fullWidth: true,
                onClick: () => onViewSeeds({}),
                sx: {
                  py: 1.5,
                  fontSize: "0.95rem",
                  fontWeight: 600,
                  borderRadius: "8px",
                  border: "2px solid rgba(124, 179, 66, 0.6)",
                  color: "#9CCC65",
                  textTransform: "none",
                  "&:hover": {
                    border: "2px solid rgba(124, 179, 66, 0.9)",
                    background: "rgba(124, 179, 66, 0.15)"
                  }
                },
                children: " Browse All Seeds"
              }
            )
          ] })
        ]
      }
    )
  ] });
}
function UnknownStrainCard({
  isPackagedProduct,
  isPackagedKnown,
  isBudUnknown,
  summary,
  effects,
  flavors,
  intensity,
  dispensaryNotes,
  growerNotes,
  warnings,
  canonicalStrain,
  onViewSeeds,
  result,
  scan
}) {
  if (isPackagedProduct && (isPackagedKnown || canonicalStrain && canonicalStrain.confidence === 1)) {
    return null;
  }
  let title = "Cannabis (strain unknown)";
  let subtitle = "STRAIN UNKNOWN  0%";
  let description = "";
  if (isPackagedProduct && !isPackagedKnown) {
    title = "Packaged product (strain unknown)";
    subtitle = "STRAIN UNKNOWN  0%";
    description = "This looks like a packaged product, but the strain name was not clearly detected from the label. THC, CBD, and other label details may still be available below.";
  } else if (!isPackagedProduct && isBudUnknown) {
    title = "Cannabis (strain unknown)";
    subtitle = "STRAIN UNKNOWN  0%";
    description = "For live plants and buds, this is an estimated strain based on visual and label signals. Results may vary by grower and phenotype.";
  } else {
    subtitle = "STRAIN UNKNOWN  0%";
    description = "Strain information is not available for this scan. Other label or AI details may still be shown below.";
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Card,
      {
        variant: "outlined",
        sx: {
          mb: 2,
          borderColor: "rgba(165, 214, 167, 0.35)",
          background: "radial-gradient(circle at top left, rgba(129, 199, 132, 0.12), transparent 55%), #0b100a"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "overline",
              sx: {
                color: "rgba(200, 230, 201, 0.7)",
                letterSpacing: 1,
                display: "block",
                mb: 0.5
              },
              children: subtitle
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "h6",
              sx: { fontWeight: 700, color: "#E8F5E9", mb: 0.5 },
              children: title
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "body2",
              sx: { color: "rgba(200, 230, 201, 0.85)" },
              children: description
            }
          )
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AIStrainDetailsPanel,
      {
        intensity,
        effects,
        flavors,
        dispensaryNotes,
        growerNotes,
        warnings,
        summary
      }
    ),
    onViewSeeds && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box,
      {
        sx: {
          mt: 3,
          p: 2,
          borderRadius: 2,
          background: "rgba(124, 179, 66, 0.1)",
          border: "1px solid rgba(124, 179, 66, 0.3)"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "overline",
              sx: {
                color: "rgba(200, 230, 201, 0.7)",
                textTransform: "uppercase",
                letterSpacing: 1,
                fontSize: "0.75rem",
                fontWeight: 600,
                display: "block",
                mb: 1.5
              },
              children: "Find Seeds"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "column", spacing: 1.5, children: [
            (canonicalStrain == null ? void 0 : canonicalStrain.name) ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Button,
              {
                variant: "contained",
                fullWidth: true,
                onClick: () => onViewSeeds({
                  strainName: canonicalStrain == null ? void 0 : canonicalStrain.name,
                  strainSlug: canonicalStrain == null ? void 0 : canonicalStrain.slug,
                  scan,
                  result
                }),
                sx: {
                  py: 1.5,
                  fontSize: "0.95rem",
                  fontWeight: 600,
                  borderRadius: "8px",
                  background: "linear-gradient(135deg, #7CB342 0%, #9CCC65 100%)",
                  boxShadow: "0 4px 12px rgba(124, 179, 66, 0.3)",
                  textTransform: "none",
                  "&:hover": {
                    background: "linear-gradient(135deg, #9CCC65 0%, #AED581 100%)",
                    boxShadow: "0 6px 16px rgba(124, 179, 66, 0.4)"
                  }
                },
                children: [
                  " View Seeds for ",
                  canonicalStrain == null ? void 0 : canonicalStrain.name
                ]
              }
            ) : null,
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "outlined",
                fullWidth: true,
                onClick: () => onViewSeeds({}),
                sx: {
                  py: 1.5,
                  fontSize: "0.95rem",
                  fontWeight: 600,
                  borderRadius: "8px",
                  border: "2px solid rgba(124, 179, 66, 0.6)",
                  color: "#9CCC65",
                  textTransform: "none",
                  "&:hover": {
                    border: "2px solid rgba(124, 179, 66, 0.9)",
                    background: "rgba(124, 179, 66, 0.15)"
                  }
                },
                children: " Browse All Seeds"
              }
            )
          ] })
        ]
      }
    )
  ] });
}
function BudEstimateCard({
  strainName,
  matchConfidence,
  summary,
  effects,
  flavors,
  intensity,
  dispensaryNotes,
  growerNotes,
  warnings,
  result,
  scan,
  seedBank,
  growProfile,
  canonicalStrain,
  heroImageUrl,
  onViewSeeds
}) {
  const packagingInsights = (result == null ? void 0 : result.packaging_insights) || (scan == null ? void 0 : scan.packaging_insights) || null;
  const labelInsights = (result == null ? void 0 : result.label_insights) || (scan == null ? void 0 : scan.label_insights) || null;
  const lineage = (packagingInsights == null ? void 0 : packagingInsights.lineage) || (labelInsights == null ? void 0 : labelInsights.lineage) || null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    heroImageUrl && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        sx: {
          mb: 2,
          borderRadius: 2,
          overflow: "hidden",
          border: "1px solid",
          borderColor: "rgba(124, 179, 66, 0.3)"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            component: "img",
            src: heroImageUrl,
            alt: strainName || "Strain photo",
            sx: {
              width: "100%",
              height: 220,
              objectFit: "cover",
              display: "block"
            },
            onError: (e) => {
              e.currentTarget.style.display = "none";
            }
          }
        )
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Card,
      {
        variant: "outlined",
        sx: {
          mb: 2,
          borderColor: "rgba(165, 214, 167, 0.35)",
          background: "radial-gradient(circle at top left, rgba(129, 199, 132, 0.12), transparent 55%), #0b100a"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
          canonicalStrain && canonicalStrain.confidence === 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "overline",
              sx: {
                color: "rgba(200, 230, 201, 0.7)",
                letterSpacing: 1,
                display: "block",
                mb: 0.5
              },
              children: "Strain match"
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Typography,
            {
              variant: "overline",
              sx: {
                color: "rgba(200, 230, 201, 0.7)",
                letterSpacing: 1,
                display: "block",
                mb: 0.5
              },
              children: [
                "Strain estimate",
                matchConfidence != null ? `  ${Math.round(matchConfidence * 100)}%` : ""
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "h6",
              sx: { fontWeight: 700, color: "#E8F5E9", mb: 0.5 },
              children: strainName
            }
          ),
          lineage && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Typography,
            {
              variant: "body2",
              sx: { color: "rgba(200, 230, 201, 0.75)", fontSize: "0.875rem", mb: 1 },
              children: [
                "Lineage: ",
                lineage
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "body2",
              sx: { color: "rgba(200, 230, 201, 0.85)" },
              children: "For live plants and buds, this is an estimated strain based on visual and label signals. Results may vary by grower and phenotype."
            }
          )
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AIStrainDetailsPanel,
      {
        intensity,
        effects,
        flavors,
        dispensaryNotes,
        growerNotes,
        warnings,
        summary
      }
    ),
    (seedBank || growProfile) && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box,
      {
        sx: {
          mt: 3,
          p: 3,
          borderRadius: 2,
          background: "rgba(0, 0, 0, 0.35)",
          backdropFilter: "blur(12px)",
          border: "1px solid rgba(124, 179, 66, 0.2)"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "overline",
              sx: {
                color: "rgba(200, 230, 201, 0.7)",
                textTransform: "uppercase",
                letterSpacing: 1,
                fontSize: "0.75rem",
                fontWeight: 600,
                display: "block",
                mb: 2
              },
              children: "Seed Info & Grow Profile"
            }
          ),
          seedBank && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 2 }, children: [
            (seedBank == null ? void 0 : seedBank.breeder) ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Typography,
              {
                variant: "body2",
                sx: {
                  color: "rgba(200, 230, 201, 0.85)",
                  mb: 0.5
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Breeder:" }),
                  " ",
                  seedBank.breeder
                ]
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Typography,
              {
                variant: "body2",
                sx: {
                  color: "rgba(200, 230, 201, 0.6)",
                  mb: 0.5
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Breeder:" }),
                  " Unknown breeder"
                ]
              }
            ),
            (seedBank == null ? void 0 : seedBank.type) && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Typography,
              {
                variant: "body2",
                sx: {
                  color: "rgba(200, 230, 201, 0.85)",
                  mb: 0.5
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Type:" }),
                  " ",
                  seedBank.type
                ]
              }
            ),
            (seedBank == null ? void 0 : seedBank.seedBankUrl) && /* @__PURE__ */ jsxRuntimeExports.jsx(
              Typography,
              {
                variant: "body2",
                component: "a",
                href: seedBank.seedBankUrl,
                target: "_blank",
                rel: "noopener noreferrer",
                sx: {
                  color: "#9AE66E",
                  textDecoration: "underline",
                  display: "block",
                  mt: 1
                },
                children: "View seed vendors "
              }
            )
          ] }),
          growProfile && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
            growProfile.vigor && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Typography,
              {
                variant: "body2",
                sx: {
                  color: "rgba(200, 230, 201, 0.85)",
                  mb: 0.5
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Vigor:" }),
                  " ",
                  growProfile.vigor
                ]
              }
            ),
            growProfile.harvestWeeks && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Typography,
              {
                variant: "body2",
                sx: {
                  color: "rgba(200, 230, 201, 0.85)",
                  mb: 0.5
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Harvest:" }),
                  " ~",
                  growProfile.harvestWeeks,
                  " weeks"
                ]
              }
            ),
            growProfile.yield && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Typography,
              {
                variant: "body2",
                sx: {
                  color: "rgba(200, 230, 201, 0.85)",
                  mb: 0.5
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Yield:" }),
                  " ",
                  growProfile.yield
                ]
              }
            )
          ] })
        ]
      }
    ),
    onViewSeeds && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box,
      {
        sx: {
          mt: 3,
          p: 2,
          borderRadius: 2,
          background: "rgba(124, 179, 66, 0.1)",
          border: "1px solid rgba(124, 179, 66, 0.3)"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "overline",
              sx: {
                color: "rgba(200, 230, 201, 0.7)",
                textTransform: "uppercase",
                letterSpacing: 1,
                fontSize: "0.75rem",
                fontWeight: 600,
                display: "block",
                mb: 1.5
              },
              children: "Find Seeds"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "column", spacing: 1.5, children: [
            (canonicalStrain == null ? void 0 : canonicalStrain.name) || strainName ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Button,
              {
                variant: "contained",
                fullWidth: true,
                onClick: () => onViewSeeds({
                  strainName: (canonicalStrain == null ? void 0 : canonicalStrain.name) || strainName,
                  strainSlug: canonicalStrain == null ? void 0 : canonicalStrain.slug,
                  scan,
                  result
                }),
                sx: {
                  py: 1.5,
                  fontSize: "0.95rem",
                  fontWeight: 600,
                  borderRadius: "8px",
                  background: "linear-gradient(135deg, #7CB342 0%, #9CCC65 100%)",
                  boxShadow: "0 4px 12px rgba(124, 179, 66, 0.3)",
                  textTransform: "none",
                  "&:hover": {
                    background: "linear-gradient(135deg, #9CCC65 0%, #AED581 100%)",
                    boxShadow: "0 6px 16px rgba(124, 179, 66, 0.4)"
                  }
                },
                children: [
                  " View Seeds for ",
                  (canonicalStrain == null ? void 0 : canonicalStrain.name) || strainName
                ]
              }
            ) : null,
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "outlined",
                fullWidth: true,
                onClick: () => onViewSeeds({}),
                sx: {
                  py: 1.5,
                  fontSize: "0.95rem",
                  fontWeight: 600,
                  borderRadius: "8px",
                  border: "2px solid rgba(124, 179, 66, 0.6)",
                  color: "#9CCC65",
                  textTransform: "none",
                  "&:hover": {
                    border: "2px solid rgba(124, 179, 66, 0.9)",
                    background: "rgba(124, 179, 66, 0.15)"
                  }
                },
                children: " Browse All Seeds"
              }
            )
          ] })
        ]
      }
    )
  ] });
}
const getCanonicalStrainName = (scan, result) => {
  var _a2, _b, _c, _d, _e, _f;
  const scanResult = result || (scan == null ? void 0 : scan.result) || {};
  const candidates = [
    (_a2 = scanResult.canonical) == null ? void 0 : _a2.name,
    (_b = scanResult.seedBank) == null ? void 0 : _b.name,
    (_c = scanResult.packaging) == null ? void 0 : _c.strainName,
    (_d = scanResult.label) == null ? void 0 : _d.strainName,
    (_e = scanResult.packaging_insights) == null ? void 0 : _e.strainName,
    (_f = scanResult.label_insights) == null ? void 0 : _f.strainName,
    scan == null ? void 0 : scan.strainName,
    scan == null ? void 0 : scan.matched_strain_name
  ];
  const found = candidates.find(
    (name2) => typeof name2 === "string" && name2.trim().length > 0
  );
  return found || "this strain";
};
function ScanResultCard({ result, scan, isGuest, onViewSeeds }) {
  if (!scan && !result) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { p: 3, textAlign: "center" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", sx: { mb: 2 }, children: "Scan ready, but details are missing" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", sx: { mb: 2, display: "block" }, children: "We processed your scan, but couldn't load the full details. You can check it in your scan history." }),
      onViewSeeds && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "outlined",
          onClick: () => onViewSeeds({}),
          sx: {
            border: "2px solid rgba(124, 179, 66, 0.6)",
            color: "#9CCC65"
          },
          children: " Browse All Seeds"
        }
      )
    ] });
  }
  const scanId = (scan == null ? void 0 : scan.id) || (scan == null ? void 0 : scan.scanId) || (result == null ? void 0 : result.id) || (result == null ? void 0 : result.scanId);
  if (!scanId) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { p: 3, textAlign: "center" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", sx: { mb: 2 }, children: "Preparing your result" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", sx: { mb: 2, display: "block" }, children: "Your scan is processing. This may take a moment." }),
      onViewSeeds && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "outlined",
          onClick: () => onViewSeeds({}),
          sx: {
            border: "2px solid rgba(124, 179, 66, 0.6)",
            color: "#9CCC65"
          },
          children: " Browse All Seeds"
        }
      )
    ] });
  }
  const { proRole, proEnabled } = useProMode();
  const scanData = result || scan || {};
  const transformed = transformScanResult(scanData);
  getCanonicalStrainName(scan, result);
  if (!transformed) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { p: 3, textAlign: "center" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", sx: { mb: 2 }, children: "Preparing your result" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", sx: { mb: 2, display: "block" }, children: "Your scan is processing. This may take a moment." }),
      onViewSeeds && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "outlined",
          onClick: () => onViewSeeds({}),
          sx: {
            border: "2px solid rgba(124, 179, 66, 0.6)",
            color: "#9CCC65"
          },
          children: " Browse All Seeds"
        }
      )
    ] });
  }
  const canonicalStrain = (transformed == null ? void 0 : transformed.canonicalStrain) || null;
  const isCanonicalConfident = canonicalStrain && canonicalStrain.confidence === 1;
  const shouldShowPackagedCard = (transformed == null ? void 0 : transformed.isPackagedKnown) || (transformed == null ? void 0 : transformed.isPackagedProduct) && isCanonicalConfident;
  if (shouldShowPackagedCard) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      PackagedProductCard,
      {
        strainName: (transformed == null ? void 0 : transformed.strainName) || null,
        thc: (transformed == null ? void 0 : transformed.thc) || null,
        cbd: (transformed == null ? void 0 : transformed.cbd) || null,
        summary: (transformed == null ? void 0 : transformed.summary) || null,
        effects: (transformed == null ? void 0 : transformed.effectsTags) || [],
        flavors: (transformed == null ? void 0 : transformed.flavorTags) || [],
        intensity: (transformed == null ? void 0 : transformed.intensity) || null,
        dispensaryNotes: (transformed == null ? void 0 : transformed.dispensaryNotes) || [],
        growerNotes: (transformed == null ? void 0 : transformed.growerNotes) || [],
        warnings: (transformed == null ? void 0 : transformed.warnings) || [],
        result,
        scan,
        proRole,
        proEnabled,
        seedBank: (transformed == null ? void 0 : transformed.seedBank) || null,
        growProfile: (transformed == null ? void 0 : transformed.growProfile) || null,
        canonicalStrain,
        heroImageUrl: (transformed == null ? void 0 : transformed.heroImageUrl) || null,
        onViewSeeds
      }
    );
  }
  if (((transformed == null ? void 0 : transformed.isBudUnknown) || (transformed == null ? void 0 : transformed.isPackagedProduct) && !(transformed == null ? void 0 : transformed.isPackagedKnown)) && !isCanonicalConfident) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      UnknownStrainCard,
      {
        isPackagedProduct: (transformed == null ? void 0 : transformed.isPackagedProduct) || false,
        isPackagedKnown: (transformed == null ? void 0 : transformed.isPackagedKnown) || false,
        isBudUnknown: (transformed == null ? void 0 : transformed.isBudUnknown) || false,
        summary: (transformed == null ? void 0 : transformed.summary) || null,
        effects: (transformed == null ? void 0 : transformed.effectsTags) || [],
        flavors: (transformed == null ? void 0 : transformed.flavorTags) || [],
        intensity: (transformed == null ? void 0 : transformed.intensity) || null,
        dispensaryNotes: (transformed == null ? void 0 : transformed.dispensaryNotes) || [],
        growerNotes: (transformed == null ? void 0 : transformed.growerNotes) || [],
        warnings: (transformed == null ? void 0 : transformed.warnings) || [],
        canonicalStrain,
        onViewSeeds,
        result,
        scan
      }
    );
  }
  if ((transformed == null ? void 0 : transformed.isPackagedProduct) && isCanonicalConfident) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { p: 3, textAlign: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "Processing result" }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    BudEstimateCard,
    {
      strainName: (transformed == null ? void 0 : transformed.strainName) || "Unknown Strain",
      matchConfidence: (transformed == null ? void 0 : transformed.matchConfidence) || null,
      summary: (transformed == null ? void 0 : transformed.summary) || null,
      effects: (transformed == null ? void 0 : transformed.effectsTags) || [],
      flavors: (transformed == null ? void 0 : transformed.flavorTags) || [],
      intensity: (transformed == null ? void 0 : transformed.intensity) || null,
      dispensaryNotes: (transformed == null ? void 0 : transformed.dispensaryNotes) || [],
      growerNotes: (transformed == null ? void 0 : transformed.growerNotes) || [],
      warnings: (transformed == null ? void 0 : transformed.warnings) || [],
      result,
      scan,
      seedBank: (transformed == null ? void 0 : transformed.seedBank) || null,
      growProfile: (transformed == null ? void 0 : transformed.growProfile) || null,
      canonicalStrain,
      heroImageUrl: (transformed == null ? void 0 : transformed.heroImageUrl) || null,
      onViewSeeds
    }
  );
}
function useCreditBalance() {
  var _a2, _b;
  const { user, session } = useAuth();
  const { isFounder, founderUnlimitedEnabled } = useProMode();
  const [state, setState] = reactExports.useState({
    loading: true,
    error: null,
    remainingScans: 0,
    isUnlimited: false
  });
  reactExports.useEffect(() => {
    if (!user && !session) {
      setState({
        loading: false,
        error: null,
        remainingScans: 20,
        isUnlimited: false
      });
      return;
    }
    if (isFounder && founderUnlimitedEnabled) {
      setState({
        loading: false,
        error: null,
        remainingScans: Infinity,
        isUnlimited: true
      });
      return;
    }
    let cancelled = false;
    (() => __async(null, null, function* () {
      var _a3, _b2;
      try {
        const userId = (user == null ? void 0 : user.id) || ((_a3 = session == null ? void 0 : session.user) == null ? void 0 : _a3.id);
        if (!userId) {
          setState((prev2) => __spreadProps(__spreadValues({}, prev2), {
            loading: false,
            error: "No user ID available"
          }));
          return;
        }
        const { data: { session: currentSession } } = yield supabase.auth.getSession();
        if (!currentSession) {
          setState((prev2) => __spreadProps(__spreadValues({}, prev2), {
            loading: false,
            error: "Not authenticated"
          }));
          return;
        }
        const response = yield fetch(`${API_BASE}/api/credits/balance`, {
          headers: {
            "Authorization": `Bearer ${currentSession.access_token}`
          }
        });
        if (cancelled) return;
        if (!response.ok) {
          const payload = yield response.json().catch(() => ({}));
          throw new Error(payload.error || "Unable to load credit balance");
        }
        const data = yield response.json();
        const hasUnlimited = Boolean(data.unlimited || data.isUnlimited || data.tier === "admin" || data.membershipTier === "founder_unlimited");
        const remainingScans = hasUnlimited ? Number.POSITIVE_INFINITY : (_b2 = data.creditsRemaining) != null ? _b2 : 0;
        setState({
          loading: false,
          error: null,
          remainingScans,
          isUnlimited: hasUnlimited
        });
      } catch (err) {
        if (cancelled) return;
        setState((prev2) => __spreadProps(__spreadValues({}, prev2), {
          loading: false,
          error: (err == null ? void 0 : err.message) || String(err)
        }));
      }
    }))();
    return () => {
      cancelled = true;
    };
  }, [user == null ? void 0 : user.id, user == null ? void 0 : user.email, (_a2 = session == null ? void 0 : session.user) == null ? void 0 : _a2.id, (_b = session == null ? void 0 : session.user) == null ? void 0 : _b.email, isFounder, founderUnlimitedEnabled]);
  return state;
}
function useCanScan() {
  const { remainingScans, isUnlimited, loading, error: error2 } = useCreditBalance();
  const { isFounder, founderUnlimitedEnabled } = useProMode();
  const safeRemaining = Number.isFinite(remainingScans) ? remainingScans : isUnlimited ? Number.POSITIVE_INFINITY : 0;
  const canScan = isFounder && founderUnlimitedEnabled || isUnlimited || safeRemaining > 0;
  return {
    canScan,
    remainingScans: safeRemaining,
    isFounder: Boolean(isFounder && founderUnlimitedEnabled),
    // Only true if both are true
    summary: { remainingScans: safeRemaining, isUnlimited: isUnlimited || isFounder && founderUnlimitedEnabled },
    loading,
    error: error2
  };
}
function useScanCredits() {
  const { remainingScans, isUnlimited, loading } = useCreditBalance();
  const { isFounder, founderUnlimitedEnabled } = useProMode();
  const { user, session } = useAuth();
  const isGuest = !user && !session;
  const isFounderNormalized = Boolean(isFounder && founderUnlimitedEnabled);
  let remainingScansNormalized = remainingScans != null ? remainingScans : null;
  if (isFounderNormalized) {
    remainingScansNormalized = Infinity;
  } else if (isGuest) {
    remainingScansNormalized = 20;
  }
  const canScan = isFounderNormalized || isGuest || (remainingScansNormalized != null ? remainingScansNormalized : 0) > 0;
  return {
    isFounder: isFounderNormalized,
    remainingScans: remainingScansNormalized,
    canScan,
    loading,
    isGuest
  };
}
const ConfidenceCallout = ({ confidence }) => {
  if (confidence == null) return null;
  const normalized = confidence > 1 ? confidence : confidence * 100;
  const pct = Math.max(0, Math.min(100, Math.round(normalized)));
  let severity = "success";
  if (pct < 50) severity = "warning";
  if (pct < 25) severity = "error";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Alert,
    {
      severity,
      sx: { mt: 2, bgcolor: "rgba(124,179,66,0.08)", border: "1px solid rgba(124,179,66,0.3)" },
      children: [
        "AI confidence: ",
        pct,
        "%"
      ]
    }
  );
};
function ScanWizard({ onBack, onScanComplete }) {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  const fileInputRef = reactExports.useRef(null);
  const [membershipComplete, setMembershipComplete] = reactExports.useState(true);
  const [loading, setLoading] = reactExports.useState(false);
  const [scanStatus, setScanStatus] = reactExports.useState("idle");
  const [errorMessage, setErrorMessage] = reactExports.useState("");
  const [result, setResult] = reactExports.useState(null);
  const [match2, setMatch] = reactExports.useState(null);
  const [plantHealth, setPlantHealth] = reactExports.useState(null);
  const [scanHistory, setScanHistory] = reactExports.useState([]);
  const [alertOpen, setAlertOpen] = reactExports.useState(false);
  const [alertMsg, setAlertMsg] = reactExports.useState("");
  const [detailsOpen, setDetailsOpen] = reactExports.useState(false);
  const [detailsTab, setDetailsTab] = reactExports.useState(0);
  const [scanResult, setScanResult] = reactExports.useState(null);
  const [isPolling, setIsPolling] = reactExports.useState(false);
  const [activeView, setActiveView] = reactExports.useState("scanner");
  const [completedScanId, setCompletedScanId] = reactExports.useState(null);
  const [showReviewForm, setShowReviewForm] = reactExports.useState(false);
  const [reviewText, setReviewText] = reactExports.useState("");
  const [reviewEffects, setReviewEffects] = reactExports.useState("");
  const [reviewFlavors, setReviewFlavors] = reactExports.useState("");
  const [reviewRating, setReviewRating] = reactExports.useState(5);
  const [submittingReview, setSubmittingReview] = reactExports.useState(false);
  const [existingReviews, setExistingReviews] = reactExports.useState([]);
  const [showSeedVendorFinder, setShowSeedVendorFinder] = reactExports.useState(false);
  const [showDispensaryFinder, setShowDispensaryFinder] = reactExports.useState(false);
  const [showFeedback, setShowFeedback] = reactExports.useState(false);
  const [currentUser, setCurrentUser] = reactExports.useState(null);
  const [showMembershipDialog, setShowMembershipDialog] = reactExports.useState(false);
  const [creditSummary, setCreditSummary] = reactExports.useState(null);
  const [creditsLoading, setCreditsLoading] = reactExports.useState(false);
  const [showTopUpDialog, setShowTopUpDialog] = reactExports.useState(false);
  const [topUpMessage, setTopUpMessage] = reactExports.useState("");
  const topUpOptions = [
    { credits: 50, price: "$4.99" },
    { credits: 200, price: "$9.99" },
    { credits: 500, price: "$19.99" }
  ];
  const { isFounder: isFounderFromHook } = useCanScan();
  const { remainingScans, isFounder, isGuest } = useScanCredits();
  const membershipTier = (((_a2 = currentUser == null ? void 0 : currentUser.user_metadata) == null ? void 0 : _a2.membership) || ((_b = currentUser == null ? void 0 : currentUser.user_metadata) == null ? void 0 : _b.tier) || "").toString().toLowerCase();
  const metadataMembershipActive = ["club", "full-access", "pro", "owner", "admin", "garden", "member"].some((token2) => membershipTier.includes(token2));
  const canUseEdgeUploads = typeof FUNCTIONS_BASE === "string" && FUNCTIONS_BASE.length > 0 && FUNCTIONS_BASE !== `${API_BASE}/api`;
  const uploadViaEdgeFunction = reactExports.useCallback((_0) => __async(null, [_0], function* ({ base64, filename, contentType, userId }) {
    if (!canUseEdgeUploads || !base64) return null;
    try {
      const headers = { "Content-Type": "application/json" };
      if (SUPABASE_ANON_KEY) {
        headers.Authorization = `Bearer ${SUPABASE_ANON_KEY}`;
        headers.apikey = SUPABASE_ANON_KEY;
      }
      const resp = yield fetch(`${FUNCTIONS_BASE}/uploads`, {
        method: "POST",
        headers,
        body: JSON.stringify({ filename, base64, contentType, user_id: userId })
      });
      if (!resp.ok) {
        const text = yield resp.text().catch(() => "");
        console.warn("[ScanWizard] Edge upload failed:", resp.status, text);
        return null;
      }
      const data = yield resp.json();
      if (data == null ? void 0 : data.id) {
        return data;
      }
    } catch (err) {
      console.warn("[ScanWizard] Edge upload exception:", err);
    }
    return null;
  }), [canUseEdgeUploads, FUNCTIONS_BASE]);
  reactExports.useEffect(() => {
    if (!supabase) return;
    supabase.auth.getSession().then(({ data: { session } }) => {
      var _a3;
      setCurrentUser((_a3 = session == null ? void 0 : session.user) != null ? _a3 : null);
    });
    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
      var _a3;
      setCurrentUser((_a3 = session == null ? void 0 : session.user) != null ? _a3 : null);
    });
    return () => subscription.unsubscribe();
  }, []);
  const loadCredits = reactExports.useCallback(() => __async(null, null, function* () {
    if (!currentUser) {
      setCreditSummary(null);
      return;
    }
    setCreditsLoading(true);
    try {
      const resp = yield fetch(`${API_BASE}/api/scans/credits?user_id=${currentUser.id}`);
      if (resp.ok) {
        const data = yield resp.json();
        setCreditSummary(data);
      } else {
        const err = yield resp.json().catch(() => ({}));
        console.error("Failed to load credits", err);
        if (metadataMembershipActive) {
          setCreditSummary((prev2) => prev2 != null ? prev2 : {
            credits: 999,
            membershipActive: true,
            starterExpired: false,
            trialDaysRemaining: null,
            monthlyBundle: 999
          });
        }
      }
    } catch (err) {
      console.error("Credit summary error:", err);
      if (metadataMembershipActive) {
        setCreditSummary((prev2) => prev2 != null ? prev2 : {
          credits: 999,
          membershipActive: true,
          starterExpired: false,
          trialDaysRemaining: null,
          monthlyBundle: 999
        });
      }
    } finally {
      setCreditsLoading(false);
    }
  }), [currentUser, metadataMembershipActive]);
  reactExports.useEffect(() => {
    if (!currentUser) {
      setCreditSummary(null);
      return;
    }
    loadCredits();
  }, [currentUser, loadCredits]);
  reactExports.useEffect(() => {
    var _a3;
    if ((_a3 = match2 == null ? void 0 : match2.strain) == null ? void 0 : _a3.slug) {
      fetch(`${API_BASE}/api/reviews?strain_slug=${match2.strain.slug}`).then((res) => res.json()).then((data) => {
        setExistingReviews(Array.isArray(data) ? data : []);
      }).catch(() => {
        setExistingReviews([]);
      });
    }
  }, [(_c = match2 == null ? void 0 : match2.strain) == null ? void 0 : _c.slug]);
  const handleLeaveReviewClick = () => {
    if (!currentUser) {
      setShowMembershipDialog(true);
      return;
    }
    setShowReviewForm(true);
  };
  const handleSubmitReview = () => __async(null, null, function* () {
    var _a3;
    if (!((_a3 = match2 == null ? void 0 : match2.strain) == null ? void 0 : _a3.slug) || !currentUser) return;
    setSubmittingReview(true);
    try {
      let fullReview = reviewText;
      if (reviewEffects.trim()) {
        fullReview += `

Effects: ${reviewEffects}`;
      }
      if (reviewFlavors.trim()) {
        fullReview += `

Flavors: ${reviewFlavors}`;
      }
      const response = yield fetch(`${API_BASE}/api/reviews`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          user_id: currentUser.id,
          strain_slug: match2.strain.slug,
          rating: reviewRating,
          comment: fullReview
        })
      });
      if (response.ok) {
        setAlertMsg("Thank you for your review! It helps the community learn about this strain.");
        setAlertOpen(true);
        setShowReviewForm(false);
        setReviewText("");
        setReviewEffects("");
        setReviewFlavors("");
        setReviewRating(5);
        const reviewsResponse = yield fetch(`${API_BASE}/api/reviews?strain_slug=${match2.strain.slug}`);
        const reviewsData = yield reviewsResponse.json();
        setExistingReviews(reviewsData || []);
      } else {
        const errorData = yield response.json();
        throw new Error(errorData.error || "Failed to submit review");
      }
    } catch (err) {
      setAlertMsg(err.message || "Failed to submit review. Please try again.");
      setAlertOpen(true);
    } finally {
      setSubmittingReview(false);
    }
  });
  const parseErrorResponse = (response) => __async(null, null, function* () {
    try {
      const data = yield response.json();
      return data.error || data.message || response.statusText || "Unexpected error";
    } catch (e) {
      return response.statusText || "Unexpected error";
    }
  });
  reactExports.useCallback((scan, scanId) => {
    var _a3, _b2, _c2, _d2, _e2;
    if (!scan) {
      console.warn("[ScanWizard] handlePollSuccess called without scan object");
      return;
    }
    const normalizedScan = __spreadValues({
      id: scan.id || scan.scanId || scanId,
      status: scan.status || "completed",
      created_at: (_b2 = (_a3 = scan.created_at) != null ? _a3 : scan.createdAt) != null ? _b2 : null,
      processed_at: (_d2 = (_c2 = scan.processed_at) != null ? _c2 : scan.processedAt) != null ? _d2 : null,
      image_url: scan.image_url || scan.imageUrl || scan.result && scan.result.image_url || null,
      result: (_e2 = scan.result) != null ? _e2 : {}
    }, scan);
    if (!normalizedScan.id) {
      console.warn("[ScanWizard] Poll success but missing scan id", { scan, normalizedScan });
    }
    const normalized = normalizeScanResult(normalizedScan);
    if (normalized) {
      normalizedScan.normalizedResult = normalized;
    }
    if (onScanComplete && typeof onScanComplete === "function") {
      onScanComplete(normalizedScan);
    } else {
      setActiveView("result");
    }
  }, [onScanComplete]);
  const handleFileChange = (e) => __async(null, null, function* () {
    var _a3;
    const file = (_a3 = e.target.files) == null ? void 0 : _a3[0];
    if (!file) {
      setScanStatus("idle");
      return;
    }
    if (e.target) {
      e.target.value = "";
    }
    setLoading(true);
    setScanStatus("Uploading image...");
    setErrorMessage("");
    try {
      const reader = new FileReader();
      reader.onload = () => __async(null, null, function* () {
        var _a4, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2;
        try {
          const base64 = reader.result.split(",")[1];
          let uploadData = null;
          if (canUseEdgeUploads && currentUser) {
            setScanStatus("Uploading image to Supabase...");
            const edge = yield uploadViaEdgeFunction({
              base64,
              filename: file.name,
              contentType: file.type,
              userId: currentUser.id
            });
            if (edge == null ? void 0 : edge.id) {
              uploadData = edge;
            }
          }
          if (!uploadData) {
            setScanStatus("Uploading image to backend...");
            const uploadResp = yield fetch(`${API_BASE}/api/uploads`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                filename: file.name,
                contentType: file.type,
                base64,
                user_id: (currentUser == null ? void 0 : currentUser.id) || null
              })
            });
            if (!uploadResp.ok) {
              const message = yield parseErrorResponse(uploadResp);
              throw new Error(message || "Upload failed");
            }
            uploadData = yield uploadResp.json();
          }
          const scanId = uploadData.id;
          setScanStatus("Processing scan...");
          const processResp = yield fetch(`${API_BASE}/api/scans/${scanId}/process`, {
            method: "POST",
            headers: { "Content-Type": "application/json" }
          });
          if (processResp.status === 402) {
            if (isFounderFromHook) {
              console.warn("[ScanWizard] Founder account hit 402 - backend may not be recognizing founder status. Continuing anyway.");
            } else {
              let errorPayload = {};
              try {
                errorPayload = yield processResp.json();
              } catch (err) {
                console.warn("[ScanWizard] Could not parse credit error payload:", err);
              }
              const tier2 = errorPayload.tier || "free";
              const needsUpgrade = errorPayload.needsUpgrade || false;
              let message = errorPayload.message || "No scan credits remaining.";
              if (needsUpgrade) {
                message = " You've used all 10 free scans! Unlock StrainSpotter (20 scans) or join Monthly Member ($4.99/mo) for 200 scans/month. Top-up packs (50  200  500) are also available.";
              } else if (tier2 === "member" || tier2 === "monthly_member") {
                message = " You've used all 200 scans this month! Add a top-up pack (50  200  500 scans) or wait for your next monthly refresh.";
              } else if (tier2 === "premium") {
                message = " You've used the legacy premium allotment. Grab a top-up pack (50  200  500 scans) to keep scanning.";
              }
              setAlertMsg(message);
              setAlertOpen(true);
              setTopUpMessage(message);
              setShowTopUpDialog(true);
              setScanStatus("Out of credits");
              yield loadCredits();
              setLoading(false);
              return;
            }
          }
          if (!processResp.ok) {
            const message = yield parseErrorResponse(processResp);
            throw new Error(message || "Scan processing failed");
          }
          const processData = yield processResp.json();
          let scan = processData.scan || processData;
          if (!scan || !scan.id) {
            const scanResp = yield fetch(`${API_BASE}/api/scans/${scanId}`);
            if (scanResp.ok) {
              const scanData = yield scanResp.json();
              scan = scanData.scan || scanData;
            } else {
              scan = { id: scanId, status: "processing" };
            }
          }
          setScanStatus("Scan started successfully!");
          const normalizedScan = __spreadValues({
            id: scan.id || scan.scanId || scanId,
            status: scan.status || "processing",
            created_at: (_b2 = (_a4 = scan.created_at) != null ? _a4 : scan.createdAt) != null ? _b2 : null,
            processed_at: (_d2 = (_c2 = scan.processed_at) != null ? _c2 : scan.processedAt) != null ? _d2 : null,
            image_url: (_h2 = (_g2 = (_e2 = scan.image_url) != null ? _e2 : scan.imageUrl) != null ? _g2 : (_f2 = scan.result) == null ? void 0 : _f2.image_url) != null ? _h2 : null,
            result: (_i2 = scan.result) != null ? _i2 : {}
          }, scan);
          if (onScanComplete && typeof onScanComplete === "function") {
            onScanComplete(normalizedScan);
          }
          yield loadCredits();
          setLoading(false);
          setScanStatus("idle");
        } catch (err) {
          console.error("Scan error:", err);
          setScanStatus("error");
          setErrorMessage(err.message || "Scan failed. Please try again.");
          setAlertMsg(err.message || "Scan failed. Please try again.");
          setAlertOpen(true);
          setLoading(false);
        }
      });
      reader.onerror = () => {
        setScanStatus("error");
        setErrorMessage("Unable to read the selected file.");
        setAlertMsg("Unable to read the selected file.");
        setAlertOpen(true);
        setLoading(false);
      };
      reader.readAsDataURL(file);
    } catch (err) {
      console.error("Scan error:", err);
      setScanStatus("error");
      setErrorMessage(err.message || "Scan failed. Please try again.");
      setAlertMsg(err.message || "Scan failed. Please try again.");
      setAlertOpen(true);
      setLoading(false);
    }
  });
  reactExports.useEffect(() => {
    const poll = setInterval(() => __async(null, null, function* () {
      try {
        const resp = yield fetch(`${API_BASE}/api/scans`);
        if (resp.ok) {
          const data = yield resp.json();
          const scans = data.scans || [];
          const completed = scans.filter((s) => s.status === "complete");
          if (completed.length > 0) {
            setAlertMsg(`Scan matched: ${completed.map((s) => {
              var _a3;
              return ((_a3 = s.strain) == null ? void 0 : _a3.name) || "Unknown";
            }).join(", ")}`);
            setAlertOpen(true);
          }
          setScanHistory(scans);
        }
      } catch (err) {
        console.error("Poll error:", err);
      }
    }), 3e4);
    return () => clearInterval(poll);
  }, []);
  const renderDetailsDialog = () => {
    if (!match2 || !match2.strain) return null;
    const { strain } = match2;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Dialog,
      {
        open: detailsOpen,
        onClose: () => setDetailsOpen(false),
        maxWidth: "md",
        fullWidth: true,
        fullScreen: true,
        PaperProps: {
          sx: {
            bgcolor: "rgba(0,0,0,0.95)",
            m: 0,
            maxHeight: "100vh"
          }
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogTitle, { sx: { borderBottom: "1px solid rgba(124,179,66,0.3)", display: "flex", justifyContent: "space-between", alignItems: "center" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h6", children: [
              strain.name,
              " Details"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: () => setDetailsOpen(false), sx: { color: "#fff" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {}) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Tabs, { value: detailsTab, onChange: (_e2, v) => setDetailsTab(v), sx: { borderBottom: "1px solid rgba(124,179,66,0.2)" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { label: "Overview", sx: { color: "#c8ff9e" } }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { label: "Dispensaries", sx: { color: "#c8ff9e" } }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { label: "Seeds", sx: { color: "#c8ff9e" } }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { label: "Care Guide", sx: { color: "#c8ff9e" } })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { sx: { bgcolor: "rgba(0,0,0,0.95)" }, children: [
            detailsTab === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle1", fontWeight: 700, children: "Overview" }),
              strain.description && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { children: strain.description })
            ] }),
            detailsTab === 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle1", fontWeight: 700, children: "Dispensaries" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { children: "Nearby dispensaries feature coming soon." })
            ] }),
            detailsTab === 2 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle1", fontWeight: 700, children: "Seeds" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { children: "Seed info feature coming soon." })
            ] }),
            detailsTab === 3 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle1", fontWeight: 700, children: "Care Guide" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { children: "Care guide feature coming soon." })
            ] })
          ] })
        ]
      }
    );
  };
  const membershipActive = (() => {
    if (typeof (creditSummary == null ? void 0 : creditSummary.membershipActive) === "boolean") {
      if (creditSummary.membershipActive) return true;
      if (metadataMembershipActive) return true;
      if (typeof creditSummary.monthlyBundle === "number" && creditSummary.monthlyBundle > 0) return true;
      return false;
    }
    return metadataMembershipActive;
  })();
  const creditsRemaining = typeof (creditSummary == null ? void 0 : creditSummary.credits) === "number" ? creditSummary.credits : null;
  const monthlyBundle = typeof (creditSummary == null ? void 0 : creditSummary.monthlyBundle) === "number" ? creditSummary.monthlyBundle : null;
  const resetAt = (creditSummary == null ? void 0 : creditSummary.resetAt) ? new Date(creditSummary.resetAt) : null;
  const accessExpiresAt = (creditSummary == null ? void 0 : creditSummary.accessExpiresAt) ? new Date(creditSummary.accessExpiresAt) : null;
  const starterExpired = Boolean(creditSummary == null ? void 0 : creditSummary.starterExpired) && !membershipActive;
  const trialDaysRemaining = typeof (creditSummary == null ? void 0 : creditSummary.trialDaysRemaining) === "number" ? creditSummary.trialDaysRemaining : accessExpiresAt ? Math.max(0, Math.ceil((accessExpiresAt.getTime() - Date.now()) / (1e3 * 60 * 60 * 24))) : null;
  const lowCredits = typeof creditsRemaining === "number" && creditsRemaining <= 5;
  const isOutOfScans = !isFounder && !isGuest && (remainingScans != null ? remainingScans : 0) <= 0;
  const primaryLabel = isOutOfScans ? "Upgrade to keep scanning" : "Scan";
  const trialMessage = (() => {
    if (membershipActive) return null;
    if (!accessExpiresAt) return null;
    if (starterExpired) {
      return "Your starter access has ended. Join the Garden to keep scanning with full AI access.";
    }
    const diffDays = trialDaysRemaining != null ? trialDaysRemaining : Math.ceil((accessExpiresAt.getTime() - Date.now()) / (1e3 * 60 * 60 * 24));
    if (diffDays <= 0) {
      return "Starter access ends today. Join the Garden to keep scanning with full AI access.";
    }
    return `Starter access ends in ${diffDays} day${diffDays === 1 ? "" : "s"}. Join the Garden or grab a top-up pack to keep scanning.`;
  })();
  const nextResetLabel = (() => {
    if (!resetAt) return null;
    return resetAt.toLocaleDateString(void 0, { month: "short", day: "numeric", year: "numeric" });
  })();
  const accessExpiresLabel = accessExpiresAt ? accessExpiresAt.toLocaleDateString(void 0, { month: "short", day: "numeric", year: "numeric" }) : null;
  if (showSeedVendorFinder) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SeedVendorFinder, { onBack: () => setShowSeedVendorFinder(false) });
  }
  if (showDispensaryFinder) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DispensaryFinder, { onBack: () => setShowDispensaryFinder(false) });
  }
  if (activeView === "result" && scanResult) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box,
      {
        sx: {
          display: "flex",
          flexDirection: "column",
          height: "100vh",
          overflow: "hidden",
          bgcolor: "#000"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Box,
            {
              sx: {
                flexShrink: 0,
                display: "flex",
                alignItems: "center",
                gap: 1.5,
                p: 2,
                borderBottom: "1px solid rgba(255,255,255,0.08)",
                bgcolor: "rgba(0,0,0,0.7)",
                backdropFilter: "blur(10px)",
                zIndex: 1
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IconButton$1,
                  {
                    edge: "start",
                    onClick: () => {
                      setActiveView("scanner");
                      setScanResult(null);
                      setCompletedScanId(null);
                    },
                    sx: { color: "#fff" },
                    "aria-label": "Go back to scanner",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowBackIcon, {})
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { fontWeight: 600, color: "#fff", flex: 1 }, children: "Scan Result" })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Box,
            {
              sx: {
                flex: 1,
                minHeight: 0,
                overflowY: "auto",
                WebkitOverflowScrolling: "touch",
                px: 2,
                py: 2
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { maxWidth: "md", sx: { py: 2 }, children: [
                (() => {
                  var _a3, _b2, _c2, _d2, _e2, _f2;
                  const isPackage = Boolean(scanResult.isPackagedProduct);
                  const dbName = cleanCandidateName(
                    (scanResult == null ? void 0 : scanResult.topMatch) && scanResult.topMatch.name || (scanResult == null ? void 0 : scanResult.matchedName) || (scanResult == null ? void 0 : scanResult.name)
                  );
                  const labelStrain = cleanCandidateName((_a3 = scanResult.labelInsights) == null ? void 0 : _a3.strainName);
                  const aiTitle = cleanCandidateName(
                    ((_b2 = scanResult.aiSummary) == null ? void 0 : _b2.title) || ((_d2 = (_c2 = scanResult.labelInsights) == null ? void 0 : _c2.aiSummary) == null ? void 0 : _d2.title)
                  );
                  const primaryName = isPackage ? aiTitle || labelStrain || dbName || "Unknown product" : dbName || labelStrain || "Unknown strain";
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { sx: {
                    fontSize: { xs: "1.25rem", sm: "1.5rem" },
                    fontWeight: 900,
                    color: "#00e676",
                    letterSpacing: { xs: 0.5, sm: 1 },
                    mb: { xs: 1, sm: 1.5 },
                    textAlign: "center",
                    textShadow: "0 2px 8px #388e3c",
                    fontFamily: "Montserrat, Arial, sans-serif"
                  }, children: [
                    getScanKindLabel({
                      isPackagedProduct: scanResult.isPackagedProduct || false,
                      category: (_e2 = scanResult.labelInsights) == null ? void 0 : _e2.category,
                      productType: (_f2 = scanResult.labelInsights) == null ? void 0 : _f2.productType
                    }),
                    " identified: ",
                    primaryName
                  ] });
                })(),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ScanResultCard,
                  {
                    result: scanResult,
                    isGuest: !currentUser,
                    onSaveMatch: () => console.log("Save match"),
                    onLogExperience: () => handleLeaveReviewClick(),
                    onReportMismatch: () => {
                      setAlertMsg("Thank you for reporting. We'll review this match.");
                      setAlertOpen(true);
                    },
                    onViewStrain: () => setDetailsOpen(true)
                  }
                ),
                plantHealth && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
                  mb: { xs: 2, sm: 3 },
                  p: { xs: 2, sm: 3 },
                  bgcolor: "rgba(0, 0, 0, 0.4)",
                  borderRadius: { xs: 2, sm: 3 },
                  border: `2px solid ${plantHealth.healthStatus.color}`,
                  boxShadow: `0 0 20px ${plantHealth.healthStatus.color}40`,
                  width: "100%",
                  mt: 2
                }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#fff", fontWeight: 700, mb: { xs: 1.5, sm: 2 } }, children: "Plant Analysis" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#fff" }, children: [
                    "Growth Stage: ",
                    ((_d = plantHealth.growthStage) == null ? void 0 : _d.stage) || "Unknown"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#fff", mt: 1 }, children: [
                    "Health Status: ",
                    ((_e = plantHealth.healthStatus) == null ? void 0 : _e.status) || "Unknown"
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
                  display: "flex",
                  flexDirection: "column",
                  gap: 2,
                  mt: 3,
                  width: "100%",
                  maxWidth: "400px",
                  mx: "auto"
                }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: "contained",
                    fullWidth: true,
                    onClick: () => {
                      var _a3;
                      setActiveView("scanner");
                      setScanResult(null);
                      setCompletedScanId(null);
                      (_a3 = fileInputRef.current) == null ? void 0 : _a3.click();
                    },
                    sx: {
                      py: 2,
                      fontSize: "1rem",
                      fontWeight: 700,
                      borderRadius: "12px",
                      background: "linear-gradient(135deg, #7CB342 0%, #9CCC65 100%)",
                      textTransform: "none"
                    },
                    children: " Scan Another"
                  }
                ) })
              ] })
            }
          )
        ]
      }
    ) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: !membershipComplete ? /* @__PURE__ */ jsxRuntimeExports.jsx(MembershipLogin, { onSuccess: () => setMembershipComplete(true) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        height: "100dvh",
        display: "flex",
        flexDirection: "column",
        bgcolor: "background.default",
        color: "text.primary",
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            sx: {
              flexShrink: 0,
              pt: "calc(env(safe-area-inset-top) + 8px)",
              px: 2,
              pb: 1,
              display: "flex",
              alignItems: "center",
              gap: 1.5
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton$1,
                {
                  edge: "start",
                  onClick: () => onBack ? onBack() : window.history.back(),
                  size: "small",
                  sx: { borderRadius: 2, border: "1px solid", borderColor: "divider", color: "#fff" },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowBackIcon, { fontSize: "small" })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { flex: 1 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle1", fontWeight: 600, noWrap: true, sx: { color: "#fff" }, children: "StrainSpotter Scanner" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { color: "rgba(255,255,255,0.7)" }, noWrap: true, children: "Snap packaging or buds to decode everything" })
              ] }),
              currentUser && /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "text",
                  size: "small",
                  onClick: () => __async(null, null, function* () {
                    try {
                      yield supabase.auth.signOut();
                      setCurrentUser(null);
                      setAlertMsg("Logged out successfully");
                      setAlertOpen(true);
                      setTimeout(() => {
                        if (onBack) {
                          onBack();
                        } else {
                          window.location.href = "/";
                        }
                      }, 1e3);
                    } catch (err) {
                      console.error("Logout error:", err);
                      setAlertMsg("Logout failed");
                      setAlertOpen(true);
                    }
                  }),
                  sx: {
                    color: "#fff",
                    textTransform: "none"
                  },
                  children: "Logout"
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            sx: {
              flex: 1,
              minHeight: 0,
              overflowY: "auto",
              WebkitOverflowScrolling: "touch",
              px: 2,
              pb: 2
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Box,
                {
                  sx: {
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    justifyContent: "center",
                    gap: 2,
                    minHeight: "100%"
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", justifyContent: "center", mb: { xs: 1, sm: 2 } }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Box,
                      {
                        sx: {
                          width: { xs: 50, sm: 70 },
                          height: { xs: 50, sm: 70 },
                          borderRadius: "50%",
                          background: "transparent",
                          border: "2px solid rgba(124, 179, 66, 0.5)",
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          boxShadow: "0 0 30px rgba(124, 179, 66, 0.5)",
                          overflow: "hidden"
                        },
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "img",
                          {
                            src: "/hero.png?v=13",
                            alt: "StrainSpotter",
                            style: { width: "100%", height: "100%", objectFit: "cover" }
                          }
                        )
                      }
                    ) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Typography,
                      {
                        variant: "h3",
                        align: "center",
                        sx: {
                          fontWeight: 900,
                          letterSpacing: 1,
                          color: "#fff",
                          mb: { xs: 0.5, sm: 1 },
                          fontSize: { xs: "1.5rem", sm: "2.5rem" },
                          textShadow: "0 2px 12px #388e3c, 0 0px 2px #000",
                          filter: "drop-shadow(0 0 8px #00e676)",
                          fontFamily: "Montserrat, Arial, sans-serif"
                        },
                        children: "Identify Your Cannabis Plant"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Typography,
                      {
                        align: "center",
                        sx: {
                          mt: { xs: 1, sm: 2 },
                          color: "#fff",
                          fontSize: { xs: "0.875rem", sm: "1.375rem" },
                          fontWeight: 600,
                          px: { xs: 1, sm: 0 },
                          textShadow: "0 1px 8px #388e3c",
                          fontFamily: "Montserrat, Arial, sans-serif"
                        },
                        children: [
                          "Snap a photo of your cannabis and let our AI deliver the full strain breakdown",
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "#00e676", fontWeight: 900 }, children: "no hype" }),
                          ", just ",
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "#ffd600", fontWeight: 900 }, children: "next-gen science" }),
                          "."
                        ]
                      }
                    ),
                    currentUser && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Paper,
                      {
                        sx: {
                          mt: { xs: 2, sm: 4 },
                          mb: { xs: 2, sm: 3 },
                          p: { xs: 2, sm: 3 },
                          width: "100%",
                          maxWidth: 720,
                          background: "rgba(0, 0, 0, 0.45)",
                          borderRadius: { xs: 2, sm: 4 },
                          border: "1px solid rgba(124, 179, 66, 0.4)",
                          color: "#e8f5e9"
                        },
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", sx: { textTransform: "uppercase", letterSpacing: 1, color: "#c8ff9e", fontSize: { xs: "0.7rem", sm: "0.875rem" } }, children: "Scan Credits" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h3", sx: { fontWeight: 800, color: "#fff", display: "flex", alignItems: "baseline", gap: 1, fontSize: { xs: "2rem", sm: "3rem" } }, children: [
                              creditsLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 28, sx: { color: "#c8ff9e" } }) : isFounder ? "Unlimited" : typeof remainingScans === "number" && remainingScans === Infinity ? "Unlimited" : typeof remainingScans === "number" ? remainingScans : creditsRemaining != null ? creditsRemaining : "--",
                              !isFounder && !(typeof remainingScans === "number" && remainingScans === Infinity) && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { component: "span", variant: "h6", sx: { color: "#c8ff9e", fontWeight: 500, fontSize: { xs: "1rem", sm: "1.25rem" } }, children: "left" })
                            ] }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#d0ffd6", maxWidth: 420, fontSize: { xs: "0.75rem", sm: "0.875rem" } }, children: membershipActive ? "Membership perks active  we auto-refresh your bundle every month so you never lose your streak." : "Starter bundle includes 20 scans. After 3 days you'll need a membership or a top-up pack to keep scanning." }),
                            membershipActive && nextResetLabel && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", sx: { display: "block", mt: 1, color: "#b2fab4", fontSize: { xs: "0.65rem", sm: "0.75rem" } }, children: [
                              "Next monthly reset: ",
                              nextResetLabel
                            ] }),
                            !membershipActive && accessExpiresLabel && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", sx: { display: "block", mt: 1, color: "#ffcc80", fontSize: { xs: "0.65rem", sm: "0.75rem" } }, children: [
                              "Starter access expires: ",
                              accessExpiresLabel
                            ] })
                          ] }),
                          !membershipActive && trialMessage && /* @__PURE__ */ jsxRuntimeExports.jsx(
                            Alert,
                            {
                              severity: starterExpired ? "error" : "info",
                              sx: {
                                mt: 2,
                                bgcolor: starterExpired ? "rgba(244, 67, 54, 0.2)" : "rgba(124, 179, 66, 0.18)",
                                color: "#fff",
                                "& .MuiAlert-icon": { color: starterExpired ? "#ffccbc" : "#c8ff9e" }
                              },
                              children: trialMessage
                            }
                          ),
                          membershipActive && monthlyBundle && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                            Alert,
                            {
                              severity: "success",
                              sx: {
                                mt: 2,
                                bgcolor: "rgba(76, 175, 80, 0.18)",
                                color: "#e8f5e9",
                                "& .MuiAlert-icon": { color: "#c8ff9e" }
                              },
                              children: [
                                "Your membership includes a ",
                                monthlyBundle,
                                "-scan bundle each month. Well keep it topped up automatically."
                              ]
                            }
                          ),
                          !membershipActive && lowCredits && !starterExpired && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                            Alert,
                            {
                              severity: "warning",
                              sx: {
                                mt: 2,
                                bgcolor: "rgba(255, 193, 7, 0.18)",
                                color: "#fff",
                                "& .MuiAlert-icon": { color: "#ffe082" }
                              },
                              children: [
                                "Only ",
                                creditsRemaining,
                                " scan",
                                creditsRemaining === 1 ? "" : "s",
                                " left. Add a top-up pack or join the Garden to keep results flowing."
                              ]
                            }
                          ),
                          !membershipActive && starterExpired && /* @__PURE__ */ jsxRuntimeExports.jsx(
                            Alert,
                            {
                              severity: "error",
                              sx: {
                                mt: 2,
                                bgcolor: "rgba(244, 67, 54, 0.25)",
                                color: "#fff",
                                "& .MuiAlert-icon": { color: "#ffccbc" }
                              },
                              children: "Starter access has ended. Join the Garden membership or redeem a top-up pack within the app stores to continue scanning."
                            }
                          )
                        ]
                      }
                    ),
                    loading && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", flexDirection: "column", alignItems: "center", mt: 2 }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { color: "success" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { mt: 1, color: "#388e3c" }, children: [
                        scanStatus === "Uploading image..." && "Uploading your photo securely...",
                        scanStatus === "Uploading image to Supabase..." && "Uploading your photo securely...",
                        scanStatus === "Uploading image to backend..." && "Uploading your photo securely...",
                        scanStatus === "Processing scan..." && "Analyzing your product...",
                        scanStatus === "Scan started successfully!" && "Scan started! Redirecting to results..."
                      ] })
                    ] }),
                    errorMessage && !loading && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Typography,
                      {
                        variant: "body2",
                        color: "error",
                        sx: { mt: 2, textAlign: "center", px: 2 },
                        children: errorMessage
                      }
                    ),
                    scanStatus && scanStatus !== "idle" && !loading && !errorMessage && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { align: "center", sx: { mt: { xs: 1, sm: 2 }, color: "#388e3c", fontWeight: 700, fontSize: { xs: "0.875rem", sm: "1rem" } }, children: scanStatus })
                  ]
                }
              ),
              scanResult && activeView === "scanner" && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
                mt: { xs: 2, sm: 4 },
                width: "100%",
                maxWidth: 600
              }, children: [
                (() => {
                  var _a3, _b2, _c2, _d2, _e2, _f2;
                  const isPackage = Boolean(scanResult.isPackagedProduct);
                  const dbName = cleanCandidateName(
                    (scanResult == null ? void 0 : scanResult.topMatch) && scanResult.topMatch.name || (scanResult == null ? void 0 : scanResult.matchedName) || (scanResult == null ? void 0 : scanResult.name)
                  );
                  const labelStrain = cleanCandidateName((_a3 = scanResult.labelInsights) == null ? void 0 : _a3.strainName);
                  const aiTitle = cleanCandidateName(
                    ((_b2 = scanResult.aiSummary) == null ? void 0 : _b2.title) || ((_d2 = (_c2 = scanResult.labelInsights) == null ? void 0 : _c2.aiSummary) == null ? void 0 : _d2.title)
                  );
                  let primaryName = null;
                  if (isPackage) {
                    primaryName = aiTitle || labelStrain || dbName || "Unknown product";
                  } else {
                    primaryName = dbName || labelStrain || "Unknown strain";
                  }
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { sx: {
                    fontSize: { xs: "1.25rem", sm: "1.5rem" },
                    fontWeight: 900,
                    color: "#00e676",
                    letterSpacing: { xs: 0.5, sm: 1 },
                    mb: { xs: 1, sm: 1.5 },
                    textAlign: "center",
                    textShadow: "0 2px 8px #388e3c",
                    fontFamily: "Montserrat, Arial, sans-serif"
                  }, children: [
                    getScanKindLabel({
                      isPackagedProduct: scanResult.isPackagedProduct || false,
                      category: (_e2 = scanResult.labelInsights) == null ? void 0 : _e2.category,
                      productType: (_f2 = scanResult.labelInsights) == null ? void 0 : _f2.productType
                    }),
                    " identified: ",
                    primaryName
                  ] });
                })(),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ScanResultCard,
                  {
                    result: scanResult,
                    isGuest: !currentUser,
                    onSaveMatch: () => {
                      console.log("Save match");
                    },
                    onLogExperience: () => {
                      handleLeaveReviewClick();
                    },
                    onReportMismatch: () => {
                      setAlertMsg("Thank you for reporting. We'll review this match.");
                      setAlertOpen(true);
                    },
                    onViewStrain: () => {
                      setDetailsOpen(true);
                    }
                  }
                ),
                plantHealth && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
                  mb: { xs: 2, sm: 3 },
                  p: { xs: 2, sm: 3 },
                  bgcolor: "rgba(0, 0, 0, 0.4)",
                  borderRadius: { xs: 2, sm: 3 },
                  border: `2px solid ${plantHealth.healthStatus.color}`,
                  boxShadow: `0 0 20px ${plantHealth.healthStatus.color}40`,
                  width: "100%"
                }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#fff", fontWeight: 700, mb: { xs: 1.5, sm: 2 }, display: "flex", alignItems: "center", gap: 1, fontSize: { xs: "1rem", sm: "1.25rem" } }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 1, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { component: "img", src: "/hero.png?v=13", alt: "", sx: { width: 18, height: 18, filter: "drop-shadow(0 0 4px rgba(124, 179, 66, 0.6))" } }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Plant Analysis" })
                  ] }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 2 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#9CCC65", fontWeight: 700, mb: 0.5 }, children: "Growth Stage:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body1", sx: { color: "#fff", fontSize: 18, fontWeight: 600 }, children: [
                      plantHealth.growthStage.icon,
                      " ",
                      plantHealth.growthStage.stage
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#b0b0b0", mt: 0.5 }, children: plantHealth.growthStage.description }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", sx: { color: "#808080" }, children: [
                      "Timeframe: ",
                      plantHealth.growthStage.timeframe
                    ] })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 2 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#9CCC65", fontWeight: 700, mb: 0.5 }, children: "Health Status:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Chip,
                      {
                        label: plantHealth.healthStatus.status,
                        sx: {
                          bgcolor: `${plantHealth.healthStatus.color}30`,
                          color: plantHealth.healthStatus.color,
                          fontWeight: 700,
                          border: `2px solid ${plantHealth.healthStatus.color}`,
                          fontSize: 16,
                          px: 2,
                          py: 2.5
                        }
                      }
                    ),
                    plantHealth.healthStatus.issues.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mt: 1 }, children: plantHealth.healthStatus.issues.map((issue, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#fff", mt: 0.5 }, children: [
                      " ",
                      issue
                    ] }, idx)) })
                  ] }),
                  plantHealth.recommendations && plantHealth.recommendations.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#9CCC65", fontWeight: 700, mb: 1 }, children: "Care Recommendations:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 0.5, children: plantHealth.recommendations.map((rec, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#fff", fontSize: 14 }, children: rec }, idx)) })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(ConfidenceCallout, { confidence: plantHealth.confidence })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
                  mt: 3,
                  mb: 3,
                  p: 3,
                  bgcolor: "rgba(0, 0, 0, 0.3)",
                  borderRadius: 3,
                  border: "2px solid rgba(124, 179, 66, 0.3)",
                  width: "100%"
                }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#00e676", fontWeight: 700, mb: 2 }, children: " Share Your Experience" }),
                  !showReviewForm ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", color: "#fff", sx: { mb: 2 }, children: [
                      "Have you tried ",
                      (_f = match2.strain) == null ? void 0 : _f.name,
                      "? Help the community by sharing your experience with effects, flavors, and overall rating."
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Button,
                      {
                        variant: "contained",
                        sx: {
                          fontWeight: 700,
                          borderRadius: 999,
                          px: 4,
                          py: 1,
                          fontSize: 16,
                          boxShadow: "none",
                          bgcolor: "rgba(124, 179, 66, 0.3)",
                          border: "2px solid rgba(124, 179, 66, 0.6)",
                          backdropFilter: "blur(10px)",
                          color: "#fff",
                          textTransform: "none",
                          "&:hover": {
                            bgcolor: "rgba(124, 179, 66, 0.5)",
                            border: "2px solid rgba(124, 179, 66, 0.8)"
                          }
                        },
                        onClick: handleLeaveReviewClick,
                        children: [
                          " Leave a Review ",
                          !currentUser && "(Members Only)"
                        ]
                      }
                    )
                  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", flexDirection: "column", gap: 2 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      TextField,
                      {
                        label: "Your Review",
                        multiline: true,
                        rows: 4,
                        value: reviewText,
                        onChange: (e) => setReviewText(e.target.value),
                        placeholder: "Share your experience with this strain...",
                        fullWidth: true,
                        sx: {
                          "& .MuiOutlinedInput-root": {
                            color: "#fff",
                            "& fieldset": { borderColor: "rgba(124, 179, 66, 0.5)" },
                            "&:hover fieldset": { borderColor: "rgba(124, 179, 66, 0.7)" },
                            "&.Mui-focused fieldset": { borderColor: "rgba(124, 179, 66, 0.9)" }
                          },
                          "& .MuiInputLabel-root": { color: "#fff" }
                        }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      TextField,
                      {
                        label: "Effects (comma-separated)",
                        value: reviewEffects,
                        onChange: (e) => setReviewEffects(e.target.value),
                        placeholder: "e.g., relaxed, happy, euphoric",
                        fullWidth: true,
                        sx: {
                          "& .MuiOutlinedInput-root": {
                            color: "#fff",
                            "& fieldset": { borderColor: "rgba(124, 179, 66, 0.5)" },
                            "&:hover fieldset": { borderColor: "rgba(124, 179, 66, 0.7)" },
                            "&.Mui-focused fieldset": { borderColor: "rgba(124, 179, 66, 0.9)" }
                          },
                          "& .MuiInputLabel-root": { color: "#fff" }
                        }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      TextField,
                      {
                        label: "Flavors (comma-separated)",
                        value: reviewFlavors,
                        onChange: (e) => setReviewFlavors(e.target.value),
                        placeholder: "e.g., berry, sweet, earthy",
                        fullWidth: true,
                        sx: {
                          "& .MuiOutlinedInput-root": {
                            color: "#fff",
                            "& fieldset": { borderColor: "rgba(124, 179, 66, 0.5)" },
                            "&:hover fieldset": { borderColor: "rgba(124, 179, 66, 0.7)" },
                            "&.Mui-focused fieldset": { borderColor: "rgba(124, 179, 66, 0.9)" }
                          },
                          "& .MuiInputLabel-root": { color: "#fff" }
                        }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", color: "#fff", sx: { mb: 1 }, children: [
                        "Rating: ",
                        reviewRating,
                        "/10"
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "input",
                        {
                          type: "range",
                          min: "1",
                          max: "10",
                          value: reviewRating,
                          onChange: (e) => setReviewRating(parseInt(e.target.value)),
                          style: { width: "100%" }
                        }
                      )
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 2, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Button,
                        {
                          variant: "contained",
                          disabled: submittingReview || !reviewText.trim(),
                          sx: {
                            fontWeight: 700,
                            borderRadius: 999,
                            px: 4,
                            py: 1,
                            fontSize: 16,
                            boxShadow: "none",
                            bgcolor: "rgba(124, 179, 66, 0.3)",
                            border: "2px solid rgba(124, 179, 66, 0.6)",
                            backdropFilter: "blur(10px)",
                            color: "#fff",
                            textTransform: "none",
                            "&:hover": {
                              bgcolor: "rgba(124, 179, 66, 0.5)",
                              border: "2px solid rgba(124, 179, 66, 0.8)"
                            }
                          },
                          onClick: handleSubmitReview,
                          children: submittingReview ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 20, color: "inherit" }) : "Submit Review"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Button,
                        {
                          variant: "outlined",
                          disabled: submittingReview,
                          sx: {
                            fontWeight: 700,
                            borderRadius: 999,
                            px: 4,
                            py: 1,
                            fontSize: 16,
                            boxShadow: "none",
                            bgcolor: "rgba(124, 179, 66, 0.2)",
                            border: "2px solid rgba(124, 179, 66, 0.5)",
                            backdropFilter: "blur(10px)",
                            color: "#fff",
                            textTransform: "none",
                            "&:hover": {
                              bgcolor: "rgba(124, 179, 66, 0.3)",
                              border: "2px solid rgba(124, 179, 66, 0.7)"
                            }
                          },
                          onClick: () => setShowReviewForm(false),
                          children: "Cancel"
                        }
                      )
                    ] })
                  ] })
                ] }),
                existingReviews.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
                  mt: 3,
                  mb: 3,
                  p: 3,
                  bgcolor: "rgba(0, 0, 0, 0.3)",
                  borderRadius: 3,
                  border: "2px solid rgba(124, 179, 66, 0.3)",
                  width: "100%"
                }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h6", sx: { color: "#00e676", fontWeight: 700, mb: 2 }, children: [
                    " Community Reviews (",
                    existingReviews.length,
                    ")"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 2, children: existingReviews.map((review, idx) => {
                    var _a3;
                    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Box,
                      {
                        sx: {
                          p: 2,
                          bgcolor: "rgba(255, 255, 255, 0.05)",
                          borderRadius: 2,
                          borderLeft: "3px solid rgba(124, 179, 66, 0.6)"
                        },
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#ffd600", fontWeight: 700, mb: 1 }, children: [
                            ((_a3 = review.users) == null ? void 0 : _a3.username) || review.user || "Anonymous",
                            "  ",
                            new Date(review.created_at || review.date).toLocaleDateString()
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#fff", whiteSpace: "pre-line" }, children: review.comment || review.review }),
                          review.rating && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#00e676", mt: 1 }, children: [
                            " Rating: ",
                            review.rating,
                            "/5"
                          ] })
                        ]
                      },
                      idx
                    );
                  }) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
                  display: "flex",
                  flexDirection: "column",
                  gap: 2,
                  mt: 3,
                  width: "100%",
                  maxWidth: "400px",
                  mx: "auto",
                  px: 2
                }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      variant: "contained",
                      fullWidth: true,
                      onClick: () => {
                        var _a3, _b2;
                        if (currentUser) {
                          setShowSeedVendorFinder(true);
                        } else {
                          const strainName = ((_a3 = match2.strain) == null ? void 0 : _a3.slug) || ((_b2 = match2.strain) == null ? void 0 : _b2.name);
                          window.open(`https://www.seedsman.com/en/search?q=${encodeURIComponent(strainName)}`, "_blank");
                        }
                      },
                      sx: {
                        py: 2,
                        fontSize: "1rem",
                        fontWeight: 700,
                        borderRadius: "12px",
                        background: "linear-gradient(135deg, #7CB342 0%, #9CCC65 100%)",
                        boxShadow: "0 4px 12px rgba(124, 179, 66, 0.3)",
                        textTransform: "none",
                        transition: "all 0.2s ease",
                        "&:active": {
                          transform: "scale(0.98)",
                          boxShadow: "0 2px 8px rgba(124, 179, 66, 0.4)"
                        }
                      },
                      children: " Buy Seeds"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      variant: "outlined",
                      fullWidth: true,
                      onClick: () => {
                        var _a3, _b2;
                        if (currentUser) {
                          setShowDispensaryFinder(true);
                        } else {
                          const strainName = ((_a3 = match2.strain) == null ? void 0 : _a3.name) || ((_b2 = match2.strain) == null ? void 0 : _b2.slug);
                          window.open(`https://www.google.com/search?q=${encodeURIComponent(strainName + " cannabis dispensary near me")}`, "_blank");
                        }
                      },
                      sx: {
                        py: 2,
                        fontSize: "1rem",
                        fontWeight: 700,
                        borderRadius: "12px",
                        border: "2px solid rgba(124, 179, 66, 0.6)",
                        color: "#9CCC65",
                        textTransform: "none",
                        transition: "all 0.2s ease",
                        "&:active": {
                          transform: "scale(0.98)",
                          background: "rgba(124, 179, 66, 0.15)",
                          border: "2px solid rgba(124, 179, 66, 0.8)"
                        }
                      },
                      children: " Find Dispensaries"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
                  display: "flex",
                  flexDirection: "column",
                  alignItems: "center",
                  gap: { xs: 1.5, sm: 2 },
                  mt: { xs: 2, sm: 3 },
                  background: "rgba(30,30,30,0.25)",
                  backdropFilter: "blur(16px) saturate(180%)",
                  borderRadius: { xs: 3, sm: 6 },
                  px: { xs: 2, sm: 4 },
                  py: { xs: 2, sm: 3 },
                  boxShadow: "0 4px 32px 0 rgba(0,0,0,0.12)",
                  border: "1px solid rgba(255,255,255,0.18)",
                  width: "100%"
                }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "file",
                      accept: "image/*",
                      style: { display: "none" },
                      ref: fileInputRef,
                      onChange: handleFileChange
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Button,
                    {
                      variant: "contained",
                      color: "success",
                      fullWidth: true,
                      sx: {
                        fontWeight: 700,
                        borderRadius: 999,
                        px: { xs: 3, sm: 5 },
                        py: { xs: 1.25, sm: 1.5 },
                        fontSize: { xs: "0.95rem", sm: "1.125rem" },
                        boxShadow: "none",
                        bgcolor: "rgba(124, 179, 66, 0.3)",
                        border: "2px solid rgba(124, 179, 66, 0.6)",
                        backdropFilter: "blur(10px)",
                        color: "#fff",
                        textTransform: "none",
                        maxWidth: { xs: "100%", sm: "400px" },
                        "&:hover": {
                          bgcolor: "rgba(124, 179, 66, 0.5)",
                          border: "2px solid rgba(124, 179, 66, 0.8)"
                        },
                        "&:active": {
                          transform: "scale(0.98)"
                        }
                      },
                      onClick: () => {
                        var _a3;
                        return (_a3 = fileInputRef.current) == null ? void 0 : _a3.click();
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { role: "img", "aria-label": "camera", style: { marginRight: 8 }, children: "" }),
                        "Scan Another Strain"
                      ]
                    }
                  ),
                  loading && /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { color: "success", sx: { mt: { xs: 1, sm: 2 } } }),
                  scanStatus && !loading && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { align: "center", sx: { mt: { xs: 1, sm: 2 }, color: "#00e676", fontWeight: 700, fontSize: { xs: "0.875rem", sm: "1rem" } }, children: scanStatus })
                ] }),
                ((_g = match2.strain) == null ? void 0 : _g.labTestResults) && match2.strain.labTestResults.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 2, width: "100%" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", color: "#fff", gutterBottom: true, children: "Lab Test Results:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 1, children: match2.strain.labTestResults.map((test, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { bgcolor: "rgba(255,255,255,0.10)", backdropFilter: "blur(6px)", borderRadius: 2, p: 1 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", color: "#fff", children: [
                    test.date && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Date:" }),
                      " ",
                      test.date,
                      " "
                    ] }),
                    test.lab && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Lab:" }),
                      " ",
                      test.lab,
                      " "
                    ] }),
                    test.testType && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Type:" }),
                      " ",
                      test.testType,
                      " "
                    ] }),
                    typeof test.thc === "number" && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "THC:" }),
                      " ",
                      test.thc,
                      "% "
                    ] }),
                    typeof test.cbd === "number" && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "CBD:" }),
                      " ",
                      test.cbd,
                      "% "
                    ] }),
                    test.comment && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Note:" }),
                      " ",
                      test.comment
                    ] })
                  ] }) }, idx)) })
                ] }),
                ((_h = match2.strain) == null ? void 0 : _h.growTips) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 2, width: "100%" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", color: "#fff", gutterBottom: true, children: "Grow Tips:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "#fff", children: match2.strain.growTips })
                ] }),
                ((_i = match2.strain) == null ? void 0 : _i.seedVendors) && match2.strain.seedVendors.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 2, width: "100%" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", color: "#fff", gutterBottom: true, children: "Seed Vendors:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { direction: "row", spacing: 1, flexWrap: "wrap", useFlexGap: true, children: match2.strain.seedVendors.map((vendor, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Chip,
                    {
                      label: vendor.name,
                      size: "small",
                      variant: "outlined",
                      component: "a",
                      href: vendor.url,
                      clickable: true,
                      sx: {
                        borderColor: "#7CB342",
                        color: "#9CCC65",
                        "&:hover": {
                          borderColor: "#9CCC65",
                          bgcolor: "rgba(124, 179, 66, 0.1)"
                        }
                      }
                    },
                    idx
                  )) })
                ] }),
                ((_j = match2.strain) == null ? void 0 : _j.breeder) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 2, width: "100%" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", color: "#fff", gutterBottom: true, children: "Breeder:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "#fff", children: match2.strain.breeder })
                ] })
              ] }),
              currentUser && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mt: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
                borderRadius: 6,
                p: 3,
                boxShadow: "none",
                border: "none"
              }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { mb: 2, color: "#fff" }, children: "Your Scan History" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 2, children: scanHistory && Array.isArray(scanHistory) && scanHistory.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: { color: "#e0e0e0" }, children: "No scans yet." }) : (scanHistory || []).map((scan, idx) => {
                  var _a3;
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper, { sx: {
                    p: 2,
                    borderRadius: 2,
                    bgcolor: "rgba(255,255,255,0.1)",
                    backdropFilter: "blur(10px)",
                    border: "1px solid rgba(124, 179, 66, 0.3)",
                    boxShadow: "none"
                  }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#fff" }, children: (scan == null ? void 0 : scan.status) === "pending" ? "Pending scan..." : `Matched: ${((_a3 = scan == null ? void 0 : scan.strain) == null ? void 0 : _a3.name) || "Unknown"}` }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { color: "#e0e0e0" }, children: scan == null ? void 0 : scan.created })
                  ] }, (scan == null ? void 0 : scan.id) || idx);
                }) })
              ] }) }),
              result && !match2 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mt: 3 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle1", fontWeight: 700, children: "Raw Scan Result" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mt: 1, p: 2, borderRadius: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { style: { textAlign: "left", fontSize: 14 }, children: JSON.stringify(result, null, 2) }) })
              ] }),
              renderDetailsDialog(),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Dialog,
                {
                  open: showTopUpDialog,
                  onClose: () => setShowTopUpDialog(false),
                  maxWidth: "sm",
                  fullWidth: true,
                  fullScreen: true,
                  PaperProps: {
                    sx: {
                      bgcolor: "#111",
                      m: 0,
                      maxHeight: "100vh"
                    }
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogTitle, { sx: { bgcolor: "#111", color: "#c8ff9e", fontWeight: 700, borderBottom: "1px solid rgba(124,179,66,0.3)", display: "flex", justifyContent: "space-between", alignItems: "center" }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", children: "Keep Your Scans Going" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: () => setShowTopUpDialog(false), sx: { color: "#c8ff9e" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {}) })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { sx: { bgcolor: "#111", color: "#fff", pt: 3 }, children: [
                      topUpMessage && /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentText, { sx: { color: "#e0ffe3", mb: 2 }, children: topUpMessage }),
                      !membershipActive && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        Paper,
                        {
                          sx: {
                            p: 2,
                            mb: 3,
                            background: "linear-gradient(135deg, rgba(124,179,66,0.25), rgba(0,0,0,0.65))",
                            border: "1px solid rgba(124,179,66,0.4)",
                            borderRadius: 3
                          },
                          children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { fontWeight: 700, color: "#c8ff9e", mb: 1 }, children: "Garden Membership  $7.99 / month" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#e8f5e9", mb: 1 }, children: "Unlimited monthly scan bundles, private grower community access, and priority support. Perfect if you scan often or want the full Garden experience." }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              Button,
                              {
                                variant: "contained",
                                color: "success",
                                fullWidth: true,
                                sx: { mt: 1, borderRadius: 999, textTransform: "none", fontWeight: 700 },
                                onClick: () => {
                                  setShowTopUpDialog(false);
                                  setShowMembershipDialog(true);
                                },
                                children: "Join the Garden"
                              }
                            )
                          ]
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, { sx: { borderColor: "rgba(255,255,255,0.12)", mb: 3 } }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle1", sx: { fontWeight: 700, color: "#c8ff9e", mb: 1 }, children: "Quick Top-Up Packs (3-day access window)" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#e8f5e9", mb: 2 }, children: "Redeem on iOS or Android. Each pack reloads your credits instantly and keeps your non-member access alive for 3 more days." }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 2, sx: { mb: 3 }, children: topUpOptions.map((pack) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        Paper,
                        {
                          sx: {
                            p: 2,
                            borderRadius: 3,
                            background: "rgba(255,255,255,0.06)",
                            border: "1px solid rgba(124,179,66,0.3)",
                            display: "flex",
                            justifyContent: "space-between",
                            alignItems: "center"
                          },
                          children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
                              /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "subtitle1", sx: { color: "#fff", fontWeight: 700 }, children: [
                                pack.credits,
                                " scans"
                              ] }),
                              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { color: "#c8ff9e" }, children: "Expires 3 days after activation" })
                            ] }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              Button,
                              {
                                variant: "outlined",
                                sx: {
                                  borderColor: "rgba(200,255,158,0.7)",
                                  color: "#c8ff9e",
                                  textTransform: "none",
                                  borderRadius: 999,
                                  fontWeight: 600,
                                  "&:hover": { borderColor: "rgba(200,255,158,1)" }
                                },
                                onClick: () => {
                                  setAlertMsg("Checkout for scan packs happens through Apple App Store or Google Play. Launch the mobile app to complete your purchase.");
                                  setAlertOpen(true);
                                },
                                children: pack.price
                              }
                            )
                          ]
                        },
                        pack.credits
                      )) }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Alert,
                        {
                          severity: "info",
                          sx: {
                            bgcolor: "rgba(124, 179, 66, 0.2)",
                            color: "#e8f5e9",
                            "& .MuiAlert-icon": { color: "#c8ff9e" }
                          },
                          children: "Purchases finalize inside the Apple App Store or Google Play app. Once the store confirms your order we auto-sync credits to your account. Need a hand? Email support@strainspotter.com."
                        }
                      )
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActions, { sx: { bgcolor: "#111", borderTop: "1px solid rgba(255,255,255,0.12)" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => setShowTopUpDialog(false), sx: { color: "#c8ff9e", textTransform: "none" }, children: "Close" }) })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Dialog,
                {
                  open: showMembershipDialog,
                  onClose: () => setShowMembershipDialog(false),
                  maxWidth: "sm",
                  fullWidth: true,
                  fullScreen: true,
                  PaperProps: {
                    sx: {
                      bgcolor: "rgba(0, 0, 0, 0.95)",
                      m: 0,
                      maxHeight: "100vh"
                    }
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogTitle, { sx: {
                      display: "flex",
                      justifyContent: "space-between",
                      alignItems: "center",
                      bgcolor: "rgba(0, 0, 0, 0.9)",
                      color: "#00e676",
                      borderBottom: "1px solid rgba(124,179,66,0.3)"
                    }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { fontWeight: 700 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 1, children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { component: "img", src: "/hero.png?v=13", alt: "", sx: { width: 18, height: 18, filter: "drop-shadow(0 0 4px rgba(124, 179, 66, 0.6))" } }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Garden Membership Access" })
                      ] }) }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        IconButton$1,
                        {
                          onClick: () => setShowMembershipDialog(false),
                          sx: { color: "#fff" },
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {})
                        }
                      )
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { sx: { bgcolor: "rgba(0, 0, 0, 0.9)", color: "#fff", pt: 3 }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", sx: { mb: 3 }, children: "Membership unlocks unlimited scan refills, in-depth strain tools, and the private grower community. Join the StrainSpotter Garden to:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { component: "ul", sx: { pl: 3, mb: 3 }, children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Access unlimited AI scan bundles every month" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Unlock reviews, ratings, and premium strain breakdowns" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Connect with certified growers in members-only chats" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Get early access to new cultivation features" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Support the AI lab that keeps strain matching sharp" })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(MembershipLogin, { onSuccess: () => {
                        setShowMembershipDialog(false);
                        setAlertMsg("Welcome to the Garden! Membership perks are now active.");
                        setAlertOpen(true);
                        loadCredits();
                      } })
                    ] })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Snackbar,
                {
                  open: alertOpen,
                  autoHideDuration: 4e3,
                  onClose: () => setAlertOpen(false),
                  message: alertMsg,
                  anchorOrigin: { vertical: "top", horizontal: "center" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Send Feedback", placement: "left", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Fab,
                {
                  color: "primary",
                  onClick: () => setShowFeedback(true),
                  sx: {
                    position: "fixed",
                    bottom: 24,
                    right: 24,
                    zIndex: 1e3,
                    background: "linear-gradient(135deg, #7CB342 0%, #9CCC65 100%)",
                    boxShadow: "0 8px 30px rgba(124, 179, 66, 0.4)",
                    "&:hover": {
                      background: "linear-gradient(135deg, #9CCC65 0%, #7CB342 100%)",
                      boxShadow: "0 12px 40px rgba(124, 179, 66, 0.6)",
                      transform: "scale(1.05)"
                    }
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(FeedbackIcon, {})
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                FeedbackModal,
                {
                  open: showFeedback,
                  onClose: () => setShowFeedback(false),
                  user: currentUser
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            sx: {
              position: "sticky",
              bottom: 0,
              zIndex: 20,
              background: "linear-gradient(to top, rgba(3,10,3,0.95), rgba(3,10,3,0.4))",
              pt: 1,
              pb: "calc(env(safe-area-inset-bottom) + 8px)",
              px: 2,
              flexShrink: 0
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "file",
                  accept: "image/*",
                  style: { display: "none" },
                  ref: fileInputRef,
                  onChange: handleFileChange
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  fullWidth: true,
                  variant: "contained",
                  size: "large",
                  onClick: () => {
                    var _a3;
                    if (isOutOfScans) {
                      const message = starterExpired ? "Your starter access window has ended. Join the Garden membership or purchase a top-up pack within 3 days to keep scanning." : "You are out of scan credits. Join the Garden or purchase a top-up pack to continue scanning.";
                      setAlertMsg(message);
                      setAlertOpen(true);
                      setTopUpMessage(message);
                      setShowTopUpDialog(true);
                      return;
                    }
                    (_a3 = fileInputRef.current) == null ? void 0 : _a3.click();
                  },
                  disabled: isOutOfScans || loading,
                  sx: {
                    borderRadius: 999,
                    py: 1.4,
                    fontWeight: 600,
                    textTransform: "none",
                    mb: 1
                  },
                  children: loading ? "Scanning" : primaryLabel
                }
              ),
              !isOutOfScans && !isFounder && typeof remainingScans === "number" && remainingScans > 0 && remainingScans !== Infinity && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { mt: 1, textAlign: "center", color: "#c8ff9e", opacity: 0.9 }, children: [
                remainingScans,
                " scan",
                remainingScans === 1 ? "" : "s",
                " remaining"
              ] })
            ]
          }
        )
      ]
    }
  ) });
}
function FeedbackChat({ onBack }) {
  const [messages, setMessages] = reactExports.useState([]);
  const [input, setInput] = reactExports.useState("");
  const [posting, setPosting] = reactExports.useState(false);
  const [testingEmail, setTestingEmail] = reactExports.useState(false);
  const [testResult, setTestResult] = reactExports.useState(null);
  const load = () => __async(null, null, function* () {
    try {
      const res = yield fetch(`${API_BASE}/api/feedback/messages`);
      if (res.ok) {
        setMessages(yield res.json());
      }
    } catch (e) {
      console.error("[Feedback] Load error:", e);
    }
  });
  const sendTestEmail = () => __async(null, null, function* () {
    setTestingEmail(true);
    setTestResult(null);
    try {
      const res = yield fetch(`${API_BASE}/diagnostic/email-test`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ to: "strainspotter25feedback@gmail.com" })
      });
      const data = yield res.json();
      setTestResult(data.ok ? "Email sent!" : `Error: ${data.error || "Unknown"}`);
    } catch (e) {
      setTestResult("Network error");
    }
    setTestingEmail(false);
  });
  reactExports.useEffect(() => {
    load();
  }, []);
  const send = () => __async(null, null, function* () {
    const content = input.trim();
    if (!content) return;
    setPosting(true);
    try {
      console.log("[Feedback] Sending to:", `${API_BASE}/api/feedback/messages`);
      const res = yield fetch(`${API_BASE}/api/feedback/messages`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "apikey": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJkcXB4aXhzYnFjc3lmZXdjbWJ6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAxMjI3NTMsImV4cCI6MjA3NTY5ODc1M30.rTbYZNKNv1szvzjA2D828OVt7qUZVSXgi4G_tUqm3mA"
        },
        body: JSON.stringify({ content, user_id: null })
      });
      if (res.ok) {
        setInput("");
        yield load();
      } else {
        const errText = yield res.text();
        console.error("[Feedback] Send failed:", errText);
        alert("Failed to send feedback. Please try again.");
      }
    } catch (e) {
      console.error("[Feedback] Error:", e);
      alert("Network error sending feedback.");
    } finally {
      setPosting(false);
    }
  });
  const handleKeyPress = (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      send();
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { p: 2 }, children: [
    onBack && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        onClick: onBack,
        size: "small",
        variant: "contained",
        sx: {
          bgcolor: "white",
          color: "black",
          textTransform: "none",
          fontWeight: 700,
          borderRadius: 999,
          mb: 2,
          "&:hover": { bgcolor: "grey.100" }
        },
        children: "Home"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: {
      bgcolor: "rgba(255,255,255,0.7)",
      boxShadow: "0 8px 32px 0 rgba(31, 38, 135, 0.37)",
      backdropFilter: "blur(12px)",
      borderRadius: 4,
      border: "1px solid rgba(255,255,255,0.18)"
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { mb: 2 }, children: "Feedback" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 1, sx: { mb: 2, maxHeight: 300, overflow: "auto" }, children: [
        messages.map((m) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { p: 1, bgcolor: "background.default", borderRadius: 1 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: new Date(m.created_at).toLocaleString() }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", children: m.content })
        ] }, m.id)),
        messages.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "No feedback yet. Be the first!" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            fullWidth: true,
            size: "small",
            placeholder: "Type feedback... (press Enter to send)",
            value: input,
            onChange: (e) => setInput(e.target.value),
            onKeyPress: handleKeyPress
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "outlined",
            size: "small",
            onClick: sendTestEmail,
            disabled: testingEmail,
            sx: { textTransform: "none" },
            children: testingEmail ? "Sending..." : "Send Test Email"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "contained", onClick: send, disabled: posting, children: "Send" })
      ] }),
      testResult && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { px: 2, pb: 1 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: testResult === "Email sent!" ? "success.main" : "error.main", children: testResult }) })
    ] }) })
  ] });
}
function GrowerRegistration({ onBack }) {
  const [mode, setMode] = reactExports.useState("non-certified");
  const [form, setForm] = reactExports.useState({
    growerId: "",
    farmName: "",
    city: "",
    state: "",
    specialties: "",
    bio: "",
    experienceYears: 3,
    licenseStatus: "not_applicable",
    acceptsMessages: true,
    optInDirectory: true,
    phone: "",
    address: "",
    contactRiskAcknowledged: false,
    moderatorOptIn: false,
    moderatorMotivation: "",
    moderatorAvailability: "",
    moderatorExperience: "",
    moderatorNotes: ""
  });
  const [loading, setLoading] = reactExports.useState(false);
  const [error2, setError] = reactExports.useState(null);
  const [snack, setSnack] = reactExports.useState("");
  const handleChange = (key) => (e) => setForm(__spreadProps(__spreadValues({}, form), { [key]: e.target.value }));
  const handleBoolean = (key) => (e) => setForm(__spreadProps(__spreadValues({}, form), { [key]: e.target.checked }));
  const licenseOptions = reactExports.useMemo(() => [
    { value: "licensed", label: "Licensed" },
    { value: "unlicensed", label: "Unlicensed" },
    { value: "not_applicable", label: "Not Applicable" }
  ], []);
  const resetForm = () => setForm({
    growerId: "",
    farmName: "",
    city: "",
    state: "",
    specialties: "",
    bio: "",
    experienceYears: 3,
    licenseStatus: mode === "certified" ? "licensed" : "not_applicable",
    acceptsMessages: true,
    optInDirectory: true,
    phone: "",
    address: "",
    contactRiskAcknowledged: false,
    moderatorOptIn: false,
    moderatorMotivation: "",
    moderatorAvailability: "",
    moderatorExperience: "",
    moderatorNotes: ""
  });
  function submit() {
    return __async(this, null, function* () {
      var _a2, _b;
      setLoading(true);
      setError(null);
      try {
        const { data: sessionData, error: sessionErr } = yield supabase.auth.getSession();
        if (sessionErr) throw sessionErr;
        const userId = (_b = (_a2 = sessionData == null ? void 0 : sessionData.session) == null ? void 0 : _a2.user) == null ? void 0 : _b.id;
        if (!userId) {
          throw new Error("Please sign in before registering as a grower.");
        }
        const certified = mode === "certified";
        const basePayload = {
          userId,
          isGrower: true,
          licenseStatus: certified ? "licensed" : form.licenseStatus,
          experienceYears: Number(form.experienceYears) || 0,
          bio: form.bio,
          specialties: form.specialties,
          city: form.city,
          state: form.state,
          country: "USA",
          farmName: form.farmName,
          acceptsMessages: form.acceptsMessages,
          optInDirectory: form.optInDirectory,
          phone: form.phone || null,
          address: form.address || null,
          contactRiskAcknowledged: form.contactRiskAcknowledged,
          certified,
          moderatorOptIn: certified && form.moderatorOptIn
        };
        if ((basePayload.phone || basePayload.address) && !basePayload.contactRiskAcknowledged) {
          throw new Error("Please acknowledge the risks of sharing contact information.");
        }
        if (certified && !form.growerId) {
          throw new Error("Certified growers must provide their certification or license ID.");
        }
        let moderatorApplication = null;
        if (certified && form.moderatorOptIn) {
          const motivation = form.moderatorMotivation.trim();
          const availability = form.moderatorAvailability.trim();
          const experience = form.moderatorExperience.trim();
          const notes = form.moderatorNotes.trim();
          if (!motivation || !availability) {
            throw new Error("Please tell us why you would be a great moderator and when you are available.");
          }
          moderatorApplication = __spreadValues(__spreadValues({
            motivation,
            availability
          }, experience ? { experience } : {}), notes ? { notes } : {});
        }
        const payload = __spreadProps(__spreadValues({}, basePayload), {
          growerId: certified ? form.growerId : null,
          moderatorApplication
        });
        const res = yield fetch(`${API_BASE}/api/growers/profile/setup`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        if (!res.ok) {
          const message = yield res.json().catch(() => ({}));
          throw new Error(message.error || "Failed to register grower profile.");
        }
        setSnack("Registration submitted!");
        resetForm();
      } catch (e) {
        setError(e.message);
      } finally {
        setLoading(false);
      }
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { maxWidth: 720, mx: "auto", py: 4 }, children: [
    onBack && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onBack, size: "small", variant: "contained", sx: { bgcolor: "white", color: "black", textTransform: "none", fontWeight: 700, borderRadius: 999, mb: 1, "&:hover": { bgcolor: "grey.100" } }, children: "Home" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h5", children: "Grower Registration" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        TextField,
        {
          select: true,
          label: "Registration Type",
          value: mode,
          onChange: (e) => {
            const value = e.target.value;
            setMode(value);
            setForm((prev2) => __spreadProps(__spreadValues({}, prev2), {
              licenseStatus: value === "certified" ? "licensed" : prev2.licenseStatus === "licensed" ? "licensed" : "not_applicable",
              moderatorOptIn: value === "certified" ? prev2.moderatorOptIn : false,
              moderatorMotivation: value === "certified" ? prev2.moderatorMotivation : "",
              moderatorAvailability: value === "certified" ? prev2.moderatorAvailability : "",
              moderatorExperience: value === "certified" ? prev2.moderatorExperience : "",
              moderatorNotes: value === "certified" ? prev2.moderatorNotes : ""
            }));
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "certified", children: "Certified Grower" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "non-certified", children: "Non-Certified Grower" })
          ]
        }
      ),
      mode === "certified" && /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { label: "Grower ID", value: form.growerId, onChange: handleChange("growerId"), required: true }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { container: true, spacing: 2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { label: "Farm / Brand Name", value: form.farmName, onChange: handleChange("farmName"), fullWidth: true }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { label: "City", value: form.city, onChange: handleChange("city"), fullWidth: true }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { label: "State", value: form.state, onChange: handleChange("state"), fullWidth: true }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: "Years of Experience",
            type: "number",
            inputProps: { min: 0 },
            value: form.experienceYears,
            onChange: handleChange("experienceYears"),
            fullWidth: true
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { label: "Specialties (comma-separated)", value: form.specialties, onChange: handleChange("specialties"), fullWidth: true }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { label: "Bio", value: form.bio, onChange: handleChange("bio"), fullWidth: true, multiline: true, minRows: 3 }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            select: true,
            label: "License Status",
            value: form.licenseStatus,
            onChange: handleChange("licenseStatus"),
            fullWidth: true,
            disabled: mode === "certified",
            children: licenseOptions.map((opt) => /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: opt.value, children: opt.label }, opt.value))
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, sx: { display: "flex", alignItems: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FormControlLabel,
          {
            control: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Switch,
              {
                checked: form.acceptsMessages,
                onChange: handleBoolean("acceptsMessages")
              }
            ),
            label: "Accept direct messages from members"
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormControlLabel,
        {
          control: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Switch,
            {
              checked: form.optInDirectory,
              onChange: handleBoolean("optInDirectory")
            }
          ),
          label: "List me in the public grower directory"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", children: "New growers are welcome  we highlight certified growers separately and sort the list by experience so members can find the right fit." }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { container: true, spacing: 2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { label: "Public Phone (optional)", value: form.phone, onChange: handleChange("phone"), fullWidth: true }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { label: "Public Address (optional)", value: form.address, onChange: handleChange("address"), fullWidth: true }) })
      ] }),
      (form.phone || form.address) && /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormControlLabel,
        {
          control: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              checked: form.contactRiskAcknowledged,
              onChange: handleBoolean("contactRiskAcknowledged")
            }
          ),
          label: "I understand the risks of sharing my contact information publicly."
        }
      ),
      mode === "certified" && /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormControlLabel,
        {
          control: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Switch,
            {
              checked: form.moderatorOptIn,
              onChange: (e) => {
                const checked = e.target.checked;
                setForm((prev2) => __spreadProps(__spreadValues({}, prev2), {
                  moderatorOptIn: checked,
                  moderatorMotivation: checked ? prev2.moderatorMotivation : "",
                  moderatorAvailability: checked ? prev2.moderatorAvailability : "",
                  moderatorExperience: checked ? prev2.moderatorExperience : "",
                  moderatorNotes: checked ? prev2.moderatorNotes : ""
                }));
              }
            }
          ),
          label: "I'll earn that free membership by helping moderate the community (you gotta earn it!)"
        }
      ),
      mode === "certified" && form.moderatorOptIn && /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, sx: { p: 2, bgcolor: "rgba(124,179,66,0.08)", borderRadius: 2, border: "1px solid rgba(124,179,66,0.3)" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "info", sx: { bgcolor: "rgba(255,255,255,0.7)" }, children: "Certified moderators help keep conversations safe and on-topic. Share a quick note about how you can contribute so we can activate your complimentary membership." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: "Why you'd be a great moderator",
            value: form.moderatorMotivation,
            onChange: handleChange("moderatorMotivation"),
            fullWidth: true,
            multiline: true,
            minRows: 2,
            required: true
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: "Weekly availability (hours / time windows)",
            value: form.moderatorAvailability,
            onChange: handleChange("moderatorAvailability"),
            fullWidth: true,
            multiline: true,
            minRows: 2,
            required: true
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: "Experience moderating or supporting communities",
            value: form.moderatorExperience,
            onChange: handleChange("moderatorExperience"),
            fullWidth: true,
            multiline: true,
            minRows: 2
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: "Anything else we should know?",
            value: form.moderatorNotes,
            onChange: handleChange("moderatorNotes"),
            fullWidth: true,
            multiline: true,
            minRows: 2
          }
        )
      ] }),
      error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", children: error2 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { direction: "row", spacing: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "contained", onClick: submit, disabled: loading, children: loading ? "Submitting" : "Submit" }) })
    ] }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Snackbar, { open: !!snack, autoHideDuration: 2500, onClose: () => setSnack(""), message: snack })
  ] });
}
function GrowerDirectory({ onBack }) {
  const [growers, setGrowers] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [showRegistration, setShowRegistration] = reactExports.useState(false);
  reactExports.useEffect(() => {
    (() => __async(null, null, function* () {
      try {
        const res = yield fetch(`${API_BASE}/api/growers`);
        if (res.ok) {
          const payload = yield res.json();
          const list = Array.isArray(payload) ? payload : Array.isArray(payload.growers) ? payload.growers : [];
          setGrowers(list);
        }
      } finally {
        setLoading(false);
      }
    }))();
  }, []);
  const normalizeTags2 = reactExports.useMemo(
    () => (tags2) => Array.isArray(tags2) ? tags2.filter(Boolean) : [],
    []
  );
  const renderGrowerCard = (g) => {
    const primaryName = g.display_name || g.grower_farm_name || "Grower";
    const secondaryName = g.display_name && g.grower_farm_name && g.grower_farm_name !== g.display_name ? g.grower_farm_name : null;
    const tags2 = normalizeTags2(g.profile_tags);
    const roleLabel = g.role === "admin" ? "Admin" : g.role === "moderator" ? "Moderator" : g.role === "grower" ? "Grower" : null;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { height: "100%", background: "rgba(255,255,255,0.10)", backdropFilter: "blur(12px)", border: "2px solid black", boxShadow: "none" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 2, alignItems: "center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { sx: { bgcolor: "primary.main", width: 56, height: 56 }, children: primaryName.substring(0, 2).toUpperCase() }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { flex: 1 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", children: primaryName }),
          secondaryName && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: secondaryName }),
          g.grower_certified && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Chip,
            {
              label: "Certified",
              color: "success",
              size: "small",
              sx: { mt: 0.5, alignSelf: "flex-start" }
            }
          ),
          g.grower_city && /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 0.5, alignItems: "center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(LocationOnIcon, { fontSize: "small", color: "action" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", color: "text.secondary", children: [
              g.grower_city,
              g.grower_state ? `, ${g.grower_state}` : ""
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, sx: { mt: 1, flexWrap: "wrap" }, children: [
            roleLabel && /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: roleLabel, size: "small", color: "warning", variant: "outlined" }),
            tags2.slice(0, 3).map((tag) => /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: tag.replace(/_/g, " "), size: "small", variant: "outlined" }, tag))
          ] })
        ] })
      ] }),
      Array.isArray(g.grower_specialties) && g.grower_specialties.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", children: "Specialties:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { direction: "row", spacing: 0.5, flexWrap: "wrap", sx: { mt: 0.5 }, children: g.grower_specialties.map((s, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: s, size: "small", color: "success", variant: "outlined" }, i)) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", color: "text.secondary", children: [
        "Experience: ",
        g.grower_experience_years || 0,
        " years"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Chip,
        {
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(EmojiEvents, { fontSize: "small" }),
          label: g.grower_license_status === "licensed" ? "Licensed" : "Community",
          size: "small",
          sx: { alignSelf: "flex-start" }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outlined", size: "small", onClick: () => setShowRegistration(true), children: "Edit / View Profile" })
    ] }) }) }) }, g.user_id || g.id);
  };
  const renderSection = (title, list) => {
    if (!list || list.length === 0) return null;
    const sorted = [...list].sort((a, b) => {
      const experienceA = Number(a.grower_experience_years) || 0;
      const experienceB = Number(b.grower_experience_years) || 0;
      return experienceB - experienceA;
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h5", sx: { mb: 2, fontWeight: 700 }, children: title }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { container: true, spacing: 2, children: sorted.map(renderGrowerCard) })
    ] });
  };
  if (showRegistration) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      GrowerRegistration,
      {
        onBack: () => {
          setShowRegistration(false);
          (() => __async(null, null, function* () {
            try {
              const res = yield fetch(`${API_BASE}/api/growers`);
              if (res.ok) {
                const payload = yield res.json();
                const list = Array.isArray(payload) ? payload : Array.isArray(payload.growers) ? payload.growers : [];
                setGrowers(list);
              }
            } catch (err) {
              console.error("Error refreshing growers:", err);
            }
          }))();
        }
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { maxWidth: "lg", sx: {
    pt: "calc(env(safe-area-inset-top) + 48px)",
    pb: 4
  }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "space-between", alignItems: "center", sx: { mb: 3 }, children: [
      onBack && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onBack, size: "small", variant: "contained", sx: { bgcolor: "#7CB342", color: "white", textTransform: "none", fontWeight: 700, borderRadius: 999, "&:hover": { bgcolor: "#689f38" } }, children: " Back to Garden" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "contained",
          color: "primary",
          onClick: () => setShowRegistration(true),
          sx: { textTransform: "none", fontWeight: 600 },
          children: "Register as Grower"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", gap: 2, mb: 3 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Box,
        {
          sx: {
            width: 60,
            height: 60,
            borderRadius: "50%",
            background: "transparent",
            border: "2px solid rgba(124, 179, 66, 0.5)",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            boxShadow: "0 0 20px rgba(124, 179, 66, 0.4)",
            overflow: "hidden",
            flexShrink: 0
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: "/hero.png?v=13",
              alt: "StrainSpotter",
              style: { width: "100%", height: "100%", objectFit: "cover" }
            }
          )
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", sx: { fontWeight: 700 }, children: "Grower Directory" })
    ] }),
    loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { children: "Loading..." }) : growers.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { sx: { textAlign: "center", py: 5 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", color: "text.secondary", children: "No growers yet. Be the first to register!" }) }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 4, children: [
      renderSection("Certified Growers", growers.filter((g) => g.grower_certified)),
      renderSection("Community Growers", growers.filter((g) => !g.grower_certified))
    ] })
  ] });
}
function ProfileSetupDialog({
  open,
  email,
  initialDisplayName = "",
  saving = false,
  error: error2 = "",
  onSave,
  onClose
}) {
  const [displayName, setDisplayName] = reactExports.useState(initialDisplayName);
  reactExports.useEffect(() => {
    if (open) {
      setDisplayName(initialDisplayName || "");
    }
  }, [open, initialDisplayName]);
  const handleSubmit = () => {
    const trimmedName = displayName.trim();
    if (!trimmedName || trimmedName.length < 2) {
      return;
    }
    onSave == null ? void 0 : onSave({
      displayName: trimmedName
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Dialog,
    {
      open,
      onClose,
      maxWidth: "xs",
      fullWidth: true,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { sx: { fontWeight: 700, color: "#2e7d32" }, children: "Complete Your Profile" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, sx: { mt: 1 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "text.secondary" }, children: "Pick the name other members will see in groups and direct messages. You can change this anytime." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextField,
            {
              label: "Display Name",
              value: displayName,
              onChange: (e) => setDisplayName(e.target.value),
              placeholder: "e.g. Topher",
              required: true,
              inputProps: { maxLength: 60 }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextField,
            {
              label: "Email",
              value: email || "",
              InputProps: { readOnly: true }
            }
          ),
          error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#d32f2f" }, children: error2 })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions, { sx: { px: 3, pb: 2 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onClose, disabled: saving, children: "Not now" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "contained",
              onClick: handleSubmit,
              disabled: saving,
              children: saving ? "Saving..." : "Save"
            }
          )
        ] })
      ]
    }
  );
}
function normalizeMessage(msg, mode, currentUserId) {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _i;
  if (mode === "group") {
    return {
      id: msg.id,
      groupId: msg.group_id,
      senderId: msg.sender_user_id,
      senderName: ((_a2 = msg.users) == null ? void 0 : _a2.display_name) || ((_b = msg.users) == null ? void 0 : _b.username) || "User",
      senderAvatarUrl: ((_c = msg.users) == null ? void 0 : _c.avatar_url) || null,
      text: msg.body,
      attachments: msg.image_url ? [{ type: "image", url: msg.image_url }] : [],
      createdAt: msg.created_at,
      isSystem: false,
      isPinned: msg.is_pinned || false,
      raw: msg
      // Keep raw data for compatibility
    };
  } else {
    const attachments = Array.isArray(msg.attachments) ? msg.attachments : msg.image_url ? [{ type: "image", url: msg.image_url }] : [];
    return {
      id: msg.id,
      dmId: msg.conversation_id,
      senderId: msg.sender_id || msg.sender_user_id,
      senderName: ((_d = msg.sender) == null ? void 0 : _d.display_name) || ((_e = msg.sender) == null ? void 0 : _e.username) || ((_f = msg.profiles) == null ? void 0 : _f.display_name) || ((_g = msg.profiles) == null ? void 0 : _g.username) || "User",
      senderAvatarUrl: ((_h = msg.sender) == null ? void 0 : _h.avatar_url) || ((_i = msg.profiles) == null ? void 0 : _i.avatar_url) || null,
      text: msg.text || msg.body || "",
      attachments,
      createdAt: msg.created_at,
      isSystem: false,
      raw: msg
      // Keep raw data for compatibility
    };
  }
}
function useInfiniteMessages({ mode, id }) {
  const { session } = useAuth();
  const [messages, setMessages] = reactExports.useState([]);
  const [pinnedMessages, setPinnedMessages] = reactExports.useState([]);
  const [isLoadingInitial, setIsLoadingInitial] = reactExports.useState(true);
  const [isLoadingMore, setIsLoadingMore] = reactExports.useState(false);
  const [hasMore, setHasMore] = reactExports.useState(false);
  const [nextCursor, setNextCursor] = reactExports.useState(null);
  const [error2, setError] = reactExports.useState(null);
  const scrollToBottomRef = reactExports.useRef(null);
  const scrollContainerRef = reactExports.useRef(null);
  const isNearBottomRef = reactExports.useRef(true);
  const shouldAutoScrollRef = reactExports.useRef(true);
  const handleScroll = reactExports.useCallback(() => {
    if (!scrollContainerRef.current) return;
    const container = scrollContainerRef.current;
    const distanceFromBottom = container.scrollHeight - (container.scrollTop + container.clientHeight);
    isNearBottomRef.current = distanceFromBottom < 200;
  }, []);
  const scrollToBottom = reactExports.useCallback((behavior = "smooth") => {
    if (scrollToBottomRef.current) {
      scrollToBottomRef.current.scrollIntoView({ behavior, block: "end" });
    }
  }, []);
  reactExports.useEffect(() => {
    if (!id || !(session == null ? void 0 : session.access_token)) {
      setMessages([]);
      setPinnedMessages([]);
      setIsLoadingInitial(false);
      return;
    }
    let cancel = false;
    setIsLoadingInitial(true);
    setError(null);
    shouldAutoScrollRef.current = true;
    const token2 = session.access_token;
    const url = mode === "group" ? `${API_BASE}/api/groups/${id}/messages?limit=50` : `${API_BASE}/api/dm/${id}/messages?limit=50`;
    fetch(url, {
      headers: {
        Authorization: `Bearer ${token2}`,
        "Content-Type": "application/json"
      }
    }).then((res) => __async(null, null, function* () {
      if (!res.ok) {
        console.error("[useInfiniteMessages] Failed to load messages", res.status, res.statusText);
        if (!cancel) {
          setError(new Error(`Failed to load messages (${res.status})`));
          setIsLoadingInitial(false);
          setHasMore(false);
        }
        return { messages: [], pinned: [], hasMore: false, error: "unavailable" };
      }
      return res.json();
    })).then((data) => {
      if (cancel) return;
      if (data.error) {
        console.warn("[useInfiniteMessages] backend indicated error", data.error);
      }
      const incoming = data.messages || [];
      const normalizedMessages = incoming.map(
        (msg) => {
          var _a2;
          return normalizeMessage(msg, mode, (_a2 = session == null ? void 0 : session.user) == null ? void 0 : _a2.id);
        }
      );
      normalizedMessages.sort(
        (a, b) => new Date(a.createdAt) - new Date(b.createdAt)
      );
      setMessages(normalizedMessages);
      if (mode === "group" && data.pinned) {
        const normalizedPinned = (data.pinned || []).map(
          (msg) => {
            var _a2;
            return normalizeMessage(msg, mode, (_a2 = session == null ? void 0 : session.user) == null ? void 0 : _a2.id);
          }
        );
        setPinnedMessages(normalizedPinned);
      }
      setHasMore(data.hasMore || false);
      setNextCursor(data.nextCursor || null);
      setTimeout(() => {
        scrollToBottom("auto");
        isNearBottomRef.current = true;
      }, 100);
    }).catch((err) => {
      console.error("[useInfiniteMessages] error", err);
      if (!cancel) {
        setMessages([]);
        setHasMore(false);
        setError("Unable to load messages");
      }
    }).finally(() => {
      if (!cancel) {
        setIsLoadingInitial(false);
      }
    });
    return () => {
      cancel = true;
    };
  }, [id, mode, session]);
  const loadMore = reactExports.useCallback(() => __async(null, null, function* () {
    if (!id || !(session == null ? void 0 : session.access_token) || isLoadingMore || !hasMore || !nextCursor) {
      return;
    }
    setIsLoadingMore(true);
    setError(null);
    const container = scrollContainerRef.current;
    const oldScrollHeight = container ? container.scrollHeight : 0;
    const token2 = session.access_token;
    const url = mode === "group" ? `${API_BASE}/api/groups/${id}/messages?limit=50&before=${encodeURIComponent(nextCursor)}` : `${API_BASE}/api/dm/${id}/messages?limit=50&before=${encodeURIComponent(nextCursor)}`;
    try {
      const res = yield fetch(url, {
        headers: {
          Authorization: `Bearer ${token2}`,
          "Content-Type": "application/json"
        }
      });
      if (!res.ok) {
        const text = yield res.text().catch(() => "");
        throw new Error(`Failed to load more messages: ${res.status} ${text}`);
      }
      const data = yield res.json();
      const normalizedMessages = (data.messages || []).map(
        (msg) => {
          var _a2;
          return normalizeMessage(msg, mode, (_a2 = session == null ? void 0 : session.user) == null ? void 0 : _a2.id);
        }
      );
      normalizedMessages.sort(
        (a, b) => new Date(a.createdAt) - new Date(b.createdAt)
      );
      setMessages((prev2) => {
        const combined = [...normalizedMessages, ...prev2];
        const unique = combined.reduce((acc, msg) => {
          if (!acc.find((m) => m.id === msg.id)) {
            acc.push(msg);
          }
          return acc;
        }, []);
        return unique.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
      });
      setHasMore(data.hasMore || false);
      setNextCursor(data.nextCursor || null);
      if (container) {
        const newScrollHeight = container.scrollHeight;
        const scrollDiff = newScrollHeight - oldScrollHeight;
        container.scrollTop += scrollDiff;
      }
    } catch (err) {
      console.error("[useInfiniteMessages] loadMore error", err);
      setError((err == null ? void 0 : err.message) || "Failed to load more messages");
    } finally {
      setIsLoadingMore(false);
    }
  }), [id, mode, session, isLoadingMore, hasMore, nextCursor]);
  const onNewMessage = reactExports.useCallback((newMsg) => {
    var _a2;
    const normalized = normalizeMessage(newMsg, mode, (_a2 = session == null ? void 0 : session.user) == null ? void 0 : _a2.id);
    setMessages((prev2) => {
      if (prev2.find((m) => m.id === normalized.id)) {
        return prev2;
      }
      return [...prev2, normalized].sort(
        (a, b) => new Date(a.createdAt) - new Date(b.createdAt)
      );
    });
    if (isNearBottomRef.current) {
      setTimeout(() => {
        scrollToBottom("smooth");
      }, 100);
    }
  }, [mode, session, scrollToBottom]);
  return {
    messages,
    pinnedMessages,
    isLoadingInitial,
    isLoadingMore,
    hasMore,
    error: error2,
    loadMore,
    scrollToBottomRef,
    scrollContainerRef,
    onNewMessage,
    scrollToBottom,
    handleScroll
  };
}
function useTypingIndicator({ scope, id, currentUserId }) {
  const { session } = useAuth();
  const [typingUsers, setTypingUsers] = reactExports.useState([]);
  const typingTimeoutRef = reactExports.useRef(null);
  const lastTypingSentRef = reactExports.useRef(0);
  reactExports.useEffect(() => {
    if (!id || !scope || !(session == null ? void 0 : session.access_token)) {
      setTypingUsers([]);
      return;
    }
    const pollTyping = () => __async(null, null, function* () {
      try {
        const token2 = session.access_token;
        const res = yield fetch(`${API_BASE}/api/chat/typing?scope=${scope}&id=${id}`, {
          headers: {
            Authorization: `Bearer ${token2}`,
            "Content-Type": "application/json"
          }
        });
        if (res.ok) {
          const data = yield res.json();
          setTypingUsers(data.users || []);
        }
      } catch (err) {
        console.error("[useTypingIndicator] poll error", err);
      }
    });
    pollTyping();
    const interval = setInterval(pollTyping, 3e3);
    return () => clearInterval(interval);
  }, [id, scope, session]);
  const notifyTyping = reactExports.useCallback(() => {
    if (!id || !scope || !(session == null ? void 0 : session.access_token) || !currentUserId) {
      return;
    }
    const now = Date.now();
    if (now - lastTypingSentRef.current < 2e3) {
      return;
    }
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }
    const token2 = session.access_token;
    fetch(`${API_BASE}/api/chat/typing`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${token2}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        scope,
        id,
        isTyping: true
      })
    }).catch((err) => {
      console.error("[useTypingIndicator] notifyTyping error", err);
    });
    lastTypingSentRef.current = now;
    typingTimeoutRef.current = setTimeout(() => {
      fetch(`${API_BASE}/api/chat/typing`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${token2}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          scope,
          id,
          isTyping: false
        })
      }).catch((err) => {
        console.error("[useTypingIndicator] stopTyping error", err);
      });
    }, 5e3);
  }, [id, scope, session, currentUserId]);
  reactExports.useEffect(() => {
    return () => {
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }
      if (id && scope && (session == null ? void 0 : session.access_token) && currentUserId) {
        fetch(`${API_BASE}/api/chat/typing`, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${session.access_token}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            scope,
            id,
            isTyping: false
          })
        }).catch(() => {
        });
      }
    };
  }, [id, scope, session, currentUserId]);
  return {
    typingUsers,
    notifyTyping
  };
}
function formatTime$1(iso) {
  if (!iso) return "";
  const date = new Date(iso);
  const now = /* @__PURE__ */ new Date();
  const diffMs = now - date;
  const diffMins = Math.floor(diffMs / 6e4);
  if (diffMins < 1) return "now";
  if (diffMins < 60) return `${diffMins}m`;
  const diffHours = Math.floor(diffMins / 60);
  if (diffHours < 24) return `${diffHours}h`;
  const diffDays = Math.floor(diffHours / 24);
  if (diffDays < 7) return `${diffDays}d`;
  return date.toLocaleDateString();
}
function messageSnippet(content) {
  if (!content) return "No messages yet";
  return content.length > 50 ? `${content.slice(0, 47)}` : content;
}
function GroupList({ groups, selectedGroupId, onSelectGroup, isLoading }) {
  if (isLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { p: 2, textAlign: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "rgba(255,255,255,0.5)" }, children: "Loading groups..." }) });
  }
  if (!groups || groups.length === 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { p: 2, textAlign: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "rgba(255,255,255,0.5)" }, children: "No groups available" }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      sx: {
        flex: 1,
        overflowY: "auto",
        WebkitOverflowScrolling: "touch",
        padding: 1
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 0.5, children: groups.map((group) => {
        var _a2, _b;
        const isActive = group.id === selectedGroupId;
        const lastMessage = group.last_message;
        const unreadCount = group.unread_count || 0;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            onClick: () => onSelectGroup == null ? void 0 : onSelectGroup(group),
            sx: {
              display: "flex",
              alignItems: "center",
              gap: 1.5,
              padding: "10px 12px",
              borderRadius: 2,
              cursor: "pointer",
              backgroundColor: isActive ? "rgba(124, 179, 66, 0.15)" : "transparent",
              border: isActive ? "1px solid rgba(124, 179, 66, 0.3)" : "1px solid transparent",
              "&:hover": {
                backgroundColor: isActive ? "rgba(124, 179, 66, 0.2)" : "rgba(255,255,255,0.06)"
              },
              transition: "background-color 0.2s"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Avatar,
                {
                  sx: {
                    width: 40,
                    height: 40,
                    bgcolor: "rgba(124, 179, 66, 0.3)",
                    color: "#CDDC39",
                    flexShrink: 0
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(GroupsIcon, {})
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { flex: 1, minWidth: 0 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", justifyContent: "space-between", mb: 0.5 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Typography,
                    {
                      variant: "subtitle2",
                      sx: {
                        fontWeight: 600,
                        color: "#F1F8E9",
                        overflow: "hidden",
                        textOverflow: "ellipsis",
                        whiteSpace: "nowrap"
                      },
                      children: group.name
                    }
                  ),
                  lastMessage && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Typography,
                    {
                      variant: "caption",
                      sx: {
                        color: "rgba(255,255,255,0.5)",
                        fontSize: "0.7rem",
                        flexShrink: 0,
                        ml: 1
                      },
                      children: formatTime$1(lastMessage.created_at)
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", gap: 1 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Typography,
                    {
                      variant: "caption",
                      sx: {
                        color: "rgba(255,255,255,0.6)",
                        fontSize: "0.75rem",
                        overflow: "hidden",
                        textOverflow: "ellipsis",
                        whiteSpace: "nowrap",
                        flex: 1
                      },
                      children: lastMessage ? `${((_a2 = lastMessage.user) == null ? void 0 : _a2.display_name) || ((_b = lastMessage.user) == null ? void 0 : _b.username) || "Someone"}: ${messageSnippet(lastMessage.content)}` : "No messages yet"
                    }
                  ),
                  unreadCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Badge,
                    {
                      badgeContent: unreadCount,
                      sx: {
                        "& .MuiBadge-badge": {
                          bgcolor: "#7CB342",
                          color: "#0c220f",
                          fontWeight: 700,
                          fontSize: "0.65rem",
                          minWidth: "18px",
                          height: "18px"
                        }
                      }
                    }
                  )
                ] })
              ] })
            ]
          },
          group.id
        );
      }) })
    }
  );
}
function GroupHeader({
  group,
  memberCount,
  onBack,
  onMenu,
  isMobile = false,
  typingUsers = []
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        display: "flex",
        alignItems: "center",
        gap: 1.5,
        paddingX: 2,
        paddingY: 1.5,
        borderBottom: "1px solid rgba(255,255,255,0.08)",
        flexShrink: 0,
        backgroundColor: "rgba(0,0,0,0.2)",
        backdropFilter: "blur(10px)"
      },
      children: [
        isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton$1,
          {
            onClick: onBack,
            sx: {
              color: "#CDDC39",
              "&:hover": {
                bgcolor: "rgba(124,179,66,0.1)"
              }
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowBackIcon, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            sx: {
              width: 40,
              height: 40,
              borderRadius: "50%",
              bgcolor: "rgba(124, 179, 66, 0.3)",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              flexShrink: 0
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(GroupsIcon, { sx: { color: "#CDDC39" } })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { flex: 1, minWidth: 0 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "subtitle1",
              sx: {
                fontWeight: 600,
                color: "#F1F8E9",
                overflow: "hidden",
                textOverflow: "ellipsis",
                whiteSpace: "nowrap"
              },
              children: (group == null ? void 0 : group.name) || "Group"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Typography,
            {
              variant: "caption",
              sx: {
                color: "rgba(255,255,255,0.6)",
                fontSize: "0.75rem"
              },
              children: [
                memberCount || 0,
                " member",
                memberCount !== 1 ? "s" : ""
              ]
            }
          ),
          typingUsers.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "caption",
              sx: {
                color: "#9CCC65",
                fontSize: "0.7rem",
                fontStyle: "italic",
                mt: 0.25
              },
              children: typingUsers.length === 1 ? `${typingUsers[0].displayName} is typing` : "Several people are typing"
            }
          )
        ] }),
        onMenu && /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton$1,
          {
            onClick: onMenu,
            sx: {
              color: "#9CCC65",
              "&:hover": {
                bgcolor: "rgba(124,179,66,0.1)"
              }
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(MoreVertIcon, {})
          }
        )
      ]
    }
  );
}
function ChatInput({
  value,
  onChange,
  onSend,
  onAttach,
  disabled,
  sending,
  placeholder = "Type a message",
  showAttach = false,
  replyToMessage = null,
  onCancelReply = null,
  notifyTyping = null,
  scope = "group",
  // 'group' or 'dm'
  channelId = null
  // groupId or conversationId for uploads
}) {
  var _a2;
  const [pendingAttachments, setPendingAttachments] = reactExports.useState([]);
  const [uploading, setUploading] = reactExports.useState(false);
  const fileInputRef = reactExports.useRef(null);
  const handleKeyDown = (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      if ((value.trim() || pendingAttachments.length > 0) && !disabled && !sending && !uploading) {
        handleSend();
      }
    }
  };
  const handleChange = (newValue) => {
    onChange == null ? void 0 : onChange(newValue);
    if (notifyTyping && newValue.trim()) {
      notifyTyping();
    }
  };
  const handleImagePick = () => {
    var _a3;
    (_a3 = fileInputRef.current) == null ? void 0 : _a3.click();
  };
  const handleFileSelect = (e) => __async(null, null, function* () {
    var _a3;
    const file = (_a3 = e.target.files) == null ? void 0 : _a3[0];
    if (!file) return;
    if (!file.type.startsWith("image/")) {
      alert("Please select an image file");
      return;
    }
    if (file.size > 8 * 1024 * 1024) {
      alert("Image must be smaller than 8MB");
      return;
    }
    if (!channelId) {
      alert("Channel ID is required for uploads");
      return;
    }
    setUploading(true);
    try {
      const ext = file.name.split(".").pop() || "jpg";
      const filename = `${crypto.randomUUID()}.${ext}`;
      const path = `${scope}/${channelId}/${filename}`;
      const { data: uploadData, error: uploadError } = yield supabase.storage.from("chat-attachments").upload(path, file, {
        contentType: file.type,
        cacheControl: "3600"
      });
      if (uploadError) {
        console.error("[ChatInput] Upload error", uploadError);
        alert("Failed to upload image. Please try again.");
        return;
      }
      const { data: urlData } = supabase.storage.from("chat-attachments").getPublicUrl(path);
      const img = new Image();
      img.src = urlData.publicUrl;
      yield new Promise((resolve, reject) => {
        img.onload = () => resolve({ width: img.width, height: img.height });
        img.onerror = reject;
      });
      const attachment = {
        type: "image",
        url: urlData.publicUrl,
        width: img.width,
        height: img.height
      };
      setPendingAttachments((prev2) => [...prev2, attachment]);
    } catch (err) {
      console.error("[ChatInput] File handling error", err);
      alert("Failed to process image. Please try again.");
    } finally {
      setUploading(false);
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    }
  });
  const handleSend = () => {
    if (!value.trim() && pendingAttachments.length === 0) return;
    if (disabled || sending || uploading) return;
    onSend == null ? void 0 : onSend(value, pendingAttachments.length > 0 ? pendingAttachments : null);
    onChange == null ? void 0 : onChange("");
    setPendingAttachments([]);
    if (onCancelReply) {
      onCancelReply();
    }
  };
  const removeAttachment = (index2) => {
    setPendingAttachments((prev2) => prev2.filter((_, i) => i !== index2));
  };
  const canSend = (value.trim() || pendingAttachments.length > 0) && !disabled && !sending && !uploading;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        borderTop: "1px solid rgba(255,255,255,0.08)",
        padding: 1.5,
        flexShrink: 0,
        backgroundColor: "rgba(0,0,0,0.3)",
        backdropFilter: "blur(10px)"
      },
      children: [
        replyToMessage && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            sx: {
              display: "flex",
              alignItems: "center",
              gap: 1,
              mb: 1,
              p: 1,
              borderRadius: 1,
              bgcolor: "rgba(124,179,66,0.15)",
              borderLeft: "3px solid rgba(124,179,66,0.5)"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { flex: 1, minWidth: 0 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", sx: { fontWeight: 600, color: "#CDDC39", display: "block" }, children: [
                  "Replying to ",
                  replyToMessage.senderName || ((_a2 = replyToMessage.sender) == null ? void 0 : _a2.display_name) || "someone"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Typography,
                  {
                    variant: "caption",
                    sx: {
                      color: "rgba(255,255,255,0.7)",
                      fontSize: "0.7rem",
                      overflow: "hidden",
                      textOverflow: "ellipsis",
                      whiteSpace: "nowrap",
                      display: "block"
                    },
                    children: replyToMessage.text || replyToMessage.body || replyToMessage.content || ""
                  }
                )
              ] }),
              onCancelReply && /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton$1,
                {
                  size: "small",
                  onClick: onCancelReply,
                  sx: {
                    color: "#9CCC65",
                    "&:hover": {
                      bgcolor: "rgba(124,179,66,0.2)"
                    }
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, { fontSize: "small" })
                }
              )
            ]
          }
        ),
        pendingAttachments.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mb: 1, display: "flex", gap: 1, flexWrap: "wrap" }, children: pendingAttachments.map((att, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            sx: {
              position: "relative",
              width: 60,
              height: 60,
              borderRadius: 1,
              overflow: "hidden",
              border: "1px solid rgba(255,255,255,0.2)"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "img",
                {
                  src: att.url,
                  alt: "Attachment preview",
                  style: {
                    width: "100%",
                    height: "100%",
                    objectFit: "cover"
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton$1,
                {
                  size: "small",
                  onClick: () => removeAttachment(idx),
                  sx: {
                    position: "absolute",
                    top: 0,
                    right: 0,
                    bgcolor: "rgba(0,0,0,0.6)",
                    color: "#fff",
                    width: 20,
                    height: 20,
                    "&:hover": {
                      bgcolor: "rgba(0,0,0,0.8)"
                    }
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, { sx: { fontSize: "0.75rem" } })
                }
              )
            ]
          },
          idx
        )) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, alignItems: "flex-end", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              ref: fileInputRef,
              type: "file",
              accept: "image/*",
              style: { display: "none" },
              onChange: handleFileSelect
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton$1,
            {
              onClick: handleImagePick,
              disabled: disabled || uploading || !channelId,
              sx: {
                color: "#9CCC65",
                "&:hover": {
                  bgcolor: "rgba(124,179,66,0.1)"
                },
                "&:disabled": {
                  opacity: 0.5
                }
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(ImageIcon, {})
            }
          ),
          showAttach && onAttach && /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton$1,
            {
              onClick: onAttach,
              disabled,
              sx: {
                color: "#9CCC65",
                "&:hover": {
                  bgcolor: "rgba(124,179,66,0.1)"
                }
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(AttachFileIcon, {})
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextField,
            {
              fullWidth: true,
              multiline: true,
              maxRows: 4,
              value,
              onChange: (e) => handleChange(e.target.value),
              onKeyDown: handleKeyDown,
              placeholder,
              disabled: disabled || uploading,
              variant: "outlined",
              sx: {
                "& .MuiOutlinedInput-root": {
                  bgcolor: "rgba(255,255,255,0.05)",
                  borderRadius: 3,
                  border: "1px solid rgba(255,255,255,0.1)",
                  color: "#F1F8E9",
                  "&:hover": {
                    borderColor: "rgba(124,179,66,0.3)"
                  },
                  "&.Mui-focused": {
                    borderColor: "rgba(124,179,66,0.5)",
                    bgcolor: "rgba(255,255,255,0.08)"
                  },
                  "& fieldset": {
                    border: "none"
                  }
                },
                "& .MuiInputBase-input": {
                  padding: "10px 14px",
                  fontSize: "0.9rem",
                  "&::placeholder": {
                    color: "rgba(255,255,255,0.4)",
                    opacity: 1
                  }
                }
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton$1,
            {
              onClick: handleSend,
              disabled: !canSend,
              sx: {
                color: canSend ? "#7CB342" : "rgba(255,255,255,0.3)",
                bgcolor: canSend ? "rgba(124,179,66,0.2)" : "transparent",
                "&:hover": {
                  bgcolor: canSend ? "rgba(124,179,66,0.3)" : "transparent"
                },
                "&:disabled": {
                  opacity: 0.5
                }
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(SendIcon, {})
            }
          )
        ] }),
        uploading && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { color: "rgba(255,255,255,0.6)", fontSize: "0.7rem", mt: 0.5, display: "block" }, children: "Uploading image..." })
      ]
    }
  );
}
function formatTime(iso) {
  if (!iso) return "";
  const date = new Date(iso);
  const now = /* @__PURE__ */ new Date();
  const diffMs = now - date;
  const diffMins = Math.floor(diffMs / 6e4);
  if (diffMins < 1) return "just now";
  if (diffMins < 60) return `${diffMins}m ago`;
  const diffHours = Math.floor(diffMins / 60);
  if (diffHours < 24) return `${diffHours}h ago`;
  const diffDays = Math.floor(diffHours / 24);
  if (diffDays < 7) return `${diffDays}d ago`;
  return date.toLocaleDateString();
}
function getInitials(name2) {
  return name2.slice(0, 2).toUpperCase();
}
function GroupMessages({
  messages,
  pinnedMessages,
  isLoadingInitial,
  isLoadingMore,
  hasMore,
  onLoadMore,
  scrollContainerRef,
  scrollToBottomRef,
  onScroll,
  currentUserId,
  onReply = null,
  group,
  onBack,
  onSend,
  typingUsers = []
}) {
  const { user } = useAuth();
  const userId = currentUserId || (user == null ? void 0 : user.id);
  const theme2 = useTheme();
  const isMobile = useMediaQuery(theme2.breakpoints.down("md"));
  const [replyTo, setReplyTo] = reactExports.useState(null);
  const clearReply = () => setReplyTo(null);
  const handleSend = (text, attachments) => {
    if (onSend) {
      onSend(text, attachments, replyTo);
      clearReply();
    }
  };
  const scrollAnchorRef = reactExports.useRef(null);
  const touchStartXRef = reactExports.useRef(0);
  const touchStartYRef = reactExports.useRef(0);
  const loading = isLoadingInitial;
  if (error && !loading && (!messages || messages.length === 0)) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box,
      {
        sx: {
          display: "flex",
          flexDirection: "column",
          height: "100%",
          overflow: "hidden",
          backgroundColor: "#000"
        },
        children: [
          group && /* @__PURE__ */ jsxRuntimeExports.jsx(
            GroupHeader,
            {
              group,
              onBack,
              typingUsers,
              isMobile
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
            flex: 1,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            p: 3,
            textAlign: "center"
          }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#ccc", mb: 1 }, children: "Couldn't load messages right now. You can still send a new one." }),
            onSend && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { color: "#999" }, children: "Try sending a message to refresh the conversation." })
          ] }) }),
          group && onSend && /* @__PURE__ */ jsxRuntimeExports.jsx(
            ChatInput,
            {
              value: "",
              onChange: () => {
              },
              onSend: handleSend,
              disabled: false,
              sending: false,
              placeholder: "Type a message",
              replyToMessage: replyTo,
              onCancelReply: clearReply,
              scope: "group",
              channelId: group.id
            }
          )
        ]
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        display: "flex",
        flexDirection: "column",
        height: "100%",
        overflow: "hidden",
        backgroundColor: "#000"
      },
      children: [
        group && /* @__PURE__ */ jsxRuntimeExports.jsx(
          GroupHeader,
          {
            group,
            onBack,
            typingUsers,
            isMobile
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            sx: {
              flex: 1,
              minHeight: 0,
              overflowY: "auto",
              WebkitOverflowScrolling: "touch",
              paddingBottom: "16px"
            },
            ref: scrollContainerRef,
            onScroll,
            children: [
              loading && (!messages || messages.length === 0) && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                height: "100%",
                p: 2,
                color: "#ccc"
              }, children: "Loading messages" }),
              !loading && !error && (!messages || messages.length === 0) && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
                p: 2,
                color: "#ccc",
                textAlign: "center",
                mt: 2
              }, children: "No messages yet. Be the first to say hi " }),
              hasMore && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mb: 2, display: "flex", justifyContent: "center", pt: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: onLoadMore,
                  disabled: isLoadingMore,
                  variant: "outlined",
                  size: "small",
                  sx: {
                    color: "#9CCC65",
                    borderColor: "rgba(124,179,66,0.4)",
                    "&:hover": {
                      borderColor: "rgba(124,179,66,0.6)",
                      bgcolor: "rgba(124,179,66,0.1)"
                    }
                  },
                  children: isLoadingMore ? "Loading" : "Load earlier messages"
                }
              ) }),
              pinnedMessages && pinnedMessages.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Box,
                {
                  sx: {
                    mb: 2,
                    p: 1.5,
                    borderRadius: 2,
                    bgcolor: "rgba(205, 220, 57, 0.15)",
                    border: "2px solid rgba(205, 220, 57, 0.4)"
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Typography,
                      {
                        variant: "subtitle2",
                        sx: {
                          color: "#CDDC39",
                          fontWeight: 700,
                          mb: 1,
                          fontSize: "0.75rem"
                        },
                        children: " Pinned Messages"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 1, children: pinnedMessages.slice(0, 3).map((pm) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Typography,
                      {
                        variant: "caption",
                        sx: {
                          color: "#F1F8E9",
                          fontSize: "0.75rem",
                          display: "block"
                        },
                        children: pm.body || pm.text || pm.content
                      },
                      pm.id
                    )) })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 1, sx: { px: 2 }, children: (Array.isArray(messages) ? messages : []).filter((m) => !m.isPinned && !m.pinned_at).map((message, idx) => {
                var _a2, _b, _c, _d, _e, _f;
                const msg = message.raw || message;
                const isMine = msg.sender_user_id === userId || msg.senderId === userId;
                const senderName = msg.senderName || ((_a2 = msg.users) == null ? void 0 : _a2.display_name) || ((_b = msg.users) == null ? void 0 : _b.username) || ((_c = msg.sender) == null ? void 0 : _c.display_name) || ((_d = msg.sender) == null ? void 0 : _d.username) || "User";
                const text = msg.text || msg.body || msg.content || "";
                const createdAt = msg.createdAt || msg.created_at;
                const avatarUrl = msg.senderAvatarUrl || ((_e = msg.users) == null ? void 0 : _e.avatar_url) || ((_f = msg.sender) == null ? void 0 : _f.avatar_url) || null;
                const prevMessage = idx > 0 ? messages[idx - 1] : null;
                const prevMsg = (prevMessage == null ? void 0 : prevMessage.raw) || prevMessage;
                const isSameSender = prevMsg && (prevMsg.sender_user_id === msg.sender_user_id || prevMsg.senderId === msg.senderId);
                const showAvatar = !isMine && (!isSameSender || idx === 0);
                const showName = !isMine && !isSameSender;
                const handleTouchStart = (e) => {
                  if (!isMobile || !onReply || isMine) return;
                  touchStartXRef.current = e.touches[0].clientX;
                  touchStartYRef.current = e.touches[0].clientY;
                };
                const handleTouchEnd = (e) => {
                  if (!isMobile || !onReply || isMine) return;
                  const deltaX = e.changedTouches[0].clientX - touchStartXRef.current;
                  const deltaY = Math.abs(e.changedTouches[0].clientY - touchStartYRef.current);
                  if (deltaX > 40 && deltaY < 50) {
                    onReply(message);
                  }
                };
                return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Box,
                  {
                    onTouchStart: handleTouchStart,
                    onTouchEnd: handleTouchEnd,
                    sx: {
                      display: "flex",
                      justifyContent: isMine ? "flex-end" : "flex-start",
                      paddingX: 1,
                      paddingY: showAvatar ? 0.5 : 0.25,
                      cursor: isMobile && !isMine && onReply ? "grab" : "default",
                      userSelect: "none"
                    },
                    children: [
                      !isMine && /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Avatar,
                        {
                          sx: {
                            width: 32,
                            height: 32,
                            bgcolor: "rgba(124, 179, 66, 0.3)",
                            color: "#CDDC39",
                            mr: 1,
                            flexShrink: 0,
                            display: showAvatar ? "flex" : "none"
                          },
                          src: avatarUrl,
                          children: getInitials(senderName)
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        Box,
                        {
                          sx: {
                            maxWidth: "75%",
                            minWidth: "120px"
                          },
                          children: [
                            showName && /* @__PURE__ */ jsxRuntimeExports.jsx(
                              Typography,
                              {
                                variant: "caption",
                                sx: {
                                  color: "rgba(255,255,255,0.7)",
                                  fontSize: "0.7rem",
                                  fontWeight: 600,
                                  mb: 0.25,
                                  display: "block"
                                },
                                children: senderName
                              }
                            ),
                            /* @__PURE__ */ jsxRuntimeExports.jsxs(
                              Box,
                              {
                                sx: {
                                  borderRadius: 3,
                                  padding: "8px 12px",
                                  backgroundColor: isMine ? "rgba(124, 179, 66, 0.25)" : "rgba(255, 255, 255, 0.08)",
                                  border: isMine ? "1px solid rgba(124, 179, 66, 0.3)" : "1px solid rgba(255, 255, 255, 0.1)",
                                  backdropFilter: "blur(10px)"
                                },
                                children: [
                                  text && /* @__PURE__ */ jsxRuntimeExports.jsx(
                                    Typography,
                                    {
                                      variant: "body2",
                                      sx: {
                                        color: "#F1F8E9",
                                        whiteSpace: "pre-wrap",
                                        wordBreak: "break-word",
                                        fontSize: "0.9rem",
                                        lineHeight: 1.4
                                      },
                                      children: text
                                    }
                                  ),
                                  msg.image_url && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mt: text ? 1 : 0 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                                    "img",
                                    {
                                      src: msg.image_url,
                                      alt: "Attachment",
                                      style: {
                                        maxWidth: "100%",
                                        borderRadius: "8px",
                                        display: "block"
                                      }
                                    }
                                  ) }),
                                  msg.attachments && Array.isArray(msg.attachments) && msg.attachments.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mt: text ? 1 : 0, display: "flex", flexDirection: "column", gap: 1 }, children: msg.attachments.map((att, idx2) => {
                                    if (att.type === "image" && att.url) {
                                      return /* @__PURE__ */ jsxRuntimeExports.jsx(
                                        Box,
                                        {
                                          sx: {
                                            borderRadius: 2,
                                            overflow: "hidden",
                                            border: "1px solid rgba(255,255,255,0.1)"
                                          },
                                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                                            "img",
                                            {
                                              src: att.url,
                                              alt: "Message attachment",
                                              style: {
                                                maxWidth: "100%",
                                                height: "auto",
                                                display: "block"
                                              }
                                            }
                                          )
                                        },
                                        idx2
                                      );
                                    }
                                    return null;
                                  }) }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                    Typography,
                                    {
                                      variant: "caption",
                                      sx: {
                                        display: "block",
                                        textAlign: isMine ? "right" : "left",
                                        color: "rgba(255,255,255,0.5)",
                                        fontSize: "0.65rem",
                                        marginTop: 0.25
                                      },
                                      children: [
                                        formatTime(createdAt),
                                        msg.optimistic && "  sending"
                                      ]
                                    }
                                  )
                                ]
                              }
                            )
                          ]
                        }
                      )
                    ]
                  },
                  msg.id || idx
                );
              }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  ref: scrollAnchorRef,
                  "data-scroll-anchor": "group-messages-end",
                  style: { height: 1 }
                }
              ),
              scrollToBottomRef && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: scrollToBottomRef })
            ]
          }
        ),
        group && onSend && /* @__PURE__ */ jsxRuntimeExports.jsx(
          ChatInput,
          {
            value: "",
            onChange: () => {
            },
            onSend: handleSend,
            disabled: false,
            sending: false,
            placeholder: "Type a message",
            replyToMessage: replyTo,
            onCancelReply: clearReply,
            scope: "group",
            channelId: group.id
          }
        )
      ]
    }
  );
}
function Groups({ userId: userIdProp, onNavigate, onBack }) {
  const { user: authUser } = useAuth();
  useTheme();
  const isMobile = useMediaQuery("(max-width:900px)");
  const [groups, setGroups] = reactExports.useState([]);
  const [userId, setUserId] = reactExports.useState(userIdProp || (authUser == null ? void 0 : authUser.id) || null);
  const [selectedGroup, setSelectedGroup] = reactExports.useState(null);
  const [groupDialogOpen, setGroupDialogOpen] = reactExports.useState(false);
  const [members, setMembers] = reactExports.useState([]);
  const groupMessagesHook = useInfiniteMessages({
    mode: "group",
    id: (selectedGroup == null ? void 0 : selectedGroup.id) || null
  });
  const groupTypingHook = useTypingIndicator({
    scope: "group",
    id: (selectedGroup == null ? void 0 : selectedGroup.id) || null,
    currentUserId: userId
  });
  const [messages, setMessages] = reactExports.useState([]);
  const [pinnedMessages, setPinnedMessages] = reactExports.useState([]);
  const [userRole, setUserRole] = reactExports.useState("consumer");
  const [input, setInput] = reactExports.useState("");
  const [sending, setSending] = reactExports.useState(false);
  const [sendError, setSendError] = reactExports.useState("");
  const [replyTo, setReplyTo] = reactExports.useState(null);
  const [pendingAttachments, setPendingAttachments] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [activeTab, setActiveTab] = reactExports.useState(0);
  const [directChats, setDirectChats] = reactExports.useState([]);
  const [selectedChat, setSelectedChat] = reactExports.useState(null);
  const [chatDialogOpen, setChatDialogOpen] = reactExports.useState(false);
  const [dmConversationId, setDmConversationId] = reactExports.useState(null);
  const [allUsers, setAllUsers] = reactExports.useState([]);
  const dmMessagesHook = useInfiniteMessages({
    mode: "dm",
    id: dmConversationId || null
  });
  const [directMessages, setDirectMessages] = reactExports.useState([]);
  const [usersError, setUsersError] = reactExports.useState(null);
  const [loadingUsers, setLoadingUsers] = reactExports.useState(false);
  const [userSearchTerm, setUserSearchTerm] = reactExports.useState("");
  const [dmFilter, setDmFilter] = reactExports.useState("recent");
  (authUser == null ? void 0 : authUser.email) === "topher.cook7@gmail.com" || (authUser == null ? void 0 : authUser.email) === "strainspotter25@gmail.com" || (authUser == null ? void 0 : authUser.email) === "admin@strainspotter.com" || (authUser == null ? void 0 : authUser.email) === "andrewbeck209@gmail.com";
  const [showMemberList, setShowMemberList] = reactExports.useState(false);
  const ALLOWED_GROUPS = [
    "Growers",
    "Budtenders",
    "Medical",
    "Recreational",
    "Local Chat",
    "General",
    "Dispensary Owners",
    "Seed Swap",
    "Events",
    "Help & Advice"
  ];
  const [isMember, setIsMember] = reactExports.useState(false);
  const [reportDialogOpen, setReportDialogOpen] = reactExports.useState(false);
  const [reportingMessage, setReportingMessage] = reactExports.useState(null);
  const [reportReason, setReportReason] = reactExports.useState("inappropriate");
  const [reportDetails, setReportDetails] = reactExports.useState("");
  const [guidelinesOpen, setGuidelinesOpen] = reactExports.useState(false);
  const [guidelinesChecked, setGuidelinesChecked] = reactExports.useState(false);
  const [guidelinesAccepted, setGuidelinesAccepted] = reactExports.useState(false);
  const [snackbar, setSnackbar] = reactExports.useState({ open: false, message: "", severity: "success" });
  const guidelinesKey = reactExports.useMemo(() => `ss_guidelines_accepted_${userId || "guest"}`, [userId]);
  const handleSnackbarClose = (_event, reason) => {
    if (reason === "clickaway") return;
    setSnackbar((prev2) => __spreadProps(__spreadValues({}, prev2), { open: false }));
  };
  const normalizeText = reactExports.useCallback((value) => (value || "").toString().toLowerCase().trim(), []);
  const userDisplayName = reactExports.useCallback((user) => {
    return (user == null ? void 0 : user.display_name) || (user == null ? void 0 : user.username) || ((user == null ? void 0 : user.email) ? user.email.split("@")[0] : null) || "User";
  }, []);
  const filteredDirectChats = reactExports.useMemo(() => {
    const term = normalizeText(userSearchTerm);
    if (!term) return directChats;
    return directChats.filter((chat) => normalizeText(userDisplayName(chat.user)).includes(term));
  }, [directChats, userSearchTerm, normalizeText, userDisplayName]);
  const filteredUsers = reactExports.useMemo(() => {
    const term = normalizeText(userSearchTerm);
    const list = allUsers.map((user) => __spreadProps(__spreadValues({}, user), {
      _label: userDisplayName(user)
    })).sort((a, b) => a._label.localeCompare(b._label));
    if (!term) return list;
    return list.filter((user) => normalizeText(user._label).includes(term));
  }, [allUsers, userSearchTerm, normalizeText, userDisplayName]);
  const [adminUserId, setAdminUserId] = reactExports.useState(null);
  const [lastRefresh, setLastRefresh] = reactExports.useState(null);
  const [profileInfo, setProfileInfo] = reactExports.useState(null);
  const [profileDialogOpen, setProfileDialogOpen] = reactExports.useState(false);
  const [profileSaving, setProfileSaving] = reactExports.useState(false);
  const [profileError, setProfileError] = reactExports.useState("");
  const [profilePromptDismissed, setProfilePromptDismissed] = reactExports.useState(false);
  const sendHeartbeat = reactExports.useCallback(() => __async(null, null, function* () {
    if (!userId) return;
    try {
      const { data: { session } } = yield supabase.auth.getSession();
      const token2 = session == null ? void 0 : session.access_token;
      if (!token2) return;
      yield fetch(`${API_BASE}/api/users/heartbeat`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${token2}`
        }
      });
    } catch (err) {
      console.error("[Groups] Heartbeat failed:", err);
    }
  }), [userId]);
  const formatTimestamp = reactExports.useCallback((iso) => {
    if (!iso) return "";
    const date = new Date(iso);
    const diffSeconds = (Date.now() - date.getTime()) / 1e3;
    if (diffSeconds < 45) return "just now";
    if (diffSeconds < 90) return "1 min ago";
    const diffMinutes = diffSeconds / 60;
    if (diffMinutes < 60) return `${Math.round(diffMinutes)} min ago`;
    const diffHours = diffMinutes / 60;
    if (diffHours < 24) return `${Math.round(diffHours)} hr${Math.round(diffHours) === 1 ? "" : "s"} ago`;
    const diffDays = diffHours / 24;
    if (diffDays < 30) return `${Math.round(diffDays)} day${Math.round(diffDays) === 1 ? "" : "s"} ago`;
    return date.toLocaleDateString();
  }, []);
  const messageSnippet2 = reactExports.useCallback((content) => {
    if (!content) return "";
    return content.length > 90 ? `${content.slice(0, 87)}` : content;
  }, []);
  const [currentUserName, setCurrentUserName] = reactExports.useState("You");
  const shouldPromptProfile = reactExports.useCallback((profile, email, id) => {
    const name2 = ((profile == null ? void 0 : profile.display_name) || "").trim();
    if (!name2) return true;
    if (name2.length < 3) return true;
    const lower = name2.toLowerCase();
    const emailPrefix = email ? email.split("@")[0].toLowerCase() : "";
    const sanitizedEmail = emailPrefix.replace(/[^a-z]/g, "");
    const fallbacks = [
      emailPrefix,
      sanitizedEmail,
      `user_${(id || "").slice(0, 8)}`.toLowerCase(),
      `user ${(id || "").slice(0, 8)}`.toLowerCase(),
      `member ${(id || "").slice(0, 8)}`.toLowerCase()
    ];
    if (fallbacks.includes(lower)) return true;
    if (lower.includes("@")) return true;
    if (/_/.test(lower) || /[0-9]{3,}/.test(lower)) return true;
    return false;
  }, []);
  const deriveDisplayName = reactExports.useCallback((profile, email, id) => {
    if (profile == null ? void 0 : profile.display_name) return profile.display_name;
    if (profile == null ? void 0 : profile.username) return profile.username;
    if (email === "topher.cook7@gmail.com") return "Topher";
    if (email) return email.split("@")[0];
    if (id) return `Member ${id.slice(0, 8)}`;
    return "You";
  }, []);
  reactExports.useEffect(() => {
    var _a2;
    if (userIdProp) {
      setUserId(userIdProp);
      return;
    }
    if (authUser == null ? void 0 : authUser.id) {
      setUserId(authUser.id);
      console.log("[Groups] Using auth context user:", authUser.email);
      return;
    }
    let sub;
    (() => __async(null, null, function* () {
      var _a3, _b;
      try {
        if (!supabase) return;
        const { data } = yield supabase.auth.getSession();
        const sessionUserId = ((_b = (_a3 = data == null ? void 0 : data.session) == null ? void 0 : _a3.user) == null ? void 0 : _b.id) || null;
        console.log("[Groups] Session user ID:", sessionUserId);
        setUserId(sessionUserId);
      } catch (e) {
        console.error("Groups: getSession failed");
      }
    }))();
    if (supabase) {
      const listener = supabase.auth.onAuthStateChange((_e, session) => {
        var _a3;
        setUserId(((_a3 = session == null ? void 0 : session.user) == null ? void 0 : _a3.id) || null);
      });
      sub = (_a2 = listener == null ? void 0 : listener.data) == null ? void 0 : _a2.subscription;
    }
    return () => {
      var _a3;
      return (_a3 = sub == null ? void 0 : sub.unsubscribe) == null ? void 0 : _a3.call(sub);
    };
  }, [userIdProp, authUser]);
  reactExports.useEffect(() => {
    if (!userId) return;
    sendHeartbeat();
    const interval = setInterval(() => {
      sendHeartbeat();
    }, 6e4);
    return () => clearInterval(interval);
  }, [userId, sendHeartbeat]);
  reactExports.useEffect(() => {
    (() => __async(null, null, function* () {
      var _a2, _b;
      if (userId) {
        try {
          console.log("[Groups] Auto-setting up user account for:", userId);
          const { data: { session } } = yield supabase.auth.getSession();
          const email = (_a2 = session == null ? void 0 : session.user) == null ? void 0 : _a2.email;
          if (email) {
            const { data: profile } = yield supabase.from("profiles").select("display_name, username, email, role").eq("user_id", userId).single();
            const profileWithEmail = profile ? __spreadProps(__spreadValues({}, profile), { email: (_b = profile.email) != null ? _b : email }) : { display_name: null, username: null, email, role: "consumer" };
            setProfileInfo(profileWithEmail);
            setUserRole((profile == null ? void 0 : profile.role) || "consumer");
            const userName = deriveDisplayName(profileWithEmail, email, userId);
            setCurrentUserName(userName);
            if (!profilePromptDismissed && shouldPromptProfile(profileWithEmail, email, userId)) {
              setProfileDialogOpen(true);
            }
            console.log("[Groups] Ensuring user record exists for:", userId, email);
            const ensureRes = yield fetch(`${API_BASE}/api/users/ensure`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ user_id: userId, email, username: userName })
            });
            if (ensureRes.ok) {
              console.log("[Groups] User account ready");
            }
          } else if (!profilePromptDismissed) {
            setProfileDialogOpen(true);
          }
        } catch (e) {
          console.error("[Groups] Auto-setup error:", e);
        }
      }
      yield loadGroups();
      setLoading(false);
    }))();
    const stored = localStorage.getItem(guidelinesKey);
    if (stored === "true") setGuidelinesAccepted(true);
  }, [guidelinesKey, userId, adminUserId, profilePromptDismissed, deriveDisplayName, shouldPromptProfile]);
  reactExports.useEffect(() => {
    if (!selectedGroup || !groupDialogOpen) {
      setMessages([]);
      return;
    }
    console.log(" Starting auto-refresh for group:", selectedGroup.id);
    const interval = setInterval(() => {
      console.log(" Auto-refreshing messages...");
      if ((selectedGroup == null ? void 0 : selectedGroup.id) && groupDialogOpen) {
        loadMessages(selectedGroup.id);
      }
    }, 3e3);
    return () => {
      console.log(" Stopping auto-refresh");
      clearInterval(interval);
      setMessages([]);
    };
  }, [selectedGroup == null ? void 0 : selectedGroup.id, groupDialogOpen, loadMessages]);
  reactExports.useEffect(() => {
    if (chatDialogOpen && selectedChat) {
      setDirectMessages(dmMessagesHook.messages.map((m) => m.raw || m));
    }
  }, [dmMessagesHook.messages, chatDialogOpen, selectedChat]);
  reactExports.useEffect(() => {
    if (activeTab === 1 && userId) {
      console.log(" Direct Messages tab activated, loading users...");
      console.log(" API_BASE:", API_BASE);
      console.log(" userId:", userId);
      loadAllUsers();
      loadDirectChats();
    }
  }, [activeTab, userId]);
  const loadGroups = () => __async(null, null, function* () {
    var _a2;
    try {
      console.log("[Groups] Fetching from:", `${API_BASE}/api/groups`);
      const res = yield fetch(`${API_BASE}/api/groups`);
      console.log("[Groups] Response status:", res.status, res.statusText);
      if (res.ok) {
        const payload = yield res.json();
        console.log("[Groups] Received groups:", (payload == null ? void 0 : payload.length) || 0);
        const curated = Array.isArray(payload) ? payload.filter((group) => ALLOWED_GROUPS.includes(group.name)) : [];
        console.log("[Groups] Filtered groups:", (curated == null ? void 0 : curated.length) || 0);
        setGroups(curated);
        if (!adminUserId && Array.isArray(payload) && payload.length) {
          setAdminUserId(((_a2 = payload[0]) == null ? void 0 : _a2.admin_user_id) || null);
        }
      } else {
        console.error("[Groups] Failed to fetch groups:", res.status, res.statusText);
      }
    } catch (err) {
      console.error("[Groups] Fetch error:", err);
    }
  });
  const loadMessages = (groupId) => __async(null, null, function* () {
    try {
      console.log(" Loading messages for group:", groupId);
      console.log(" API URL:", `${API_BASE}/api/groups/${groupId}/messages`);
      const res = yield fetch(`${API_BASE}/api/groups/${groupId}/messages`);
      console.log(" Load messages response:", res.status, res.ok);
      if (res.ok) {
        const data = yield res.json();
        if (Array.isArray(data)) {
          setMessages(data);
          setPinnedMessages([]);
        } else {
          setMessages(data.messages || []);
          setPinnedMessages(data.pinnedMessages || []);
        }
        console.log(" Loaded messages:", (data.messages || data).length, "messages");
        console.log(" Loaded pinned messages:", (data.pinnedMessages || []).length);
        setLastRefresh(/* @__PURE__ */ new Date());
      } else {
        console.error(" Failed to load messages:", res.status, res.statusText);
      }
    } catch (e) {
      console.error(" Error loading messages:", e);
    }
  });
  const loadMembers = (groupId) => __async(null, null, function* () {
    console.log(" Loading members for group:", groupId);
    const res = yield fetch(`${API_BASE}/api/groups/${groupId}/members`);
    if (res.ok) {
      const data = yield res.json();
      console.log(" Members loaded:", data.length, "members");
      console.log(" Member details:", data.map((m) => {
        var _a2, _b;
        return {
          user_id: m.user_id,
          username: (_a2 = m.users) == null ? void 0 : _a2.username,
          email: (_b = m.users) == null ? void 0 : _b.email
        };
      }));
      setMembers(data);
      setIsMember(userId ? data.some((m) => m.user_id === userId) : false);
      return data;
    }
    console.error(" Failed to load members:", res.status);
    return [];
  });
  const loadAllUsers = () => __async(null, null, function* () {
    setUsersError(null);
    setLoadingUsers(true);
    try {
      console.log(" Loading all users from:", `${API_BASE}/api/users`);
      console.log(" Current user ID:", userId);
      const res = yield fetch(`${API_BASE}/api/users`, {
        method: "GET",
        headers: {
          "Accept": "application/json",
          "Content-Type": "application/json"
        }
      });
      console.log(" Users response status:", res.status, res.statusText);
      console.log(" Response headers:", Object.fromEntries(res.headers.entries()));
      if (res.ok) {
        const data = yield res.json();
        console.log(" Total users loaded:", data.length);
        console.log(" User details:", data.map((u) => ({
          user_id: u.user_id,
          display_name: u.display_name,
          username: u.username,
          email: u.email
        })));
        const otherUsers = data.filter((u) => u.user_id !== userId);
        console.log(" Other users (excluding current):", otherUsers.length);
        setAllUsers(otherUsers);
        setUsersError(null);
      } else {
        const errorText = yield res.text();
        console.error(" Failed to load users:", res.status, res.statusText);
        console.error(" Error response:", errorText);
        const errorMsg = `Failed to load users: ${res.status} ${res.statusText}`;
        setUsersError(errorMsg);
      }
    } catch (e) {
      console.error(" Failed to load users - Exception:", e);
      console.error(" Error stack:", e.stack);
      const errorMsg = `Cannot connect to backend: ${e.message}

Make sure:
1. Backend is running (npm run dev)
2. You're on the same WiFi network
3. API_BASE is set to: ${API_BASE}`;
      setUsersError(errorMsg);
    } finally {
      setLoadingUsers(false);
    }
  });
  const handleProfileSave = (_0) => __async(null, [_0], function* ({ displayName }) {
    var _a2;
    setProfileSaving(true);
    setProfileError("");
    try {
      const { data: { session } } = yield supabase.auth.getSession();
      const token2 = session == null ? void 0 : session.access_token;
      if (!token2) {
        throw new Error("Please log in again.");
      }
      const res = yield fetch(`${API_BASE}/api/users/profile`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token2}`
        },
        body: JSON.stringify({
          display_name: displayName
        })
      });
      if (!res.ok) {
        const err = yield res.json().catch(() => ({}));
        throw new Error(err.error || "Failed to update profile.");
      }
      const { profile } = yield res.json();
      if (profile) {
        setProfileInfo(profile);
        const friendlyName = deriveDisplayName(profile, profile.email || ((_a2 = session == null ? void 0 : session.user) == null ? void 0 : _a2.email), userId);
        setCurrentUserName(friendlyName);
      }
      setProfileDialogOpen(false);
      setProfilePromptDismissed(false);
      setSnackbar({ open: true, message: "Profile updated!", severity: "success" });
      if (selectedGroup) {
        yield loadMembers(selectedGroup.id);
      }
      yield loadAllUsers();
    } catch (e) {
      console.error("[Groups] Profile update failed:", e);
      setProfileError(e.message || "Failed to update profile.");
    } finally {
      setProfileSaving(false);
    }
  });
  const handleProfileDialogClose = () => {
    setProfileDialogOpen(false);
    setProfilePromptDismissed(true);
  };
  const loadDirectChats = () => __async(null, null, function* () {
    if (!userId) return;
    try {
      const res = yield fetch(`${API_BASE}/api/direct-chats/chats/${userId}`);
      if (res.ok) {
        const data = yield res.json();
        setDirectChats(data);
      }
    } catch (e) {
      console.error("Failed to load direct chats:", e);
    }
  });
  const loadDirectMessages = (otherUserId) => __async(null, null, function* () {
    if (!userId) return;
    try {
      console.log(" Loading direct messages with user:", otherUserId);
      const res = yield fetch(`${API_BASE}/api/direct-messages/${userId}/${otherUserId}`);
      console.log(" Direct messages response:", res.status);
      if (res.ok) {
        const data = yield res.json();
        console.log(" Loaded direct messages:", data.length);
        setDirectMessages(data);
        setLastRefresh(/* @__PURE__ */ new Date());
      }
    } catch (e) {
      console.error("Failed to load direct messages:", e);
    }
  });
  const startDirectChat = (otherUser) => __async(null, null, function* () {
    console.log(" Starting direct chat with:", otherUser.display_name || otherUser.username, otherUser.user_id);
    setSelectedChat(otherUser);
    setDirectMessages([]);
    setChatDialogOpen(true);
    try {
      const { data: { session } } = yield supabase.auth.getSession();
      const token2 = session == null ? void 0 : session.access_token;
      if (token2 && userId) {
        const res = yield fetch(`${API_BASE}/api/dm/start`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token2}`
          },
          body: JSON.stringify({ userId: otherUser.user_id })
        });
        if (res.ok) {
          const data = yield res.json();
          setDmConversationId(data.conversation_id || data.id);
        }
      }
    } catch (e) {
      console.error("Failed to get conversation ID:", e);
    }
    yield loadDirectMessages(otherUser.user_id);
    if (userId) {
      try {
        yield fetch(`${API_BASE}/api/direct-messages/mark-read/${userId}/${otherUser.user_id}`, {
          method: "PUT"
        });
        loadDirectChats();
      } catch (e) {
        console.error("Failed to mark messages as read:", e);
      }
    }
  });
  const sendDirectMessage = () => __async(null, null, function* () {
    const content = input.trim();
    if (!content || !selectedChat) return;
    if (!userId) {
      alert("Please log in to send messages.");
      onNavigate && onNavigate("login");
      return;
    }
    const { data: { session } } = yield supabase.auth.getSession();
    const accessToken = session == null ? void 0 : session.access_token;
    if (!accessToken) {
      alert("Please log in to send messages.");
      onNavigate && onNavigate("login");
      return;
    }
    const optimisticId = `temp-${Date.now()}`;
    const optimisticMessage = {
      id: optimisticId,
      content,
      created_at: (/* @__PURE__ */ new Date()).toISOString(),
      sender_id: userId,
      receiver_id: selectedChat.user_id,
      sender: {
        user_id: userId,
        display_name: currentUserName,
        username: currentUserName,
        avatar_url: null
      },
      optimistic: true
    };
    setDirectMessages((prev2) => [...prev2, optimisticMessage]);
    setInput("");
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 1e4);
      const apiUrl2 = `${API_BASE}/api/direct-messages`;
      console.log(" Sending direct message to:", apiUrl2);
      console.log(" Message content:", content);
      console.log(" Sender ID:", userId);
      console.log(" Receiver ID:", selectedChat.user_id);
      const res = yield fetch(apiUrl2, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${accessToken}`
        },
        body: JSON.stringify({
          sender_id: userId,
          receiver_id: selectedChat.user_id,
          content
        }),
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (res.ok) {
        console.log(" Direct message sent successfully!");
        const responseData = yield res.json();
        setDirectMessages((prev2) => prev2.filter((m) => m.id !== optimisticId));
        if (responseData && responseData.id) {
          dmMessagesHook.onNewMessage(responseData);
        } else {
          setTimeout(() => __async(null, null, function* () {
          }), 500);
        }
        loadDirectChats();
      } else {
        const errorText = yield res.text();
        console.error(" Server error response:", errorText);
        setDirectMessages((prev2) => prev2.filter((m) => m.id !== optimisticId));
        alert(`Failed to send direct message!

Status: ${res.status} ${res.statusText}
Error: ${errorText}

API: ${apiUrl2}

Make sure:
1. Backend is running
2. You're on the same WiFi
3. API is: ${API_BASE}`);
      }
    } catch (e) {
      setDirectMessages((prev2) => prev2.filter((m) => m.id !== optimisticId));
      console.error(" Send direct message error:", e);
      alert(`Failed to send direct message!

Error: ${e.message}

API: ${apiUrl}

This usually means:
1. Backend is not running
2. Wrong WiFi network
3. Firewall blocking connection

Current API: ${API_BASE}`);
    }
  });
  const selectGroup = (g) => __async(null, null, function* () {
    console.log(" Opening group:", g.name, g.id);
    console.log(" Current messages state before clearing:", messages.length);
    setSelectedGroup(g);
    setMessages([]);
    console.log(" Messages cleared, opening dialog");
    setGroupDialogOpen(true);
    yield loadMessages(g.id);
    const currentMembers = yield loadMembers(g.id);
    const alreadyMember = userId ? currentMembers.some((m) => m.user_id === userId) : false;
    if (userId && !alreadyMember) {
      yield joinGroup({ group: g, silent: true });
      yield loadMembers(g.id);
      yield loadMessages(g.id);
    }
  });
  const joinGroup = (..._0) => __async(null, [..._0], function* ({ group = selectedGroup, silent: silent2 = false } = {}) {
    const targetGroup = group;
    if (!targetGroup) return;
    try {
      if (!userId) {
        if (!silent2) {
          alert("Please log in to join groups.");
          onNavigate && onNavigate("login");
        }
        return;
      }
      const res = yield fetch(`${API_BASE}/api/groups/${targetGroup.id}/join`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ user_id: userId })
      });
      if (res.ok) {
        yield loadMembers(targetGroup.id);
        setIsMember(true);
        if (!silent2) {
          setSnackbar({ open: true, message: "Joined group!", severity: "success" });
        }
        return;
      }
      const err = yield res.json().catch(() => ({}));
      const message = err.error || "";
      if (typeof message === "string" && message.toLowerCase().includes("already a member")) {
        yield loadMembers(targetGroup.id);
        setIsMember(true);
        if (!silent2) {
          setSnackbar({ open: true, message: "You are already in this group.", severity: "info" });
        }
        return;
      }
      if (!silent2) {
        alert(message || "Failed to join group");
      } else {
        console.error("Failed to join group silently:", message || "Unknown error");
      }
    } catch (e) {
      console.error("Failed to join group", e);
      if (!silent2) {
        alert("Failed to join group");
      }
    }
  });
  const closeGroupDialog = reactExports.useCallback(() => {
    setGroupDialogOpen(false);
    setSelectedGroup(null);
    setMessages([]);
  }, []);
  const sendMessage = () => __async(null, null, function* () {
    const content = input.trim();
    if (!content || !selectedGroup) return;
    if (sending) return;
    if (!guidelinesAccepted) {
      setGuidelinesOpen(true);
      return;
    }
    if (!userId) {
      setSendError("Please log in to send messages.");
      onNavigate && onNavigate("login");
      return;
    }
    setSending(true);
    setSendError("");
    const { data: { session } } = yield supabase.auth.getSession();
    const accessToken = session == null ? void 0 : session.access_token;
    if (!accessToken) {
      setSendError("Please log in to send messages.");
      setSending(false);
      onNavigate && onNavigate("login");
      return;
    }
    const optimisticId = `temp-${Date.now()}`;
    const optimisticMessage = {
      id: optimisticId,
      content,
      created_at: (/* @__PURE__ */ new Date()).toISOString(),
      user_id: userId,
      users: {
        id: userId,
        display_name: currentUserName,
        username: currentUserName,
        avatar_url: null
      },
      optimistic: true
    };
    setMessages((prev2) => [...prev2, optimisticMessage]);
    const messageToSend = input;
    setInput("");
    const replyToId = (replyTo == null ? void 0 : replyTo.id) || null;
    setReplyTo(null);
    let timeoutId;
    try {
      const controller = new AbortController();
      timeoutId = setTimeout(() => controller.abort(), 1e4);
      const apiUrl2 = `${API_BASE}/api/groups/${selectedGroup.id}/messages`;
      console.log(" Sending message to:", apiUrl2);
      console.log(" Message content:", content);
      console.log(" User ID:", userId);
      const payload = {
        content: messageToSend.trim() || null,
        user_id: userId,
        // Include reply_to_id if backend supports it (will be ignored if not)
        reply_to_id: replyToId,
        // Include attachments if provided (from parameter or state)
        attachments: attachmentsToUse && attachmentsToUse.length > 0 ? attachmentsToUse : null
      };
      const res = yield fetch(apiUrl2, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${accessToken}`
        },
        body: JSON.stringify(payload),
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      console.log(" Response status:", res.status);
      console.log(" Response ok:", res.ok);
      if (res.ok) {
        console.log(" Message sent successfully!");
        const responseData = yield res.json();
        console.log(" Response data:", responseData);
        setMessages((prev2) => prev2.filter((m) => m.id !== optimisticId));
        if (responseData && responseData.id) {
          console.log(" Adding message from response:", responseData);
          groupMessagesHook.onNewMessage(responseData);
        } else {
          console.log(" No message in response, reloading...");
          setTimeout(() => __async(null, null, function* () {
          }), 500);
        }
        loadGroups();
      } else {
        let body2 = null;
        try {
          body2 = yield res.json();
        } catch (e) {
          body2 = null;
        }
        const errorMsg = (body2 == null ? void 0 : body2.error) || (body2 == null ? void 0 : body2.hint) || `Send failed (${res.status})`;
        console.error(" Server error response:", errorMsg);
        setSendError(errorMsg);
        if (contentOverride === null) {
          setInput(messageToSend);
        }
        if (replyToId) {
          const currentMessages = groupMessagesHook.messages || [];
          const originalReply = currentMessages.find((m) => {
            var _a2;
            return m.id === replyToId || ((_a2 = m.raw) == null ? void 0 : _a2.id) === replyToId;
          });
          if (originalReply) setReplyTo(originalReply);
        }
      }
    } catch (err) {
      console.error(" Error sending message:", err);
      setMessages((prev2) => prev2.filter((m) => m.id !== optimisticId));
      let errorMsg = "Failed to send message. Please try again.";
      if (err.name === "AbortError") {
        errorMsg = "Request timed out. Please check your connection and try again.";
      } else if (err.message) {
        errorMsg = err.message;
      }
      setSendError(errorMsg);
      setInput(messageToSend);
      if (replyToId) {
        const originalReply = messages.find((m) => m.id === replyToId);
        if (originalReply) setReplyTo(originalReply);
      }
    } finally {
      setSending(false);
    }
  });
  const handleReport = () => __async(null, null, function* () {
    if (!reportingMessage) return;
    try {
      if (!userId) {
        alert("Please log in to report messages.");
        onNavigate && onNavigate("login");
        return;
      }
      const { data: { session } } = yield supabase.auth.getSession();
      const headers = {
        "Content-Type": "application/json"
      };
      if (session == null ? void 0 : session.access_token) {
        headers.Authorization = `Bearer ${session.access_token}`;
      }
      const res = yield fetch(`${API_BASE}/api/moderation/report`, {
        method: "POST",
        headers,
        body: JSON.stringify({
          message_id: reportingMessage.id,
          reported_by: userId,
          reason: reportReason,
          details: reportDetails
        })
      });
      if (res.ok) {
        alert("Report submitted. Thank you for helping keep our community safe.");
        setReportDialogOpen(false);
        setReportingMessage(null);
        setReportDetails("");
      } else {
        const err = yield res.json();
        alert(err.error || "Failed to submit report");
      }
    } catch (e) {
      console.error("Failed to submit report", e);
      alert("Failed to submit report");
    }
  });
  reactExports.useEffect(() => {
    if (!selectedGroup) return;
    const updated = groups.find((g) => g.id === selectedGroup.id);
    if (updated && updated !== selectedGroup) {
      setSelectedGroup(updated);
    }
  }, [groups, selectedGroup]);
  const sortedGroups = reactExports.useMemo(() => {
    const copy2 = [...groups];
    return copy2.sort((a, b) => {
      var _a2, _b;
      const aTime = ((_a2 = a == null ? void 0 : a.last_message) == null ? void 0 : _a2.created_at) || (a == null ? void 0 : a.created_at) || 0;
      const bTime = ((_b = b == null ? void 0 : b.last_message) == null ? void 0 : _b.created_at) || (b == null ? void 0 : b.created_at) || 0;
      return new Date(bTime).getTime() - new Date(aTime).getTime();
    });
  }, [groups]);
  const renderGroupButton = (group) => {
    var _a2, _b;
    const last = group.last_message;
    const lastAuthor = ((_a2 = last == null ? void 0 : last.user) == null ? void 0 : _a2.display_name) || ((_b = last == null ? void 0 : last.user) == null ? void 0 : _b.username);
    const snippet = last ? `${lastAuthor ? `${lastAuthor}: ` : ""}${messageSnippet2(last.content)}` : "No conversations yet.";
    const timestamp = formatTimestamp((last == null ? void 0 : last.created_at) || group.created_at);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Button,
      {
        variant: "outlined",
        onClick: () => selectGroup(group),
        fullWidth: true,
        sx: {
          justifyContent: "space-between",
          alignItems: "flex-start",
          textAlign: "left",
          p: 2,
          borderRadius: 3,
          borderColor: "rgba(124,179,66,0.4)",
          bgcolor: "rgba(255,255,255,0.05)",
          backdropFilter: "blur(10px)",
          WebkitBackdropFilter: "blur(10px)",
          color: "#CDDC39",
          "&:hover": {
            bgcolor: "rgba(124,179,66,0.2)",
            borderColor: "rgba(124,179,66,0.6)"
          }
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 0.5, sx: { flex: 1, pr: 2 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle1", sx: { fontWeight: 700, color: "#CDDC39" }, children: group.name }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#9CCC65" }, children: snippet }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", sx: { color: "#7CB342" }, children: [
              group.member_count || 0,
              " member",
              group.member_count === 1 ? "" : "s"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { color: "rgba(22,34,22,0.6)" }, children: timestamp })
        ]
      },
      group.id
    );
  };
  if (!isMobile && selectedGroup && groupDialogOpen) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box,
      {
        sx: {
          display: "flex",
          height: "100vh",
          overflow: "hidden",
          position: "relative"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Box,
            {
              sx: {
                width: 320,
                borderRight: "1px solid rgba(255,255,255,0.08)",
                display: "flex",
                flexDirection: "column",
                overflow: "hidden",
                backgroundColor: "rgba(0,0,0,0.3)",
                backdropFilter: "blur(10px)"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { p: 2, borderBottom: "1px solid rgba(255,255,255,0.08)", flexShrink: 0 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { fontWeight: 700, color: "#CDDC39" }, children: "Groups" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  GroupList,
                  {
                    groups: sortedGroups,
                    selectedGroupId: selectedGroup == null ? void 0 : selectedGroup.id,
                    onSelectGroup: (g) => {
                      setSelectedGroup(g);
                      setGroupDialogOpen(true);
                    },
                    isLoading: loading
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Box,
            {
              sx: {
                flex: 1,
                minWidth: 0,
                display: "flex",
                flexDirection: "column",
                overflow: "hidden"
              },
              children: [
                !guidelinesAccepted && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Alert,
                  {
                    severity: "warning",
                    icon: false,
                    sx: {
                      background: "rgba(255,193,7,0.25)",
                      color: "#CDDC39",
                      border: "1px solid rgba(255,193,7,0.5)",
                      flexShrink: 0,
                      m: 1,
                      mb: 0
                    },
                    children: [
                      "By participating, you agree to our",
                      " ",
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Link,
                        {
                          component: "button",
                          onClick: () => onNavigate && onNavigate("guidelines"),
                          sx: { fontWeight: 700, color: "#fff", textDecoration: "underline" },
                          children: "Community Guidelines"
                        }
                      ),
                      "."
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  GroupMessages,
                  {
                    messages: groupMessagesHook.messages,
                    pinnedMessages: groupMessagesHook.pinnedMessages,
                    isLoadingInitial: groupMessagesHook.isLoadingInitial,
                    isLoadingMore: groupMessagesHook.isLoadingMore,
                    hasMore: groupMessagesHook.hasMore,
                    onLoadMore: groupMessagesHook.loadMore,
                    scrollContainerRef: groupMessagesHook.scrollContainerRef,
                    scrollToBottomRef: groupMessagesHook.scrollToBottomRef,
                    onScroll: groupMessagesHook.handleScroll,
                    currentUserId: userId,
                    group: selectedGroup,
                    onBack: () => {
                      setGroupDialogOpen(false);
                      setSelectedGroup(null);
                    },
                    onSend: isMember && guidelinesAccepted ? (text, attachments, replyToMsg) => __async(null, null, function* () {
                      if (!(text == null ? void 0 : text.trim()) && (!attachments || attachments.length === 0)) return;
                      if (!selectedGroup || !userId) return;
                      if (replyToMsg) {
                        setReplyTo(replyToMsg);
                      }
                      yield sendMessage();
                    }) : null,
                    typingUsers: groupTypingHook.typingUsers || []
                  }
                ),
                !isMember && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { p: 2, textAlign: "center", borderTop: "1px solid rgba(255,255,255,0.08)", flexShrink: 0 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: "contained",
                    onClick: () => joinGroup(),
                    sx: {
                      bgcolor: "rgba(124,179,66,0.9)",
                      color: "#fff",
                      "&:hover": {
                        bgcolor: "rgba(156,204,101,1)"
                      }
                    },
                    children: "Join Group to Send Messages"
                  }
                ) })
              ]
            }
          )
        ]
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        display: "flex",
        flexDirection: "column",
        height: "100vh",
        overflow: "hidden",
        position: "relative"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            sx: {
              position: "absolute",
              inset: 0,
              zIndex: 0,
              background: `
            linear-gradient(135deg,
              rgba(10, 31, 10, 0.4) 0%,
              rgba(26, 58, 26, 0.5) 15%,
              rgba(45, 90, 45, 0.6) 30%,
              rgba(34, 139, 34, 0.5) 45%,
              rgba(45, 90, 45, 0.6) 60%,
              rgba(26, 58, 26, 0.5) 75%,
              rgba(10, 31, 10, 0.4) 100%
            ),
            radial-gradient(circle at 20% 30%, rgba(124, 179, 66, 0.3) 0%, transparent 50%),
            radial-gradient(circle at 80% 70%, rgba(34, 139, 34, 0.3) 0%, transparent 50%),
            radial-gradient(circle at 50% 50%, rgba(45, 90, 45, 0.2) 0%, transparent 70%),
            linear-gradient(180deg, rgba(0, 0, 0, 0.3) 0%, rgba(0, 50, 0, 0.4) 100%)
          `,
              backgroundSize: "100% 100%, 150% 150%, 150% 150%, 200% 200%, 100% 100%",
              backgroundPosition: "center, 20% 30%, 80% 70%, 50% 50%, center",
              boxShadow: "inset 0 0 100px rgba(0, 0, 0, 0.3), inset 0 0 50px rgba(124, 179, 66, 0.1)",
              "&::before": {
                content: '""',
                position: "absolute",
                inset: 0,
                background: `url("data:image/svg+xml,%3Csvg width='100' height='100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' /%3E%3C/filter%3E%3Crect width='100' height='100' filter='url(%23noise)' opacity='0.05'/%3E%3C/svg%3E")`,
                opacity: 0.5,
                pointerEvents: "none"
              }
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { flexShrink: 0, position: "relative", zIndex: 1 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Container,
          {
            maxWidth: "lg",
            sx: {
              pt: "calc(env(safe-area-inset-top, 0px) + 16px)",
              pb: 2,
              px: { xs: 1.5, md: 4 }
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                ProfileSetupDialog,
                {
                  open: profileDialogOpen,
                  email: (profileInfo == null ? void 0 : profileInfo.email) || (authUser == null ? void 0 : authUser.email) || "",
                  initialDisplayName: (profileInfo == null ? void 0 : profileInfo.display_name) || currentUserName,
                  initialUsername: (profileInfo == null ? void 0 : profileInfo.username) || "",
                  saving: profileSaving,
                  error: profileError,
                  onSave: handleProfileSave,
                  onClose: handleProfileDialogClose
                }
              ),
              onBack ? /* @__PURE__ */ jsxRuntimeExports.jsx(BackHeader$1, { title: "Groups", onBack }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => window.history.back(),
                  size: "small",
                  variant: "contained",
                  sx: {
                    bgcolor: "rgba(124, 179, 66, 0.9)",
                    color: "#fff",
                    textTransform: "none",
                    fontWeight: 700,
                    borderRadius: 999,
                    mb: 2,
                    boxShadow: "0 4px 12px rgba(124, 179, 66, 0.4)",
                    "&:hover": {
                      bgcolor: "rgba(156, 204, 101, 1)",
                      boxShadow: "0 6px 16px rgba(124, 179, 66, 0.6)",
                      transform: "translateY(-2px)"
                    }
                  },
                  children: " Back to Garden"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", gap: 2, mb: 3 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Box,
                  {
                    sx: {
                      width: 60,
                      height: 60,
                      borderRadius: "50%",
                      background: "transparent",
                      border: "2px solid rgba(124, 179, 66, 0.5)",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      boxShadow: "0 0 20px rgba(124, 179, 66, 0.4)",
                      overflow: "hidden",
                      flexShrink: 0
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "img",
                      {
                        src: "/hero.png?v=13",
                        alt: "StrainSpotter",
                        style: { width: "100%", height: "100%", objectFit: "cover" }
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { fontWeight: 700, fontSize: "1.25rem", color: "#CDDC39" }, children: "Groups & Chat" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, sx: { mb: 2 }, alignItems: "center", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#9CCC65", flex: 1 }, children: [
                  "Signed in as ",
                  currentUserName
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    size: "small",
                    variant: "outlined",
                    onClick: () => {
                      setProfilePromptDismissed(false);
                      setProfileDialogOpen(true);
                    },
                    sx: {
                      color: "#CDDC39",
                      borderColor: "rgba(124,179,66,0.4)",
                      textTransform: "none",
                      fontWeight: 600,
                      "&:hover": {
                        borderColor: "rgba(124,179,66,0.7)",
                        bgcolor: "rgba(124,179,66,0.15)"
                      }
                    },
                    children: "Edit Profile"
                  }
                )
              ] })
            ]
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            sx: {
              flex: 1,
              minHeight: 0,
              overflowY: "auto",
              WebkitOverflowScrolling: "touch",
              position: "relative",
              zIndex: 1
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Container,
              {
                maxWidth: "lg",
                sx: {
                  px: { xs: 1.5, md: 4 },
                  py: 2,
                  pb: "calc(env(safe-area-inset-bottom, 0px) + 80px)"
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { sx: {
                  bgcolor: "rgba(255,255,255,0.08)",
                  color: "#CDDC39",
                  boxShadow: "0 12px 30px rgba(0,0,0,0.4)",
                  backdropFilter: "blur(20px)",
                  WebkitBackdropFilter: "blur(20px)",
                  borderRadius: 3,
                  border: "1px solid rgba(124,179,66,0.3)"
                }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Tabs,
                    {
                      value: activeTab,
                      onChange: (e, newValue) => setActiveTab(newValue),
                      sx: {
                        borderBottom: "1px solid rgba(124,179,66,0.3)",
                        "& .MuiTab-root": {
                          color: "#9CCC65",
                          "&.Mui-selected": {
                            color: "#CDDC39"
                          }
                        },
                        "& .MuiTabs-indicator": {
                          backgroundColor: "#CDDC39"
                        }
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(GroupsIcon, {}), label: "Groups", iconPosition: "start" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          Tab,
                          {
                            icon: /* @__PURE__ */ jsxRuntimeExports.jsx(
                              Badge,
                              {
                                badgeContent: directChats.reduce((sum, chat) => sum + (chat.unread_count || 0), 0),
                                color: "error",
                                sx: {
                                  "& .MuiBadge-badge": {
                                    bgcolor: "#FF5252",
                                    color: "#fff",
                                    fontWeight: 700,
                                    fontSize: "0.65rem",
                                    minWidth: "18px",
                                    height: "18px"
                                  }
                                },
                                children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChatIcon, {})
                              }
                            ),
                            label: "Direct Messages",
                            iconPosition: "start"
                          }
                        )
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { sx: { p: 2 }, children: [
                    activeTab === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 1.5, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { mb: 0.5, color: "#9CCC65", fontSize: "0.75rem" }, children: userId ? "Tap a group to open the chat." : "Sign in to join groups." }),
                      !userId && /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Button,
                        {
                          variant: "contained",
                          color: "primary",
                          fullWidth: true,
                          onClick: () => onNavigate && onNavigate("login"),
                          sx: { mb: 2 },
                          children: "Sign In to Continue"
                        }
                      ),
                      loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "rgba(22,34,22,0.6)" }, children: "Loading..." }) : sortedGroups.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#9CCC65" }, children: "No groups yet." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 1.5, children: sortedGroups.map(renderGroupButton) })
                    ] }),
                    activeTab === 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 1.5, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { mb: 0.5, color: "#9CCC65", fontSize: "0.75rem" }, children: userId ? "Start a private conversation with any user." : "Sign in to send direct messages." }),
                      !userId && /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Button,
                        {
                          variant: "contained",
                          color: "primary",
                          fullWidth: true,
                          onClick: () => onNavigate && onNavigate("login"),
                          sx: { mb: 2 },
                          children: "Sign In to Continue"
                        }
                      ),
                      userId && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          TextField,
                          {
                            size: "small",
                            value: userSearchTerm,
                            onChange: (e) => setUserSearchTerm(e.target.value),
                            placeholder: "Search by name",
                            variant: "outlined",
                            fullWidth: true,
                            sx: {
                              "& .MuiInputBase-root": {
                                bgcolor: "rgba(255,255,255,0.05)",
                                borderRadius: 2,
                                border: "1px solid rgba(124,179,66,0.3)",
                                color: "#CDDC39"
                              },
                              mb: 2
                            }
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: { xs: "column", sm: "row" }, spacing: 1, alignItems: { xs: "stretch", sm: "center" }, sx: { mb: 1 }, children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", sx: { color: "#CDDC39", fontWeight: 700 }, children: "Direct Messages" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs(
                            ToggleButtonGroup,
                            {
                              color: "success",
                              exclusive: true,
                              value: dmFilter,
                              onChange: (_e, next2) => next2 && setDmFilter(next2),
                              size: "small",
                              sx: {
                                borderRadius: 999,
                                "& .MuiToggleButton-root": {
                                  color: "#9CCC65",
                                  borderColor: "rgba(124,179,66,0.3)",
                                  textTransform: "none",
                                  fontSize: "0.8rem"
                                },
                                "& .Mui-selected": {
                                  color: "#0c220f",
                                  backgroundColor: "rgba(124,179,66,0.7) !important"
                                }
                              },
                              children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleButton, { value: "recent", children: "Recent" }),
                                /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleButton, { value: "all", children: "All Users" })
                              ]
                            }
                          ),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            Button,
                            {
                              size: "small",
                              onClick: loadAllUsers,
                              disabled: loadingUsers,
                              variant: "outlined",
                              sx: {
                                color: "#CDDC39",
                                borderColor: "rgba(124,179,66,0.4)",
                                "&:hover": {
                                  borderColor: "rgba(124,179,66,0.6)",
                                  bgcolor: "rgba(124,179,66,0.1)"
                                }
                              },
                              children: loadingUsers ? "Loading..." : "Refresh"
                            }
                          )
                        ] }),
                        usersError && /* @__PURE__ */ jsxRuntimeExports.jsx(
                          Typography,
                          {
                            variant: "body2",
                            sx: {
                              color: "#ff8a80",
                              fontWeight: 500,
                              mb: 1
                            },
                            children: usersError
                          }
                        ),
                        loadingUsers && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#9CCC65" }, children: "Loading users..." }),
                        dmFilter === "recent" && filteredDirectChats.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 3 }, children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", sx: { color: "#CDDC39", fontWeight: 700, mb: 1.5, display: "flex", alignItems: "center", gap: 1 }, children: " Recent Chats" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 1, children: filteredDirectChats.map((chat) => {
                            var _a2;
                            return /* @__PURE__ */ jsxRuntimeExports.jsx(
                              Button,
                              {
                                variant: "outlined",
                                onClick: () => startDirectChat(chat.user),
                                fullWidth: true,
                                sx: {
                                  justifyContent: "flex-start",
                                  textAlign: "left",
                                  p: 1.5,
                                  borderRadius: 2,
                                  borderColor: "rgba(124,179,66,0.6)",
                                  bgcolor: "rgba(124,179,66,0.15)",
                                  backdropFilter: "blur(10px)",
                                  WebkitBackdropFilter: "blur(10px)",
                                  color: "#CDDC39",
                                  "&:hover": {
                                    bgcolor: "rgba(124,179,66,0.25)",
                                    borderColor: "rgba(124,179,66,0.8)"
                                  }
                                },
                                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1.5, alignItems: "center", sx: { width: "100%" }, children: [
                                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                                    Badge,
                                    {
                                      badgeContent: chat.unread_count || 0,
                                      color: "error",
                                      sx: {
                                        "& .MuiBadge-badge": {
                                          bgcolor: "#FF5252",
                                          color: "#fff",
                                          fontWeight: 700
                                        }
                                      },
                                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { sx: { bgcolor: "rgba(124,179,66,0.5)", color: "#0c220f" }, children: (chat.user.username || "U").slice(0, 2).toUpperCase() })
                                    }
                                  ),
                                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { flex: 1, minWidth: 0 }, children: [
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", sx: { fontWeight: 700, color: "#CDDC39" }, children: chat.user.display_name || chat.user.username || "User" }),
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                                      Typography,
                                      {
                                        variant: "caption",
                                        sx: {
                                          color: "#9CCC65",
                                          overflow: "hidden",
                                          textOverflow: "ellipsis",
                                          whiteSpace: "nowrap",
                                          display: "block"
                                        },
                                        children: ((_a2 = chat.last_message) == null ? void 0 : _a2.content) || "No messages yet"
                                      }
                                    )
                                  ] })
                                ] })
                              },
                              chat.user.user_id
                            );
                          }) })
                        ] }),
                        dmFilter === "recent" && !loadingUsers && !usersError && filteredDirectChats.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#9CCC65" }, children: "No recent chats yet. Switch to All Users to start a new conversation." }),
                        dmFilter === "all" && !loadingUsers && !usersError && filteredUsers.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#9CCC65" }, children: "No other users found. Click Refresh to try again." }),
                        dmFilter === "all" && !loadingUsers && !usersError && filteredUsers.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", sx: { color: "#9CCC65", fontWeight: 700, mb: 1.5, display: "flex", alignItems: "center", gap: 1 }, children: " All Users" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 1, children: filteredUsers.map((user) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                            Button,
                            {
                              variant: "outlined",
                              onClick: () => startDirectChat(user),
                              fullWidth: true,
                              sx: {
                                justifyContent: "flex-start",
                                textAlign: "left",
                                p: 1.5,
                                borderRadius: 2,
                                borderColor: "rgba(124,179,66,0.4)",
                                bgcolor: "rgba(255,255,255,0.05)",
                                backdropFilter: "blur(10px)",
                                WebkitBackdropFilter: "blur(10px)",
                                color: "#CDDC39",
                                "&:hover": {
                                  bgcolor: "rgba(124,179,66,0.2)",
                                  borderColor: "rgba(124,179,66,0.6)"
                                }
                              },
                              children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1.5, alignItems: "center", children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { sx: { bgcolor: "rgba(124,179,66,0.35)", color: "#0c220f" }, children: (user.display_name || user.username || "U").slice(0, 2).toUpperCase() }),
                                /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
                                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", sx: { fontWeight: 700, color: "#CDDC39" }, children: user.display_name || user.username || "User" }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { color: "#9CCC65" }, children: "Click to chat" })
                                ] })
                              ] })
                            },
                            user.user_id
                          )) })
                        ] })
                      ] })
                    ] })
                  ] })
                ] })
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          groupDialogOpen && selectedGroup && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Box,
            {
              sx: {
                position: "fixed",
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                zIndex: 1300,
                display: "flex",
                flexDirection: "column",
                backgroundColor: "rgba(0,0,0,0.95)",
                backdropFilter: "blur(20px)"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  GroupHeader,
                  {
                    group: selectedGroup,
                    memberCount: members.length,
                    onBack: closeGroupDialog,
                    isMobile,
                    typingUsers: groupTypingHook.typingUsers
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { flex: 1, minHeight: 0, display: "flex", flexDirection: "column", overflow: "hidden" }, children: [
                  !guidelinesAccepted && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Alert,
                    {
                      severity: "warning",
                      icon: false,
                      sx: {
                        background: "rgba(255,193,7,0.25)",
                        color: "#CDDC39",
                        border: "1px solid rgba(255,193,7,0.5)",
                        flexShrink: 0,
                        m: 1,
                        mb: 0
                      },
                      children: [
                        "By participating, you agree to our",
                        " ",
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          Link,
                          {
                            component: "button",
                            onClick: () => onNavigate && onNavigate("guidelines"),
                            sx: { fontWeight: 700, color: "#fff", textDecoration: "underline" },
                            children: "Community Guidelines"
                          }
                        ),
                        "."
                      ]
                    }
                  ),
                  groupMessagesHook.error ? /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { p: 2, textAlign: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "info", sx: { bgcolor: "rgba(124, 179, 66, 0.15)", color: "#fff", border: "1px solid rgba(124, 179, 66, 0.3)" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#e0e0e0" }, children: "Chat is having trouble loading messages right now. You can still see groups and try again later." }) }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                    GroupMessages,
                    {
                      messages: groupMessagesHook.messages,
                      pinnedMessages: groupMessagesHook.pinnedMessages,
                      isLoadingInitial: groupMessagesHook.isLoadingInitial,
                      isLoadingMore: groupMessagesHook.isLoadingMore,
                      hasMore: groupMessagesHook.hasMore,
                      onLoadMore: groupMessagesHook.loadMore,
                      scrollContainerRef: groupMessagesHook.scrollContainerRef,
                      scrollToBottomRef: groupMessagesHook.scrollToBottomRef,
                      onScroll: groupMessagesHook.handleScroll,
                      currentUserId: userId
                    }
                  )
                ] }),
                isMember ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ChatInput,
                  {
                    value: input,
                    onChange: setInput,
                    onSend: (text, attachments) => {
                      sendMessage();
                    },
                    disabled: sending || !guidelinesAccepted,
                    sending,
                    placeholder: guidelinesAccepted ? "Type a message" : "Accept guidelines to send messages",
                    replyToMessage: replyTo,
                    onCancelReply: () => setReplyTo(null),
                    notifyTyping: groupTypingHook.notifyTyping,
                    scope: "group",
                    channelId: (selectedGroup == null ? void 0 : selectedGroup.id) || null
                  }
                ) : /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { p: 2, textAlign: "center", borderTop: "1px solid rgba(255,255,255,0.08)" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: "contained",
                    onClick: () => joinGroup(),
                    sx: {
                      bgcolor: "rgba(124,179,66,0.9)",
                      color: "#fff",
                      "&:hover": {
                        bgcolor: "rgba(156,204,101,1)"
                      }
                    },
                    children: "Join Group to Send Messages"
                  }
                ) })
              ]
            }
          ),
          false,
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Dialog,
            {
              open: chatDialogOpen,
              onClose: () => setChatDialogOpen(false),
              maxWidth: "md",
              fullWidth: true,
              fullScreen: true,
              PaperProps: {
                sx: {
                  background: "rgba(0, 0, 0, 0.3)",
                  backdropFilter: "blur(30px)",
                  WebkitBackdropFilter: "blur(30px)",
                  m: 0,
                  maxHeight: "100vh",
                  display: "flex",
                  flexDirection: "column",
                  border: "1px solid rgba(124,179,66,0.3)"
                }
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogTitle, { sx: {
                  borderBottom: "2px solid rgba(124,179,66,0.4)",
                  background: "rgba(124,179,66,0.1)",
                  backdropFilter: "blur(10px)",
                  WebkitBackdropFilter: "blur(10px)",
                  display: "flex",
                  justifyContent: "space-between",
                  alignItems: "center",
                  p: 2,
                  pt: "120px",
                  boxShadow: "0 2px 8px rgba(0,0,0,0.3)"
                }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1.5, alignItems: "center", sx: { flex: 1, minWidth: 0 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Button,
                      {
                        startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowBackIosNewIcon, { fontSize: "small" }),
                        onClick: () => setChatDialogOpen(false),
                        sx: {
                          color: "#CDDC39",
                          textTransform: "none",
                          fontWeight: 600,
                          "&:hover": { bgcolor: "rgba(124,179,66,0.2)" }
                        },
                        children: "Back"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { sx: { bgcolor: "rgba(124,179,66,0.35)", color: "#0c220f" }, children: ((selectedChat == null ? void 0 : selectedChat.username) || (selectedChat == null ? void 0 : selectedChat.display_name) || "U").slice(0, 2).toUpperCase() }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", noWrap: true, sx: { fontWeight: 700, color: "#CDDC39", textShadow: "0 2px 4px rgba(0,0,0,0.3)" }, children: (selectedChat == null ? void 0 : selectedChat.display_name) || (selectedChat == null ? void 0 : selectedChat.username) || "User" })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      size: "small",
                      onClick: () => setChatDialogOpen(false),
                      sx: {
                        color: "#CDDC39",
                        "&:hover": {
                          bgcolor: "rgba(124,179,66,0.2)"
                        }
                      },
                      children: "Close"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent, { sx: {
                  flex: 1,
                  minHeight: 0,
                  p: 0,
                  display: "flex",
                  flexDirection: "column",
                  overflow: "hidden",
                  background: "rgba(0,0,0,0.2)"
                }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, sx: {
                  p: 2,
                  flex: 1,
                  display: "flex",
                  flexDirection: "column",
                  minHeight: 0
                }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Alert,
                    {
                      severity: "info",
                      sx: {
                        flexShrink: 0,
                        bgcolor: "rgba(124,179,66,0.08)",
                        backdropFilter: "blur(10px)",
                        WebkitBackdropFilter: "blur(10px)",
                        color: "#CDDC39",
                        border: "1px solid rgba(124,179,66,0.3)",
                        "& .MuiAlert-icon": {
                          color: "#CDDC39"
                        }
                      },
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { fontSize: "0.75rem" }, children: " Only the most recent 500 messages are shown. Older messages are automatically archived." })
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Box,
                    {
                      ref: dmMessagesHook.scrollContainerRef,
                      onScroll: dmMessagesHook.handleScroll,
                      sx: {
                        flex: 1,
                        minHeight: 0,
                        overflowY: "auto",
                        WebkitOverflowScrolling: "touch",
                        border: "2px solid rgba(124,179,66,0.4)",
                        borderRadius: 2,
                        p: 2,
                        background: "rgba(0,0,0,0.2)",
                        backdropFilter: "blur(15px)",
                        WebkitBackdropFilter: "blur(15px)",
                        boxShadow: "inset 0 2px 8px rgba(0,0,0,0.3)"
                      },
                      children: [
                        dmMessagesHook.hasMore && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mb: 2, display: "flex", justifyContent: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                          Button,
                          {
                            onClick: dmMessagesHook.loadMore,
                            disabled: dmMessagesHook.isLoadingMore,
                            variant: "outlined",
                            size: "small",
                            sx: {
                              color: "#9CCC65",
                              borderColor: "rgba(124,179,66,0.4)",
                              "&:hover": {
                                borderColor: "rgba(124,179,66,0.6)",
                                bgcolor: "rgba(124,179,66,0.1)"
                              }
                            },
                            children: dmMessagesHook.isLoadingMore ? "Loading" : "Load earlier messages"
                          }
                        ) }),
                        dmMessagesHook.isLoadingInitial && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", justifyContent: "center", py: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#9CCC65" }, children: "Loading messages..." }) }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(List$1, { sx: { p: 0 }, children: !dmMessagesHook.isLoadingInitial && dmMessagesHook.messages.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                          ListItemText,
                          {
                            secondary: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#9CCC65" }, children: "Start a conversation! Say hello or ask a question." })
                          }
                        ) }) : dmMessagesHook.messages.map((m, idx) => {
                          var _a2, _b;
                          const msg = m.raw || m;
                          const isCurrentUser = m.sender_id === userId;
                          const senderName = isCurrentUser ? "You" : ((_a2 = m.sender) == null ? void 0 : _a2.display_name) || ((_b = m.sender) == null ? void 0 : _b.username) || (selectedChat == null ? void 0 : selectedChat.display_name) || (selectedChat == null ? void 0 : selectedChat.username) || "User";
                          const initials = senderName.slice(0, 2).toUpperCase();
                          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                            ListItem,
                            {
                              sx: {
                                flexDirection: isCurrentUser ? "row-reverse" : "row",
                                alignItems: "flex-start",
                                gap: 1,
                                mb: 1.5
                              },
                              children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemAvatar, { sx: { minWidth: "auto" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { sx: {
                                  bgcolor: isCurrentUser ? "rgba(124,179,66,0.5)" : "rgba(124,179,66,0.35)",
                                  color: "#0c220f",
                                  width: 32,
                                  height: 32,
                                  fontSize: "0.875rem"
                                }, children: initials }) }),
                                /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
                                  maxWidth: "70%",
                                  bgcolor: isCurrentUser ? "rgba(124,179,66,0.2)" : "rgba(255,255,255,0.05)",
                                  backdropFilter: "blur(10px)",
                                  WebkitBackdropFilter: "blur(10px)",
                                  border: `1px solid ${isCurrentUser ? "rgba(124,179,66,0.4)" : "rgba(124,179,66,0.3)"}`,
                                  borderRadius: 2,
                                  p: 1.5,
                                  boxShadow: "0 2px 8px rgba(0,0,0,0.2)"
                                }, children: [
                                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#CDDC39", wordBreak: "break-word" }, children: msg.body || msg.text || msg.content }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", sx: { color: "#9CCC65", display: "block", mt: 0.5 }, children: [
                                    senderName,
                                    "  ",
                                    new Date(msg.created_at || msg.createdAt).toLocaleString(),
                                    msg.optimistic ? "  sending" : ""
                                  ] })
                                ] })
                              ]
                            },
                            msg.id || idx
                          );
                        }) }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: dmMessagesHook.scrollToBottomRef })
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, sx: { flexShrink: 0 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      TextField,
                      {
                        fullWidth: true,
                        size: "small",
                        placeholder: "Type a message...",
                        value: input,
                        onChange: (e) => setInput(e.target.value),
                        onKeyDown: (e) => e.key === "Enter" && !e.shiftKey && sendDirectMessage(),
                        multiline: true,
                        maxRows: 3,
                        sx: {
                          "& .MuiInputBase-root": {
                            bgcolor: "rgba(255,255,255,0.05)",
                            backdropFilter: "blur(10px)",
                            WebkitBackdropFilter: "blur(10px)",
                            border: "1px solid rgba(124,179,66,0.4)",
                            borderRadius: 2,
                            "&:hover": {
                              border: "1px solid rgba(124,179,66,0.6)"
                            },
                            "&.Mui-focused": {
                              border: "1px solid rgba(205,220,57,0.8)",
                              boxShadow: "0 0 8px rgba(124,179,66,0.4)"
                            }
                          },
                          "& .MuiInputBase-input": { color: "#CDDC39" },
                          "& .MuiInputBase-input::placeholder": { color: "#9CCC65", opacity: 0.7 }
                        }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Button,
                      {
                        variant: "contained",
                        onClick: sendDirectMessage,
                        sx: {
                          minWidth: "80px",
                          bgcolor: "rgba(124,179,66,0.9)",
                          color: "#fff",
                          fontWeight: 700,
                          boxShadow: "0 4px 12px rgba(124,179,66,0.4)",
                          "&:hover": {
                            bgcolor: "rgba(156,204,101,1)",
                            boxShadow: "0 6px 16px rgba(124,179,66,0.6)"
                          }
                        },
                        children: "Send"
                      }
                    )
                  ] })
                ] }) })
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: reportDialogOpen, onClose: () => setReportDialogOpen(false), maxWidth: "sm", fullWidth: true, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { sx: {
            bgcolor: "rgba(255,255,255,0.7)",
            boxShadow: "0 8px 32px 0 rgba(31, 38, 135, 0.37)",
            backdropFilter: "blur(12px)",
            borderRadius: 4,
            border: "1px solid rgba(255,255,255,0.18)"
          }, children: "Report Message" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { sx: {
            bgcolor: "rgba(255,255,255,0.7)",
            boxShadow: "0 8px 32px 0 rgba(31, 38, 135, 0.37)",
            backdropFilter: "blur(12px)",
            borderRadius: 4,
            border: "1px solid rgba(255,255,255,0.18)"
          }, children: [
            reportingMessage && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 2 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", color: "text.secondary", children: "Message:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { p: 1, bgcolor: "grey.100", borderRadius: 1 }, children: reportingMessage.content })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, sx: { mt: 2 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                TextField,
                {
                  select: true,
                  label: "Reason",
                  value: reportReason,
                  onChange: (e) => setReportReason(e.target.value),
                  fullWidth: true,
                  SelectProps: { native: true },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "inappropriate", children: "Inappropriate content" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "harassment", children: "Harassment or bullying" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "spam", children: "Spam or advertising" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "hate", children: "Hate speech" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "threats", children: "Threats or violence" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "other", children: "Other" })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                TextField,
                {
                  label: "Additional details (optional)",
                  multiline: true,
                  rows: 3,
                  fullWidth: true,
                  value: reportDetails,
                  onChange: (e) => setReportDetails(e.target.value),
                  placeholder: "Provide any additional context..."
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => setReportDialogOpen(false), children: "Cancel" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleReport, variant: "contained", color: "error", children: "Submit Report" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: guidelinesOpen, onClose: () => setGuidelinesOpen(false), maxWidth: "sm", fullWidth: true, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: "Agree to Community Guidelines" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, sx: { mt: 1 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: "To keep conversations helpful and safe, please agree to follow our community rules (no solicitations, no personal contact info, no harassment, obey local laws)." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { component: "button", onClick: () => onNavigate && onNavigate("guidelines"), sx: { alignSelf: "flex-start" }, children: "View full Community Guidelines" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              FormControlLabel,
              {
                control: /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { checked: guidelinesChecked, onChange: (e) => setGuidelinesChecked(e.target.checked) }),
                label: "I agree to follow the Community Guidelines"
              }
            )
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => setGuidelinesOpen(false), children: "Cancel" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                onClick: () => {
                  localStorage.setItem(guidelinesKey, "true");
                  setGuidelinesAccepted(true);
                  setGuidelinesOpen(false);
                },
                variant: "contained",
                disabled: !guidelinesChecked,
                children: "Accept & Continue"
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Snackbar,
          {
            open: snackbar.open,
            autoHideDuration: 4e3,
            onClose: handleSnackbarClose,
            anchorOrigin: { vertical: "bottom", horizontal: "center" },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Alert,
              {
                onClose: handleSnackbarClose,
                severity: snackbar.severity,
                sx: { width: "100%" },
                children: snackbar.message
              }
            )
          }
        )
      ]
    }
  );
}
function Seeds({ onBack }) {
  const navigate = useNavigate();
  const [seeds, setSeeds] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [error2, setError] = reactExports.useState(null);
  reactExports.useEffect(() => {
    let cancelled = false;
    const fallbackSeeds = [
      { id: "ilgm", name: "I Love Growing Marijuana (ILGM)", breeder: "ILGM", type: "seed bank", description: "Premium cannabis seeds with germination guarantee. Feminized, autoflower, and regular seeds available.", url: "https://ilgm.com" },
      { id: "seedsman", name: "Seedsman", breeder: "Seedsman", type: "seed bank", description: "One of the oldest and most trusted online seed banks. Huge selection from top breeders worldwide.", url: "https://www.seedsman.com" },
      { id: "crop-king", name: "Crop King Seeds", breeder: "Crop King", type: "seed bank", description: "Canadian seed bank with fast shipping to US. Great selection of feminized and autoflower strains.", url: "https://www.cropkingseeds.com" },
      { id: "msnl", name: "Marijuana Seeds NL", breeder: "MSNL", type: "seed bank", description: "Established seed bank with stealth shipping worldwide. Competitive prices and frequent sales.", url: "https://www.msnl.com" },
      { id: "growers-choice", name: "Growers Choice Seeds", breeder: "Growers Choice", type: "seed bank", description: "US-based seed company with 90% germination guarantee. Fast domestic shipping.", url: "https://growerschoiceseeds.com" },
      { id: "homegrown", name: "Homegrown Cannabis Co.", breeder: "Homegrown", type: "seed bank", description: "Premium genetics with expert growing advice. Free seeds with every order.", url: "https://homegrowncannabisco.com" }
    ];
    function fetchVendors() {
      return __async(this, null, function* () {
        setLoading(true);
        setError(null);
        try {
          const res = yield fetch(`${API_BASE}/api/seeds`);
          if (!res.ok) {
            throw new Error(`Failed to load seeds: ${res.status}`);
          }
          const data = yield res.json();
          if (cancelled) return;
          const allSeeds = [...Array.isArray(data) ? data : [], ...fallbackSeeds].filter(
            (seed, idx, arr) => arr.findIndex((s) => s.id === seed.id) === idx
          );
          setSeeds(allSeeds);
        } catch (e) {
          console.error("[Seeds] Error loading vendors:", e);
          if (!cancelled) {
            setError("Unable to load seed vendors right now.");
            setSeeds(fallbackSeeds);
          }
        } finally {
          if (!cancelled) {
            setLoading(false);
          }
        }
      });
    }
    fetchVendors();
    return () => {
      cancelled = true;
    };
  }, []);
  !seeds || seeds.length === 0;
  const handleBack = () => {
    if (onBack) {
      onBack();
    } else {
      navigate("/");
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        height: "100vh",
        display: "flex",
        flexDirection: "column",
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            sx: {
              flexShrink: 0,
              display: "flex",
              alignItems: "center",
              p: 2,
              gap: 1.5,
              borderBottom: "1px solid rgba(255,255,255,0.08)",
              bgcolor: "rgba(0,0,0,0.7)",
              backdropFilter: "blur(10px)",
              zIndex: 1
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton$1,
                {
                  edge: "start",
                  onClick: handleBack,
                  sx: { color: "#fff" },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowBackIcon, {})
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { fontWeight: 600, color: "#fff", flex: 1 }, children: "Seed Vendors" })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            sx: {
              flex: 1,
              minHeight: 0,
              overflowY: "auto",
              WebkitOverflowScrolling: "touch"
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { maxWidth: "lg", sx: { py: 3 }, children: [
              loading && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", justifyContent: "center", alignItems: "center", minHeight: "200px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 28 }) }),
              !loading && error2 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { p: 2, textAlign: "center" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", sx: { color: "#fff", mb: 1 }, children: "Seed vendor search is warming up. Live data isn't available yet, but we'll add it soon." }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: "outlined",
                    size: "small",
                    onClick: () => window.location.reload(),
                    sx: { mt: 1, color: "#fff", borderColor: "rgba(255,255,255,0.3)" },
                    children: "Retry"
                  }
                )
              ] }),
              !loading && !error2 && (!seeds || seeds.length === 0) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { padding: "16px", textAlign: "center", opacity: 0.7, mt: 4 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#fff", mb: 1 }, children: "No vendors available" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#fff" }, children: "Seed vendors will appear here once configured." })
              ] }),
              !loading && !error2 && seeds && seeds.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { container: true, spacing: 2, children: seeds.map((seed) => /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { height: "100%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { fontWeight: 600, mb: 1 }, children: seed.name || "Unknown Vendor" }),
                seed.breeder && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { opacity: 0.8, mb: 0.5 }, children: seed.breeder }),
                seed.type && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { opacity: 0.7, mb: 0.5 }, children: [
                  "Type: ",
                  seed.type
                ] }),
                seed.description && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { mt: 1, opacity: 0.9 }, children: seed.description }),
                seed.url && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    size: "small",
                    variant: "contained",
                    color: "primary",
                    href: seed.url,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    sx: { mt: 2 },
                    children: "Visit Website"
                  }
                )
              ] }) }) }, seed.id || seed.name)) })
            ] })
          }
        )
      ]
    }
  );
}
function Dispensaries({ onBack }) {
  const navigate = useNavigate();
  const [dispensaries, setDispensaries] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [error2, setError] = reactExports.useState(null);
  const [userLocation, setUserLocation] = reactExports.useState(null);
  const [locationError, setLocationError] = reactExports.useState(null);
  reactExports.useEffect(() => {
    const getLocation = () => __async(null, null, function* () {
      try {
        if (window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Geolocation) {
          const { Geolocation } = window.Capacitor.Plugins;
          const position2 = yield Geolocation.getCurrentPosition({
            timeout: 15e3,
            enableHighAccuracy: false,
            maximumAge: 3e5
            // 5 min cache
          });
          console.log("[Dispensaries] Location obtained via Capacitor:", position2);
          setUserLocation({
            lat: position2.coords.latitude,
            lng: position2.coords.longitude
          });
          return;
        }
        if ("geolocation" in navigator) {
          navigator.geolocation.getCurrentPosition(
            (position2) => {
              console.log("[Dispensaries] Location obtained successfully");
              setUserLocation({
                lat: position2.coords.latitude,
                lng: position2.coords.longitude
              });
            },
            (err) => {
              console.warn("[Dispensaries] Location access denied:", err.message);
              if (err.code === 1) {
                setLocationError("Location access denied. Please enable location services or search manually.");
              } else {
                setLocationError("Unable to detect location. Please search manually or enable location services.");
              }
            },
            {
              timeout: 15e3,
              // 15 second timeout
              maximumAge: 3e5,
              // 5 min cache
              enableHighAccuracy: false
            }
          );
        } else {
          console.log("[Dispensaries] Geolocation not supported");
          setLocationError("Geolocation not supported. Please search manually.");
        }
      } catch (error22) {
        console.error("[Dispensaries] Location error:", error22);
        setLocationError("Unable to detect location. Please search manually.");
      }
    });
    getLocation();
  }, []);
  reactExports.useEffect(() => {
    if (!userLocation) {
      setLoading(false);
      return;
    }
    const params = new URLSearchParams();
    params.set("lat", userLocation.lat);
    params.set("lng", userLocation.lng);
    params.set("radius", "50");
    const url = `${API_BASE}/api/dispensaries?${params}`;
    console.log("[Dispensaries] Fetching from:", url);
    fetch(url).then((res) => {
      console.log("[Dispensaries] Response status:", res.status, res.statusText);
      if (!res.ok) {
        if (res.status === 400) {
          return res.json().then((err) => {
            throw new Error(err.error || "Location required");
          });
        }
        throw new Error("Failed to load dispensaries");
      }
      return res.json();
    }).then((data) => {
      console.log("[Dispensaries] Received dispensaries:", (data == null ? void 0 : data.length) || 0);
      if (userLocation && Array.isArray(data)) {
        data.sort((a, b) => (a.distance || Infinity) - (b.distance || Infinity));
      }
      setDispensaries(data || []);
      setError(null);
    }).catch((e) => {
      console.error("[Dispensaries] Error:", e);
      setError(e.message || "Failed to load dispensaries. Please try again.");
      setDispensaries([]);
    }).finally(() => setLoading(false));
  }, [userLocation]);
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", flexDirection: "column", alignItems: "center", gap: 2, m: 4 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: userLocation ? "Finding dispensaries near you..." : "Getting your location..." })
    ] });
  }
  if (error2) return /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { m: 2 }, children: error2 });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { p: 3 }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        style: {
          position: "absolute",
          top: 16,
          left: 16,
          zIndex: 100,
          background: "rgba(34, 139, 34, 0.25)",
          border: "1px solid #228B22",
          borderRadius: 12,
          boxShadow: "0 2px 12px rgba(34,139,34,0.15)",
          backdropFilter: "blur(8px)",
          color: "#228B22",
          padding: "8px 16px",
          display: "flex",
          alignItems: "center",
          fontWeight: 600,
          fontSize: 18
        },
        onClick: () => navigate("/"),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CannabisLeafIcon, { style: { marginRight: 8, height: 24 } }),
          "Home"
        ]
      }
    ),
    onBack && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mb: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onBack, size: "small", variant: "contained", sx: { bgcolor: "#7CB342", color: "white", textTransform: "none", fontWeight: 700, borderRadius: 999, "&:hover": { bgcolor: "#689f38" } }, children: " Back to Garden" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 2, sx: { mb: 3 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", sx: { fontWeight: 700 }, children: "Dispensaries Near You" }),
      userLocation && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Chip,
        {
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(MyLocationIcon, {}),
          label: "Location enabled",
          color: "success",
          size: "small"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 4 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { mb: 1 }, children: "Google Maps Results" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "outlined",
          color: "primary",
          startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(OpenInNewIcon, {}),
          href: userLocation ? `https://www.google.com/maps/search/dispensary/@${userLocation.lat},${userLocation.lng},13z` : `https://www.google.com/maps/search/dispensary/`,
          target: "_blank",
          rel: "noopener noreferrer",
          sx: { mb: 2 },
          children: "View Dispensaries on Google Maps"
        }
      )
    ] }),
    locationError && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "info", sx: { mb: 2 }, children: locationError }),
    dispensaries.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "info", children: "No dispensaries found nearby. Try expanding your search radius or check back later." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { container: true, spacing: 3, children: dispensaries.map((d, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, size: { xs: 12, sm: 6, md: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { sx: { mb: 2, background: "rgba(255,255,255,0.10)", backdropFilter: "blur(12px)", border: "2px solid black", boxShadow: "none" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { sx: { flex: 1 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", gutterBottom: true, sx: { fontWeight: 600 }, children: d.name }),
        d.distance && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Chip,
          {
            label: `${d.distance.toFixed(1)} mi away`,
            size: "small",
            color: "primary",
            sx: { mb: 1 }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 0.5, sx: { mt: 1 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "black", fontSize: "1.08rem" }, children: d.address }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", color: "text.secondary", children: [
            d.city,
            ", ",
            d.state,
            " ",
            d.zip || ""
          ] }),
          d.description && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { mt: 1 }, children: d.description })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { p: 2, pt: 0 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonGroup, { fullWidth: true, orientation: "vertical", variant: "contained", children: [
        d.phone && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Button,
          {
            startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(PhoneIcon, {}),
            href: `tel:${d.phone.replace(/[^0-9+]/g, "")}`,
            sx: {
              background: "linear-gradient(45deg, #4caf50 30%, #66bb6a 90%)",
              "&:hover": {
                background: "linear-gradient(45deg, #388e3c 30%, #4caf50 90%)"
              }
            },
            children: [
              "Call ",
              d.phone
            ]
          }
        ),
        d.lat && d.lng || d.address && d.city && d.state ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(DirectionsIcon, {}),
            onClick: () => {
              const destination = d.lat && d.lng ? `${d.lat},${d.lng}` : `${d.address}, ${d.city}, ${d.state} ${d.zip || ""}`.trim();
              const mapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${encodeURIComponent(destination)}`;
              window.open(mapsUrl, "_blank");
            },
            sx: {
              background: "linear-gradient(45deg, #2196f3 30%, #42a5f5 90%)",
              "&:hover": {
                background: "linear-gradient(45deg, #1976d2 30%, #2196f3 90%)"
              }
            },
            children: "Get Directions"
          }
        ) : null,
        d.website && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(OpenInNewIcon, {}),
            href: d.website,
            target: "_blank",
            rel: "noopener noreferrer",
            sx: {
              background: "linear-gradient(45deg, #ff9800 30%, #ffa726 90%)",
              "&:hover": {
                background: "linear-gradient(45deg, #f57c00 30%, #ff9800 90%)"
              }
            },
            children: "Visit Website"
          }
        )
      ] }) })
    ] }) }, `${d.id}-${idx}`)) })
  ] });
}
function ProModeGate() {
  const { proRole, proEnabled, proLoading, activateProWithCode, clearProMode } = useProMode();
  const [code, setCode] = reactExports.useState("");
  const [error2, setError] = reactExports.useState("");
  const [success, setSuccess] = reactExports.useState("");
  function handleSubmit(e) {
    return __async(this, null, function* () {
      e.preventDefault();
      setError("");
      setSuccess("");
      if (!code.trim()) {
        setError("Please enter your access code.");
        return;
      }
      try {
        const result = yield activateProWithCode(code.trim());
        setSuccess(`Pro mode activated for ${result.role === "dispensary" ? "Dispensary" : "Grower"}.`);
        setCode("");
      } catch (err) {
        setError((err == null ? void 0 : err.message) || "Invalid access code.");
      }
    });
  }
  function handleClear() {
    clearProMode();
    setSuccess("");
    setError("");
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        p: 3,
        borderRadius: 2,
        border: "1px solid rgba(124, 179, 66, 0.3)",
        background: "rgba(0, 0, 0, 0.2)",
        mb: 2
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { mb: 1, color: "#E8F5E9" }, children: "Dispensary & Grower Mode" }),
        proEnabled && proRole ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 2 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Chip,
            {
              label: `Active: ${proRole === "dispensary" ? "Dispensary mode" : "Grower mode"}`,
              color: "success",
              sx: { mb: 1 }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "rgba(200, 230, 201, 0.8)" }, children: "Pro-level AI details are now enabled for your scans." })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { mb: 2, color: "rgba(200, 230, 201, 0.8)" }, children: "Enter your access code to unlock pro-level AI details tailored for dispensaries and growers." }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, style: { display: "flex", flexDirection: "column", gap: "12px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextField,
            {
              type: "text",
              value: code,
              onChange: (e) => setCode(e.target.value),
              placeholder: "Enter access code",
              disabled: proLoading || proEnabled,
              fullWidth: true,
              sx: {
                "& .MuiOutlinedInput-root": {
                  borderRadius: "999px",
                  backgroundColor: "rgba(0, 0, 0, 0.3)",
                  color: "#fff",
                  "& fieldset": {
                    borderColor: "rgba(255, 255, 255, 0.2)"
                  },
                  "&:hover fieldset": {
                    borderColor: "rgba(255, 255, 255, 0.3)"
                  },
                  "&.Mui-focused fieldset": {
                    borderColor: "#7CB342"
                  }
                },
                "& .MuiInputBase-input": {
                  color: "#fff"
                }
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              type: "submit",
              disabled: proLoading || proEnabled,
              variant: "contained",
              sx: {
                borderRadius: "999px",
                backgroundColor: "#7CB342",
                color: "#000",
                fontWeight: 600,
                "&:hover": {
                  backgroundColor: "#9AE66E"
                },
                "&:disabled": {
                  backgroundColor: "rgba(124, 179, 66, 0.3)",
                  color: "rgba(255, 255, 255, 0.5)"
                }
              },
              children: proLoading ? "Checking code" : proEnabled ? "Already Active" : "Activate Pro Mode"
            }
          ),
          proEnabled && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              type: "button",
              onClick: handleClear,
              variant: "outlined",
              sx: {
                borderRadius: "999px",
                borderColor: "rgba(255, 255, 255, 0.2)",
                color: "#fff",
                fontSize: "12px",
                mt: 1,
                "&:hover": {
                  borderColor: "rgba(255, 255, 255, 0.4)",
                  backgroundColor: "rgba(255, 255, 255, 0.05)"
                }
              },
              children: "Disable Pro Mode"
            }
          )
        ] }),
        error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mt: 2 }, children: error2 }),
        success && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "success", sx: { mt: 2 }, children: success })
      ]
    }
  );
}
function Help({ onNavigate, onBack }) {
  const tiles = [
    { key: "scanner", title: "Scanner", emoji: "", blurb: "Snap bud or label for AI match" },
    { key: "history", title: "Scan History", emoji: "", blurb: "Revisit past scans & results" },
    { key: "strains", title: "Strain Browser", emoji: "hero", blurb: "Explore 35k+ strains" },
    { key: "dispensaries", title: "Dispensaries", emoji: "", blurb: "Find nearby shops" },
    { key: "seeds", title: "Seeds", emoji: "", blurb: "Where to buy seed packs" },
    { key: "grow-coach", title: "Grow Coach", emoji: "", blurb: "Stepbystep grow guide" },
    { key: "groups", title: "Groups & Chat", emoji: "", blurb: "Talk with the community" },
    { key: "friends", title: "Friends", emoji: "", blurb: "Add friends and connect" },
    { key: "growers", title: "Grower Directory", emoji: "", blurb: "Discover local growers" },
    { key: "membership", nav: "membership-join", title: "Membership", emoji: "", blurb: "Unlimited scans & more" },
    { key: "feedback", title: "Feedback", emoji: "", blurb: "Send us ideas & issues" }
  ];
  const GlassTile = ({ title, emoji, onClick }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    ButtonBase,
    {
      disableRipple: true,
      onClick,
      sx: {
        position: "relative",
        borderRadius: 3,
        p: 0.5,
        // Little buttons
        minHeight: { xs: 72, sm: 84 },
        aspectRatio: "1 / 1",
        width: "100%",
        textAlign: "center",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        gap: 1,
        // Single-layer, highly see-through glass
        background: "rgba(20, 40, 30, 0.10)",
        border: "1px solid rgba(124,179,66,0.14)",
        backdropFilter: "blur(3px)",
        boxShadow: "0 1px 8px rgba(0,0,0,0.10)",
        color: "white",
        transition: "all 200ms cubic-bezier(0.4, 0, 0.2, 1)",
        outline: "none",
        "&:focus-visible": { outline: "none", boxShadow: "none" },
        "&:hover": {
          transform: "none",
          background: "rgba(24, 52, 38, 0.12)",
          borderColor: "rgba(124,179,66,0.18)",
          boxShadow: "0 2px 10px rgba(0,0,0,0.12)"
        }
      },
      children: [
        emoji === "hero" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { component: "img", src: "/hero.png?v=13", alt: "", sx: {
          width: { xs: 20, sm: 22 },
          height: { xs: 20, sm: 22 },
          filter: "drop-shadow(0 2px 4px rgba(0,0,0,0.2)) drop-shadow(0 0 4px rgba(124, 179, 66, 0.6))"
        } }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
          fontSize: { xs: 20, sm: 22 },
          lineHeight: 1,
          filter: "drop-shadow(0 2px 4px rgba(0,0,0,0.2))"
        }, "aria-hidden": true, children: emoji }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Typography,
          {
            variant: "subtitle2",
            sx: {
              fontWeight: 700,
              lineHeight: 1.3,
              fontSize: { xs: "0.70rem", sm: "0.80rem" },
              textShadow: "0 1px 2px rgba(0,0,0,0.25), 0 0 12px rgba(124,179,66,0.15)",
              maxWidth: "90%"
            },
            children: title
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { position: "absolute", bottom: 8, left: 8, opacity: 0.08 }, "aria-hidden": true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CannabisLeafIcon, {}) })
      ]
    }
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { minHeight: "100vh" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { maxWidth: "lg", sx: { py: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 3, children: [
    onBack && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onBack, size: "small", variant: "contained", sx: { bgcolor: "white", color: "black", textTransform: "none", fontWeight: 700, alignSelf: "flex-start", borderRadius: 999, "&:hover": { bgcolor: "grey.100" } }, children: "Home" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, alignItems: "center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(CannabisLeafIcon, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: "bold", color: "primary.light", children: "Help & How-To" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        sx: {
          display: "grid",
          gap: 2,
          gridTemplateColumns: {
            xs: "repeat(2, minmax(0, 1fr))",
            sm: "repeat(3, minmax(0, 1fr))",
            md: "repeat(4, minmax(0, 1fr))"
          }
        },
        children: tiles.map((t) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          GlassTile,
          {
            title: t.title,
            emoji: t.emoji,
            onClick: () => onNavigate == null ? void 0 : onNavigate(t.nav || t.key)
          },
          t.key
        ))
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { background: "rgba(255,255,255,0.05)", border: "1px solid rgba(255,255,255,0.15)", backdropFilter: "blur(6px)" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", gutterBottom: true, children: "Getting Started" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 1, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "1. Create an Account:" }),
          " Tap the Account tile to sign up with email and password."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "2. Enable Location:" }),
          " Allow location access for nearby dispensaries and grower directory."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "3. Start Scanning:" }),
          " Tap the Scanner tile and take a photo of your cannabis to identify the strain."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "4. Join the Community:" }),
          " Use Groups & Chat to connect with other cannabis enthusiasts."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "5. Unlock + Membership:" }),
          " One-time app unlock (20 scans) plus $4.99/mo for 200 scans and community perks. Add 50/200/500 top-ups whenever you need more."
        ] })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { background: "rgba(255,255,255,0.05)", border: "1px solid rgba(255,255,255,0.15)", backdropFilter: "blur(6px)" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", gutterBottom: true, children: "Scanning tips" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 1, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: " Frame the whole bud inside the guide. Avoid extreme macro." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: " Even lighting. Avoid glare and deep shadows." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: " Include the label or strain name when possible." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: " Try 23 angles of the same bud for richer features." })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { background: "rgba(255,255,255,0.05)", border: "1px solid rgba(255,255,255,0.15)", backdropFilter: "blur(6px)" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", gutterBottom: true, children: "Common issues" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 1, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", children: "No match or low confidence" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: "Retake with better lighting and framing; include text if available." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", sx: { mt: 1 }, children: "Upload error" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: "Check connectivity and retry. Service may be briefly busy." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", sx: { mt: 1 }, children: "Stuck on processing" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: "Close and retry the scan. If repeated, wait a minute and try again." })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "info", children: "Questions or suggestions? Use the Feedback tile to send us a message." }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ProModeGate, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", children: "For privacy, login isn't required. Select scans may be used to improve the service." })
  ] }) }) });
}
function Friends({ userId = "demo-user", onBack }) {
  const [tab, setTab] = reactExports.useState(0);
  const [friends, setFriends] = reactExports.useState([]);
  const [sent, setSent] = reactExports.useState([]);
  const [received, setReceived] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [error2, setError] = reactExports.useState(null);
  const [friendUsername, setFriendUsername] = reactExports.useState("");
  const fetchFriends = reactExports.useCallback(() => __async(null, null, function* () {
    setLoading(true);
    setError(null);
    try {
      const res = yield fetch(`${API_BASE}/api/friends?user_id=${userId}`);
      if (!res.ok) {
        const errData = yield res.json().catch(() => ({}));
        throw new Error(errData.error || "Failed to load friends");
      }
      const data = yield res.json();
      setFriends(data.friends || []);
      setSent(data.sent || []);
      setReceived(data.received || []);
      setError(null);
    } catch (e) {
      console.error("Friends fetch error:", e);
      setError(e.message);
      setFriends([]);
      setSent([]);
      setReceived([]);
    } finally {
      setLoading(false);
    }
  }), [userId]);
  reactExports.useEffect(() => {
    fetchFriends();
  }, [fetchFriends]);
  const sendRequest = () => __async(null, null, function* () {
    if (!friendUsername.trim()) return;
    try {
      const res = yield fetch(`${API_BASE}/api/friends/request`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ user_id: userId, friend_id: "friend-user-id" })
        // Replace with actual lookup
      });
      if (!res.ok) {
        const err = yield res.json();
        throw new Error(err.error || "Failed to send request");
      }
      setFriendUsername("");
      fetchFriends();
    } catch (e) {
      setError(e.message);
    }
  });
  const acceptRequest = (friendshipId) => __async(null, null, function* () {
    try {
      const res = yield fetch(`${API_BASE}/api/friends/accept`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ friendship_id: friendshipId })
      });
      if (!res.ok) throw new Error("Failed to accept");
      fetchFriends();
    } catch (e) {
      setError(e.message);
    }
  });
  const rejectRequest = (friendshipId) => __async(null, null, function* () {
    try {
      const res = yield fetch(`${API_BASE}/api/friends/reject`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ friendship_id: friendshipId })
      });
      if (!res.ok) throw new Error("Failed to reject");
      fetchFriends();
    } catch (e) {
      setError(e.message);
    }
  });
  const removeFriend = (friendshipId) => __async(null, null, function* () {
    try {
      const res = yield fetch(`${API_BASE}/api/friends/${friendshipId}`, { method: "DELETE" });
      if (!res.ok) throw new Error("Failed to remove");
      fetchFriends();
    } catch (e) {
      setError(e.message);
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { minHeight: "100vh" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { maxWidth: "md", sx: { py: 4 }, children: [
    onBack && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onBack, size: "small", variant: "contained", sx: { bgcolor: "white", color: "black", textTransform: "none", fontWeight: 700, borderRadius: 999, mb: 1, "&:hover": { bgcolor: "grey.100" } }, children: "Home" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", gutterBottom: true, children: "Friends" }),
    error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mb: 2 }, children: error2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { mb: 3 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", gutterBottom: true, children: "Add Friend" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            placeholder: "Enter username",
            value: friendUsername,
            onChange: (e) => setFriendUsername(e.target.value),
            fullWidth: true
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "contained", onClick: sendRequest, children: "Send Request" })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Tabs, { value: tab, onChange: (_, v) => setTab(v), sx: { mb: 2 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { label: `Friends (${friends.length})` }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { label: `Requests (${received.length})` }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { label: `Sent (${sent.length})` })
    ] }),
    loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {}) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      tab === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(List$1, { children: friends.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "No friends yet" }) : friends.map((f) => {
        var _a2;
        const friend = f.user_id === userId ? f.friend : f.users;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemAvatar, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { src: friend == null ? void 0 : friend.avatar_url, children: ((_a2 = friend == null ? void 0 : friend.username) == null ? void 0 : _a2[0]) || "?" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText, { primary: (friend == null ? void 0 : friend.username) || "Unknown", secondary: `Friends since ${new Date(f.accepted_at).toLocaleDateString()}` }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { size: "small", color: "error", onClick: () => removeFriend(f.id), children: "Remove" })
        ] }, f.id);
      }) }),
      tab === 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(List$1, { children: received.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "No pending requests" }) : received.map((r2) => {
        var _a2, _b, _c, _d;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemAvatar, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { src: (_a2 = r2.users) == null ? void 0 : _a2.avatar_url, children: ((_c = (_b = r2.users) == null ? void 0 : _b.username) == null ? void 0 : _c[0]) || "?" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText, { primary: ((_d = r2.users) == null ? void 0 : _d.username) || "Unknown", secondary: `Requested ${new Date(r2.requested_at).toLocaleDateString()}` }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { size: "small", variant: "contained", onClick: () => acceptRequest(r2.id), children: "Accept" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { size: "small", variant: "outlined", onClick: () => rejectRequest(r2.id), children: "Reject" })
          ] })
        ] }, r2.id);
      }) }),
      tab === 2 && /* @__PURE__ */ jsxRuntimeExports.jsx(List$1, { children: sent.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "No sent requests" }) : sent.map((s) => {
        var _a2, _b, _c, _d;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemAvatar, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { src: (_a2 = s.friend) == null ? void 0 : _a2.avatar_url, children: ((_c = (_b = s.friend) == null ? void 0 : _b.username) == null ? void 0 : _c[0]) || "?" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText, { primary: ((_d = s.friend) == null ? void 0 : _d.username) || "Unknown", secondary: `Sent ${new Date(s.requested_at).toLocaleDateString()}` }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: "Pending", size: "small" })
        ] }, s.id);
      }) })
    ] })
  ] }) });
}
const defaultForm = (defaults) => {
  const safeDefaults = defaults && typeof defaults === "object" ? defaults : {};
  return {
    strain_name: safeDefaults.strain_name || "",
    strain_slug: safeDefaults.strain_slug || "",
    entry_date: (/* @__PURE__ */ new Date()).toISOString().slice(0, 10),
    rating: safeDefaults.rating || 0,
    notes: "",
    method: "",
    dosage: "",
    time_of_day: "",
    tags: ""
  };
};
function JournalDialog({ open, defaults, onClose, onSaved }) {
  const [form, setForm] = reactExports.useState(() => defaultForm(defaults));
  const [saving, setSaving] = reactExports.useState(false);
  const [error2, setError] = reactExports.useState(null);
  reactExports.useEffect(() => {
    setForm(defaultForm(defaults));
  }, [defaults, open]);
  const handleChange = (field) => (event, value) => {
    var _a2, _b;
    if (field === "rating") {
      setForm((prev2) => __spreadProps(__spreadValues({}, prev2), { rating: value || 0 }));
      return;
    }
    const val = (_b = (_a2 = event == null ? void 0 : event.target) == null ? void 0 : _a2.value) != null ? _b : "";
    setForm((prev2) => __spreadProps(__spreadValues({}, prev2), { [field]: val }));
  };
  const handleSubmit = () => __async(null, null, function* () {
    var _a2;
    setSaving(true);
    setError(null);
    try {
      const { data } = yield supabase.auth.getSession();
      const token2 = (_a2 = data == null ? void 0 : data.session) == null ? void 0 : _a2.access_token;
      const resp = yield fetch(`${API_BASE}/api/journals`, {
        method: "POST",
        headers: __spreadValues({
          "Content-Type": "application/json"
        }, token2 ? { Authorization: `Bearer ${token2}` } : {}),
        body: JSON.stringify(__spreadProps(__spreadValues({}, form), {
          tags: form.tags ? form.tags.split(",").map((tag) => tag.trim()).filter(Boolean) : []
        }))
      });
      const payload = yield resp.json().catch(() => ({}));
      if (!resp.ok) {
        throw new Error(payload.error || "Failed to save journal entry.");
      }
      onSaved == null ? void 0 : onSaved(payload);
      onClose == null ? void 0 : onClose();
    } catch (err) {
      setError(err.message || "Unable to save entry.");
    } finally {
      setSaving(false);
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open, onClose, fullWidth: true, maxWidth: "sm", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: "Log your experience" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent, { dividers: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, sx: { mt: 1 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextField,
        {
          label: "Strain name",
          value: form.strain_name,
          onChange: handleChange("strain_name"),
          fullWidth: true
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextField,
        {
          label: "Strain slug / nickname",
          value: form.strain_slug,
          onChange: handleChange("strain_slug"),
          fullWidth: true
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextField,
        {
          label: "Date",
          type: "date",
          value: form.entry_date,
          onChange: handleChange("entry_date"),
          InputLabelProps: { shrink: true },
          fullWidth: true
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Rating,
        {
          value: form.rating,
          onChange: handleChange("rating"),
          size: "large"
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextField,
        {
          label: "Consumption method",
          value: form.method,
          onChange: handleChange("method"),
          placeholder: "Joint, vape, edible...",
          fullWidth: true
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: { xs: "column", sm: "row" }, spacing: 2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: "Dosage",
            value: form.dosage,
            onChange: handleChange("dosage"),
            placeholder: "0.5g, 5mg edible...",
            fullWidth: true
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: "Time of day",
            value: form.time_of_day,
            onChange: handleChange("time_of_day"),
            placeholder: "Morning, Night...",
            fullWidth: true
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextField,
        {
          label: "Tags",
          value: form.tags,
          onChange: handleChange("tags"),
          placeholder: "sleep, focus",
          helperText: "Comma-separated keywords",
          fullWidth: true
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextField,
        {
          label: "Notes",
          value: form.notes,
          onChange: handleChange("notes"),
          fullWidth: true,
          multiline: true,
          rows: 4
        }
      ),
      error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { color: "error", label: error2 })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onClose, disabled: saving, children: "Cancel" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "contained", onClick: handleSubmit, disabled: saving, children: "Save entry" })
    ] })
  ] });
}
const STRAINS_PER_PAGE = 100;
const FETCH_BATCH_SIZE = 1e3;
const getStrainImageUrl = (strain) => {
  if (!strain) return null;
  const candidates = [
    strain.thumbnail_url,
    // Prioritize thumbnail for faster loading
    strain.image_url,
    strain.photo_url,
    strain.main_image,
    strain.leafly_image,
    strain.hero_image_url,
    strain.image,
    strain.imageUrl
  ];
  return candidates.find((u) => typeof u === "string" && u.startsWith("http")) || null;
};
function StrainBrowser({ onBack }) {
  const [strains, setStrains] = reactExports.useState([]);
  const [filteredStrains, setFilteredStrains] = reactExports.useState([]);
  const [displayedStrains, setDisplayedStrains] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [searchQuery, setSearchQuery] = reactExports.useState("");
  const [typeFilter, setTypeFilter] = reactExports.useState("all");
  const [selectedStrain, setSelectedStrain] = reactExports.useState(null);
  const [detailsOpen, setDetailsOpen] = reactExports.useState(false);
  const [detailsTab, setDetailsTab] = reactExports.useState(0);
  const [vendors, setVendors] = reactExports.useState([]);
  const [dispensaries, setDispensaries] = reactExports.useState([]);
  const [reviews, setReviews] = reactExports.useState([]);
  const [userLocation, setUserLocation] = reactExports.useState(null);
  const [loadingLocation, setLoadingLocation] = reactExports.useState(true);
  const [page, setPage] = reactExports.useState(0);
  const [hasMore, setHasMore] = reactExports.useState(true);
  const [allStrainsLoaded, setAllStrainsLoaded] = reactExports.useState(false);
  const [sortBy, setSortBy] = reactExports.useState("type");
  const [thcRange, setThcRange] = reactExports.useState([0, 35]);
  const [favorites, setFavorites] = reactExports.useState([]);
  const [showFilters, setShowFilters] = reactExports.useState(false);
  const [snackbar, setSnackbar] = reactExports.useState({ open: false, message: "", severity: "success" });
  const [showSeedFinder, setShowSeedFinder] = reactExports.useState(false);
  const [showingFavorites, setShowingFavorites] = reactExports.useState(false);
  const [journalDialogOpen, setJournalDialogOpen] = reactExports.useState(false);
  const [journalDefaults, setJournalDefaults] = reactExports.useState(null);
  const [maxToShow, setMaxToShow] = reactExports.useState(300);
  const observerTarget = reactExports.useRef(null);
  const handleLogExperience = (strain) => {
    if (!strain) return;
    setJournalDefaults({
      strain_name: strain.name,
      strain_slug: strain.slug
    });
    setJournalDialogOpen(true);
  };
  reactExports.useEffect(() => {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (position2) => {
          console.log("[StrainBrowser] Location obtained successfully");
          setUserLocation({
            lat: position2.coords.latitude,
            lng: position2.coords.longitude
          });
          setLoadingLocation(false);
        },
        (error2) => {
          console.log("[StrainBrowser] Location denied or unavailable:", error2.message);
          setUserLocation({ lat: 37.7749, lng: -122.4194 });
          setLoadingLocation(false);
        },
        {
          timeout: 5e3,
          maximumAge: 3e5,
          // 5 min cache
          enableHighAccuracy: false
        }
      );
    } else {
      console.log("[StrainBrowser] Geolocation not supported");
      setUserLocation({ lat: 37.7749, lng: -122.4194 });
      setLoadingLocation(false);
    }
  }, []);
  const fetchStrainsFromSupabase = reactExports.useCallback(() => __async(null, null, function* () {
    if (!supabase) return [];
    let allData = [];
    let from2 = 0;
    const batchSize = FETCH_BATCH_SIZE;
    let hasMoreData = true;
    while (hasMoreData) {
      const to = from2 + batchSize - 1;
      const { data, error: error2, count } = yield supabase.from("strains").select("*", { count: "exact" }).order("name").range(from2, to);
      if (error2) throw error2;
      if (data && data.length > 0) {
        allData = [...allData, ...data];
        if (count && allData.length < count) {
          from2 += batchSize;
        } else {
          hasMoreData = false;
        }
      } else {
        hasMoreData = false;
      }
    }
    return allData;
  }), [supabase]);
  const fetchStrainsFromApi = reactExports.useCallback(() => __async(null, null, function* () {
    let results = [];
    let pageIndex = 1;
    let totalPages = 1;
    while (pageIndex <= totalPages) {
      const res = yield fetch(`${API_BASE}/api/strains?page=${pageIndex}&limit=${FETCH_BATCH_SIZE}`);
      if (!res.ok) {
        throw new Error(`HTTP ${res.status} when fetching strains from API`);
      }
      const payload = yield res.json();
      const pageStrains = Array.isArray(payload == null ? void 0 : payload.strains) ? payload.strains : [];
      results = [...results, ...pageStrains];
      totalPages = (payload == null ? void 0 : payload.pages) || 1;
      if (pageStrains.length === 0) {
        break;
      }
      pageIndex += 1;
    }
    return results;
  }), [API_BASE]);
  const fetchAllStrains = reactExports.useCallback(() => __async(null, null, function* () {
    try {
      setLoading(true);
      console.log(" Fetching ALL strains from database...");
      let allData = [];
      let usedSupabase = false;
      if (supabase) {
        try {
          allData = yield fetchStrainsFromSupabase();
          usedSupabase = allData.length > 0;
          if (usedSupabase) {
            console.log(` Loaded ${allData.length} total strains from Supabase!`);
          } else {
            console.warn("Supabase returned 0 strains, attempting API fallback...");
          }
        } catch (supabaseError) {
          console.error(" Supabase error fetching strains:", supabaseError);
        }
      }
      if (!allData.length) {
        console.log(" Falling back to local API for strain data...");
        allData = yield fetchStrainsFromApi();
        console.log(` Loaded ${allData.length} strains via API fallback`);
      }
      if (!allData.length) {
        throw new Error("No strain data returned from Supabase or API");
      }
      setStrains(allData);
      setAllStrainsLoaded(true);
      setHasMore(false);
    } catch (error2) {
      console.error(" Error fetching strains:", error2);
      setStrains([]);
    } finally {
      setLoading(false);
    }
  }), [fetchStrainsFromApi, fetchStrainsFromSupabase, supabase]);
  reactExports.useEffect(() => {
    fetchAllStrains();
  }, [fetchAllStrains]);
  const sortStrains = reactExports.useCallback((strainsToSort) => {
    const sorted = [...strainsToSort];
    const typeOrder = { "indica": 1, "sativa": 2, "hybrid": 3 };
    switch (sortBy) {
      case "type": {
        return sorted.sort((a, b) => {
          const aType = (a.type || "unknown").toLowerCase();
          const bType = (b.type || "unknown").toLowerCase();
          const aOrder = typeOrder[aType] || 4;
          const bOrder = typeOrder[bType] || 4;
          if (aOrder !== bOrder) return aOrder - bOrder;
          return (a.name || "").localeCompare(b.name || "");
        });
      }
      case "name":
        return sorted.sort((a, b) => (a.name || "").localeCompare(b.name || ""));
      case "thc":
        return sorted.sort((a, b) => (parseFloat(b.thc) || 0) - (parseFloat(a.thc) || 0));
      case "rating":
        return sorted.sort((a, b) => (a.name || "").localeCompare(b.name || ""));
      default:
        return sorted;
    }
  }, [sortBy]);
  const applyThcFilter = reactExports.useCallback((strainsToFilter) => {
    return strainsToFilter.filter((strain) => {
      const thc = parseFloat(strain.thc) || 0;
      return thc >= thcRange[0] && thc <= thcRange[1];
    });
  }, [thcRange]);
  const filterStrains = reactExports.useCallback(() => {
    setShowingFavorites(false);
    let filtered = [...strains];
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      filtered = filtered.filter(
        (s) => {
          var _a2, _b, _c, _d;
          return ((_a2 = s.name) == null ? void 0 : _a2.toLowerCase().includes(query)) || ((_b = s.description) == null ? void 0 : _b.toLowerCase().includes(query)) || ((_c = s.effects) == null ? void 0 : _c.some((e) => e.toLowerCase().includes(query))) || ((_d = s.flavors) == null ? void 0 : _d.some((f) => f.toLowerCase().includes(query)));
        }
      );
    }
    if (typeFilter !== "all") {
      filtered = filtered.filter((s) => {
        var _a2;
        return ((_a2 = s.type) == null ? void 0 : _a2.toLowerCase()) === typeFilter;
      });
    }
    if (showFilters) {
      filtered = applyThcFilter(filtered);
    } else {
      filtered = filtered.filter((s) => {
        var _a2;
        const thcValue = (_a2 = s.thc) != null ? _a2 : 0;
        return thcValue >= thcRange[0] && thcValue <= thcRange[1];
      });
    }
    filtered = sortStrains(filtered);
    setFilteredStrains(filtered);
  }, [strains, searchQuery, typeFilter, showFilters, thcRange, sortStrains, applyThcFilter]);
  reactExports.useEffect(() => {
    filterStrains();
  }, [filterStrains]);
  const visibleStrains = reactExports.useMemo(
    () => Array.isArray(displayedStrains) ? displayedStrains.slice(0, maxToShow) : [],
    [displayedStrains, maxToShow]
  );
  reactExports.useEffect(() => {
    setDisplayedStrains(filteredStrains.slice(0, STRAINS_PER_PAGE));
    setPage(0);
    setHasMore(filteredStrains.length > STRAINS_PER_PAGE);
    setMaxToShow(300);
  }, [filteredStrains]);
  reactExports.useEffect(() => {
    const loadMoreDisplayedStrains = () => {
      const nextPage = page + 1;
      const start2 = nextPage * STRAINS_PER_PAGE;
      const end2 = start2 + STRAINS_PER_PAGE;
      const moreStrains = filteredStrains.slice(start2, end2);
      if (moreStrains.length > 0) {
        setDisplayedStrains((prev2) => [...prev2, ...moreStrains]);
        setPage(nextPage);
      }
      const hasMoreToDisplay = end2 < filteredStrains.length;
      setHasMore(hasMoreToDisplay);
    };
    const currentTarget = observerTarget.current;
    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && hasMore && !loading) {
          loadMoreDisplayedStrains();
        }
      },
      { threshold: 0.1 }
    );
    if (currentTarget) {
      observer.observe(currentTarget);
    }
    return () => {
      if (currentTarget) {
        observer.unobserve(currentTarget);
      }
    };
  }, [hasMore, loading, page, filteredStrains]);
  const handleStrainClick = (strain) => __async(null, null, function* () {
    setSelectedStrain(strain);
    setDetailsOpen(true);
    setDetailsTab(0);
    fetchVendorsForStrain(strain.name);
    fetchDispensariesForStrain();
    fetchReviewsForStrain(strain.slug, strain);
  });
  const fetchVendorsForStrain = (strainName) => __async(null, null, function* () {
    try {
      const apiBase = API_BASE || "http://localhost:5181";
      const response = yield fetch(`${apiBase}/api/seeds-live?strain=${encodeURIComponent(strainName)}&limit=20`);
      const data = yield response.json();
      const transformedVendors = (data.results || []).map((vendor) => ({
        seed_vendors: {
          name: vendor.name,
          website: vendor.website,
          country: vendor.country,
          rating: vendor.rating || 0,
          verified: vendor.verified || false
        },
        price: vendor.price || "N/A",
        seed_count: vendor.seed_count || 10,
        url: vendor.website,
        in_stock: vendor.in_stock !== false
      }));
      setVendors(transformedVendors);
    } catch (error2) {
      console.error("Error fetching vendors:", error2);
      setVendors([]);
    }
  });
  const fetchDispensariesForStrain = () => __async(null, null, function* () {
    try {
      if (!userLocation) {
        setDispensaries([]);
        return;
      }
      const apiBase = API_BASE || "http://localhost:5181";
      const response = yield fetch(
        `${apiBase}/api/dispensaries-live?lat=${userLocation.lat}&lng=${userLocation.lng}&radius=100&limit=20`
      );
      const data = yield response.json();
      const transformedDispensaries = (data.results || []).map((disp) => {
        var _a2, _b, _c, _d;
        return {
          dispensaries: {
            name: disp.name,
            city: disp.city || ((_b = (_a2 = disp.address) == null ? void 0 : _a2.split(",")[1]) == null ? void 0 : _b.trim()) || "Unknown",
            state: disp.state || ((_d = (_c = disp.address) == null ? void 0 : _c.split(",")[2]) == null ? void 0 : _d.trim()) || "",
            rating: disp.rating || 0,
            verified: disp.verified || false,
            website: disp.website || null
          },
          price_per_eighth: disp.price_per_eighth || "N/A",
          price_per_ounce: disp.price_per_ounce || "N/A",
          distance: disp.distance,
          in_stock: true
        };
      });
      setDispensaries(transformedDispensaries);
    } catch (error2) {
      console.error("Error fetching dispensaries:", error2);
      setDispensaries([]);
    }
  });
  const fetchReviewsForStrain = (strainSlug, strainForFallback) => __async(null, null, function* () {
    try {
      if (supabase) {
        const { data, error: error2 } = yield supabase.from("reviews").select("*").eq("strain_slug", strainSlug).order("created_at", { ascending: false }).limit(10);
        if (error2) throw error2;
        if (data && data.length) {
          setReviews(data);
          return;
        }
      }
      const res = yield fetch(`${API_BASE}/api/strains/${strainSlug}/reviews`);
      if (res.ok) {
        const payload = yield res.json().catch(() => ({}));
        const reviewList = Array.isArray(payload == null ? void 0 : payload.reviews) ? payload.reviews : [];
        setReviews(reviewList);
        return;
      }
      throw new Error(`HTTP ${res.status} when fetching reviews`);
    } catch (error2) {
      console.error("Error fetching reviews:", error2);
      const fallbackReviews = strainForFallback == null ? void 0 : strainForFallback.reviews;
      setReviews(Array.isArray(fallbackReviews) ? fallbackReviews : []);
    }
  });
  const getTypeColor = (type) => {
    switch (type == null ? void 0 : type.toLowerCase()) {
      case "indica":
        return "#9c27b0";
      case "sativa":
        return "#ff9800";
      case "hybrid":
        return "#4caf50";
      default:
        return "#757575";
    }
  };
  reactExports.useEffect(() => {
    const savedFavorites = localStorage.getItem("strainFavorites");
    if (savedFavorites) {
      try {
        setFavorites(JSON.parse(savedFavorites));
      } catch (e) {
        console.error("Error loading favorites:", e);
      }
    }
  }, []);
  reactExports.useEffect(() => {
    localStorage.setItem("strainFavorites", JSON.stringify(favorites));
  }, [favorites]);
  const toggleFavorite = (strainSlug) => {
    setFavorites((prev2) => {
      const isFavorite = prev2.includes(strainSlug);
      if (isFavorite) {
        setSnackbar({ open: true, message: "Removed from favorites", severity: "info" });
        return prev2.filter((s) => s !== strainSlug);
      } else {
        setSnackbar({ open: true, message: "Added to favorites! ", severity: "success" });
        return [...prev2, strainSlug];
      }
    });
  };
  const renderDetailsTab = () => {
    var _a2, _b;
    if (!selectedStrain) return null;
    switch (detailsTab) {
      case 0:
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", sx: { color: "#fff", mb: 2 }, children: selectedStrain.description || "No description available" }),
          selectedStrain.effects && selectedStrain.effects.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 2 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", sx: { color: "#7cb342", fontWeight: 700, mb: 1 }, children: "Effects:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { direction: "row", spacing: 1, flexWrap: "wrap", children: selectedStrain.effects.map((effect2, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: effect2, size: "small", sx: { bgcolor: "rgba(124, 179, 66, 0.3)", color: "#fff", mb: 1 } }, idx)) })
          ] }),
          selectedStrain.flavors && selectedStrain.flavors.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 2 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", sx: { color: "#7cb342", fontWeight: 700, mb: 1 }, children: "Flavors:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { direction: "row", spacing: 1, flexWrap: "wrap", children: selectedStrain.flavors.map((flavor, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: flavor, size: "small", sx: { bgcolor: "rgba(255, 152, 0, 0.3)", color: "#fff", mb: 1 } }, idx)) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { container: true, spacing: 2, sx: { mt: 2 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 6, sm: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper, { sx: { p: 2, bgcolor: "rgba(124, 179, 66, 0.15)", borderRadius: 2 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { color: "#e0e0e0" }, children: "Type" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#fff", textTransform: "capitalize" }, children: selectedStrain.type || "Unknown" })
            ] }) }),
            selectedStrain.thc && /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 6, sm: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper, { sx: { p: 2, bgcolor: "rgba(124, 179, 66, 0.2)", borderRadius: 2 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { color: "#e0e0e0" }, children: "THC" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h5", sx: { color: "#7cb342", fontWeight: 700 }, children: [
                selectedStrain.thc,
                "%"
              ] })
            ] }) }),
            selectedStrain.cbd && /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 6, sm: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper, { sx: { p: 2, bgcolor: "rgba(33, 150, 243, 0.2)", borderRadius: 2 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { color: "#e0e0e0" }, children: "CBD" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h5", sx: { color: "#2196f3", fontWeight: 700 }, children: [
                selectedStrain.cbd,
                "%"
              ] })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: selectedStrain.cbd ? 3 : 6, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper, { sx: { p: 2, bgcolor: "rgba(255,255,255,0.08)", borderRadius: 2 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { color: "#e0e0e0" }, children: "Common effects" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#fff" }, children: ((_a2 = selectedStrain.effects) == null ? void 0 : _a2.slice(0, 3).join(", ")) || "" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper, { sx: { p: 2, bgcolor: "rgba(255,255,255,0.08)", borderRadius: 2 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { color: "#e0e0e0" }, children: "Flavors" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#fff" }, children: ((_b = selectedStrain.flavors) == null ? void 0 : _b.slice(0, 3).join(", ")) || "" })
            ] }) })
          ] })
        ] });
      case 1:
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 2, sx: { mb: 3 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button,
            {
              variant: "contained",
              size: "small",
              startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(SearchIcon, {}),
              onClick: () => {
                setShowSeedFinder(true);
                setDetailsOpen(false);
              },
              sx: {
                bgcolor: "rgba(124, 179, 66, 0.3)",
                color: "#fff",
                border: "1px solid rgba(124, 179, 66, 0.6)",
                backdropFilter: "blur(10px)",
                "&:hover": {
                  bgcolor: "rgba(124, 179, 66, 0.5)",
                  border: "1px solid rgba(124, 179, 66, 0.8)"
                }
              },
              children: [
                "Search All Seed Banks for ",
                selectedStrain == null ? void 0 : selectedStrain.name
              ]
            }
          ) }),
          vendors.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, sx: { textAlign: "center", py: 4 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: { color: "#e0e0e0" }, children: "No seed vendors found for this strain" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { color: "#aaa" }, children: "Click the button above to search all seed banks" })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(List$1, { children: vendors.map((v, idx) => {
            var _a3, _b2, _c, _d;
            return /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { sx: { bgcolor: "rgba(255,255,255,0.05)", borderRadius: 2, mb: 2, border: "1px solid rgba(124, 179, 66, 0.3)" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIcon, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(LocalFloristIcon, { sx: { color: "#7cb342" } }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                ListItemText,
                {
                  primary: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, alignItems: "center", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: { color: "#fff", fontWeight: 600 }, children: (_a3 = v.seed_vendors) == null ? void 0 : _a3.name }),
                    ((_b2 = v.seed_vendors) == null ? void 0 : _b2.verified) && /* @__PURE__ */ jsxRuntimeExports.jsx(VerifiedIcon, { sx: { fontSize: 16, color: "#2196f3" } })
                  ] }),
                  secondary: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 0.5, sx: { mt: 1 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#e0e0e0" }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(AttachMoneyIcon, { sx: { fontSize: 14, verticalAlign: "middle", mr: 0.5 } }),
                      "$",
                      v.price,
                      " for ",
                      v.seed_count,
                      " seeds"
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", sx: { color: "#aaa" }, children: [
                      (_c = v.seed_vendors) == null ? void 0 : _c.country,
                      "  Rating: ",
                      (_d = v.seed_vendors) == null ? void 0 : _d.rating,
                      "/5"
                    ] }),
                    v.url && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { size: "small", href: v.url, target: "_blank", sx: { mt: 1, color: "#7cb342" }, children: "Visit Store " })
                  ] })
                }
              )
            ] }, idx);
          }) })
        ] });
      case 2:
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "info", sx: { mb: 2, bgcolor: "rgba(33, 150, 243, 0.1)", color: "#90caf9", border: "1px solid rgba(33, 150, 243, 0.3)" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", children: [
            "Showing dispensaries within 100 miles of your location. Call ahead to confirm ",
            selectedStrain == null ? void 0 : selectedStrain.name,
            " is in stock."
          ] }) }),
          dispensaries.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, sx: { textAlign: "center", py: 4 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: { color: "#e0e0e0" }, children: loadingLocation ? "Detecting your location..." : "No dispensaries found within 100 miles" }),
            userLocation && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", sx: { color: "#aaa" }, children: [
              "Searching near: ",
              userLocation.lat.toFixed(4),
              ", ",
              userLocation.lng.toFixed(4)
            ] })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(List$1, { children: dispensaries.map((d, idx) => {
            var _a3, _b2, _c, _d, _e, _f;
            return /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItem, { sx: { bgcolor: "rgba(255,255,255,0.05)", borderRadius: 2, mb: 2, border: "1px solid rgba(124, 179, 66, 0.3)" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIcon, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(StoreIcon, { sx: { color: "#7cb342" } }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                ListItemText,
                {
                  primary: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, alignItems: "center", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: { color: "#fff", fontWeight: 600 }, children: (_a3 = d.dispensaries) == null ? void 0 : _a3.name }),
                    ((_b2 = d.dispensaries) == null ? void 0 : _b2.verified) && /* @__PURE__ */ jsxRuntimeExports.jsx(VerifiedIcon, { sx: { fontSize: 16, color: "#2196f3" } })
                  ] }),
                  secondary: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 0.5, sx: { mt: 1 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#e0e0e0" }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(LocationOnIcon, { sx: { fontSize: 14, verticalAlign: "middle", mr: 0.5 } }),
                      (_c = d.dispensaries) == null ? void 0 : _c.city,
                      ", ",
                      (_d = d.dispensaries) == null ? void 0 : _d.state,
                      d.distance && /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: `${d.distance.toFixed(1)} mi`, size: "small", sx: { ml: 1, height: 18, fontSize: "0.65rem", bgcolor: "rgba(124, 179, 66, 0.2)", color: "#7cb342" } })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#e0e0e0" }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(AttachMoneyIcon, { sx: { fontSize: 14, verticalAlign: "middle", mr: 0.5 } }),
                      d.price_per_eighth !== "N/A" ? `$${d.price_per_eighth}/eighth` : "Price varies",
                      d.price_per_ounce !== "N/A" && `  $${d.price_per_ounce}/oz`
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", sx: { color: "#aaa" }, children: [
                      "Rating: ",
                      (_e = d.dispensaries) == null ? void 0 : _e.rating,
                      "/5"
                    ] }),
                    ((_f = d.dispensaries) == null ? void 0 : _f.website) && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { size: "small", href: d.dispensaries.website, target: "_blank", sx: { mt: 1, color: "#7cb342" }, children: "Visit Website " })
                  ] })
                }
              )
            ] }, idx);
          }) })
        ] });
      case 3:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: reviews.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: { color: "#e0e0e0", textAlign: "center", py: 4 }, children: "No reviews yet for this strain" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 2, children: reviews.map((review) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper, { sx: { p: 2, bgcolor: "rgba(255,255,255,0.05)", border: "1px solid rgba(124, 179, 66, 0.3)", borderRadius: 2 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "space-between", alignItems: "center", mb: 1, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "subtitle2", sx: { color: "#7cb342", fontWeight: 600 }, children: [
              "Rating: ",
              review.rating,
              "/5"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { color: "#aaa" }, children: new Date(review.created_at).toLocaleDateString() })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#fff" }, children: review.comment })
        ] }, review.id)) }) });
      default:
        return null;
    }
  };
  if (showSeedFinder) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SeedVendorFinder,
      {
        onBack: () => {
          setShowSeedFinder(false);
          setDetailsOpen(true);
        }
      }
    );
  }
  const handleBack = () => {
    if (onBack) {
      onBack();
    } else {
      if (window.history.length > 1) {
        window.history.back();
      }
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        height: "100vh",
        display: "flex",
        flexDirection: "column",
        overflow: "hidden",
        // Important so only the inner area scrolls
        pt: "env(safe-area-inset-top)"
        // Account for iOS safe area
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            sx: {
              flexShrink: 0,
              display: "flex",
              alignItems: "center",
              p: 2,
              gap: 1.5,
              borderBottom: "1px solid rgba(255,255,255,0.08)",
              bgcolor: "rgba(0,0,0,0.7)",
              backdropFilter: "blur(10px)",
              zIndex: 1
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton$1,
                {
                  edge: "start",
                  onClick: handleBack,
                  sx: { color: "#fff" },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowBackIcon, {})
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { fontWeight: 600, color: "#fff", flex: 1 }, children: "Strain Browser" })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            sx: {
              flex: 1,
              minHeight: 0,
              // CRITICAL for flex scrolling
              overflowY: "auto",
              WebkitOverflowScrolling: "touch"
              // iOS momentum scroll
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { maxWidth: "md", sx: { py: 2 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", justifyContent: "center", mb: 3 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Box,
                {
                  sx: {
                    width: { xs: 80, sm: 100 },
                    height: { xs: 80, sm: 100 },
                    borderRadius: "50%",
                    background: "transparent",
                    border: "2px solid rgba(124, 179, 66, 0.5)",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    boxShadow: "0 0 30px rgba(124, 179, 66, 0.5)",
                    overflow: "hidden",
                    animation: "pulse 3s ease-in-out infinite",
                    "@keyframes pulse": {
                      "0%": { boxShadow: "0 0 20px rgba(124, 179, 66, 0.4)" },
                      "50%": { boxShadow: "0 0 40px rgba(124, 179, 66, 0.7)" },
                      "100%": { boxShadow: "0 0 20px rgba(124, 179, 66, 0.4)" }
                    }
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "img",
                    {
                      src: "/hero.png?v=13",
                      alt: "StrainSpotter",
                      style: { width: "100%", height: "100%", objectFit: "cover" }
                    }
                  )
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", justifyContent: "center", spacing: 1, sx: { mb: 2 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { component: "img", src: "/hero.png?v=13", alt: "", sx: { width: 24, height: 24, borderRadius: "50%", filter: "drop-shadow(0 0 4px rgba(124, 179, 66, 0.6))" } }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h5", sx: { color: "#fff", fontWeight: 700 }, children: "Strain Browser" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper, { sx: { p: 2, mb: 2, background: "rgba(255,255,255,0.1)", backdropFilter: "blur(20px)", border: "1px solid rgba(124, 179, 66, 0.3)", borderRadius: 2 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { container: true, spacing: 1.5, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    TextField,
                    {
                      fullWidth: true,
                      size: "small",
                      placeholder: "Search strains by name, effects, flavors...",
                      value: searchQuery,
                      onChange: (e) => setSearchQuery(e.target.value),
                      onKeyPress: (e) => {
                        if (e.key === "Enter") {
                          filterStrains();
                        }
                      },
                      slotProps: {
                        input: {
                          startAdornment: /* @__PURE__ */ jsxRuntimeExports.jsx(InputAdornment, { position: "start", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SearchIcon, { sx: { color: "#7cb342", fontSize: 20 } }) }),
                          endAdornment: searchQuery && /* @__PURE__ */ jsxRuntimeExports.jsx(InputAdornment, { position: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                            IconButton$1,
                            {
                              size: "small",
                              onClick: () => setSearchQuery(""),
                              sx: { color: "#fff", padding: "4px" },
                              children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, { sx: { fontSize: 18 } })
                            }
                          ) }),
                          sx: { color: "#fff", fontSize: "0.875rem", "& .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.5)" }, "&:hover .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.8)" }, "&.Mui-focused .MuiOutlinedInput-notchedOutline": { borderColor: "#7cb342" } }
                        }
                      }
                    }
                  ) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 6, sm: 4, md: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl, { fullWidth: true, size: "small", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, { sx: { color: "#fff", fontSize: "0.875rem" }, children: "Type" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(Select, { value: typeFilter, onChange: (e) => setTypeFilter(e.target.value), label: "Type", sx: { color: "#fff", fontSize: "0.875rem", "& .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.5)" }, "&:hover .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.8)" }, "&.Mui-focused .MuiOutlinedInput-notchedOutline": { borderColor: "#7cb342" } }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "all", children: "All" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "indica", children: "Indica" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "sativa", children: "Sativa" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "hybrid", children: "Hybrid" })
                    ] })
                  ] }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 6, sm: 4, md: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl, { fullWidth: true, size: "small", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, { sx: { color: "#fff", fontSize: "0.875rem" }, children: "Sort" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(Select, { value: sortBy, onChange: (e) => setSortBy(e.target.value), label: "Sort", sx: { color: "#fff", fontSize: "0.875rem", "& .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.5)" }, "&:hover .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.8)" }, "&.Mui-focused .MuiOutlinedInput-notchedOutline": { borderColor: "#7cb342" } }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "type", children: "Type (ISH)" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "name", children: "Name" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "thc", children: "THC %" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "rating", children: "Rating" })
                    ] })
                  ] }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 4, md: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      fullWidth: true,
                      size: "small",
                      variant: showFilters ? "contained" : "outlined",
                      onClick: () => setShowFilters(!showFilters),
                      startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(FilterListIcon, { fontSize: "small" }),
                      sx: {
                        color: showFilters ? "#000" : "#fff",
                        bgcolor: showFilters ? "#7cb342" : "transparent",
                        borderColor: "rgba(124, 179, 66, 0.6)",
                        fontSize: "0.875rem",
                        "&:hover": {
                          borderColor: "rgba(124, 179, 66, 1)",
                          bgcolor: showFilters ? "#7cb342" : "rgba(124, 179, 66, 0.1)"
                        }
                      },
                      children: "Filters"
                    }
                  ) })
                ] }),
                showFilters && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mt: 3, p: 2, background: "rgba(124, 179, 66, 0.1)", borderRadius: 2, border: "1px solid rgba(124, 179, 66, 0.3)" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", sx: { color: "#7cb342", fontWeight: 700, mb: 2 }, children: "Advanced Filters" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { px: 2 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#fff", mb: 1 }, children: [
                      "THC Range: ",
                      thcRange[0],
                      "% - ",
                      thcRange[1],
                      "%"
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Slider,
                      {
                        value: thcRange,
                        onChange: (e, newValue) => setThcRange(newValue),
                        valueLabelDisplay: "auto",
                        min: 0,
                        max: 35,
                        sx: {
                          color: "#7cb342",
                          "& .MuiSlider-thumb": {
                            bgcolor: "#7cb342"
                          },
                          "& .MuiSlider-track": {
                            bgcolor: "#7cb342"
                          },
                          "& .MuiSlider-rail": {
                            bgcolor: "rgba(124, 179, 66, 0.3)"
                          }
                        }
                      }
                    )
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "space-between", alignItems: "center", mt: 2, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { color: "#e0e0e0", fontSize: "0.8rem" }, children: loading ? "Loading strains..." : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                    "Showing ",
                    displayedStrains.length,
                    " of ",
                    filteredStrains.length,
                    " strains",
                    filteredStrains.length < strains.length && ` (filtered from ${strains.length} total)`,
                    !allStrainsLoaded && " - Loading all strains..."
                  ] }) }),
                  showingFavorites && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      size: "small",
                      variant: "text",
                      onClick: () => {
                        setShowingFavorites(false);
                        filterStrains();
                      },
                      sx: { color: "#7cb342" },
                      children: "Show all strains"
                    }
                  ),
                  favorites.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "View favorites", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Chip,
                    {
                      size: "small",
                      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FavoriteIcon, { sx: { fontSize: 16 } }),
                      label: `${favorites.length}`,
                      onClick: () => {
                        if (favorites.length === 0) {
                          setSnackbar({ open: true, message: "No favorites yet. Tap the heart on any strain to save it.", severity: "warning" });
                          return;
                        }
                        setSearchQuery("");
                        setTypeFilter("all");
                        const favStrains = strains.filter((s) => favorites.includes(s.slug));
                        setFilteredStrains(favStrains);
                        setDisplayedStrains(favStrains.slice(0, STRAINS_PER_PAGE));
                        setHasMore(false);
                        setShowingFavorites(true);
                        setSnackbar({ open: true, message: "Showing favorites only", severity: "info" });
                      },
                      sx: {
                        bgcolor: "rgba(255, 64, 129, 0.2)",
                        color: "#ff4081",
                        cursor: "pointer",
                        fontSize: "0.75rem",
                        height: 24,
                        "&:hover": { bgcolor: "rgba(255, 64, 129, 0.3)" }
                      }
                    }
                  ) })
                ] })
              ] }),
              !loading && favorites.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mb: 3 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                EmptyStateCard,
                {
                  title: "No favorites yet",
                  description: "Tap the heart icon on any strain to pin it here for quick access.",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FavoriteBorderIcon, { sx: { fontSize: 48, color: "#ff4081" } })
                }
              ) }),
              loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", justifyContent: "center", py: 8 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { sx: { color: "#7cb342" } }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 1, children: visibleStrains.map((strain) => {
                  const indicaPercent = strain.type === "indica" ? 100 : strain.type === "sativa" ? 0 : 50;
                  const sativaPercent = 100 - indicaPercent;
                  const typeColor = strain.type === "indica" ? "#7b1fa2" : strain.type === "sativa" ? "#f57c00" : "#00897b";
                  const strainNumber = filteredStrains.findIndex((s) => s.slug === strain.slug) + 1;
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Paper,
                    {
                      onClick: () => handleStrainClick(strain),
                      sx: {
                        p: 1.5,
                        cursor: "pointer",
                        background: "rgba(255,255,255,0.1)",
                        backdropFilter: "blur(20px)",
                        border: `2px solid ${typeColor}40`,
                        borderRadius: 2,
                        transition: "all 0.2s ease",
                        "&:hover": {
                          transform: "translateX(4px)",
                          border: `2px solid ${typeColor}`,
                          boxShadow: `0 4px 16px ${typeColor}40`
                        }
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          Box,
                          {
                            sx: {
                              width: "100%",
                              aspectRatio: "16/9",
                              overflow: "hidden",
                              borderRadius: 1,
                              mb: 1,
                              bgcolor: "rgba(0,0,0,0.2)",
                              display: "flex",
                              alignItems: "center",
                              justifyContent: "center",
                              minHeight: 120,
                              position: "relative"
                            },
                            children: [
                              (() => {
                                const imageUrl = getStrainImageUrl(strain);
                                return imageUrl ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                                  Box,
                                  {
                                    component: "img",
                                    src: imageUrl,
                                    alt: strain.name || "Strain photo",
                                    loading: "lazy",
                                    sx: {
                                      width: "100%",
                                      height: "100%",
                                      objectFit: "cover",
                                      display: "block",
                                      background: "#111"
                                    },
                                    onError: (e) => {
                                      var _a2;
                                      e.currentTarget.style.display = "none";
                                      const placeholder = (_a2 = e.currentTarget.parentElement) == null ? void 0 : _a2.querySelector(".strain-placeholder");
                                      if (placeholder) {
                                        placeholder.style.display = "flex";
                                      }
                                    }
                                  }
                                ) : null;
                              })(),
                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                Box,
                                {
                                  className: "strain-placeholder",
                                  sx: {
                                    display: getStrainImageUrl(strain) ? "none" : "flex",
                                    alignItems: "center",
                                    justifyContent: "center",
                                    width: "100%",
                                    height: "100%",
                                    position: "absolute",
                                    top: 0,
                                    left: 0,
                                    background: "linear-gradient(135deg, rgba(124, 179, 66, 0.15) 0%, rgba(0, 0, 0, 0.4) 100%)",
                                    border: "1px solid rgba(124, 179, 66, 0.2)"
                                  },
                                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                                    Typography,
                                    {
                                      variant: "caption",
                                      sx: {
                                        color: "rgba(200, 230, 201, 0.6)",
                                        fontSize: 11,
                                        textAlign: "center",
                                        px: 2,
                                        fontWeight: 500
                                      },
                                      children: "No strain photo yet"
                                    }
                                  )
                                }
                              )
                            ]
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 1, children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", sx: {
                            color: "#7cb342",
                            fontWeight: 700,
                            fontSize: "0.7rem",
                            minWidth: 32,
                            textAlign: "right",
                            opacity: 0.7
                          }, children: [
                            "#",
                            strainNumber
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            IconButton$1,
                            {
                              size: "small",
                              onClick: (e) => {
                                e.stopPropagation();
                                toggleFavorite(strain.slug);
                              },
                              sx: {
                                color: favorites.includes(strain.slug) ? "#ff4081" : "#666",
                                padding: "2px",
                                "&:hover": {
                                  color: "#ff4081",
                                  transform: "scale(1.2)"
                                }
                              },
                              children: favorites.includes(strain.slug) ? /* @__PURE__ */ jsxRuntimeExports.jsx(FavoriteIcon, { sx: { fontSize: 18 } }) : /* @__PURE__ */ jsxRuntimeExports.jsx(FavoriteBorderIcon, { sx: { fontSize: 18 } })
                            }
                          ),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", sx: {
                            color: "#fff",
                            fontWeight: 700,
                            flex: 1,
                            fontSize: "0.85rem",
                            overflow: "hidden",
                            textOverflow: "ellipsis",
                            whiteSpace: "nowrap"
                          }, children: strain.name }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 0.3, sx: { minWidth: 55, flexShrink: 0 }, children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", sx: { color: "#7b1fa2", fontWeight: 600, fontSize: "0.65rem" }, children: [
                              "I",
                              indicaPercent
                            ] }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { color: "#666", fontSize: "0.65rem" }, children: "|" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", sx: { color: "#f57c00", fontWeight: 600, fontSize: "0.65rem" }, children: [
                              "S",
                              sativaPercent
                            ] })
                          ] }),
                          strain.thc && /* @__PURE__ */ jsxRuntimeExports.jsx(
                            Chip,
                            {
                              label: `${strain.thc}%`,
                              size: "small",
                              sx: {
                                bgcolor: "#7cb342",
                                color: "#fff",
                                fontWeight: 700,
                                fontSize: "0.65rem",
                                height: 20,
                                minWidth: 40,
                                flexShrink: 0,
                                "& .MuiChip-label": { px: 0.5 }
                              }
                            }
                          ),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            Chip,
                            {
                              label: strain.type || "Unk",
                              size: "small",
                              sx: {
                                bgcolor: typeColor,
                                color: "#fff",
                                fontWeight: 700,
                                fontSize: "0.65rem",
                                height: 20,
                                minWidth: 45,
                                flexShrink: 0,
                                textTransform: "capitalize",
                                "& .MuiChip-label": { px: 0.5 }
                              }
                            }
                          )
                        ] })
                      ]
                    },
                    strain.slug
                  );
                }) }),
                Array.isArray(displayedStrains) && displayedStrains.length > maxToShow && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { textAlign: "center", padding: "16px 0" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "button",
                    onClick: () => setMaxToShow((prev2) => prev2 + 300),
                    variant: "contained",
                    sx: {
                      padding: "10px 18px",
                      borderRadius: 999,
                      fontWeight: 600,
                      fontSize: 14,
                      bgcolor: "#7cb342",
                      "&:hover": { bgcolor: "#689f38" }
                    },
                    children: "Load 300 more strains"
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { ref: observerTarget, sx: { py: 4, display: "flex", flexDirection: "column", alignItems: "center", gap: 2 }, children: [
                  hasMore && displayedStrains.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 30, sx: { color: "#7cb342" } }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#7cb342", fontWeight: 600 }, children: "Loading more strains..." })
                  ] }),
                  !hasMore && displayedStrains.length > 0 && displayedStrains.length === filteredStrains.length && /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 1, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#e0e0e0" }, children: [
                      "All ",
                      filteredStrains.length,
                      " strains displayed!"
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { component: "img", src: "/hero.png?v=13", alt: "", sx: { width: 16, height: 16, borderRadius: "50%", filter: "drop-shadow(0 0 4px rgba(124, 179, 66, 0.6))" } })
                  ] })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Dialog,
                {
                  open: detailsOpen,
                  onClose: () => setDetailsOpen(false),
                  maxWidth: "md",
                  fullWidth: true,
                  fullScreen: true,
                  slotProps: {
                    paper: {
                      sx: {
                        background: "linear-gradient(135deg, rgba(30, 30, 30, 0.98) 0%, rgba(20, 20, 20, 0.98) 100%)",
                        backdropFilter: "blur(20px)",
                        border: "2px solid rgba(124, 179, 66, 0.3)",
                        borderRadius: { xs: 0, sm: 4 },
                        m: 0,
                        maxHeight: "100vh"
                      }
                    }
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { sx: {
                      color: "#fff",
                      fontWeight: 700,
                      borderBottom: "1px solid rgba(124, 179, 66, 0.3)",
                      pt: "calc(env(safe-area-inset-top) + 16px)"
                    }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "space-between", alignItems: "center", spacing: 2, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { flex: 1 }, children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h5", sx: { fontWeight: 700, fontSize: { xs: "1.25rem", sm: "1.5rem" } }, children: selectedStrain == null ? void 0 : selectedStrain.name }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: (selectedStrain == null ? void 0 : selectedStrain.type) || "Unknown", size: "small", sx: { bgcolor: getTypeColor(selectedStrain == null ? void 0 : selectedStrain.type), color: "#fff", fontWeight: 600, mt: 1 } })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, alignItems: "center", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          Button,
                          {
                            size: "small",
                            variant: "contained",
                            startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(NoteAltIcon, {}),
                            onClick: () => handleLogExperience(selectedStrain),
                            children: "Log experience"
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          Button,
                          {
                            size: "small",
                            variant: "outlined",
                            startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(LibraryBooksIcon, {}),
                            onClick: () => {
                              setDetailsOpen(false);
                              window.dispatchEvent(new CustomEvent("nav:set-view", { detail: "grow-coach" }));
                            },
                            sx: { color: "#fff", borderColor: "rgba(255,255,255,0.3)" },
                            children: "Grow log"
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: () => setDetailsOpen(false), sx: { color: "#fff" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {}) })
                      ] })
                    ] }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { sx: { pt: 2 }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(Tabs, { value: detailsTab, onChange: (e, v) => setDetailsTab(v), sx: { borderBottom: "1px solid rgba(124, 179, 66, 0.3)", mb: 3 }, children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { label: "Overview", sx: { color: "#fff", "&.Mui-selected": { color: "#7cb342" } } }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { label: `Seed Vendors (${vendors.length})`, sx: { color: "#fff", "&.Mui-selected": { color: "#7cb342" } } }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { label: `Dispensaries (${dispensaries.length})`, sx: { color: "#fff", "&.Mui-selected": { color: "#7cb342" } } }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { label: `Reviews (${reviews.length})`, sx: { color: "#fff", "&.Mui-selected": { color: "#7cb342" } } })
                      ] }),
                      renderDetailsTab()
                    ] })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Snackbar,
                {
                  open: snackbar.open,
                  autoHideDuration: 3e3,
                  onClose: () => setSnackbar(__spreadProps(__spreadValues({}, snackbar), { open: false })),
                  anchorOrigin: { vertical: "bottom", horizontal: "center" },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Alert,
                    {
                      onClose: () => setSnackbar(__spreadProps(__spreadValues({}, snackbar), { open: false })),
                      severity: snackbar.severity,
                      sx: { width: "100%" },
                      children: snackbar.message
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                JournalDialog,
                {
                  open: journalDialogOpen,
                  defaults: journalDefaults,
                  onClose: () => setJournalDialogOpen(false),
                  onSaved: () => {
                    setJournalDialogOpen(false);
                    setSnackbar({ open: true, message: "Journal entry saved.", severity: "success" });
                  }
                }
              )
            ] })
          }
        )
      ]
    }
  );
}
function MembershipJoin() {
  const [strainStats, setStrainStats] = reactExports.useState({ count: null, lastUpdated: null });
  reactExports.useEffect(() => {
    (() => __async(null, null, function* () {
      try {
        const [countRes, updatedRes] = yield Promise.all([
          fetch(`${API_BASE}/api/strains/count`),
          fetch(`${API_BASE}/api/strains/last-updated`)
        ]);
        const countData = yield countRes.json();
        const updatedData = yield updatedRes.json();
        setStrainStats({
          count: countData.count,
          lastUpdated: updatedData.lastUpdated ? new Date(updatedData.lastUpdated) : null
        });
      } catch (e) {
      }
    }))();
  }, []);
  const [showLogin, setShowLogin] = reactExports.useState(false);
  const [loginEmail, setLoginEmail] = reactExports.useState("");
  const [loginPassword, setLoginPassword] = reactExports.useState("");
  const [loginError, setLoginError] = reactExports.useState(null);
  const [user, setUser] = reactExports.useState(null);
  const [status, setStatus] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(true);
  const [applying, setApplying] = reactExports.useState(false);
  const [showForm, setShowForm] = reactExports.useState(false);
  const [formData, setFormData] = reactExports.useState({
    email: "",
    full_name: "",
    phone: "",
    message: ""
  });
  const [error2, setError] = reactExports.useState(null);
  const [success, setSuccess] = reactExports.useState(null);
  const [pricingPackages, setPricingPackages] = reactExports.useState([]);
  const [pricingRole, setPricingRole] = reactExports.useState(null);
  const [pricingLoading, setPricingLoading] = reactExports.useState(true);
  const [pricingError, setPricingError] = reactExports.useState(null);
  const getSessionId = reactExports.useCallback(() => {
    let sid = localStorage.getItem("ss-session-id");
    if (!sid) {
      sid = `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      localStorage.setItem("ss-session-id", sid);
    }
    return sid;
  }, []);
  const loadStatus = reactExports.useCallback(() => __async(null, null, function* () {
    try {
      const res = yield fetch(`${API_BASE}/api/membership/status`, {
        headers: { "x-session-id": getSessionId() }
      });
      if (res.ok) {
        setStatus(yield res.json());
      }
    } catch (e) {
      console.error("Failed to load status:", e);
    } finally {
      setLoading(false);
    }
  }), [getSessionId]);
  reactExports.useEffect(() => {
    loadStatus();
  }, [loadStatus]);
  reactExports.useEffect(() => {
    (() => __async(null, null, function* () {
      try {
        const res = yield fetch(`${API_BASE}/api/credits/packages`);
        const data = yield res.json();
        if (!res.ok || !data.success) {
          throw new Error(data.error || "Unable to load pricing");
        }
        setPricingPackages(Array.isArray(data.packages) ? data.packages : []);
        setPricingRole(data.role || null);
      } catch (e) {
        console.error("Pricing load error:", e);
        setPricingError(e.message || "Failed to load pricing");
      } finally {
        setPricingLoading(false);
      }
    }))();
  }, []);
  const handleLogin = () => __async(null, null, function* () {
    setLoginError(null);
    if (!loginEmail || !loginPassword) {
      setLoginError("Please enter both email and password.");
      return;
    }
    try {
      const { error: error22 } = yield supabase.auth.signInWithPassword({ email: loginEmail, password: loginPassword });
      if (error22) {
        setLoginError(error22.message);
        return;
      }
      setShowLogin(false);
    } catch (error22) {
      console.error("Supabase login failed:", error22);
      setLoginError("Login failed. Please try again.");
    }
  });
  reactExports.useEffect(() => {
    let listener;
    const getSession = () => __async(null, null, function* () {
      var _a2, _b, _c, _d;
      const sessionObj = yield (_b = (_a2 = supabase.auth).getSession) == null ? void 0 : _b.call(_a2);
      if ((_d = (_c = sessionObj == null ? void 0 : sessionObj.data) == null ? void 0 : _c.session) == null ? void 0 : _d.user) setUser(sessionObj.data.session.user);
    });
    getSession();
    listener = supabase.auth.onAuthStateChange((_event, session) => {
      setUser((session == null ? void 0 : session.user) || null);
    });
    return () => {
      var _a2;
      ((_a2 = listener == null ? void 0 : listener.data) == null ? void 0 : _a2.unsubscribe) && listener.data.unsubscribe();
    };
  }, []);
  if (user) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { maxWidth: "md", sx: { py: 4 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          onClick: () => window.location.href = "/",
          variant: "contained",
          sx: { position: "absolute", top: 16, left: 16, bgcolor: "#388e3c", color: "white", fontWeight: 700, borderRadius: 999, boxShadow: "0 2px 8px 0 rgba(46,125,50,0.18)", zIndex: 10, textTransform: "none", px: 3, py: 1 },
          children: "Home"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mt: 8, textAlign: "center" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h4", sx: { fontWeight: 700, color: "#2e7d32", mb: 2 }, children: [
          "Welcome, ",
          user.email,
          "!"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", sx: { color: "#388e3c", mb: 2 }, children: "You are now logged in and have full access to all features." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "contained", color: "error", sx: { borderRadius: 999, px: 4, py: 1, fontWeight: 600 }, onClick: () => __async(null, null, function* () {
          yield supabase.auth.signOut();
          setUser(null);
        }), children: "Logout" })
      ] })
    ] });
  }
  const handleSubmit = (e) => __async(null, null, function* () {
    e.preventDefault();
    setError(null);
    setSuccess(null);
    setApplying(true);
    try {
      const res = yield fetch(`${API_BASE}/api/membership/apply`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData)
      });
      const data = yield res.json();
      if (!res.ok) {
        setError(data.error || "Application failed");
        return;
      }
      setSuccess("Application submitted! We will review and be in touch via email within 24-48 hours. Thank you!");
      setShowForm(false);
      setFormData({ email: "", full_name: "", phone: "", message: "" });
    } catch (e2) {
      console.error("Membership apply error:", e2);
      setError("Network error. Please check your connection and try again.");
    } finally {
      setApplying(false);
    }
  });
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { maxWidth: "md", sx: { py: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(LinearProgress, {}) });
  }
  const appUnlockPackage = pricingPackages.find((pkg) => pkg.type === "app_purchase");
  const membershipPackage = pricingPackages.find((pkg) => pkg.type === "membership");
  const topUpPackages = pricingPackages.filter((pkg) => pkg.type === "top_up");
  const priceLabel = (pkg) => pkg ? `$${pkg.effectivePrice.toFixed(2)}` : "";
  const perScanLabel = (pkg) => {
    if (!(pkg == null ? void 0 : pkg.credits)) return "";
    const cost = pkg.effectivePrice / pkg.credits;
    if (cost < 1) return `${(cost * 100).toFixed(1)} per scan`;
    return `$${cost.toFixed(2)} per scan`;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { maxWidth: "md", sx: { py: 4, position: "relative" }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        onClick: () => window.location.href = "/",
        variant: "contained",
        sx: {
          position: "absolute",
          top: 16,
          left: 16,
          bgcolor: "#388e3c",
          color: "white",
          fontWeight: 700,
          borderRadius: 999,
          boxShadow: "0 2px 8px 0 rgba(46,125,50,0.18)",
          zIndex: 10,
          textTransform: "none",
          px: 3,
          py: 1
        },
        children: "Home"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 2, display: "flex", justifyContent: "center", alignItems: "center", flexDirection: "column", opacity: 0.95 }, children: [
      strainStats.count !== null && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { fontWeight: 600, color: "#388e3c", textAlign: "center", fontSize: "1rem", mb: 0.5 }, children: [
        "Over ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontWeight: 800 }, children: strainStats.count.toLocaleString() }),
        " strains in our database"
      ] }),
      strainStats.lastUpdated && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", sx: { color: "#388e3c", textAlign: "center" }, children: [
        "Updated ",
        strainStats.lastUpdated.toLocaleDateString(void 0, { month: "short", day: "numeric", year: "numeric" })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", sx: { mb: 3, fontWeight: 700, color: "#2e7d32", textShadow: "0 2px 12px rgba(46,125,50,0.2)" }, children: "Welcome to StrainSpotter Membership" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { mb: 3, borderRadius: 3, background: "rgba(255,255,255,0.08)", border: "1px solid rgba(56,142,60,0.18)", backdropFilter: "blur(8px)" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#388e3c", mb: 1 }, children: "Simple Pricing" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", sx: { mb: 2 }, children: "One-time unlock for the first 20 scans, then $4.99/month for 200 scans + optional top-ups (50 / 200 / 500)." }),
      pricingLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LinearProgress, {}) : pricingError ? /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "warning", children: pricingError }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: { xs: "column", sm: "row" }, spacing: 2, sx: { mb: 2 }, children: [
          appUnlockPackage && /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { variant: "outlined", sx: { flex: 1, borderColor: "rgba(56,142,60,0.25)" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", color: "text.secondary", children: "Step 1" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#2e7d32", mb: 1 }, children: "Unlock the App" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", sx: { fontWeight: 700, color: "#1b5e20" }, children: priceLabel(appUnlockPackage) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "20 scans included. Unlock Groups, Grow Coach, and The Garden forever." })
          ] }) }),
          membershipPackage && /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { variant: "outlined", sx: { flex: 1, borderColor: "rgba(56,142,60,0.25)" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", color: "text.secondary", children: "Step 2" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#2e7d32", mb: 1 }, children: "Monthly Member" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h4", sx: { fontWeight: 700, color: "#1b5e20" }, children: [
              priceLabel(membershipPackage),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { component: "span", variant: "body2", color: "text.secondary", children: "/month" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "200 AI scans each month + priority support. Cancel anytime." }),
            pricingRole === "moderator" && membershipPackage.moderatorDiscount && /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: `${membershipPackage.moderatorDiscount.percent}% moderator discount`, size: "small", color: "success", sx: { mt: 1 } })
          ] }) })
        ] }),
        topUpPackages.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 1, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", color: "text.secondary", children: "Need more scans?" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { direction: { xs: "column", sm: "row" }, spacing: 1, children: topUpPackages.map((pkg) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            Chip,
            {
              label: `${pkg.credits} scans  ${priceLabel(pkg)}  ${perScanLabel(pkg)}`,
              variant: "outlined",
              sx: { borderColor: "rgba(56,142,60,0.4)" }
            },
            pkg.id
          )) })
        ] })
      ] })
    ] }) }),
    (status == null ? void 0 : status.isMember) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
      mt: 3,
      p: 4,
      borderRadius: 4,
      background: "rgba(255,255,255,0.15)",
      boxShadow: "0 8px 32px 0 rgba(46,125,50,0.25)",
      backdropFilter: "blur(12px)",
      border: "1px solid rgba(56,142,60,0.25)",
      color: "#2e7d32",
      fontWeight: 600
    }, children: "You're an active member! Enjoy unlimited access to all features." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: {
      mb: 3,
      borderRadius: 4,
      background: "rgba(255,255,255,0.10)",
      boxShadow: "0 8px 32px 0 rgba(46,125,50,0.18)",
      backdropFilter: "blur(10px)",
      border: "1px solid rgba(56,142,60,0.18)",
      color: "#388e3c"
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { mb: 2, color: "#388e3c" }, children: "Basic Access" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
        background: "rgba(255,255,255,0.10)",
        borderRadius: 2,
        p: 2,
        color: "#388e3c",
        fontWeight: 500,
        boxShadow: "0 2px 8px 0 rgba(46,125,50,0.10)",
        border: "1px solid rgba(56,142,60,0.10)"
      }, children: [
        "You have access to the scanner and results.",
        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Unlock Full Access:" }),
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { style: { margin: "8px 0 0 16px", color: "#388e3c" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Sign up for membership to enjoy exclusive strain data, grow guides, chat/groups, dispensary/grower access, and more." }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "contained", sx: { mt: 2, bgcolor: "#388e3c", color: "white", fontWeight: 700, borderRadius: 2, boxShadow: "0 2px 8px 0 rgba(46,125,50,0.18)" }, onClick: () => setShowForm(true), children: "Join Now" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outlined", sx: { mt: 2, ml: 2, borderRadius: 2, fontWeight: 700 }, onClick: () => setShowLogin(true), children: "Login to Unlock Full Access" })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: showLogin, onClose: () => setShowLogin(false), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: "Login" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, sx: { pt: 1 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "contained", color: "primary", sx: { borderRadius: 999, px: 4, py: 1, fontWeight: 600 }, onClick: () => __async(null, null, function* () {
          const { error: error22 } = yield supabase.auth.signInWithOAuth({ provider: "google" });
          if (error22) setLoginError("Google login failed: " + error22.message);
        }), children: "Login with Google" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "contained", color: "secondary", sx: { borderRadius: 999, px: 4, py: 1, fontWeight: 600 }, onClick: () => __async(null, null, function* () {
          const { error: error22 } = yield supabase.auth.signInWithOAuth({ provider: "apple" });
          if (error22) setLoginError("Apple login failed: " + error22.message);
        }), children: "Login with Apple" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: (e) => {
          e.preventDefault();
          handleLogin();
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextField,
            {
              label: "Email",
              type: "email",
              value: loginEmail,
              onChange: (e) => setLoginEmail(e.target.value),
              fullWidth: true,
              autoFocus: true,
              sx: { mt: 1 },
              required: true
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextField,
            {
              label: "Password",
              type: "password",
              value: loginPassword,
              onChange: (e) => setLoginPassword(e.target.value),
              fullWidth: true,
              sx: { mt: 2 },
              required: true
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "submit", variant: "outlined", sx: { mt: 2, borderRadius: 999, px: 3, py: 1, fontWeight: 600 }, children: "Login with Email" })
        ] }),
        loginError && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mt: 2 }, children: loginError })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActions, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => setShowLogin(false), children: "Cancel" }) })
    ] }),
    error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mt: 2 }, onClose: () => setError(null), children: error2 }),
    success && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "success", sx: { mt: 2 }, onClose: () => setSuccess(null), children: success }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: showForm, onClose: () => setShowForm(false), maxWidth: "sm", fullWidth: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: "Membership Application" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, sx: { pt: 1 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: "Email",
            type: "email",
            required: true,
            fullWidth: true,
            value: formData.email,
            onChange: (e) => setFormData(__spreadProps(__spreadValues({}, formData), { email: e.target.value }))
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: "Full Name",
            required: true,
            fullWidth: true,
            value: formData.full_name,
            onChange: (e) => setFormData(__spreadProps(__spreadValues({}, formData), { full_name: e.target.value }))
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: "Phone (optional)",
            fullWidth: true,
            value: formData.phone,
            onChange: (e) => setFormData(__spreadProps(__spreadValues({}, formData), { phone: e.target.value }))
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: "Message (optional)",
            multiline: true,
            rows: 3,
            fullWidth: true,
            value: formData.message,
            onChange: (e) => setFormData(__spreadProps(__spreadValues({}, formData), { message: e.target.value })),
            placeholder: "Tell us why you want to join..."
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "info", children: "After submitting, our team will review your application and contact you with payment instructions." })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => setShowForm(false), disabled: applying, children: "Cancel" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "submit", variant: "contained", disabled: applying, children: applying ? "Submitting..." : "Submit Application" })
      ] })
    ] }) })
  ] });
}
const stageOptions = [
  "Planning",
  "Germination",
  "Seedling",
  "Vegetative",
  "Early Flower",
  "Mid Flower",
  "Late Flower",
  "Flush",
  "Harvest",
  "Dry & Cure",
  "Maintenance"
];
const initialForm = () => ({
  runLabel: "",
  strainSlug: "",
  stage: "Vegetative",
  day: "",
  entryDate: (/* @__PURE__ */ new Date()).toISOString().slice(0, 10),
  notes: "",
  highlight: "",
  healthIssues: "",
  remedies: "",
  nextActions: "",
  tasksCompleted: "",
  nutrientsUsed: "",
  medium: "",
  waterVolume: "",
  environmentNotes: "",
  aiPrompt: "",
  imageUrls: "",
  metrics: {
    temperature: "",
    humidity: "",
    vpd: "",
    ec: "",
    ph: "",
    co2: "",
    height: ""
  },
  shareEnabled: true,
  shareMessage: "",
  shareTags: "#StrainSpotter #GrowLog",
  vigor: "Thriving",
  pestCheck: "No pests detected"
});
const parseList = (value) => value.split(",").map((item) => item.trim()).filter(Boolean);
const buildShareSummary = (log) => {
  var _a2, _b, _c, _d, _e;
  const progress = log.progress || {};
  const environment = progress.metrics || {};
  const share = progress.share || {};
  const lines = [
    `Grow Update  ${progress.run_label || "Untitled Run"}`,
    progress.day ? `Day ${progress.day}` : null,
    log.stage ? `Stage: ${log.stage}` : null,
    log.strain_slug ? `Strain: ${log.strain_slug}` : null,
    environment.temperature || environment.humidity || environment.ec || environment.ph ? `Vitals  Temp: ${environment.temperature || ""} | RH: ${environment.humidity || ""} | EC: ${environment.ec || ""} | pH: ${environment.ph || ""}` : null,
    log.notes ? `Highlights: ${log.notes}` : null,
    ((_a2 = progress.tasks_completed) == null ? void 0 : _a2.length) ? `Tasks: ${progress.tasks_completed.join(", ")}` : null,
    ((_b = progress.next_actions) == null ? void 0 : _b.length) ? `Next: ${progress.next_actions.join(", ")}` : null,
    ((_d = (_c = log.health_status) == null ? void 0 : _c.issues) == null ? void 0 : _d.length) ? `Watch: ${log.health_status.issues.join(", ")}` : null,
    ((_e = share.tags) == null ? void 0 : _e.length) ? `Tags: ${share.tags.map((tag) => tag.startsWith("#") ? tag : `#${tag}`).join(" ")}` : null
  ].filter(Boolean);
  if (share.summary) {
    return share.summary;
  }
  return lines.join("\n");
};
function GrowLogBook() {
  const [form, setForm] = reactExports.useState(() => initialForm());
  const [logs, setLogs] = reactExports.useState([]);
  const [user, setUser] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(true);
  const [saving, setSaving] = reactExports.useState(false);
  const [error2, setError] = reactExports.useState(null);
  const [snackbar, setSnackbar] = reactExports.useState({ open: false, message: "" });
  const loadUserAndLogs = reactExports.useCallback(() => __async(null, null, function* () {
    var _a2;
    setLoading(true);
    setError(null);
    try {
      const { data } = yield supabase.auth.getSession();
      const sessionUser = ((_a2 = data == null ? void 0 : data.session) == null ? void 0 : _a2.user) || null;
      setUser(sessionUser);
      if (!(sessionUser == null ? void 0 : sessionUser.id)) {
        setLogs([]);
        setLoading(false);
        return;
      }
      const resp = yield fetch(`${API_BASE}/api/growlogs?user_id=${sessionUser.id}`);
      if (!resp.ok) {
        const body2 = yield resp.json().catch(() => ({}));
        throw new Error(body2.error || "Failed to load grow logs.");
      }
      const dataLogs = yield resp.json();
      setLogs(Array.isArray(dataLogs) ? dataLogs : []);
    } catch (err) {
      console.error("[grow-logbook] load failed", err);
      setError(err.message || "Unable to load grow logs.");
    } finally {
      setLoading(false);
    }
  }), []);
  reactExports.useEffect(() => {
    loadUserAndLogs();
  }, [loadUserAndLogs]);
  const groupedLogs = reactExports.useMemo(() => {
    const groups = /* @__PURE__ */ new Map();
    logs.forEach((log) => {
      var _a2;
      const label = ((_a2 = log.progress) == null ? void 0 : _a2.run_label) || "Unlabeled Run";
      if (!groups.has(label)) {
        groups.set(label, []);
      }
      groups.get(label).push(log);
    });
    return Array.from(groups.entries()).map(([label, items]) => ({
      label,
      items: items.sort((a, b) => {
        var _a2, _b;
        const dateA = new Date(((_a2 = a.progress) == null ? void 0 : _a2.entry_date) || a.created_at || 0).getTime();
        const dateB = new Date(((_b = b.progress) == null ? void 0 : _b.entry_date) || b.created_at || 0).getTime();
        return dateB - dateA;
      })
    }));
  }, [logs]);
  const handleFormChange = (field) => (event) => {
    const value = event.target.value;
    if (field.startsWith("metrics.")) {
      const key = field.split(".")[1];
      setForm((prev2) => __spreadProps(__spreadValues({}, prev2), {
        metrics: __spreadProps(__spreadValues({}, prev2.metrics), {
          [key]: value
        })
      }));
      return;
    }
    setForm((prev2) => __spreadProps(__spreadValues({}, prev2), {
      [field]: value
    }));
  };
  const handleToggleShare = (_event, checked) => {
    setForm((prev2) => __spreadProps(__spreadValues({}, prev2), {
      shareEnabled: checked
    }));
  };
  const handleSubmit = () => __async(null, null, function* () {
    if (!(user == null ? void 0 : user.id)) {
      setError("You need to be signed in to save grow logs.");
      return;
    }
    setSaving(true);
    setError(null);
    try {
      const shareSummary = form.shareMessage || [
        `${form.runLabel || "Grow Log"}  ${form.stage}`,
        form.day ? `Day ${form.day}` : null,
        form.highlight || form.notes || null,
        form.nextActions ? `Next: ${form.nextActions}` : null
      ].filter(Boolean).join("\n");
      const payload = {
        user_id: user.id,
        strain_slug: form.strainSlug || null,
        stage: form.stage,
        notes: form.notes,
        images: parseList(form.imageUrls).slice(0, 6),
        health_status: {
          vigor: form.vigor,
          highlight: form.highlight,
          issues: parseList(form.healthIssues),
          medium: form.medium,
          pest_check: form.pestCheck,
          environment_notes: form.environmentNotes,
          water_volume: form.waterVolume
        },
        remedies: {
          actions: parseList(form.remedies),
          next_actions: parseList(form.nextActions),
          ai_prompt: form.aiPrompt
        },
        progress: {
          run_label: form.runLabel || "Untitled Run",
          day: form.day ? Number(form.day) : null,
          entry_date: form.entryDate,
          metrics: form.metrics,
          tasks_completed: parseList(form.tasksCompleted),
          next_actions: parseList(form.nextActions),
          nutrients: parseList(form.nutrientsUsed),
          environment_notes: form.environmentNotes,
          share: {
            enabled: form.shareEnabled,
            summary: shareSummary,
            tags: parseList(form.shareTags),
            token: form.shareEnabled ? crypto.randomUUID() : null
          },
          created_with: "grow-logbook-v1",
          last_updated: (/* @__PURE__ */ new Date()).toISOString()
        }
      };
      const resp = yield fetch(`${API_BASE}/api/growlogs`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      const data = yield resp.json().catch(() => ({}));
      if (!resp.ok) {
        throw new Error(data.error || "Failed to save grow log entry.");
      }
      setLogs((prev2) => [data, ...prev2]);
      setForm((prev2) => __spreadProps(__spreadValues({}, initialForm()), {
        runLabel: prev2.runLabel,
        strainSlug: prev2.strainSlug,
        stage: prev2.stage
      }));
      setSnackbar({ open: true, message: "Grow log entry saved." });
    } catch (err) {
      console.error("[grow-logbook] save failed", err);
      setError(err.message || "Unable to save grow log entry.");
    } finally {
      setSaving(false);
    }
  });
  const handleCopyShare = (log) => __async(null, null, function* () {
    const summary = buildShareSummary(log);
    try {
      yield navigator.clipboard.writeText(summary);
      setSnackbar({ open: true, message: "Share summary copied to clipboard." });
    } catch (err) {
      console.error("[grow-logbook] copy share failed", err);
      setError("Could not copy to clipboard. Please copy manually.");
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 3, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Paper,
      {
        elevation: 0,
        id: "grow-log-form",
        sx: {
          p: 3,
          borderRadius: 3,
          background: "rgba(255,255,255,0.96)",
          border: "1px solid rgba(0,0,0,0.08)"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: { xs: "column", sm: "row" }, spacing: 2, justifyContent: "space-between", alignItems: { xs: "flex-start", sm: "center" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, alignItems: "center", sx: { mb: 1 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(NoteAdd, { sx: { color: "#7CB342" } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", fontWeight: 800, children: "Capture Todays Grow Session" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#333", maxWidth: 520 }, children: "Log environment vitals, training moves, feed adjustments, and AI prompts so every run builds on real data. Entries sync with your private grow log and can be shared with peers in a single tap." })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { direction: "row", spacing: 1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Refresh entries", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: loadUserAndLogs, color: "success", children: /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshIcon, {}) }) }) })
        ] })
      }
    ),
    error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", onClose: () => setError(null), children: error2 }),
    !user && !loading && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "info", children: "Sign in to unlock the Grow Logbook and keep detailed records of every run." }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Paper,
      {
        elevation: 0,
        sx: {
          p: 3,
          borderRadius: 3,
          background: "rgba(255,255,255,0.97)",
          border: "1px solid rgba(0,0,0,0.08)"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle1", fontWeight: 800, children: "Log Entry" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { container: true, spacing: 2, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                label: "Grow / Run Label",
                value: form.runLabel,
                onChange: handleFormChange("runLabel"),
                fullWidth: true
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                label: "Day",
                value: form.day,
                onChange: handleFormChange("day"),
                fullWidth: true,
                type: "number",
                inputProps: { min: 0 }
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                label: "Entry Date",
                type: "date",
                value: form.entryDate,
                onChange: handleFormChange("entryDate"),
                fullWidth: true,
                InputLabelProps: { shrink: true }
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                label: "Strain (slug or nickname)",
                value: form.strainSlug,
                onChange: handleFormChange("strainSlug"),
                fullWidth: true
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                label: "Growth Stage",
                select: true,
                value: form.stage,
                onChange: handleFormChange("stage"),
                fullWidth: true,
                children: stageOptions.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: option, children: option }, option))
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                label: "Session Notes / Highlights",
                value: form.notes,
                onChange: handleFormChange("notes"),
                multiline: true,
                minRows: 3,
                fullWidth: true
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                label: "Key Highlight",
                value: form.highlight,
                onChange: handleFormChange("highlight"),
                fullWidth: true
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                label: "Tasks Completed (comma separated)",
                value: form.tasksCompleted,
                onChange: handleFormChange("tasksCompleted"),
                fullWidth: true
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                label: "Upcoming Actions (comma separated)",
                value: form.nextActions,
                onChange: handleFormChange("nextActions"),
                fullWidth: true
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                label: "Nutrients or additives",
                value: form.nutrientsUsed,
                onChange: handleFormChange("nutrientsUsed"),
                fullWidth: true
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                label: "Medium",
                value: form.medium,
                onChange: handleFormChange("medium"),
                fullWidth: true
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                label: "Water volume / feed rate",
                value: form.waterVolume,
                onChange: handleFormChange("waterVolume"),
                fullWidth: true
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                label: "Environment Notes",
                value: form.environmentNotes,
                onChange: handleFormChange("environmentNotes"),
                multiline: true,
                minRows: 2,
                fullWidth: true
              }
            ) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", fontWeight: 700, children: "Vital Metrics" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { container: true, spacing: 2, children: Object.entries(form.metrics).map(([key, value]) => /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 6, sm: 4, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextField,
            {
              label: key.toUpperCase(),
              value,
              onChange: handleFormChange(`metrics.${key}`),
              fullWidth: true
            }
          ) }, key)) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", fontWeight: 700, children: "Health Check" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { container: true, spacing: 2, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                label: "Plant vigor",
                value: form.vigor,
                onChange: handleFormChange("vigor"),
                fullWidth: true
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                label: "Health Issues (comma separated)",
                value: form.healthIssues,
                onChange: handleFormChange("healthIssues"),
                fullWidth: true
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                label: "Pest check result",
                value: form.pestCheck,
                onChange: handleFormChange("pestCheck"),
                fullWidth: true
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                label: "Corrective actions (comma separated)",
                value: form.remedies,
                onChange: handleFormChange("remedies"),
                fullWidth: true
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                label: "AI prompt to revisit",
                value: form.aiPrompt,
                onChange: handleFormChange("aiPrompt"),
                fullWidth: true
              }
            ) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", fontWeight: 700, children: "Media & Sharing" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { container: true, spacing: 2, alignItems: "center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 8, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                label: "Image URLs (comma separated)",
                value: form.imageUrls,
                onChange: handleFormChange("imageUrls"),
                fullWidth: true
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              FormControlLabel,
              {
                control: /* @__PURE__ */ jsxRuntimeExports.jsx(Switch, { checked: form.shareEnabled, onChange: handleToggleShare, color: "success" }),
                label: "Generate share summary"
              }
            ) }),
            form.shareEnabled && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                TextField,
                {
                  label: "Share summary override",
                  value: form.shareMessage,
                  onChange: handleFormChange("shareMessage"),
                  multiline: true,
                  minRows: 2,
                  fullWidth: true,
                  placeholder: "Optional custom message for social posts or group chats"
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                TextField,
                {
                  label: "Share tags (comma separated)",
                  value: form.shareTags,
                  onChange: handleFormChange("shareTags"),
                  fullWidth: true
                }
              ) })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: { xs: "column", sm: "row" }, spacing: 2, justifyContent: "flex-end", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "outlined",
                startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(AutoAwesome, {}),
                onClick: () => {
                  const autoShare = [
                    `${form.runLabel || "Grow Log"}  ${form.stage}`,
                    form.highlight && `Highlight: ${form.highlight}`,
                    form.tasksCompleted && `Tasks: ${form.tasksCompleted}`,
                    form.nextActions && `Next: ${form.nextActions}`
                  ].filter(Boolean).join("\n");
                  setForm((prev2) => __spreadProps(__spreadValues({}, prev2), { shareMessage: autoShare }));
                },
                children: "Generate Summary"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "contained",
                color: "success",
                startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(Save, {}),
                onClick: handleSubmit,
                disabled: saving || !user,
                children: saving ? "Saving" : "Save Entry"
              }
            )
          ] })
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Paper,
      {
        elevation: 0,
        sx: {
          p: 3,
          borderRadius: 3,
          background: "rgba(255,255,255,0.97)",
          border: "1px solid rgba(0,0,0,0.08)"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: { xs: "column", sm: "row" }, justifyContent: "space-between", alignItems: { xs: "flex-start", sm: "center" }, spacing: 2, sx: { mb: 2 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle1", fontWeight: 800, children: "Logged Sessions" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: `${logs.length} entries`, color: "success", variant: "outlined" })
          ] }),
          loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", justifyContent: "center", py: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { color: "success" }) }) : groupedLogs.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            EmptyStateCard,
            {
              title: "No grow logs yet",
              description: "Capture your daily environment, feedings, and canopy changes to unlock AI insights.",
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(GrassIcon, { sx: { fontSize: 56, color: "#2e7d32" } }),
              actionLabel: "Add first log",
              onAction: () => {
                const section = document.getElementById("grow-log-form");
                if (section) {
                  section.scrollIntoView({ behavior: "smooth" });
                }
              }
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 3, children: groupedLogs.map(({ label, items }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Paper,
            {
              elevation: 0,
              sx: {
                p: 2,
                borderRadius: 3,
                border: "1px solid rgba(0,0,0,0.06)",
                background: "rgba(255,255,255,0.92)"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: { xs: "column", sm: "row" }, spacing: 1, justifyContent: "space-between", alignItems: { xs: "flex-start", sm: "center" }, sx: { mb: 1 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", fontWeight: 800, sx: { color: "#2e7d32" }, children: label }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: `${items.length} updates`, size: "small" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 2, children: items.map((log) => {
                  var _a2, _b, _c, _d, _e, _f, _g, _h, _i;
                  return /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Paper,
                    {
                      elevation: 0,
                      sx: {
                        p: 2,
                        borderRadius: 2,
                        border: "1px solid rgba(0,0,0,0.05)",
                        background: "rgba(250,250,250,0.95)"
                      },
                      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: { xs: "column", sm: "row" }, spacing: 1, justifyContent: "space-between", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 0.5, children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, alignItems: "center", children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: log.stage || "Stage?", size: "small", color: "success", variant: "outlined" }),
                            ((_a2 = log.progress) == null ? void 0 : _a2.day) && /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: `Day ${log.progress.day}`, size: "small" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { color: "#666" }, children: new Date(((_b = log.progress) == null ? void 0 : _b.entry_date) || log.created_at).toLocaleString() })
                          ] }),
                          log.notes && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#1b5e20" }, children: log.notes }),
                          ((_d = (_c = log.progress) == null ? void 0 : _c.tasks_completed) == null ? void 0 : _d.length) ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#2f4f2f" }, children: [
                            "Tasks: ",
                            log.progress.tasks_completed.join(", ")
                          ] }) : null,
                          ((_f = (_e = log.progress) == null ? void 0 : _e.next_actions) == null ? void 0 : _f.length) ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#2f4f2f" }, children: [
                            "Next: ",
                            log.progress.next_actions.join(", ")
                          ] }) : null,
                          ((_h = (_g = log.health_status) == null ? void 0 : _g.issues) == null ? void 0 : _h.length) ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#c62828" }, children: [
                            "Watch: ",
                            log.health_status.issues.join(", ")
                          ] }) : null,
                          ((_i = log.progress) == null ? void 0 : _i.metrics) ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", sx: { color: "#455a64" }, children: [
                            "Vitals  Temp ",
                            log.progress.metrics.temperature || "",
                            " | RH ",
                            log.progress.metrics.humidity || "",
                            " | EC ",
                            log.progress.metrics.ec || "",
                            " | pH ",
                            log.progress.metrics.ph || ""
                          ] }) : null
                        ] }),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 1, direction: { xs: "row", sm: "column" }, justifyContent: "flex-start", alignItems: { xs: "center", sm: "flex-end" }, children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Copy share summary", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { color: "success", onClick: () => handleCopyShare(log), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Share, {}) }) }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Copy raw entry JSON", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                            IconButton$1,
                            {
                              onClick: () => __async(null, null, function* () {
                                try {
                                  yield navigator.clipboard.writeText(JSON.stringify(log, null, 2));
                                  setSnackbar({ open: true, message: "Entry JSON copied." });
                                } catch (e) {
                                  setError("Unable to copy JSON to clipboard.");
                                }
                              }),
                              children: /* @__PURE__ */ jsxRuntimeExports.jsx(ContentCopy, {})
                            }
                          ) })
                        ] })
                      ] })
                    },
                    log.id
                  );
                }) })
              ]
            },
            label
          )) })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Snackbar,
      {
        open: snackbar.open,
        autoHideDuration: 4e3,
        onClose: () => setSnackbar({ open: false, message: "" }),
        message: snackbar.message
      }
    )
  ] });
}
function Section({ title, children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        mb: 3,
        p: 2,
        borderRadius: 3,
        backgroundColor: "rgba(255,255,255,0.95)",
        border: "1px solid rgba(0,0,0,0.08)",
        boxShadow: "0 6px 18px rgba(20,40,20,0.08)"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle1", fontWeight: 800, gutterBottom: true, sx: { color: "#000" }, children: title }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#000" }, children })
      ]
    }
  );
}
const LOGBOOK_TAB_INDEX = 13;
function GrowCoach({ onBack, initialTab = 0 }) {
  const [tab, setTab] = reactExports.useState(initialTab);
  const [timelineIndex, setTimelineIndex] = reactExports.useState(0);
  reactExports.useEffect(() => {
    setTab(initialTab);
  }, [initialTab]);
  const overviewSections = reactExports.useMemo(
    () => [
      {
        title: "The Four Pillars of Success",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Environment:" }),
          " Hold temperature, humidity, VPD, airflow, and CO inside target ranges for every stage. Stable rooms prevent most problems.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Genetics:" }),
          " Choose cultivars that fit your ceiling height, flowering window, and desired chemotype. Verify breeder data, germination rates, and lab tests.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Nutrition & Water:" }),
          " Deliver balanced feed at the correct EC and pH. Adjust based on runoff data and leaf feedback instead of bottle recommendations alone.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Observation & Logging:" }),
          " Inspect plants daily, record metrics, and photograph everything. Consistent logs unlock AI-driven insights and make troubleshooting fast."
        ] })
      },
      {
        title: "Baseline Targets",
        body: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { container: true, spacing: 2, children: [
          { stage: "Seedling", temp: "75-80F", rh: "65-75% RH", vpd: "0.4-0.8 kPa", light: "200-300 PPFD (18-24 hrs)" },
          { stage: "Vegetative", temp: "76-82F", rh: "55-65% RH", vpd: "1.0-1.2 kPa", light: "350-550 PPFD (18/6 or 20/4)" },
          { stage: "Early Flower", temp: "76-80F", rh: "45-55% RH", vpd: "1.1-1.3 kPa", light: "650-750 PPFD (12/12)" },
          { stage: "Mid/Late Flower", temp: "74-78F", rh: "40-50% RH", vpd: "1.2-1.4 kPa", light: "750-900 PPFD (12/12)" },
          { stage: "Dry + Cure", temp: "60-65F", rh: "55-60% RH", vpd: "0.7-0.8 kPa", light: "Complete darkness" }
        ].map((row) => /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper, { elevation: 0, sx: { p: 2, borderRadius: 3, background: "rgba(255,255,255,0.96)", border: "1px solid rgba(0,0,0,0.06)" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", fontWeight: 700, children: row.stage }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", children: [
            "Temperature: ",
            row.temp
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", children: [
            "Humidity: ",
            row.rh
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", children: [
            "VPD: ",
            row.vpd
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", children: [
            "Lighting: ",
            row.light
          ] })
        ] }) }, row.stage)) }) })
      },
      {
        title: "Core Equipment Checklist",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Space:" }),
          " 2244 reflective tent, inline exhaust + carbon filter (CFM  tent volume 1.25), passive or filtered active intake, oscillating clip fans for canopy and under-canopy airflow.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Lighting:" }),
          " Full-spectrum dimmable LED (PPF 2.4 mol/J) with timer/smart plug. Reference manufacturer PPFD map to set hanging height.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Mediums:" }),
          " Fabric pots (37 gal). Choose living soil (amended), coco/perlite (70/30), or soilless peat. Always use quality water (RO or filtered tap + Cal-Mag as required).",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Monitoring:" }),
          " Calibrated pH pen, EC/TDS meter, hygrometer/thermometer at canopy, jewelers loupe (60), optional Bluetooth sensors for remote logging.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Supplies:" }),
          " Two- or three-part base nutrients, silica, Cal-Mag, microbial inoculant, IPM toolkit (biologicals, neem alternatives), enzyme or flushing solution, scissors, alcohol wipes.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Automation Ready:" }),
          " Smart plugs, leak trays, Wi-Fi sensors, StrainSpotter Grow Log templates for daily data capture."
        ] })
      },
      {
        title: "Your First Cycle Roadmap",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Week 0:" }),
          " Sanitize space, assemble equipment, run empty test for 24 hours.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Weeks 1-2:" }),
          " Germinate, establish seedlings, record emergence.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Weeks 3-6:" }),
          " Vegetative growth, training, transplant, canopy leveling.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Weeks 7-16:" }),
          " Flower stretch, bud formation, bulking, ripening.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Weeks 17-18:" }),
          " Harvest, dry, cure, and review analytics for next run.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          "Pair this roadmap with the Stage Timelines tab for detailed weekly objectives."
        ] })
      }
    ],
    []
  );
  const setupSections = reactExports.useMemo(
    () => [
      {
        title: "Space & Environmental Control",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          " Position tent away from direct sunlight and HVAC vents; ensure dedicated electrical circuit.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Calculate exhaust fan size: ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("em", { children: "CFM = tent volume  air exchange target (1.25-1.5)" }),
          ". Add 25% headroom for filter resistance.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Configure air path: passive lower intake or filtered active intake; carbon filter at canopy height exhausting outdoors or into lung room.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Install two oscillating fans (above and below canopy) for gentle non-stop airflow.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Lightproof the spacepatch pinholes with foil tape, double up flaps to prevent light leaks during flower."
        ] })
      },
      {
        title: "Medium Recipes",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Living Soil (per 10 gal):" }),
          " 5 gal sphagnum peat, 3 gal aeration (pumice/perlite), 2 gal compost. Amend with 2 cups kelp meal, 2 cups neem/karanja, 2 cups crustacean meal, 1 cup gypsum, 1 cup basalt, 1 cup dolomite lime. Moisture to field capacity, rest 2-4 weeks, inoculate with mycorrhizae at transplant.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Coco/Perlite 70/30:" }),
          " Rinse buffered coco until runoff EC <0.6 mS/cm, mix with medium perlite. Feed 1.0 EC from day one, 10-15% runoff each watering, maintain root-zone pH 5.8-6.2.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Soilless Peat (Pro-Mix style):" }),
          " 80% peat, 20% perlite with mycorrhizae. Requires full nutrient program similar to coco but slower dryback. Maintain pH 6.0-6.3."
        ] })
      },
      {
        title: "Containers & Irrigation",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          " Fabric pots promote air pruning and faster oxygen exchange; pair with saucers and risers.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Plastic pots retain moisture longerreduce watering frequency or increase airflow.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Automated options: drip rings, Blumat carrots, or ebb-and-flow trays. Log irrigation events and volumes in StrainSpotter.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Sterilise irrigation lines monthly; flush with 3% peroxide solution during turnaround."
        ] })
      },
      {
        title: "Monitoring & Calibration",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          " Place hygrometer at canopy height and second sensor near root zone to monitor gradients.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Calibrate pH pen weekly if high-use; store probe in KCl solution, never dry.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Rinse EC meter with RO after use; calibrate monthly with 1413 S/cm solution.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Log calibration dates, filter changes, and cleanings for compliance.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Use lux meter (or reliable phone app) with conversion factor (lux  0.015  PPFD for white LEDs) when PAR meter absent."
        ] })
      },
      {
        title: "Automation & Data Readiness",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          " Connect smart plugs to StrainSpotter webhook for automated light cycle logging.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Install Wi-Fi or Bluetooth sensors and sync to mobile dashboards for instant alerts.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Build a StrainSpotter daily log template capturing: ambient temp, RH, CO, irrigation volume, input EC/pH, runoff EC/pH, observations.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Photograph final setup (lights on/off) and upload to AI for placement review (fan orientation, light height, potential hotspots)."
        ] })
      }
    ],
    []
  );
  const germinationSections = reactExports.useMemo(
    () => [
      {
        title: "Germination Workflow (Days 0-7)",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          "1. ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Hydrate:" }),
          " Soak seeds 12-18 hours in 68-70F filtered water (dark environment). Seeds often sink after a few hoursfloating seeds can be coaxed under.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          "2. ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Incubate:" }),
          " Transfer to moist (not soaked) paper towels between plates or inside a germination tray. Maintain 75-80F and 70-80% RH.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          "3. ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Monitor:" }),
          " Check twice daily. Keep towels damp. Wait for 0.25-0.5 inch taproot before planting.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          "4. ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Plant:" }),
          " Place taproot-down in pre-moistened medium 0.25-0.5 inch deep. Cover lightly and mist surface.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          "5. ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Acclimate:" }),
          " Use humidity dome for first 3-5 days, vent gradually to harden seedlings.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          "Track seed lot, soak time, and sprout date in StrainSpotter to build cultivar-specific averages."
        ] })
      },
      {
        title: "Environmental Targets",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          " Temperature 75-80F, RH 70-80%, gentle airflow directed above seedlings.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Lighting 18-24 hours per day, ~200 PPFD at canopy, LED 24-30 inches away.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Media moisture: evenly moist but never waterlogged. Mist surface daily; allow top layer to dry between waterings to prevent damping-off.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Avoid fertiliser until first true leaves emerge; use pH 6.0-6.2 water (or 5.8 in coco)."
        ] })
      },
      {
        title: "Troubleshooting Germination",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          " Seed fails to crack after 48 hours: gently scarify with fine sandpaper, re-soak 12 hours, retry.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Taproot stalls: temperature likely lowmove incubator to 78F zone.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Helmet head: mist husk, wait 30 minutes, use sterile tweezers to ease shell off.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Stretching seedling: increase light intensity or lower fixture; support stem with a small stake.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Leaf spotting: photograph and run through StrainSpotter AI to confirm whether it is splash, deficiency, or pathogen."
        ] })
      },
      {
        title: "AI & Data Touchpoints",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          " Log emergence date and cultivar inside Grow Log to populate later-stage timelines automatically.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Upload day 3 and day 7 photosAI flags stretch, colour deviations, or early deficiency signals.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Record irrigation volume and intervals; AI will calculate dryback rate to inform veg watering schedule."
        ] })
      }
    ],
    []
  );
  const vegetativeSections = reactExports.useMemo(
    () => [
      {
        title: "Environmental & Nutrient Targets",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          " Lighting: 18/6 or 20/4. Provide 350-550 PPFD. Maintain LED 18-24 inches above canopy.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Temperature: 76-82F day / 70-72F night. RH 55-65% (VPD 1.0-1.2 kPa).",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Feeding: EC 1.0-1.4 depending on medium. Maintain N:K ratio around 3:2. Always include calcium/magnesium under LED lighting.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Watering: allow 10-20% runoff in coco; in soil water when top inch dry. Alternate feed/water as required by runoff data."
        ] })
      },
      {
        title: "Training Protocol",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          " Week 3: Top above node 4 or 5. Begin low-stress training (LST) to spread canopy.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Week 4: Install SCROG net 8-10 inches above pots. Tuck branches daily to maintain level canopy.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Week 5: Remove interior growth/shaded shoots receiving <200 PPFD. Maintain airflow through centre.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Week 6: Final canopy leveling. Ensure even height before transition to 12/12. Document training actions with photos."
        ] })
      },
      {
        title: "Weekly Checklist",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          " Inspect foliage (top/bottom) for pests, deficiencies, mechanical damage.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Clean and sterilise scissors, ties, and support stakes.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Recalibrate sensors and meters once per week.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Photograph canopy top-down for AI analysis of light distribution.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Record plant height, node count, training adjustments, and irrigation data inside StrainSpotter."
        ] })
      },
      {
        title: "AI Utilisation",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          " Weekly StrainSpotter Scan of canopy to detect colour shift, tip burn, or early nutrient issues.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Prompt example: Predict final harvest height with veg height 18 inches and cultivar stretch factor 2.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Upload canopy map; AI suggests additional tie-down points or defoliation targets."
        ] })
      }
    ],
    []
  );
  const floweringSections = reactExports.useMemo(
    () => [
      {
        title: "Transition (Weeks 1-3 of Flower)",
        body: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: " Switch to 12/12 photoperiod; optionally add 15-minute far-red flash at lights-off to reduce stretch.  Increase PPFD to 650-750; adjust fixture height daily during stretch.  Maintain temperature 76-80F day / 68-70F night; RH 45-55% (VPD 1.1-1.3 kPa).  Transition feed over 7-10 days: reduce nitrogen, increase phosphorus/potassium gradually.  Install second trellis or plant yoyos once stretch exceeds 6 inches.  Scout daily for powdery mildew and pest pressure; document observations in Grow Log." })
      },
      {
        title: "Mid Flower (Weeks 4-7)",
        body: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: " Hold PPFD 750-850; CO (if supplementing) 900-1000 ppm during lights-on.  Maintain RH 40-50% to prevent botrytis; increase airflow beneath canopy.  Feed EC 1.4-1.8 depending on cultivar response; monitor runoff to keep input-output EC differential 0.3.  Perform single targeted defoliation at start of week 4 to open airflow; avoid repeated heavy stripping.  Record bud development photos weekly; AI compares to cultivar norms and flags lagging cola growth." })
      },
      {
        title: "Late Flower & Ripening (Weeks 8+)",
        body: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: " Begin ripening flush 10-14 days before planned harvest (RO or finishing solution). Aim for runoff EC <0.6 mS/cm by final days.  Lower night temperature to 65-68F to preserve volatile terpenes and tighten buds.  Reduce RH to 38-45%; ensure dehumidifier sized to handle transpiration load.  Inspect trichomes with 60 loupe: clear  cloudy indicates peak potency; aim for 5-10% amber for balanced effect unless cultivar-specific.  Secure heavy branches with yoyos. Eliminate light leaks to avoid foxtailing or re-veg." })
      },
      {
        title: "AI & Data Touchpoints",
        body: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: " Upload weekly macro photosAI detects early botrytis, nutrient tip burn, or foxtail formation.  Prompt example: Provide harvest readiness checklist for cultivar X at week 8 with 20% amber trichomes.  Record aroma notes and environmental deltas; AI correlates data with final terpene profile." })
      }
    ],
    []
  );
  const harvestSections = reactExports.useMemo(
    () => [
      {
        title: "Harvest Preparation",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          " Stop foliar sprays minimum 14 days pre-harvest.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Clean trimming tools with isopropyl alcohol; prepare gloves, trays, drying lines.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Plan dark period: 24-36 hours darkness optional for terpene preservation (ensure environment stable).",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Verify drying space conditions: 60F 2, 55-60% RH, gentle air exchange, total darkness."
        ] })
      },
      {
        title: "Cutting & Initial Processing",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          " Harvest just before lights-on to maximise terpene retention.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Remove large fan leaves immediately; optional wet trim to reduce drying RH load.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Hang branches evenly spaced with good airflow; avoid bud-to-bud contact.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Label each cultivar batch with harvest date, cultivar, phenotypic notes.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Log wet weight per plant for yield tracking (wet weight 0.20  expected dry weight)."
        ] })
      },
      {
        title: "AI Support",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          " Upload harvest photos for AI to verify bud density, potential mould, or trim quality.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Prompt example: Confirm if these trichomes show optimal maturity for sedative effect."
        ] })
      }
    ],
    []
  );
  const dryCureSections = reactExports.useMemo(
    () => [
      {
        title: "Drying (Days 1-10)",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          " Maintain 60F / 55-60% RH with slow air exchange; no direct fans on buds.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Inspect daily for mould, adjust RH 2% as needed to keep 7-10 day dry time.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Check small branches: when they snap (not bend), move to trimming.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Log dry-room temp/RH daily; AI monitors for deviations that risk terpene loss."
        ] })
      },
      {
        title: "Curing (Day 10+)",
        body: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: " Trim buds cleanly; store in airtight glass jars filled 65-70% (allow headspace).  Initial cure: burp jars 10 minutes twice daily for first 3 days, then once daily for days 4-7, every other day thereafter.  Use humidity packs (58-62%) once jar RH stable at 58-60%.  Cure for minimum 21 days before full evaluation; premium cure 6-8 weeks.  Record jar RH with digital mini-hygrometer; log terpene/aroma notes in StrainSpotter." })
      },
      {
        title: "Quality Assurance",
        body: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: " Test small sample for moisture using hygrometer or moisture meter (target 11-13%).  Upload cured bud photosAI evaluates trim quality, mould risk, and bag appeal.  Prompt example: Suggest corrective steps: jar RH 66% with grassy aroma at day 5 of cure." })
      }
    ],
    []
  );
  const wateringSections = reactExports.useMemo(
    () => [
      {
        title: "Water Source & Conditioning",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          " Use reverse osmosis or filtered tap (ensure chlorine/chloramine removal).",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Ideal input temperature 65-70F to maintain dissolved oxygen.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " For living soil, dechlorinate by aerating water 24 hours or using Campden tablet.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Record water source, EC, and pH before mixing nutrients."
        ] })
      },
      {
        title: "Watering Techniques by Medium",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Soil:" }),
          " Water when top inch dry; saturate until 10-20% runoff. Allow full dryback (pot light) before next irrigation.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Coco:" }),
          " Feed every watering, every 1-2 days early veg then daily in late veg/flower. Always achieve 10-15% runoff to prevent salt buildup.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Hydro:" }),
          " Maintain reservoir temps 66-68F, dissolved oxygen >6 ppm, refresh nutrient solution weekly."
        ] })
      },
      {
        title: "Soil Moisture Monitoring",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          " Use pot weight method (lift pots) or soil moisture probes for consistency.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Record irrigation volume, EC, pH, and runoff data in StrainSpotter; AI spots overwatering trends.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Integrate volumetric water sensors (optional) to stream data into mobile dashboard."
        ] })
      }
    ],
    []
  );
  const nutrientSections = reactExports.useMemo(
    () => [
      {
        title: "Feeding Strategy",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          " Base nutrients: follow manufacturer schedule at 30-50% strength initially; adjust using runoff EC and plant response.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Maintain veg pH 5.8-6.2 (coco/hydro) or 6.2-6.8 (soil). Flower pH 5.8-6.3 / 6.2-6.7 respectively.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Alternate feed/water or feed/feed/water depending on runoff EC trends.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Add silica in veg/early flower, Cal-Mag as needed, beneficial bacteria weekly."
        ] })
      },
      {
        title: "Deficiency & Toxicity Quick Reference",
        body: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { container: true, spacing: 2, children: [
          { name: "Nitrogen", deficiency: "Uniform yellowing of lower leaves, slow growth.", toxicity: "Very dark leaves, clawing, fragile stems." },
          { name: "Phosphorus", deficiency: "Dark, dull leaves with purple stems, slow budding.", toxicity: "Nutrient lockout causing micronutrient deficiencies." },
          { name: "Potassium", deficiency: "Leaf edge burn, weak stems, poor bud set.", toxicity: "Lockout of calcium and magnesium, crispy leaves." },
          { name: "Calcium", deficiency: "Rust spots on new growth, twisted leaves.", toxicity: "Rare, usually manifests as high EC runoff." },
          { name: "Magnesium", deficiency: "Interveinal yellowing on older leaves.", toxicity: "Can antagonise calcium uptake." }
        ].map((row) => /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper, { elevation: 0, sx: { p: 2, borderRadius: 3, background: "rgba(255,255,255,0.96)", border: "1px solid rgba(0,0,0,0.06)" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", fontWeight: 700, children: row.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Deficiency:" }),
            " ",
            row.deficiency
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Toxicity:" }),
            " ",
            row.toxicity
          ] })
        ] }) }, row.name)) }) })
      },
      {
        title: "AI Troubleshooting Workflow",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          " Capture close-up and whole-plant photos; upload to StrainSpotter AI to classify issue (deficiency vs toxicity vs pest).",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Log corrective action (feed adjustment, flush, foliar) and follow up with photo 48 hours later to confirm improvement.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Prompt example: Run diagnostic: week 5 flower, EC 1.6 input/2.0 runoff, leaf edges burnt."
        ] })
      }
    ],
    []
  );
  const pestSections = reactExports.useMemo(
    () => [
      {
        title: "Integrated Pest Management (IPM) Baseline",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          " Keep room clean; remove plant waste immediately, sterilise tools regularly.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Quarantine new clones for 10-14 days; treat preventatively before entering main space.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Apply biologicals (Bacillus subtilis, beneficial mites) on schedulealternate modes of action."
        ] })
      },
      {
        title: "Common Pests & Responses",
        body: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { container: true, spacing: 2, children: [
          { pest: "Spider Mites", sign: "Speckled leaves, webbing under leaves.", action: "Increase humidity temporarily, spray with horticultural oil or release predatory mites (Phytoseiulus persimilis)." },
          { pest: "Fungus Gnats", sign: "Tiny flies, larvae in topsoil.", action: "Allow top layer to dry, top-dress with GnatNix, apply Bacillus thuringiensis israelensis (BTi)." },
          { pest: "Powdery Mildew", sign: "White powder on leaves.", action: "Lower humidity, increase airflow, apply potassium bicarbonate or biological fungicide. Remove infected leaves." },
          { pest: "Bud Rot (Botrytis)", sign: "Gray mould inside buds.", action: "Remove infected material immediately, lower RH to &lt;45%, increase airflow, consider hydrogen peroxide spray on surrounding area." }
        ].map((row) => /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper, { elevation: 0, sx: { p: 2, borderRadius: 3, background: "rgba(255,255,255,0.96)", border: "1px solid rgba(0,0,0,0.06)" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", fontWeight: 700, children: row.pest }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Signs:" }),
            " ",
            row.sign
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Response:" }),
            " ",
            row.action
          ] })
        ] }) }, row.pest)) }) })
      },
      {
        title: "AI-Assisted Monitoring",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          " Use macro lens attachments on mobile to capture pest images; upload to StrainSpotter for classification and treatment recommendations.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Log every spray/application with date, product, rate, and coverage; AI ensures rotation of active ingredients.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Prompt example: Identify cause: Week 6 flower, RH 48%, white spots underside leaves."
        ] })
      }
    ],
    []
  );
  const timeline = reactExports.useMemo(
    () => [
      {
        label: "Week 0",
        stage: "Pre-Plant Planning",
        focus: "Select genetics, prep environment, sterilise tools.",
        tasks: [
          "Review grow goals: yield target (g/watt), cannabinoid profile, flowering length.",
          "Select genetics suited to space height and flowering duration; order seeds/clones from vetted suppliers.",
          "Sanitise grow space with 3% hydrogen peroxide or 1:10 bleach solution; dry thoroughly.",
          "Verify electrical load capacity and timer accuracy; install surge protection.",
          "Calibrate pH and EC meters; record calibration date in log."
        ],
        aiPrompts: [
          "Recommend three cultivars for 8 ft ceiling, 9-week flower, balanced THC:CBD.",
          "Upload previous harvest images for AI review; note phenotype traits to replicate or avoid."
        ],
        metrics: ["Room temp 68-72F empty", "RH 45-55%", "Baseline VPD 1.0-1.2 kPa"]
      },
      {
        label: "Week 1",
        stage: "Germination & Emergence",
        focus: "Even germination, gentle environment.",
        tasks: [
          "Hydrate seeds 12-18 hours, incubate in moist paper towel at 78F.",
          "Transfer to medium once taproot 0.25-0.5 inches; label cultivar and date.",
          "Maintain humidity dome 70-80% until cotyledons fully open.",
          "Provide 18-24 hour light at ~200 PPFD; ensure gentle airflow above seedlings.",
          "Log emergence dates in StrainSpotter to start growth timeline."
        ],
        aiPrompts: [
          "Is this seedling stretching? Suggest light distance adjustment.",
          "Upload seedling photo to confirm healthy colour and cotyledon shape."
        ],
        metrics: ["Temp 75-80F", "RH 70-80%", "pH 5.8-6.2", "EC 0.4"]
      },
      {
        label: "Week 2",
        stage: "Seedling Establishment",
        focus: "Root expansion, prepare for transplant.",
        tasks: [
          "Remove humidity dome; increase gentle airflow to prevent damping-off.",
          "Water 5-10% pot volume with pH 6.0, 150-200 ppm solution (or dechlorinated water for amended soil).",
          "Transplant into solo cups or 1-gal pots once roots circle starter cube.",
          "Introduce low-stress training anchors (soft wire) to prepare for future training.",
          "Record first true leaf size and colour in log."
        ],
        aiPrompts: [
          "Calculate dryback time for 1-gal coco at 78F with 55% RH.",
          "Upload leaf photo to distinguish splash marks vs deficiency."
        ],
        metrics: ["Temp 75-80F", "RH 60-70%", "VPD 0.8-1.0 kPa"]
      },
      {
        label: "Weeks 3-4",
        stage: "Vegetative Ramp",
        focus: "Build structure, accelerate root mass.",
        tasks: [
          "Transplant into final containers with microbial inoculant.",
          "Top above node 4 or 5, begin low-stress training to even canopy.",
          "Feed 0.8-1.2 EC solution; monitor runoff to prevent salt build-up.",
          "Defoliate damaged or shading leaves to improve airflow.",
          "Document plant height, node count, training actions."
        ],
        aiPrompts: [
          "Estimate final height with current veg height 18 inches and stretch factor 2.",
          "Upload canopy photo for AI tie-down recommendations."
        ],
        metrics: ["PPFD 350-450", "RH 55-65%", "VPD 1.0-1.2 kPa"]
      },
      {
        label: "Weeks 5-6",
        stage: "Late Vegetative / Flip Prep",
        focus: "Even canopy, pathogen prevention.",
        tasks: [
          "Install trellis net, finalise canopy height.",
          "Perform lollipop pruning on lower growth receiving &lt;200 PPFD.",
          "Conduct final preventative IPM spray (biologicals).",
          "Verify timer accuracy and dark-period integrity.",
          "Plan nutrient transition schedule for flower."
        ],
        aiPrompts: [
          "List defoliation order for SCROG canopy one week before flip.",
          "Upload canopy map to check PPFD uniformity."
        ],
        metrics: ["RH 50-60%", "Runoff pH 5.8-6.3", "Leaf surface vs ambient delta &lt;2F"]
      },
      {
        label: "Weeks 7-10",
        stage: "Early Flower (Stretch)",
        focus: "Manage stretch, initiate buds.",
        tasks: [
          "Switch to 12/12, ramp PPFD to 650-750.",
          "Support branches with ties/yoyos as stretch progresses.",
          "Increase bloom nutrients gradually, maintain nitrogen moderate.",
          "Inspect daily for powdery mildew and pests.",
          "Log bud site count weekly via photos."
        ],
        aiPrompts: [
          "Upload bud site photos to track stretch uniformity.",
          "Predict harvest date given pre-flower date and cultivar flowering length."
        ],
        metrics: ["Temp 76-80F / 68-70F night", "RH 45-55%", "VPD 1.1-1.3 kPa"]
      },
      {
        label: "Weeks 11-14",
        stage: "Mid Flower",
        focus: "Bulk buds, preserve terpenes.",
        tasks: [
          "Hold PPFD 750-850; keep RH 40-50%.",
          "Feed EC 1.4-1.8, adjust based on runoff trend.",
          "Inspect for botrytis; remove susceptible leaves near buds.",
          "Optional CO supplementation to 900-1000 ppm.",
          "Document aroma changes and frost development."
        ],
        aiPrompts: [
          "Upload macro shots; AI detects early bud rot or nutrient stress.",
          "Is leaf fade normal at week 6 flower given current feed data?"
        ],
        metrics: ["VPD 1.2-1.4 kPa", "Runoff EC within 0.3 of input"]
      },
      {
        label: "Weeks 15-16",
        stage: "Ripening",
        focus: "Flush, monitor maturity.",
        tasks: [
          "Begin flush 10-14 days before harvest; aim for runoff EC &lt;0.6.",
          "Lower RH to 38-45%; run dehumidifier overnight.",
          "Secure heavy branches; eliminate light leaks.",
          "Inspect trichomes every 2-3 days.",
          "Plan harvest schedule and post-harvest workflow."
        ],
        aiPrompts: [
          "Upload trichome images for AI amber/cloudy ratio.",
          "Provide final week ripening checklist for cultivar X."
        ],
        metrics: ["Night temp 65-68F", "Dark period fully sealed"]
      },
      {
        label: "Week 17",
        stage: "Harvest",
        focus: "Cut, trim, hang.",
        tasks: [
          "Harvest before lights-on; remove large fan leaves immediately.",
          "Hang branches evenly spaced with gentle airflow.",
          "Label batches with cultivar, harvest date, wet weight.",
          "Sanitise trimming tools between plants.",
          "Document wet weight and notes in Grow Log."
        ],
        aiPrompts: [
          "Calculate ideal dry-room settings for 6 lb wet weight in 48 space.",
          "Upload harvest room photo for AI layout check."
        ],
        metrics: ["Dry room 60F", "RH 55-60%", "Airflow indirect"]
      },
      {
        label: "Week 18+",
        stage: "Dry & Cure",
        focus: "Equalise moisture, preserve terpenes.",
        tasks: [
          "Dry 7-10 days until small stems snap; trim buds and jar.",
          "Burp jars daily first week, every other day second week.",
          "Stabilise jar RH at 58-62% with humidity packs.",
          "Log final dry weight, potency tests, and sensory notes.",
          "Store long-term in cool, dark location (55F, 55% RH)."
        ],
        aiPrompts: [
          "Troubleshoot hay aroma in jar at 64% RH day 5 of cure.",
          "Upload cured bud photo for AI review of trim quality and mould risk."
        ],
        metrics: ["Jar RH 58-62%", "Cure duration minimum 21 days"]
      }
    ],
    []
  );
  const safeTimelineIndex = timeline.length > 0 ? Math.min(Math.max(timelineIndex, 0), timeline.length - 1) : 0;
  const currentTimeline = timeline.length > 0 ? timeline[safeTimelineIndex] : null;
  const dailyPlaybook = reactExports.useMemo(
    () => [
      {
        stage: "Vegetative",
        tasks: {
          Morning: ["Record ambient temp/RH and CO", "Inspect leaves (top/bottom) for pests or deficiencies", "Water/feed if pots are light (target 10-15% runoff)"],
          Midday: ["Adjust LST ties or SCROG tucks", "Check light height and PPFD map", "Update StrainSpotter log with observations"],
          Evening: ["Final canopy inspection, remove debris", "Confirm timers and environmental controls", "Capture photo set for AI comparison"]
        }
      },
      {
        stage: "Flower  Weeks 1-5",
        tasks: {
          Morning: ["Measure temp/RH and VPD at canopy", "Check for powdery mildew or pest pressure", "Irrigate based on dryback schedule"],
          Midday: ["Review trichomes with loupe on sample buds", "Log runoff EC/pH values", "Upload bud photo for AI stretch monitoring"],
          Evening: ["Verify dark period light-proofing", "Adjust dehumidifier settings for night", "Note aroma or colour changes in log"]
        }
      },
      {
        stage: "Flower  Weeks 6+",
        tasks: {
          Morning: ["Measure jar/drying room conditions (if applicable)", "Inspect for botrytis, remove compromised buds immediately", "Irrigate with flush solution as scheduled"],
          Midday: ["Check support ties/yoyos, redistribute weight", "Record trichome maturity (clear/cloudy/amber %)", "Upload macro photo for AI ripeness assessment"],
          Evening: ["Lower night humidity, ensure airflow is unobstructed", "Plan next-day harvest or flush tasks", "Document any fade/purple expression"]
        }
      },
      {
        stage: "Dry & Cure",
        tasks: {
          Morning: ["Check drying room temp/RH, adjust humidifier/dehumidifier", "Inspect hanging buds for mould or overdry tips"],
          Midday: ["Burp jars (5-10 minutes) if curing", "Log jar RH and aroma impressions", "Upload cured bud photo for AI storage guidance"],
          Evening: ["Re-seal jars, rotate positions, ensure storage in dark cool location", "Plan next day QA (moisture %, jar RH)"]
        }
      }
    ],
    []
  );
  const sensorSections = reactExports.useMemo(
    () => [
      {
        title: "Essential Sensors & Placement",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          " Canopy-level temp/RH sensor (digital with logging capability).",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Root-zone probe for media temperature and moisture (optional but valuable for disease prevention).",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " CO monitor (NDIR) if supplementing; place at canopy height away from CO source.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " PAR meter or calibrated lux meter for light intensity profiling.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Optional leaf temperature IR gun to calculate actual VPD accurately."
        ] })
      },
      {
        title: "Data Logging Workflow",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          " Log data twice daily (lights-on and lights-off) in StrainSpotter or linked spreadsheet: temp, RH, VPD, CO, EC, pH, water volume.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Sync Bluetooth/Wi-Fi sensors to mobile dashboard for alerts if thresholds breached.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Use AI to analyse trends: Highlight any VPD deviations >0.2 kPa over last 7 days.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Export data at harvest for post-mortem review; adjust environment targets next cycle."
        ] })
      },
      {
        title: "Automation Opportunities",
        body: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          " Integrate smart plugs with irrigation pumps or humidifiers; automate via StrainSpotter webhook and set guardrails to avoid overwatering.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Use controllers (Inkbird, TrolMaster) for closed-loop temp/RH management; log set-points and adjustments.",
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          " Capture camera time-lapse to correlate growth spurts with environmental changes."
        ] })
      }
    ],
    []
  );
  const renderSections = (sections) => /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: sections.map(({ title, body: body2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx(Section, { title, children: body2 }, title)) });
  const renderDailyPlaybook = () => /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 3, children: dailyPlaybook.map(({ stage, tasks }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper, { elevation: 0, sx: { p: 3, borderRadius: 3, background: "rgba(255,255,255,0.96)", border: "1px solid rgba(0,0,0,0.06)" }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", fontWeight: 800, gutterBottom: true, sx: { color: "#000" }, children: stage }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { container: true, spacing: 2, children: Object.entries(tasks).map(([time, list]) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { item: true, xs: 12, sm: 4, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", fontWeight: 700, sx: { color: "#000" }, children: time }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 0.5, sx: { mt: 1 }, children: list.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#000" }, children: [
        " ",
        item
      ] }, item)) })
    ] }, time)) })
  ] }, stage)) });
  const renderTimeline = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, sx: { mb: 3 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle1", fontWeight: 800, sx: { color: "#000" }, children: "Weekly Timeline" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Slider,
        {
          value: safeTimelineIndex,
          min: 0,
          max: Math.max(timeline.length - 1, 0),
          step: 1,
          marks: timeline.map((entry, idx) => ({ value: idx, label: entry.label })),
          onChange: (_e, value) => {
            const nextValue = Array.isArray(value) ? value[0] : value;
            setTimelineIndex(typeof nextValue === "number" ? nextValue : 0);
          }
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Paper, { elevation: 0, sx: { p: 3, borderRadius: 3, background: "rgba(255,255,255,0.97)", border: "1px solid rgba(0,0,0,0.06)" }, children: currentTimeline ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", fontWeight: 800, gutterBottom: true, sx: { color: "#000" }, children: currentTimeline.stage }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: `Focus: ${currentTimeline.focus}`, color: "success", size: "small", sx: { mb: 2 } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, { sx: { mb: 2 } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", fontWeight: 700, sx: { color: "#000" }, children: "Core Tasks" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 0.5, sx: { mt: 1, mb: 2 }, children: currentTimeline.tasks.map((task) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#000" }, children: [
        " ",
        task
      ] }, task)) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", fontWeight: 700, sx: { color: "#000" }, children: "AI Prompts" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 0.5, sx: { mt: 1, mb: 2 }, children: currentTimeline.aiPrompts.map((prompt) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#000" }, children: [
        " ",
        prompt
      ] }, prompt)) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", fontWeight: 700, sx: { color: "#000" }, children: "Target Metrics" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 0.5, sx: { mt: 1 }, children: currentTimeline.metrics.map((metric) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#000" }, children: [
        " ",
        metric
      ] }, metric)) })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#000" }, children: "Timeline data unavailable." }) })
  ] });
  const renderContent = () => {
    switch (tab) {
      case 0:
        return renderSections(overviewSections);
      case 1:
        return renderSections(setupSections);
      case 2:
        return renderSections(germinationSections);
      case 3:
        return renderSections(vegetativeSections);
      case 4:
        return renderSections(floweringSections);
      case 5:
        return renderSections(harvestSections);
      case 6:
        return renderSections(dryCureSections);
      case 7:
        return renderSections(wateringSections);
      case 8:
        return renderSections(nutrientSections);
      case 9:
        return renderSections(pestSections);
      case 10:
        return renderTimeline();
      case 11:
        return renderDailyPlaybook();
      case 12:
        return renderSections(sensorSections);
      case LOGBOOK_TAB_INDEX:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(GrowLogBook, {});
      default:
        return null;
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        display: "flex",
        flexDirection: "column",
        height: "100vh",
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            sx: {
              flexShrink: 0,
              pt: "calc(env(safe-area-inset-top) + 20px)",
              pb: 2,
              px: { xs: 2, sm: 3 },
              background: "rgba(248,252,248,0.96)",
              backdropFilter: "blur(20px)",
              borderBottom: "1px solid rgba(0,0,0,0.12)",
              zIndex: 2
            },
            children: onBack && /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                onClick: onBack,
                startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowBackIcon, {}),
                sx: { mb: 1, textTransform: "none", fontWeight: 700, color: "#000" },
                children: "Back to Garden"
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            sx: {
              flex: 1,
              minHeight: 0,
              overflowY: "auto",
              WebkitOverflowScrolling: "touch"
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Container,
              {
                maxWidth: "md",
                sx: {
                  py: 3,
                  px: { xs: 2, sm: 3 },
                  background: "rgba(248,252,248,0.96)"
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 2, sx: { mb: 1 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Box,
                      {
                        sx: {
                          width: 50,
                          height: 50,
                          borderRadius: "50%",
                          background: "transparent",
                          border: "2px solid rgba(124, 179, 66, 0.5)",
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          boxShadow: "0 0 20px rgba(124, 179, 66, 0.4)",
                          overflow: "hidden",
                          flexShrink: 0
                        },
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "img",
                          {
                            src: "/hero.png?v=13",
                            alt: "StrainSpotter",
                            style: { width: "100%", height: "100%", objectFit: "cover" }
                          }
                        )
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 1, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuBookIcon, { sx: { color: "#7CB342" } }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h5", fontWeight: 900, sx: { color: "#000" }, children: "Grow Coach" })
                    ] }) })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { mb: 2, color: "#000" }, children: "Complete, step-by-step guidance from seed selection to curing, tailored for consistent mobile use. Follow the tabs in order and log every action so StrainSpotter AI can spot trends early." }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Tabs,
                    {
                      value: tab,
                      onChange: (e, value) => setTab(value),
                      variant: "scrollable",
                      allowScrollButtonsMobile: true,
                      sx: { mb: 2 },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(LocalFloristIcon, {}), iconPosition: "start", label: "Overview" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Engineering, {}), iconPosition: "start", label: "Setup" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Grain, {}), iconPosition: "start", label: "Germination" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(WbSunny, {}), iconPosition: "start", label: "Vegetative" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(SpaIcon, {}), iconPosition: "start", label: "Flowering" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuBookIcon, {}), iconPosition: "start", label: "Harvest" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Opacity, {}), iconPosition: "start", label: "Dry & Cure" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(WaterDrop, {}), iconPosition: "start", label: "Watering & Media" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(ScienceIcon, {}), iconPosition: "start", label: "Nutrients" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(BugReport, {}), iconPosition: "start", label: "Pests & IPM" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Timeline, {}), iconPosition: "start", label: "Stage Timelines" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Checklist, {}), iconPosition: "start", label: "Daily Tasks" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(MonitorHeart, {}), iconPosition: "start", label: "Sensors & Data" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(NoteAltIcon, {}), iconPosition: "start", label: "Logbook" })
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "info", sx: { mb: 3 }, children: "Use this coach in tandem with StrainSpotter Grow Logs. Capture photos, enter metrics, and ask AI follow-up questions whenever something looks unfamiliar." }),
                  renderContent()
                ]
              }
            )
          }
        )
      ]
    }
  );
}
function MembershipAdmin({ onBack }) {
  const [tab, setTab] = reactExports.useState(0);
  const [applications, setApplications] = reactExports.useState([]);
  const [members, setMembers] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [selectedApp, setSelectedApp] = reactExports.useState(null);
  const [approveDialog, setApproveDialog] = reactExports.useState(false);
  const [approveData, setApproveData] = reactExports.useState({
    payment_received: false,
    payment_amount: "",
    payment_reference: "",
    tier: "full",
    expires_at: ""
  });
  const [sessionToken, setSessionToken] = reactExports.useState(null);
  const [accessAllowed, setAccessAllowed] = reactExports.useState(false);
  const [authChecked, setAuthChecked] = reactExports.useState(false);
  const [error2, setError] = reactExports.useState(null);
  reactExports.useEffect(() => {
    checkAccess();
  }, []);
  reactExports.useEffect(() => {
    if (accessAllowed && sessionToken) {
      loadData();
    }
  }, [tab, accessAllowed, sessionToken]);
  const checkAccess = () => __async(null, null, function* () {
    var _a2;
    try {
      const { data: { session } } = yield supabase.auth.getSession();
      if (!(session == null ? void 0 : session.access_token)) {
        setError("Sign in required to view membership management.");
        setAuthChecked(true);
        return;
      }
      const res = yield fetch(`${API_BASE}/api/users/onboarding-status`, {
        headers: { Authorization: `Bearer ${session.access_token}` }
      });
      if (!res.ok) {
        setError("Unable to verify permissions.");
        setAuthChecked(true);
        return;
      }
      const payload = yield res.json();
      if (((_a2 = payload == null ? void 0 : payload.profile) == null ? void 0 : _a2.role) === "admin") {
        setAccessAllowed(true);
        setSessionToken(session.access_token);
      } else {
        setError("Admin access required.");
      }
    } catch (e) {
      console.error("[MembershipAdmin] Access check failed:", e);
      setError("Unable to verify permissions.");
    } finally {
      setAuthChecked(true);
    }
  });
  const loadData = () => __async(null, null, function* () {
    if (!sessionToken) return;
    setLoading(true);
    try {
      const headers = { Authorization: `Bearer ${sessionToken}` };
      if (tab === 0) {
        const res = yield fetch(`${API_BASE}/api/membership/applications`, { headers });
        if (res.ok) setApplications(yield res.json().then((d) => d.applications));
      } else {
        const res = yield fetch(`${API_BASE}/api/membership/members`, { headers });
        if (res.ok) setMembers(yield res.json().then((d) => d.members));
      }
    } catch (e) {
      console.error("Failed to load:", e);
    } finally {
      setLoading(false);
    }
  });
  const handleApprove = () => __async(null, null, function* () {
    if (!selectedApp) return;
    try {
      const res = yield fetch(`${API_BASE}/api/membership/applications/${selectedApp.id}/approve`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${sessionToken}`
        },
        body: JSON.stringify(approveData)
      });
      if (res.ok) {
        setApproveDialog(false);
        setSelectedApp(null);
        loadData();
      }
    } catch (e) {
      console.error("Failed to approve:", e);
    }
  });
  const getStatusColor = (status) => {
    switch (status) {
      case "pending":
        return "warning";
      case "active":
        return "success";
      case "approved":
        return "success";
      case "rejected":
        return "error";
      case "expired":
        return "default";
      case "cancelled":
        return "error";
      default:
        return "default";
    }
  };
  if (!authChecked || loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { maxWidth: "md", sx: { py: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { children: "Loading..." }) });
  }
  if (!accessAllowed) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { maxWidth: "sm", sx: { py: 6 }, children: [
      onBack && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onBack, size: "small", variant: "contained", sx: { mb: 2 }, children: "Home" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "warning", children: error2 || "Admin access required to view membership management." })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { maxWidth: "lg", sx: { py: 4 }, children: [
    onBack && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onBack, size: "small", variant: "contained", sx: { bgcolor: "white", color: "black", textTransform: "none", fontWeight: 700, borderRadius: 999, mb: 1, "&:hover": { bgcolor: "grey.100" } }, children: "Home" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", sx: { mb: 3, fontWeight: 700 }, children: "Membership Management" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Tabs, { value: tab, onChange: (e, v) => setTab(v), sx: { mb: 3 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { label: "Applications" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { label: "Members" })
    ] }),
    tab === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h6", sx: { mb: 2 }, children: [
        "Membership Applications (",
        applications.length,
        ")"
      ] }),
      loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { children: "Loading..." }) : applications.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "info", children: "No applications yet" }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Table, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: "Name" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: "Email" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: "Phone" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: "Status" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: "Submitted" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: "Actions" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody, { children: applications.map((app) => /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: app.full_name }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: app.email }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: app.phone || "-" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: app.status, color: getStatusColor(app.status), size: "small" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: new Date(app.created_at).toLocaleDateString() }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: app.status === "pending" && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              size: "small",
              variant: "contained",
              onClick: () => {
                setSelectedApp(app);
                setApproveDialog(true);
              },
              children: "Approve"
            }
          ) })
        ] }, app.id)) })
      ] })
    ] }) }),
    tab === 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h6", sx: { mb: 2 }, children: [
        "Active Members (",
        members.length,
        ")"
      ] }),
      loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { children: "Loading..." }) : members.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "info", children: "No members yet" }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Table, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: "Name" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: "Email" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: "Tier" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: "Status" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: "Joined" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: "Expires" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody, { children: members.map((member) => /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: member.full_name }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: member.email }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: member.tier, color: "primary", size: "small" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: member.status, color: getStatusColor(member.status), size: "small" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: new Date(member.joined_at).toLocaleDateString() }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: member.expires_at ? new Date(member.expires_at).toLocaleDateString() : "Never" })
        ] }, member.id)) })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: approveDialog, onClose: () => setApproveDialog(false), maxWidth: "sm", fullWidth: true, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: "Approve Membership" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent, { children: selectedApp && /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, sx: { pt: 1 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Applicant:" }),
          " ",
          selectedApp.full_name,
          " (",
          selectedApp.email,
          ")"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: "Payment Amount",
            type: "number",
            fullWidth: true,
            value: approveData.payment_amount,
            onChange: (e) => setApproveData(__spreadProps(__spreadValues({}, approveData), { payment_amount: e.target.value }))
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: "Payment Reference",
            fullWidth: true,
            value: approveData.payment_reference,
            onChange: (e) => setApproveData(__spreadProps(__spreadValues({}, approveData), { payment_reference: e.target.value }))
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          TextField,
          {
            label: "Tier",
            select: true,
            fullWidth: true,
            value: approveData.tier,
            onChange: (e) => setApproveData(__spreadProps(__spreadValues({}, approveData), { tier: e.target.value })),
            SelectProps: { native: true },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "full", children: "Full" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "premium", children: "Premium" })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: "Expires At (optional)",
            type: "date",
            fullWidth: true,
            value: approveData.expires_at,
            onChange: (e) => setApproveData(__spreadProps(__spreadValues({}, approveData), { expires_at: e.target.value })),
            InputLabelProps: { shrink: true }
          }
        )
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => setApproveDialog(false), children: "Cancel" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleApprove, variant: "contained", children: "Approve & Create Membership" })
      ] })
    ] })
  ] });
}
function PipelineStatus({ onBack }) {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
  const [latest, setLatest] = reactExports.useState(null);
  const [history2, setHistory] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [error2, setError] = reactExports.useState(null);
  reactExports.useEffect(() => {
    const load = () => __async(null, null, function* () {
      try {
        setLoading(true);
        const [l, h] = yield Promise.all([
          fetch(`${API_BASE}/api/pipeline/latest`).then((r2) => r2.json()),
          fetch(`${API_BASE}/api/pipeline/history`).then((r2) => r2.json())
        ]);
        setLatest(l);
        setHistory(Array.isArray(h) ? h : [h].filter(Boolean));
      } catch (e) {
        console.error("[Pipeline] load error", e);
        setError("Could not load pipeline status");
      } finally {
        setLoading(false);
      }
    });
    load();
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { maxWidth: 1e3, mx: "auto", p: 2 }, children: [
    onBack && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onBack, size: "small", variant: "contained", sx: { bgcolor: "white", color: "black", textTransform: "none", fontWeight: 700, borderRadius: 999, mb: 1, "&:hover": { bgcolor: "grey.100" } }, children: "Home" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", sx: { fontWeight: 800, mb: 1 }, children: "Data Pipeline" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", sx: { color: "text.secondary", mb: 2 }, children: "Schedule: Daily at 3:00 AM UTC via GitHub Actions." }),
    loading && /* @__PURE__ */ jsxRuntimeExports.jsx(LinearProgress, {}),
    error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { color: "error", sx: { mb: 2 }, children: error2 }),
    latest && /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { mb: 3 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: { xs: "column", sm: "row" }, spacing: 2, justifyContent: "space-between", alignItems: { xs: "flex-start", sm: "center" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { fontWeight: 700 }, children: "Latest Run" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "text.secondary" }, children: [
            "Date: ",
            new Date(latest.date || latest.when || Date.now()).toLocaleString()
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: `Strains (main): ${(_b = (_a2 = latest.totals) == null ? void 0 : _a2.strainsMain) != null ? _b : ""}`, color: "success", variant: "outlined" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: `Strains (enhanced): ${(_d = (_c = latest.totals) == null ? void 0 : _c.strainsEnhanced) != null ? _d : ""}`, color: "success", variant: "outlined" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, { sx: { my: 2 } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle1", sx: { fontWeight: 700, mb: 1 }, children: "Import Report" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 2, flexWrap: "wrap", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: `Attributes: ${(_g = (_f = (_e = latest.report) == null ? void 0 : _e.counts) == null ? void 0 : _f.attributes) != null ? _g : ""}` }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: `CSV Rows: ${(_j = (_i = (_h = latest.report) == null ? void 0 : _h.counts) == null ? void 0 : _i.csvRows) != null ? _j : ""}` }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: `Matched: ${(_m = (_l = (_k = latest.report) == null ? void 0 : _k.counts) == null ? void 0 : _l.matched) != null ? _m : ""}`, color: "primary" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: `Unmatched: ${(_p = (_o = (_n = latest.report) == null ? void 0 : _n.counts) == null ? void 0 : _o.unmatched) != null ? _p : ""}`, color: "warning" })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { fontWeight: 700, mb: 1 }, children: "Run History" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Table, { size: "small", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: "Date (UTC)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { align: "right", children: "Strains (main)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { align: "right", children: "Strains (enhanced)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { align: "right", children: "Matched" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { align: "right", children: "Unmatched" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody, { children: history2.map((h, idx) => {
          var _a3, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2;
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { hover: true, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: h.date_utc || (h.date ? new Date(h.date).toISOString().slice(0, 10) : "") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { align: "right", children: (_b2 = (_a3 = h.totals) == null ? void 0 : _a3.strainsMain) != null ? _b2 : "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { align: "right", children: (_d2 = (_c2 = h.totals) == null ? void 0 : _c2.strainsEnhanced) != null ? _d2 : "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { align: "right", children: (_g2 = (_f2 = (_e2 = h.report) == null ? void 0 : _e2.counts) == null ? void 0 : _f2.matched) != null ? _g2 : "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { align: "right", children: (_j2 = (_i2 = (_h2 = h.report) == null ? void 0 : _h2.counts) == null ? void 0 : _i2.unmatched) != null ? _j2 : "" })
          ] }, idx);
        }) })
      ] })
    ] }) })
  ] });
}
const STATUS_TABS = [
  { value: "pending", label: "New" },
  { value: "in_progress", label: "In Progress" },
  { value: "resolved", label: "Resolved" }
];
function ModerationDashboard({ onBack }) {
  var _a2;
  const [reportsByStatus, setReportsByStatus] = reactExports.useState({
    pending: [],
    in_progress: [],
    resolved: []
  });
  const [stats, setStats] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(true);
  const [selectedReport, setSelectedReport] = reactExports.useState(null);
  const [resolveDialogOpen, setResolveDialogOpen] = reactExports.useState(false);
  const [moderatorNotes, setModeratorNotes] = reactExports.useState("");
  const [actionType, setActionType] = reactExports.useState("approve");
  const [error2, setError] = reactExports.useState(null);
  const [activeStatus, setActiveStatus] = reactExports.useState("pending");
  const [sessionToken, setSessionToken] = reactExports.useState(null);
  const [accessAllowed, setAccessAllowed] = reactExports.useState(false);
  const [authChecked, setAuthChecked] = reactExports.useState(false);
  reactExports.useEffect(() => {
    checkAccess();
  }, []);
  reactExports.useEffect(() => {
    if (accessAllowed && sessionToken) {
      loadData();
    }
  }, [accessAllowed, sessionToken]);
  const checkAccess = () => __async(null, null, function* () {
    var _a3;
    try {
      const { data: { session } } = yield supabase.auth.getSession();
      if (!(session == null ? void 0 : session.access_token)) {
        setError("Sign in required to access moderation tools.");
        setAuthChecked(true);
        return;
      }
      const res = yield fetch(`${API_BASE}/api/users/onboarding-status`, {
        headers: { Authorization: `Bearer ${session.access_token}` }
      });
      if (!res.ok) {
        setError("Failed to verify permissions.");
        setAuthChecked(true);
        return;
      }
      const payload = yield res.json();
      const role = (_a3 = payload == null ? void 0 : payload.profile) == null ? void 0 : _a3.role;
      if (role === "admin" || role === "moderator") {
        setAccessAllowed(true);
        setSessionToken(session.access_token);
      } else {
        setError("Moderator access required.");
      }
    } catch (e) {
      console.error("[Moderation] Access check failed:", e);
      setError("Unable to verify access.");
    } finally {
      setAuthChecked(true);
    }
  });
  const loadData = () => __async(null, null, function* () {
    try {
      setLoading(true);
      const headers = { Authorization: `Bearer ${sessionToken}` };
      const reportResponses = yield Promise.all(
        STATUS_TABS.map(
          (tab) => fetch(`${API_BASE}/api/moderation/reports?status=${tab.value}`, { headers })
        )
      );
      const nextReports = {};
      yield Promise.all(reportResponses.map((resp, idx) => __async(null, null, function* () {
        const tab = STATUS_TABS[idx];
        if (resp.ok) {
          const data = yield resp.json();
          nextReports[tab.value] = data.reports || [];
        } else {
          nextReports[tab.value] = [];
        }
      })));
      setReportsByStatus((prev2) => __spreadValues(__spreadValues({}, prev2), nextReports));
      const statsRes = yield fetch(`${API_BASE}/api/moderation/stats`, { headers });
      if (statsRes.ok) {
        const statsData = yield statsRes.json();
        setStats(statsData);
      }
    } catch (e) {
      console.error("[Moderation] Load error:", e);
      setError("Failed to load moderation data");
    } finally {
      setLoading(false);
    }
  });
  const handleResolve = () => __async(null, null, function* () {
    if (!selectedReport) return;
    try {
      setError(null);
      const res = yield fetch(`${API_BASE}/api/moderation/reports/${selectedReport.id}/resolve`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${sessionToken}`
        },
        body: JSON.stringify({
          action: actionType,
          moderator_notes: moderatorNotes
        })
      });
      if (!res.ok) {
        const errData = yield res.json();
        throw new Error(errData.error || "Failed to resolve report");
      }
      setResolveDialogOpen(false);
      setSelectedReport(null);
      setModeratorNotes("");
      loadData();
    } catch (e) {
      setError(e.message);
    }
  });
  const openResolveDialog = (report, action) => {
    setSelectedReport(report);
    setActionType(action);
    setResolveDialogOpen(true);
  };
  if (!authChecked || loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { maxWidth: "lg", sx: { py: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(LinearProgress, {}) });
  }
  if (!accessAllowed) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { maxWidth: "sm", sx: { py: 6 }, children: [
      onBack && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onBack, size: "small", variant: "contained", sx: { mb: 2 }, children: "Home" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "warning", children: error2 || "Moderator access required to view this dashboard." })
    ] });
  }
  const currentReports = reportsByStatus[activeStatus] || [];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { maxWidth: "lg", sx: { py: 4 }, children: [
    onBack && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onBack, size: "small", variant: "contained", sx: { bgcolor: "white", color: "black", textTransform: "none", fontWeight: 700, borderRadius: 999, mb: 1, "&:hover": { bgcolor: "grey.100" } }, children: "Home" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", sx: { fontWeight: 800, mb: 3 }, children: "Moderation Dashboard" }),
    error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mb: 3 }, onClose: () => setError(null), children: error2 }),
    stats && /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 2, sx: { mb: 4 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { flex: 1 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h3", color: "warning.main", sx: { fontWeight: 700 }, children: stats.pendingReports }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "Pending Reports" })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { flex: 1 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h3", color: "success.main", sx: { fontWeight: 700 }, children: stats.resolvedReports }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "Resolved Reports" })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { flex: 1 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h3", color: "primary.main", sx: { fontWeight: 700 }, children: stats.totalMessages }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "Total Messages" })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { mb: 2, fontWeight: 700 }, children: "Report Triage" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tabs,
        {
          value: activeStatus,
          onChange: (_, value) => setActiveStatus(value),
          sx: { mb: 2 },
          variant: "scrollable",
          allowScrollButtonsMobile: true,
          children: STATUS_TABS.map((tab) => {
            var _a3;
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              Tab,
              {
                value: tab.value,
                label: `${tab.label} (${((_a3 = reportsByStatus[tab.value]) == null ? void 0 : _a3.length) || 0})`
              },
              tab.value
            );
          })
        }
      ),
      currentReports.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "info", children: "No reports in this queue. Great job!" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TableContainer, { component: Paper, variant: "outlined", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Table, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: "Report ID" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: "Reason" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: "Message Content" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: "Reporter" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: "Reported" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { align: "right", children: "Actions" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody, { children: currentReports.map((report) => {
          var _a3;
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { hover: true, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", sx: { fontFamily: "monospace" }, children: [
              report.id.slice(0, 8),
              "..."
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Chip,
              {
                label: report.reason,
                size: "small",
                color: report.reason === "harassment" ? "error" : "warning"
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(TableCell, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { maxWidth: 300 }, noWrap: true, children: ((_a3 = report.messages) == null ? void 0 : _a3.content) || "(message deleted)" }),
              report.details && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", color: "text.secondary", sx: { display: "block", mt: 0.5 }, children: [
                "Details: ",
                report.details
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: report.reported_by ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", sx: { fontFamily: "monospace" }, children: [
              report.reported_by.slice(0, 8),
              "..."
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", children: "Anonymous" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", children: new Date(report.created_at).toLocaleString() }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { align: "right", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, justifyContent: "flex-end", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Approve (false positive)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton$1,
                {
                  size: "small",
                  color: "success",
                  onClick: () => openResolveDialog(report, "approve"),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(CheckCircleIcon, {})
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Warn user", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton$1,
                {
                  size: "small",
                  color: "warning",
                  onClick: () => openResolveDialog(report, "warn"),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(WarningIcon, {})
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Remove message", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton$1,
                {
                  size: "small",
                  color: "error",
                  onClick: () => openResolveDialog(report, "remove"),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteIcon, {})
                }
              ) })
            ] }) })
          ] }, report.id);
        }) })
      ] }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: resolveDialogOpen, onClose: () => setResolveDialogOpen(false), maxWidth: "sm", fullWidth: true, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogTitle, { children: [
        "Resolve Report: ",
        actionType === "approve" ? "Approve" : actionType === "warn" ? "Warn User" : "Remove Message"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { children: [
        selectedReport && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 2 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", color: "text.secondary", children: "Message Content:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", sx: { mb: 2, p: 1, bgcolor: "grey.100", borderRadius: 1 }, children: ((_a2 = selectedReport.messages) == null ? void 0 : _a2.content) || "(message deleted)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "subtitle2", color: "text.secondary", children: [
            "Reason: ",
            selectedReport.reason
          ] }),
          selectedReport.details && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", color: "text.secondary", sx: { mt: 1 }, children: [
            "Details: ",
            selectedReport.details
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: "Moderator Notes (optional)",
            multiline: true,
            rows: 3,
            fullWidth: true,
            value: moderatorNotes,
            onChange: (e) => setModeratorNotes(e.target.value),
            placeholder: "Add any notes about this decision..."
          }
        ),
        actionType === "remove" && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "warning", sx: { mt: 2 }, children: "This will permanently delete the message from the database." })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => setResolveDialogOpen(false), children: "Cancel" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            onClick: handleResolve,
            variant: "contained",
            color: actionType === "remove" ? "error" : actionType === "warn" ? "warning" : "success",
            children: actionType === "approve" ? "Approve" : actionType === "warn" ? "Warn User" : "Remove Message"
          }
        )
      ] })
    ] })
  ] });
}
function Guidelines({ onBack }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { maxWidth: "md", sx: { py: 4 }, children: [
    onBack && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onBack, size: "small", variant: "contained", sx: { bgcolor: "white", color: "black", textTransform: "none", fontWeight: 700, borderRadius: 999, mb: 1, "&:hover": { bgcolor: "grey.100" } }, children: "Home" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", sx: { mb: 2, fontWeight: 700 }, children: "Community Guidelines" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", sx: { mb: 3 }, children: "These rules keep conversations helpful, safe, and legal. By participating in Groups & Chat, you agree to follow them." }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 3, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { fontWeight: 700, mb: 1 }, children: "Be respectful" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(List$1, { dense: true, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText, { primary: "No harassment, bullying, slurs, hate speech, or threats." }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText, { primary: "Debate ideas, not people. No personal attacks." }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { fontWeight: 700, mb: 1 }, children: "Keep it legal and safe" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(List$1, { dense: true, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText, { primary: "No buying, selling, trading, or soliciting cannabis, products, or services." }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText, { primary: "No arranging meetups, deliveries, or shipping; dont share contact details to transact." }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText, { primary: "Avoid dangerous instructions or dosing advice. Follow local laws and age rules." }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { fontWeight: 700, mb: 1 }, children: "No spam or scams" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(List$1, { dense: true, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText, { primary: "No promos, giveaways, referral/affiliate links unless approved by admins." }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText, { primary: "No link shorteners or off-platform sales groups (Telegram/WhatsApp/Discord)." }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText, { primary: "No repetitive, deceptive, or irrelevant content." }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { fontWeight: 700, mb: 1 }, children: "Privacy first" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(List$1, { dense: true, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText, { primary: "Dont share personal information (phone numbers, emails, addresses, IDs)." }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText, { primary: "Dont pressure others to move off-platform or share private info." }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { fontWeight: 700, mb: 1 }, children: "Quality over quantity" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(List$1, { dense: true, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText, { primary: "Share real experiences and helpful questions. Be specific and honest." }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText, { primary: "No medical diagnoses or claims; consult a professional." }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText, { primary: "Respect copyrights; dont post content you dont own rights to." }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { fontWeight: 700, mb: 1 }, children: "Moderation and enforcement" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { mb: 1 }, children: "We use automated filtering plus community reports. Depending on severity and history, actions may include content removal, warnings, temporary timeouts, or permanent bans." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: "You can report content via the flag button on messages. Appeals are available by replying to moderation notices with context." })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", children: "Health & legal: This is not medical advice. Always comply with your local laws and age requirements." }) })
    ] })
  ] });
}
const GUIDELINES_KEY = "ss_guidelines_accepted";
function GuidelinesGate({ children }) {
  const [userId, setUserId] = reactExports.useState(null);
  const [open, setOpen] = reactExports.useState(false);
  const [checked, setChecked] = reactExports.useState(false);
  const [loading, setLoading] = reactExports.useState(true);
  reactExports.useEffect(() => {
    var _a2;
    let sub;
    (() => __async(null, null, function* () {
      var _a3;
      try {
        if (!supabase) {
          setLoading(false);
          return;
        }
        const { data } = yield supabase.auth.getSession();
        const user = (_a3 = data == null ? void 0 : data.session) == null ? void 0 : _a3.user;
        setUserId((user == null ? void 0 : user.id) || null);
        if (user) {
          const key = `${GUIDELINES_KEY}_${user.id}`;
          const accepted = localStorage.getItem(key);
          if (accepted !== "true") {
            setOpen(true);
          }
        }
      } catch (e) {
        console.debug("GuidelinesGate: getSession failed", e);
      } finally {
        setLoading(false);
      }
    }))();
    if (supabase) {
      const listener = supabase.auth.onAuthStateChange((_e, session) => {
        const user = session == null ? void 0 : session.user;
        setUserId((user == null ? void 0 : user.id) || null);
        if (user) {
          const key = `${GUIDELINES_KEY}_${user.id}`;
          const accepted = localStorage.getItem(key);
          if (accepted !== "true") {
            setOpen(true);
          }
        } else {
          setOpen(false);
        }
      });
      sub = (_a2 = listener == null ? void 0 : listener.data) == null ? void 0 : _a2.subscription;
    }
    return () => {
      var _a3;
      return (_a3 = sub == null ? void 0 : sub.unsubscribe) == null ? void 0 : _a3.call(sub);
    };
  }, []);
  const handleAccept = () => {
    if (userId) {
      const key = `${GUIDELINES_KEY}_${userId}`;
      localStorage.setItem(key, "true");
      setOpen(false);
    }
  };
  if (loading) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    children,
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Dialog,
      {
        open,
        disableEscapeKeyDown: true,
        maxWidth: "sm",
        fullWidth: true,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { sx: { fontWeight: 700 }, children: "Welcome to StrainSpotter" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 3, sx: { mt: 1 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "info", children: "Before you start, please review and accept our Community Guidelines." }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", gutterBottom: true, sx: { fontWeight: 600 }, children: "Community Guidelines" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, sx: { mt: 2 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", color: "primary.light", sx: { fontWeight: 600 }, children: " Be Respectful" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "Treat everyone with respect. No harassment, hate speech, or personal attacks." })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", color: "primary.light", sx: { fontWeight: 600 }, children: " No Solicitations" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "Do not sell, buy, trade, or solicit cannabis or any products. StrainSpotter is for information and community only." })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", color: "primary.light", sx: { fontWeight: 600 }, children: " Privacy Matters" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "Never share personal contact information (phone numbers, addresses, social media) in public spaces." })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", color: "primary.light", sx: { fontWeight: 600 }, children: " Follow Local Laws" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "You are responsible for knowing and following all local, state, and federal laws regarding cannabis." })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", color: "primary.light", sx: { fontWeight: 600 }, children: " Report Issues" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "Use the report feature if you see content that violates these guidelines." })
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              FormControlLabel,
              {
                control: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Checkbox,
                  {
                    checked,
                    onChange: (e) => setChecked(e.target.checked),
                    color: "primary"
                  }
                ),
                label: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: "I have read and agree to follow the Community Guidelines" })
              }
            )
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActions, { sx: { p: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              onClick: handleAccept,
              variant: "contained",
              disabled: !checked,
              fullWidth: true,
              size: "large",
              children: "Accept & Continue"
            }
          ) })
        ]
      }
    )
  ] });
}
function ErrorViewer({ onBack }) {
  const [errors, setErrors] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [message, setMessage] = reactExports.useState("");
  const loadErrors = () => __async(null, null, function* () {
    setLoading(true);
    try {
      const { data: { session } } = yield supabase.auth.getSession();
      if (!(session == null ? void 0 : session.access_token)) {
        setMessage("Sign in as an admin to view recent errors.");
        setErrors([]);
        return;
      }
      const resp = yield fetch(`${API_BASE}/api/admin/errors/recent?limit=100`, {
        headers: { Authorization: `Bearer ${session.access_token}` }
      });
      if (!resp.ok) {
        const text = yield resp.text();
        setMessage(text || "Failed to load errors");
        setErrors([]);
        return;
      }
      const data = yield resp.json();
      setErrors(data.errors || []);
      setMessage(data.message || "");
    } catch (e) {
      setMessage(`Connection error: ${e.message}`);
      setErrors([]);
    } finally {
      setLoading(false);
    }
  });
  reactExports.useEffect(() => {
    loadErrors();
  }, []);
  const getStatusColor = (status) => {
    if (status >= 500) return "error";
    if (status >= 400) return "warning";
    return "default";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { maxWidth: "lg", sx: { py: 4 }, children: [
    onBack && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onBack, size: "small", variant: "contained", sx: { bgcolor: "white", color: "black", textTransform: "none", fontWeight: 700, borderRadius: 999, mb: 1, "&:hover": { bgcolor: "grey.100" } }, children: "Home" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "space-between", alignItems: "center", sx: { mb: 3 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: "bold", children: " Error Logs" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "contained", onClick: loadErrors, disabled: loading, children: "Refresh" })
    ] }),
    message && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "info", sx: { mb: 3 }, children: message }),
    loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { children: "Loading..." }) : errors.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "success", children: " No recent errors! Everything is running smoothly." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 2, children: errors.map((err, idx) => {
      var _a2, _b, _c;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Card,
        {
          sx: {
            bgcolor: (err.status_code || 0) >= 500 ? "rgba(211, 47, 47, 0.05)" : "rgba(255, 152, 0, 0.05)",
            border: `1px solid ${(err.status_code || 0) >= 500 ? "#d32f2f44" : "#ff980044"}`
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 2, alignItems: "center", sx: { mb: 2 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Chip,
                {
                  label: `${(_a2 = err.status_code) != null ? _a2 : "n/a"}`,
                  color: getStatusColor((_b = err.status_code) != null ? _b : 0),
                  size: "small"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Chip,
                {
                  label: err.method || "SERVER",
                  variant: "outlined",
                  size: "small"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", children: new Date(err.created_at).toLocaleString() }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", color: "text.secondary", sx: { ml: "auto" }, children: [
                "User: ",
                err.user_id || "n/a"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", fontWeight: "bold", sx: { mb: 1 }, children: [
              "Endpoint: ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: err.path })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body1", color: "error.main", sx: { mb: 2 }, children: [
              " ",
              err.message
            ] }),
            ((_c = err.context) == null ? void 0 : _c.client) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Alert, { severity: "info", sx: { mb: 2 }, children: [
              "Client crash on ",
              err.context.client.currentView || err.context.client.location || "unknown view",
              /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
              err.context.client.userAgent
            ] }),
            err.stack && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, { sx: { my: 2 } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", sx: { mb: 1, display: "block" }, children: "Stack Trace:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Box,
                {
                  component: "pre",
                  sx: {
                    bgcolor: "rgba(0,0,0,0.05)",
                    p: 2,
                    borderRadius: 1,
                    fontSize: "0.75rem",
                    overflow: "auto",
                    maxHeight: 200
                  },
                  children: err.stack
                }
              )
            ] })
          ] })
        },
        idx
      );
    }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Alert, { severity: "info", sx: { mt: 4 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", fontWeight: "bold", sx: { mb: 1 }, children: " How to view full logs:" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", component: "div", children: [
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "PM2 logs:" }),
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: "pm2 logs strainspotter-backend" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", component: "div", children: [
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "PM2 errors only:" }),
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: "pm2 logs strainspotter-backend --err" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", component: "div", children: [
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "PM2 flush logs:" }),
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: "pm2 flush" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", component: "div", sx: { mt: 1 }, children: [
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Browser console:" }),
        " Open DevTools (F12)  Console tab to see frontend errors"
      ] })
    ] })
  ] });
}
function EmergencyLogout() {
  const [loading, setLoading] = reactExports.useState(false);
  const [message, setMessage] = reactExports.useState("");
  const handleEmergencyLogout = () => __async(null, null, function* () {
    setLoading(true);
    setMessage("Logging out...");
    try {
      yield supabase.auth.signOut();
      setMessage(" Logged out successfully!");
      setTimeout(() => {
        window.location.href = "/";
      }, 1e3);
    } catch (error2) {
      console.error("Emergency logout error:", error2);
      setMessage(" Logout failed: " + error2.message);
    } finally {
      setLoading(false);
    }
  });
  const handleFullReset = () => __async(null, null, function* () {
    setLoading(true);
    setMessage("Performing full reset...");
    try {
      yield supabase.auth.signOut();
      localStorage.clear();
      sessionStorage.clear();
      setMessage(" Full reset complete! Redirecting...");
      setTimeout(() => {
        window.location.href = "/";
      }, 1e3);
    } catch (error2) {
      console.error("Full reset error:", error2);
      setMessage(" Reset failed: " + error2.message);
    } finally {
      setLoading(false);
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      sx: {
        minHeight: "100vh",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        background: "linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%)",
        p: 2
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Paper,
        {
          elevation: 8,
          sx: {
            p: 4,
            maxWidth: 500,
            width: "100%",
            background: "linear-gradient(135deg, rgba(255, 82, 82, 0.1) 0%, rgba(255, 107, 107, 0.1) 100%)",
            border: "2px solid #ff5252",
            borderRadius: 3
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { textAlign: "center", mb: 3 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(LogoutIcon, { sx: { fontSize: 64, color: "#ff5252", mb: 2 } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", sx: { color: "#fff", fontWeight: 700, mb: 1 }, children: "Emergency Logout" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "rgba(255, 255, 255, 0.7)", mb: 2 }, children: "This will log you out immediately, bypassing all membership checks." }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { color: "rgba(255, 255, 255, 0.5)" }, children: 'Use "Full Reset" to also clear age verification and see the age gate again.' })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "contained",
                fullWidth: true,
                size: "large",
                onClick: handleEmergencyLogout,
                disabled: loading,
                startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(LogoutIcon, {}),
                sx: {
                  bgcolor: "#ff5252",
                  color: "#fff",
                  fontWeight: 700,
                  fontSize: "1.1rem",
                  py: 1.5,
                  mb: 2,
                  "&:hover": {
                    bgcolor: "#ff1744"
                  },
                  "&:disabled": {
                    bgcolor: "#666",
                    color: "#999"
                  }
                },
                children: loading ? "Logging Out..." : "Force Logout Now"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "outlined",
                fullWidth: true,
                size: "large",
                onClick: handleFullReset,
                disabled: loading,
                sx: {
                  borderColor: "#ff9800",
                  color: "#ff9800",
                  fontWeight: 700,
                  fontSize: "1rem",
                  py: 1.5,
                  "&:hover": {
                    borderColor: "#f57c00",
                    bgcolor: "rgba(255, 152, 0, 0.1)"
                  },
                  "&:disabled": {
                    borderColor: "#666",
                    color: "#999"
                  }
                },
                children: loading ? "Resetting..." : "Full Reset (Clear Age Gate Too)"
              }
            ),
            message && /* @__PURE__ */ jsxRuntimeExports.jsx(
              Typography,
              {
                variant: "body1",
                sx: {
                  mt: 3,
                  p: 2,
                  bgcolor: "rgba(0, 0, 0, 0.3)",
                  borderRadius: 2,
                  color: "#fff",
                  textAlign: "center",
                  fontWeight: 600
                },
                children: message
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mt: 3, textAlign: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { color: "rgba(255, 255, 255, 0.5)" }, children: "This is a developer tool for emergency logout situations." }) })
          ]
        }
      )
    }
  );
}
function useOnboardingStatus() {
  const { session, user } = useAuth();
  const [status, setStatus] = reactExports.useState({
    loading: true,
    error: null,
    onboardingRequired: false,
    needsDisplayName: false,
    needsRole: false,
    needsPersona: false,
    profile: null
  });
  const fetchStatus = reactExports.useCallback(() => __async(null, null, function* () {
    if (!user || !(session == null ? void 0 : session.access_token)) {
      setStatus((prev2) => __spreadProps(__spreadValues({}, prev2), {
        loading: false,
        onboardingRequired: false,
        profile: null,
        error: null
      }));
      return;
    }
    setStatus((prev2) => __spreadProps(__spreadValues({}, prev2), { loading: true, error: null }));
    try {
      const response = yield fetch(`${API_BASE}/api/users/onboarding-status`, {
        headers: {
          Authorization: `Bearer ${session.access_token}`
        }
      });
      if (!response.ok) {
        const err = yield response.json().catch(() => ({}));
        throw new Error(err.error || "Failed to load onboarding status");
      }
      const payload = yield response.json();
      setStatus({
        loading: false,
        error: null,
        onboardingRequired: Boolean(payload.onboardingRequired),
        needsDisplayName: Boolean(payload.needsDisplayName),
        needsRole: Boolean(payload.needsRole),
        needsPersona: Boolean(payload.needsPersona),
        profile: payload.profile
      });
    } catch (err) {
      console.error("[useOnboardingStatus] Failed to load status:", err);
      setStatus((prev2) => __spreadProps(__spreadValues({}, prev2), {
        loading: false,
        error: err.message || "Failed to load onboarding status"
      }));
    }
  }), [user, session == null ? void 0 : session.access_token]);
  reactExports.useEffect(() => {
    fetchStatus();
  }, [fetchStatus]);
  return __spreadProps(__spreadValues({}, status), {
    refresh: fetchStatus
  });
}
const personas = [
  { value: "enthusiast", label: "Enthusiast", description: "I explore strains, dispensaries, and community content." },
  { value: "grower", label: "Grower", description: "I cultivate, test, and share knowledge with others." },
  { value: "operator", label: "Business", description: "I run a dispensary, delivery service, or cannabis brand." }
];
function OnboardingFlow() {
  var _a2;
  const { user } = useAuth();
  const { onboardingRequired, loading, profile, refresh, needsDisplayName, needsPersona, needsRole, error: error2 } = useOnboardingStatus();
  const [step, setStep] = reactExports.useState(0);
  const [displayName, setDisplayName] = reactExports.useState("");
  const [persona, setPersona] = reactExports.useState("");
  const [notifications, setNotifications] = reactExports.useState(false);
  const [saving, setSaving] = reactExports.useState(false);
  const [submitError, setSubmitError] = reactExports.useState(null);
  const [submitSuccess, setSubmitSuccess] = reactExports.useState(false);
  reactExports.useEffect(() => {
    var _a3, _b;
    if (profile) {
      setDisplayName(profile.display_name || "");
      const personaTag = (_a3 = profile.profile_tags) == null ? void 0 : _a3.find((tag) => tag.startsWith("persona:"));
      setPersona(personaTag ? personaTag.replace("persona:", "") : "");
      setNotifications(((_b = profile.profile_tags) == null ? void 0 : _b.some((tag) => tag.startsWith("notify:"))) || false);
    }
  }, [profile]);
  const steps = reactExports.useMemo(() => [
    { label: "Profile", description: "Set your public name so others recognize you." },
    { label: "Role", description: "Tell us how you use StrainSpotter." },
    { label: "Preferences", description: "Stay in the loop with community updates." }
  ], []);
  const open = Boolean(user && onboardingRequired);
  const canContinueProfile = displayName.trim().length >= 2;
  const canContinuePersona = Boolean(persona);
  const handleSubmit = () => __async(null, null, function* () {
    if (!supabase || !user) return;
    setSaving(true);
    setSubmitError(null);
    setSubmitSuccess(false);
    try {
      const { data: { session } } = yield supabase.auth.getSession();
      if (!(session == null ? void 0 : session.access_token)) {
        throw new Error("Session expired. Please sign in again.");
      }
      const response = yield fetch(`${API_BASE}/api/users/onboarding`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${session.access_token}`
        },
        body: JSON.stringify({
          display_name: displayName.trim(),
          role: persona === "grower" ? "grower" : persona === "operator" ? "operator" : "member",
          persona,
          notifications
        })
      });
      if (!response.ok) {
        const body2 = yield response.json().catch(() => ({}));
        throw new Error(body2.error || "Failed to save onboarding data");
      }
      setSubmitSuccess(true);
      yield refresh();
      setTimeout(() => {
        setSubmitSuccess(false);
      }, 3e3);
    } catch (err) {
      console.error("[OnboardingFlow] Submit failed:", err);
      setSubmitError(err.message || "Failed to complete onboarding");
    } finally {
      setSaving(false);
    }
  });
  const showStepper = needsDisplayName || needsPersona || needsRole;
  if (!open) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: true, fullScreen: true, PaperProps: { sx: { background: "#041204", color: "#fff" } }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { sx: { textAlign: "center", fontWeight: 700, color: "#CDDC39", pt: 4 }, children: "Welcome to StrainSpotter" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      DialogContent,
      {
        sx: {
          maxWidth: 520,
          mx: "auto",
          width: "100%",
          height: "100%",
          display: "flex",
          flexDirection: "column",
          pt: 1,
          pb: 6
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Box,
            {
              sx: {
                overflowY: "auto",
                pr: 1,
                flex: 1,
                "&::-webkit-scrollbar": { width: 6 },
                "&::-webkit-scrollbar-thumb": { background: "rgba(255,255,255,0.2)", borderRadius: 999 }
              },
              children: [
                error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mb: 2 }, children: error2 }),
                showStepper && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 3 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Stepper, { activeStep: step, alternativeLabel: true, children: steps.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(Step, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(StepLabel, { children: item.label }) }, item.label)) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { mt: 1, textAlign: "center", color: "#ccc" }, children: (_a2 = steps[step]) == null ? void 0 : _a2.description })
                ] }),
                step === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mt: 3 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { mb: 1, fontWeight: 700 }, children: "How should the community address you?" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    TextField,
                    {
                      value: displayName,
                      onChange: (e) => setDisplayName(e.target.value),
                      label: "Display Name",
                      fullWidth: true,
                      autoFocus: true,
                      inputProps: { maxLength: 60 },
                      helperText: "Shown in chats, groups, and grower directory.",
                      sx: {
                        "& .MuiOutlinedInput-root": { color: "#fff" },
                        "& .MuiInputLabel-root": { color: "#bbb" },
                        "& .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(255,255,255,0.3)" }
                      }
                    }
                  )
                ] }),
                step === 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mt: 2 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { mb: 1, fontWeight: 700 }, children: "Choose your primary role" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    ToggleButtonGroup,
                    {
                      exclusive: true,
                      fullWidth: true,
                      color: "success",
                      value: persona,
                      onChange: (_e, next2) => next2 && setPersona(next2),
                      orientation: "vertical",
                      children: personas.map((p) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                        ToggleButton,
                        {
                          value: p.value,
                          sx: {
                            mb: 1,
                            textTransform: "none",
                            justifyContent: "flex-start",
                            borderRadius: 2,
                            bgcolor: persona === p.value ? "rgba(124,179,66,0.25)" : "rgba(255,255,255,0.05)"
                          },
                          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { textAlign: "left" }, children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle1", sx: { fontWeight: 700 }, children: p.label }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { color: "#ccc" }, children: p.description })
                          ] })
                        },
                        p.value
                      ))
                    }
                  )
                ] }),
                step === 2 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mt: 3 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { mb: 1, fontWeight: 700 }, children: "Stay in the loop?" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { mb: 2, color: "#ccc" }, children: "Receive occasional emails about new groups, grower spotlights, and product updates. You can change this anytime in settings." }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    FormControlLabel,
                    {
                      control: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Checkbox,
                        {
                          checked: notifications,
                          onChange: (e) => setNotifications(e.target.checked),
                          sx: { color: "#CDDC39" }
                        }
                      ),
                      label: "Yes, send me StrainSpotter updates"
                    }
                  )
                ] }),
                submitError && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mt: 3 }, children: submitError }),
                submitSuccess && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "success", sx: { mt: 3 }, children: "Profile updated! Youre all set." })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 2, sx: { mt: 4 }, children: [
            step > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "outlined",
                onClick: () => setStep((prev2) => Math.max(prev2 - 1, 0)),
                sx: { flex: 1 },
                children: "Back"
              }
            ),
            step < steps.length - 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "contained",
                disabled: saving || step === 0 && !canContinueProfile || step === 1 && !canContinuePersona,
                onClick: () => setStep((prev2) => Math.min(prev2 + 1, steps.length - 1)),
                sx: { flex: 1, bgcolor: "#7CB342", color: "#fff", "&:hover": { bgcolor: "#8bc34a" } },
                children: "Continue"
              }
            ),
            step === steps.length - 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "contained",
                disabled: saving || !canContinueProfile || !canContinuePersona,
                onClick: handleSubmit,
                sx: { flex: 1, bgcolor: "#7CB342", color: "#fff", "&:hover": { bgcolor: "#8bc34a" } },
                children: saving ? "Saving" : "Finish"
              }
            )
          ] }),
          !loading && !onboardingRequired && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mt: 3, textAlign: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => setStep(0), size: "small", sx: { color: "#ccc" }, children: "Revisit onboarding" }) })
        ]
      }
    )
  ] });
}
const slides = [
  {
    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CameraAltIcon, { sx: { fontSize: 48 } }),
    title: "Snap a bud or label",
    body: "Use your camera to capture the bud, jar label, or packaging. Clear lighting and sharp focus give Vision the best chance to identify the strain."
  },
  {
    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(ScienceIcon, { sx: { fontSize: 48 } }),
    title: "AI compares against known strains",
    body: "We run your photo through Vision, cross-reference 35k+ strains, and rank the closest matches with transparent confidence scores."
  },
  {
    icon: /* @__PURE__ */ jsxRuntimeExports.jsx(PlaylistAddCheckIcon, { sx: { fontSize: 48 } }),
    title: "Log grows & experiences",
    body: "Save matches to your journal or grow log, track effects and ratings, and build a personal profile of what works best for you."
  }
];
function FirstRunIntro({ open, onFinish }) {
  const [index2, setIndex] = reactExports.useState(0);
  const activeSlide = reactExports.useMemo(() => slides[index2], [index2]);
  const handleNext = () => {
    if (index2 >= slides.length - 1) {
      onFinish == null ? void 0 : onFinish();
    } else {
      setIndex((prev2) => prev2 + 1);
    }
  };
  const handleBack = () => {
    setIndex((prev2) => Math.max(0, prev2 - 1));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open, fullScreen: true, PaperProps: { sx: { background: "#041204", color: "#fff" } }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { sx: { display: "flex", flexDirection: "column", height: "100%", alignItems: "center", justifyContent: "center", textAlign: "center", gap: 3 }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: activeSlide.icon }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: 800, children: activeSlide.title }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", color: "rgba(255,255,255,0.75)", sx: { maxWidth: 420 }, children: activeSlide.body }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      MobileStepper,
      {
        steps: slides.length,
        position: "static",
        activeStep: index2,
        nextButton: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "contained", color: "success", onClick: handleNext, children: index2 === slides.length - 1 ? "Start scanning" : "Next" }),
        backButton: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleBack, disabled: index2 === 0, children: "Back" })
      }
    )
  ] }) });
}
function JournalPage({ onBack }) {
  const [entries, setEntries] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [error2, setError] = reactExports.useState(null);
  const [filter, setFilter] = reactExports.useState("all");
  const [dialogOpen, setDialogOpen] = reactExports.useState(false);
  const [dialogDefaults, setDialogDefaults] = reactExports.useState(null);
  const loadEntries = reactExports.useCallback(() => __async(null, null, function* () {
    var _a2;
    setLoading(true);
    setError(null);
    try {
      const { data } = yield supabase.auth.getSession();
      const token2 = (_a2 = data == null ? void 0 : data.session) == null ? void 0 : _a2.access_token;
      if (!token2) {
        setEntries([]);
        setLoading(false);
        return;
      }
      const resp = yield fetch(`${API_BASE}/api/journals`, {
        headers: { Authorization: `Bearer ${token2}` }
      });
      const payload = yield resp.json().catch(() => []);
      if (!resp.ok) throw new Error(payload.error || "Failed to load journal entries.");
      setEntries(Array.isArray(payload) ? payload : []);
    } catch (err) {
      setError(err.message || "Unable to load journals.");
    } finally {
      setLoading(false);
    }
  }), []);
  reactExports.useEffect(() => {
    loadEntries();
  }, [loadEntries]);
  const grouped = reactExports.useMemo(() => {
    const filtered = filter === "all" ? entries : entries.filter((entry) => entry.strain_slug === filter);
    const map = /* @__PURE__ */ new Map();
    filtered.forEach((entry) => {
      var _a2;
      const dateKey = entry.entry_date || ((_a2 = entry.created_at) == null ? void 0 : _a2.split("T")[0]) || "Unknown Date";
      if (!map.has(dateKey)) {
        map.set(dateKey, []);
      }
      map.get(dateKey).push(entry);
    });
    return Array.from(map.entries()).sort((a, b) => new Date(b[0]) - new Date(a[0]));
  }, [entries, filter]);
  const strains = reactExports.useMemo(() => {
    const set = /* @__PURE__ */ new Set();
    entries.forEach((entry) => {
      if (entry.strain_slug) {
        set.add(entry.strain_slug);
      }
    });
    return Array.from(set);
  }, [entries]);
  const renderEntry = (entry) => /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { variant: "outlined", sx: { mb: 1.5, background: "rgba(255,255,255,0.04)", borderColor: "rgba(255,255,255,0.12)" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 1, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "space-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle1", fontWeight: 700, children: entry.strain_name || entry.strain_slug || "Unknown strain" }),
      entry.rating ? /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { size: "small", color: "success", label: `${entry.rating}/5` }) : null
    ] }),
    entry.notes && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: entry.notes }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, flexWrap: "wrap", children: [
      entry.method && /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { size: "small", label: entry.method }),
      entry.dosage && /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { size: "small", label: entry.dosage }),
      entry.time_of_day && /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { size: "small", label: entry.time_of_day }),
      (entry.tags || []).map((tag) => /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { size: "small", variant: "outlined", label: `#${tag}` }, tag))
    ] })
  ] }) }) }, entry.id);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        display: "flex",
        flexDirection: "column",
        height: "100vh",
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            sx: {
              flexShrink: 0,
              py: 2,
              px: 2,
              borderBottom: "1px solid rgba(255,255,255,0.08)",
              bgcolor: "rgba(0,0,0,0.7)",
              backdropFilter: "blur(10px)",
              zIndex: 1
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { maxWidth: "md", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "space-between", alignItems: "center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, alignItems: "center", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(LibraryBooksIcon, { sx: { color: "#7CB342" } }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h5", fontWeight: 800, sx: { color: "#fff" }, children: "Journal" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, children: [
                onBack && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outlined", onClick: onBack, sx: { color: "#fff", borderColor: "rgba(255,255,255,0.3)" }, children: "Back" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "contained", onClick: () => {
                  setDialogDefaults(null);
                  setDialogOpen(true);
                }, children: "New entry" })
              ] })
            ] }) })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            sx: {
              flex: 1,
              minHeight: 0,
              overflowY: "auto",
              WebkitOverflowScrolling: "touch"
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { maxWidth: "md", sx: { py: 4 }, children: [
              loading && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", justifyContent: "center", py: 5 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {}) }),
              !loading && error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                EmptyStateCard,
                {
                  title: "Unable to load journal",
                  description: error2,
                  actionLabel: "Retry",
                  onAction: loadEntries
                }
              ),
              !loading && !error2 && entries.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                EmptyStateCard,
                {
                  title: "No entries yet",
                  description: "Capture how each strain made you feel, the dosage, and what youd change next time.",
                  actionLabel: "Scan your first strain",
                  onAction: () => window.dispatchEvent(new CustomEvent("nav:set-view", { detail: "scanner" })),
                  secondaryActionLabel: "Add a manual entry",
                  onSecondaryAction: () => setDialogOpen(true)
                }
              ),
              !loading && !error2 && entries.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: { xs: "column", sm: "row" }, spacing: 2, sx: { mb: 2 }, alignItems: "center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "Filter by strain" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Select,
                    {
                      size: "small",
                      value: filter,
                      onChange: (e) => setFilter(e.target.value),
                      sx: { minWidth: 200 },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "all", children: "All strains" }),
                        strains.map((slug) => /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: slug, children: slug }, slug))
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 3, children: grouped.map(([date, dayEntries]) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", sx: { textTransform: "capitalize", color: "rgba(255,255,255,0.7)" }, children: new Date(date).toLocaleDateString(void 0, { weekday: "long", month: "long", day: "numeric" }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, { sx: { my: 1, opacity: 0.2 } }),
                  dayEntries.map(renderEntry)
                ] }, date)) })
              ] })
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          JournalDialog,
          {
            open: dialogOpen,
            defaults: dialogDefaults,
            onClose: () => setDialogOpen(false),
            onSaved: () => {
              setDialogOpen(false);
              loadEntries();
            }
          }
        )
      ]
    }
  );
}
function FloatingScanButton({ onClick }) {
  const { user } = useAuth();
  if (!user) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Start a new scan", placement: "left", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Fab,
    {
      color: "primary",
      onClick,
      sx: {
        position: "fixed",
        bottom: 24,
        right: 24,
        zIndex: 1500,
        boxShadow: "0 12px 32px rgba(0,0,0,0.25)"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CameraAltIcon, {})
    }
  ) });
}
function ScanBalanceIndicator({ onBuyCredits }) {
  var _a2, _b;
  const { user } = useAuth();
  const { remainingScans, isUnlimited, loading } = (_a2 = useCreditBalance == null ? void 0 : useCreditBalance()) != null ? _a2 : {};
  const hasUnlimited = isUnlimited;
  const summary = {
    creditsRemaining: remainingScans,
    remainingScans,
    isUnlimited,
    unlimited: isUnlimited
  };
  const state = reactExports.useMemo(() => {
    var _a3;
    if (!summary) return null;
    if (hasUnlimited) return "unlimited";
    const credits = (_a3 = summary.creditsRemaining) != null ? _a3 : 0;
    if (credits <= 0) return "empty";
    if (credits <= 5) return "low";
    return "ok";
  }, [summary, hasUnlimited]);
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, alignItems: "center", sx: { mb: 2 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 16 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { size: "small", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(BoltIcon, {}), label: "Checking credits" })
    ] });
  }
  if (!summary) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 1, sx: { mb: 2 }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Chip,
      {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(BoltIcon, {}),
        label: hasUnlimited ? "Unlimited scans" : `Scans left: ${summary.creditsRemaining === Infinity || summary.creditsRemaining === Number.POSITIVE_INFINITY ? "" : (_b = summary.creditsRemaining) != null ? _b : 0}`,
        color: hasUnlimited ? "primary" : state === "ok" ? "success" : state === "low" ? "warning" : "default",
        variant: "outlined",
        onClick: () => window.location.reload(),
        sx: hasUnlimited ? {
          background: "linear-gradient(135deg, rgba(255, 215, 0, 0.2) 0%, rgba(255, 165, 0, 0.2) 100%)",
          border: "1px solid rgba(255, 215, 0, 0.5)"
        } : void 0
      }
    ),
    state === "low" && !hasUnlimited && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Alert,
      {
        severity: "warning",
        action: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { color: "inherit", size: "small", onClick: onBuyCredits, children: "Buy top-up" }),
        children: "Only a few scans remaining. Top up before your next session."
      }
    ),
    state === "empty" && !hasUnlimited && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Alert,
      {
        severity: "error",
        action: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { color: "inherit", size: "small", onClick: onBuyCredits, children: "Add scans" }),
        children: "You're out of scans. Add a top-up pack or upgrade membership."
      }
    )
  ] });
}
function logEvent(_0) {
  return __async(this, arguments, function* (eventName, context = {}) {
    var _a2;
    try {
      let token2 = null;
      if (supabase) {
        const { data: { session } } = yield supabase.auth.getSession();
        token2 = (session == null ? void 0 : session.access_token) || null;
      }
      yield fetch(`${API_BASE}/api/analytics/events`, {
        method: "POST",
        headers: __spreadValues({
          "Content-Type": "application/json"
        }, token2 ? { Authorization: `Bearer ${token2}` } : {}),
        body: JSON.stringify({
          event_name: eventName,
          context,
          platform: ((_a2 = navigator == null ? void 0 : navigator.userAgentData) == null ? void 0 : _a2.platform) || (navigator == null ? void 0 : navigator.platform) || "unknown",
          session_id: localStorage.getItem("ss-session-id")
        })
      });
    } catch (err) {
      console.warn("[analytics] Failed to send event", eventName, err);
    }
  });
}
function BuyScansModal({ open, onClose, currentTier = "free", creditsRemaining = 0 }) {
  const [packages, setPackages] = reactExports.useState([]);
  const [role, setRole] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(true);
  const [purchasing, setPurchasing] = reactExports.useState(false);
  const [error2, setError] = reactExports.useState(null);
  const [success, setSuccess] = reactExports.useState(null);
  reactExports.useEffect(() => {
    if (open) {
      logEvent("credits_modal_opened");
      fetchPackages();
    }
  }, [open]);
  const fetchPackages = () => __async(null, null, function* () {
    setLoading(true);
    setError(null);
    try {
      let token2 = null;
      if (supabase) {
        const { data: { session } } = yield supabase.auth.getSession();
        token2 = (session == null ? void 0 : session.access_token) || null;
      }
      const headers = token2 ? { Authorization: `Bearer ${token2}` } : {};
      const response = yield fetch(`${API_BASE}/api/credits/packages`, { headers });
      const data = yield response.json();
      if (!response.ok || !data.success) {
        throw new Error(data.error || "Unable to load packages");
      }
      setPackages(Array.isArray(data.packages) ? data.packages : []);
      setRole(data.role || null);
    } catch (err) {
      console.error("Failed to fetch packages:", err);
      setError(err.message || "Failed to load packages");
    } finally {
      setLoading(false);
    }
  });
  const handlePurchasePackage = (packageId) => __async(null, null, function* () {
    logEvent("credits_cta_clicked", { type: "top_up", packageId });
    setPurchasing(true);
    setError(null);
    setSuccess(null);
    try {
      const { data: { session } } = yield supabase.auth.getSession();
      if (!session) {
        setError("Please sign in to purchase credits");
        setPurchasing(false);
        return;
      }
      setError("Top-up purchases are coming soon! Contact support and mention the package you want.");
    } catch (err) {
      console.error("Purchase error:", err);
      setError("Purchase failed. Please try again.");
    } finally {
      setPurchasing(false);
    }
  });
  const handleUpgradeTier = (tierId) => __async(null, null, function* () {
    logEvent("credits_cta_clicked", { type: "membership", tierId });
    setPurchasing(true);
    setError(null);
    setSuccess(null);
    try {
      const { data: { session } } = yield supabase.auth.getSession();
      if (!session) {
        setError("Please sign in to upgrade");
        setPurchasing(false);
        return;
      }
      setError("Membership billing inside the app is coming soon. Contact support to upgrade manually.");
    } catch (err) {
      console.error("Upgrade error:", err);
      setError("Upgrade failed. Please try again.");
    } finally {
      setPurchasing(false);
    }
  });
  const tierAliases = reactExports.useMemo(() => ({
    premium: "monthly_member",
    member: "monthly_member",
    moderator: "monthly_member"
  }), []);
  const normalizedTier = reactExports.useMemo(() => {
    const lowered = (currentTier || "").toLowerCase();
    return tierAliases[lowered] || lowered || "free";
  }, [currentTier, tierAliases]);
  const packageGroups = reactExports.useMemo(() => {
    return {
      appUnlock: packages.find((pkg) => pkg.type === "app_purchase"),
      membership: packages.find((pkg) => pkg.type === "membership"),
      topUps: packages.filter((pkg) => pkg.type === "top_up")
    };
  }, [packages]);
  const priceLabel = (pkg) => {
    if (!pkg) return "";
    return `$${pkg.effectivePrice.toFixed(2)}`;
  };
  const perScanLabel = (pkg) => {
    if (!(pkg == null ? void 0 : pkg.credits)) return "";
    const cost = pkg.effectivePrice / pkg.credits;
    if (cost < 1) return `${(cost * 100).toFixed(1)} per scan`;
    return `$${cost.toFixed(2)} per scan`;
  };
  const renderPriceStack = (pkg, { showRecurringLabel = false } = {}) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h4", color: "primary", gutterBottom: true, children: [
      priceLabel(pkg),
      showRecurringLabel && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { component: "span", variant: "body2", color: "text.secondary", children: "/month" })
    ] }),
    (pkg == null ? void 0 : pkg.moderatorDiscount) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", color: "text.secondary", sx: { textDecoration: "line-through" }, children: [
      "$",
      pkg.price.toFixed(2)
    ] })
  ] });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Dialog,
    {
      open,
      onClose,
      maxWidth: "md",
      fullWidth: true,
      PaperProps: {
        sx: {
          background: "linear-gradient(135deg, rgba(18, 18, 18, 0.98) 0%, rgba(30, 30, 30, 0.98) 100%)",
          backdropFilter: "blur(20px)",
          border: "1px solid rgba(124, 179, 66, 0.2)"
        }
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogTitle, { sx: {
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          borderBottom: "1px solid rgba(124, 179, 66, 0.2)"
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", gap: 1 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(BoltIcon, { sx: { color: "#7CB342" } }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", children: "Get More Scans" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: onClose, size: "small", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {}) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent, { sx: { mt: 2 }, children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", justifyContent: "center", p: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {}) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mb: 2 }, onClose: () => setError(null), children: error2 }),
          success && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "success", sx: { mb: 2 }, children: success }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 3, p: 2, background: "rgba(124, 179, 66, 0.1)", borderRadius: 2 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", color: "text.secondary", children: [
              "Current Plan: ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: normalizedTier.replace("_", " ").toUpperCase() })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", color: "text.secondary", children: [
              "Scans Remaining: ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: creditsRemaining })
            ] })
          ] }),
          (packageGroups.appUnlock || packageGroups.membership) && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h6", sx: { mb: 2, display: "flex", alignItems: "center", gap: 1 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(StarIcon, { sx: { color: "#FFD700" } }),
              "Membership & Unlocks"
            ] }),
            role === "moderator" && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "info", sx: { mb: 2 }, children: "Moderator pricing applied automatically." }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "grid", gridTemplateColumns: { xs: "1fr", sm: "1fr 1fr" }, gap: 2, mb: 4 }, children: [
              packageGroups.appUnlock && normalizedTier === "free" && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Card,
                {
                  sx: {
                    background: "linear-gradient(135deg, rgba(124, 179, 66, 0.12) 0%, rgba(156, 204, 101, 0.08) 100%)",
                    border: "1px solid rgba(124, 179, 66, 0.25)"
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", gutterBottom: true, children: "Unlock StrainSpotter" }),
                      renderPriceStack(packageGroups.appUnlock),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body1", color: "text.secondary", gutterBottom: true, children: [
                        packageGroups.appUnlock.scans,
                        " starter scans (one-time)"
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "Own the app forever and unlock Groups, Grower tools, and the Garden." })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(CardActions, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Button,
                      {
                        fullWidth: true,
                        variant: "contained",
                        color: "primary",
                        disabled: purchasing,
                        onClick: () => handleUpgradeTier("app_purchase"),
                        children: [
                          "Unlock for ",
                          priceLabel(packageGroups.appUnlock)
                        ]
                      }
                    ) })
                  ]
                },
                "app_purchase"
              ),
              packageGroups.membership && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Card,
                {
                  sx: {
                    background: "linear-gradient(135deg, rgba(124, 179, 66, 0.15) 0%, rgba(156, 204, 101, 0.12) 100%)",
                    border: "1px solid rgba(124, 179, 66, 0.35)",
                    position: "relative"
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Chip,
                      {
                        label: "BEST VALUE",
                        size: "small",
                        color: "success",
                        sx: { position: "absolute", top: -10, right: 12, fontWeight: 700 }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", gutterBottom: true, children: "Monthly Member" }),
                      renderPriceStack(packageGroups.membership, { showRecurringLabel: true }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body1", color: "text.secondary", gutterBottom: true, children: [
                        packageGroups.membership.scansPerMonth || 200,
                        " scans/month + community perks"
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "Includes Groups, Grow Coach, Grower Directory, error reporting, and more." }),
                      packageGroups.membership.moderatorDiscount && /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Chip,
                        {
                          label: `${packageGroups.membership.moderatorDiscount.percent}% moderator discount`,
                          size: "small",
                          color: "success",
                          sx: { mt: 1 }
                        }
                      )
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(CardActions, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Button,
                      {
                        fullWidth: true,
                        variant: "contained",
                        color: "primary",
                        disabled: purchasing || normalizedTier === "monthly_member",
                        onClick: () => handleUpgradeTier("monthly_member"),
                        children: normalizedTier === "monthly_member" ? "Membership Active" : "Upgrade to Monthly Member"
                      }
                    ) })
                  ]
                },
                "monthly_member"
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h6", sx: { mb: 2, display: "flex", alignItems: "center", gap: 1 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(OfferIcon, { sx: { color: "#7CB342" } }),
            "Buy Credit Packs"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "grid", gridTemplateColumns: { xs: "1fr", sm: "1fr 1fr" }, gap: 2 }, children: packageGroups.topUps.map((pkg) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Card,
            {
              sx: {
                background: "rgba(255, 255, 255, 0.05)",
                border: "1px solid rgba(124, 179, 66, 0.2)",
                transition: "all 0.2s ease",
                "&:hover": {
                  transform: "translateY(-2px)",
                  border: "1px solid rgba(124, 179, 66, 0.5)"
                }
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h6", gutterBottom: true, children: [
                    pkg.credits,
                    " Scans"
                  ] }),
                  renderPriceStack(pkg),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: perScanLabel(pkg) }),
                  pkg.moderatorDiscount && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Chip,
                    {
                      label: `${pkg.moderatorDiscount.percent}% moderator discount`,
                      size: "small",
                      color: "success",
                      sx: { mt: 1 }
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(CardActions, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    fullWidth: true,
                    variant: "outlined",
                    color: "primary",
                    disabled: purchasing,
                    onClick: () => handlePurchasePackage(pkg.id),
                    children: "Buy Now"
                  }
                ) })
              ]
            },
            pkg.id
          )) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActions, { sx: { borderTop: "1px solid rgba(124, 179, 66, 0.2)", p: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onClose, color: "inherit", children: "Close" }) })
      ]
    }
  );
}
const ADMIN_EMAILS = [
  "topher.cook7@gmail.com",
  "andrewbeck209@gmail.com",
  "strainspotter25feedback@gmail.com"
];
function isAdminEmail(email) {
  if (!email) return false;
  return ADMIN_EMAILS.includes(email.toLowerCase());
}
function authHeaders() {
  return __async(this, null, function* () {
    if (!supabase) return {};
    const { data: { session } } = yield supabase.auth.getSession();
    const token2 = session == null ? void 0 : session.access_token;
    return token2 ? { Authorization: `Bearer ${token2}` } : {};
  });
}
function AdminStatus({ onBack, onNavigate }) {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _i;
  const { user, loading } = useAuth();
  const [health, setHealth] = reactExports.useState(null);
  const [apiHealth, setApiHealth] = reactExports.useState(null);
  const [analytics, setAnalytics] = reactExports.useState(null);
  const [error2, setError] = reactExports.useState(null);
  const isAdmin = reactExports.useMemo(() => isAdminEmail(user == null ? void 0 : user.email), [user]);
  reactExports.useEffect(() => {
    if (loading || !isAdmin) return;
    (() => __async(null, null, function* () {
      try {
        const headers = yield authHeaders();
        const [rootHealth, apiHealthResp, analyticsSummary] = yield Promise.all([
          fetch(`${API_BASE}/health`).then((res) => res.json()),
          fetch(`${API_BASE}/api/health`).then((res) => res.json()),
          fetch(`${API_BASE}/api/analytics/events/summary`, { headers }).then((res) => res.json())
        ]);
        setHealth(rootHealth);
        setApiHealth(apiHealthResp);
        setAnalytics(analyticsSummary);
      } catch (err) {
        console.error("[AdminStatus] Failed to load status:", err);
        setError(err.message || "Unable to load status page.");
      }
    }))();
  }, [loading, isAdmin]);
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { minHeight: "100vh", display: "flex", alignItems: "center", justifyContent: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {}) });
  }
  if (!isAdmin) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { maxWidth: "sm", sx: { py: 6 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mb: 2 }, children: "Admin-only page. Please sign in with an approved admin account." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "contained", onClick: onBack, children: "Back" })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { minHeight: "100vh", py: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { maxWidth: "lg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "space-between", alignItems: "center", sx: { mb: 3 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, alignItems: "center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(HealthAndSafetyIcon, { color: "success" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h5", fontWeight: 800, children: "Status & Debug" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outlined", onClick: onBack, children: "Back" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "contained", startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(TroubleshootIcon, {}), onClick: () => onNavigate == null ? void 0 : onNavigate("errors"), children: "Admin Errors" })
      ] })
    ] }),
    error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mb: 3 }, children: error2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { container: true, spacing: 2, sx: { mb: 3 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", gutterBottom: true, children: "Environment" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 1, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: `Mode: ${"production"}`, size: "small" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: `API Base: ${API_BASE}`, size: "small", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(LinkIcon, {}) }),
          ((_a2 = apiHealth == null ? void 0 : apiHealth.rls) == null ? void 0 : _a2.mode) && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Chip,
            {
              label: `RLS Mode: ${apiHealth.rls.mode}`,
              size: "small",
              color: apiHealth.rls.mode === "prod" ? "success" : "default"
            }
          )
        ] })
      ] }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", gutterBottom: true, children: "Backend Health" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 1, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Chip,
            {
              label: `Supabase: ${(health == null ? void 0 : health.supabaseConfigured) ? "OK" : "Missing"}`,
              color: (health == null ? void 0 : health.supabaseConfigured) ? "success" : "error",
              size: "small"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Chip,
            {
              label: `Vision: ${(health == null ? void 0 : health.googleVisionConfigured) ? health == null ? void 0 : health.visionMethod : "Missing"}`,
              color: (health == null ? void 0 : health.googleVisionConfigured) ? "success" : "warning",
              size: "small"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Chip,
            {
              label: `Bucket: ${(health == null ? void 0 : health.bucketExists) ? "Found" : "Missing"}`,
              color: (health == null ? void 0 : health.bucketExists) ? "success" : "warning",
              size: "small"
            }
          )
        ] })
      ] }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", gutterBottom: true, children: "Links" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 1, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "outlined",
              onClick: () => onNavigate == null ? void 0 : onNavigate("moderation"),
              children: "Moderation Dashboard"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "outlined",
              onClick: () => onNavigate == null ? void 0 : onNavigate("membership-admin"),
              children: "Membership Admin"
            }
          )
        ] })
      ] }) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { mb: 3 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, alignItems: "center", sx: { mb: 2 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(BarChartIcon, { color: "primary" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle1", fontWeight: 700, children: "Last 7 days of activity" })
      ] }),
      analytics ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 2, sx: { mb: 2, flexWrap: "wrap" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: `Scans started: ${(_c = (_b = analytics.scanStats) == null ? void 0 : _b.started) != null ? _c : 0}` }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: `Scans completed: ${(_e = (_d = analytics.scanStats) == null ? void 0 : _d.completed) != null ? _e : 0}` }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Chip,
            {
              label: `Success rate: ${((_f = analytics.scanStats) == null ? void 0 : _f.successRate) != null ? `${analytics.scanStats.successRate.toFixed(1)}%` : "n/a"}`
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: `Journal entries: ${(_h = (_g = analytics.totals) == null ? void 0 : _g.journal_entry_created) != null ? _h : 0}` })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, { sx: { my: 2 } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", gutterBottom: true, children: "Top matched strains" }),
        ((_i = analytics.topStrains) == null ? void 0 : _i.length) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { direction: "row", spacing: 1, flexWrap: "wrap", children: analytics.topStrains.map((strain) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          Chip,
          {
            label: `${strain.name} (${strain.count})`,
            color: "success",
            variant: "outlined"
          },
          strain.slug
        )) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "No scan activity logged yet." })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 24 })
    ] }) })
  ] }) });
}
function PasswordReset({ onBack }) {
  const [newPassword, setNewPassword] = reactExports.useState("");
  const [confirm2, setConfirm] = reactExports.useState("");
  const [loading, setLoading] = reactExports.useState(false);
  const [error2, setError] = reactExports.useState(null);
  const [info, setInfo] = reactExports.useState("");
  const [ready, setReady] = reactExports.useState(false);
  const [showPassword, setShowPassword] = reactExports.useState(false);
  reactExports.useEffect(() => {
    let timeout;
    let cleanup = false;
    timeout = setTimeout(() => __async(null, null, function* () {
      var _a2, _b;
      try {
        if (!supabase || !supabase.auth) {
          setError("Supabase client not initialized. Please reload the page.");
          return;
        }
        const { data, error: sessionError } = yield supabase.auth.getSession();
        console.log("[PasswordReset] Session check:", ((_b = (_a2 = data == null ? void 0 : data.session) == null ? void 0 : _a2.user) == null ? void 0 : _b.email) || "none");
        if (data == null ? void 0 : data.session) {
          setReady(true);
          setInfo("Enter a new password below to complete the reset.");
          if (!cleanup && typeof window !== "undefined") {
            setTimeout(() => {
              history.replaceState(null, "", window.location.pathname + window.location.search);
            }, 500);
          }
        } else {
          console.error("[PasswordReset] No session found:", sessionError);
          setError("Recovery link is invalid or expired. Please request a new reset email from the Sign In screen.");
        }
      } catch (err) {
        console.error("[PasswordReset] Session error:", err);
        setError("Unable to validate session. Please request a new reset link.");
      }
    }), 1500);
    return () => {
      cleanup = true;
      clearTimeout(timeout);
    };
  }, []);
  function updatePassword() {
    return __async(this, null, function* () {
      var _a2;
      if (newPassword.length < 6) {
        setError("Password must be at least 6 characters.");
        return;
      }
      if (newPassword !== confirm2) {
        setError("Passwords do not match.");
        return;
      }
      setLoading(true);
      setError(null);
      setInfo(null);
      try {
        console.log("[PasswordReset] Updating password");
        const { data, error: error22 } = yield supabase.auth.updateUser({ password: newPassword });
        if (error22) {
          console.error("[PasswordReset] Error:", error22);
          setError(error22.message);
        } else {
          console.log("[PasswordReset] Password updated successfully");
          if ((_a2 = data == null ? void 0 : data.user) == null ? void 0 : _a2.id) {
            try {
              yield fetch(`${"https://strainspotter.onrender.com"}/api/users/ensure`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ user_id: data.user.id })
              });
            } catch (err) {
              console.warn("[PasswordReset] Failed to ensure user record:", err);
            }
          }
          setInfo(" Password updated! You are now signed in. Redirecting to home...");
          setTimeout(() => {
            if (onBack) {
              onBack();
            } else {
              window.location.hash = "#/";
            }
          }, 2e3);
        }
      } catch (err) {
        console.error("[PasswordReset] Catch error:", err);
        setError("Failed to update password. Please try again.");
      } finally {
        setLoading(false);
      }
    });
  }
  function goToLogin() {
    if (onBack) {
      onBack();
      setTimeout(() => {
        window.location.hash = "#/login";
      }, 100);
    } else {
      window.location.hash = "#/login";
    }
  }
  function goHome() {
    if (onBack) {
      onBack();
    } else {
      window.location.hash = "#/";
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { maxWidth: 420, mx: "auto", py: 4 }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        onClick: goHome,
        size: "small",
        variant: "contained",
        sx: {
          mb: 2,
          bgcolor: "#7CB342",
          color: "white",
          textTransform: "none",
          fontWeight: 700,
          borderRadius: 999,
          "&:hover": { bgcolor: "#689f38" }
        },
        children: " Home"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h5", children: "Reset Password" }),
      info && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "success", children: info }),
      error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", children: error2 }),
      ready ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: "New Password",
            type: showPassword ? "text" : "password",
            value: newPassword,
            onChange: (e) => setNewPassword(e.target.value),
            fullWidth: true,
            autoComplete: "new-password",
            helperText: /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Button,
              {
                size: "small",
                onClick: () => setShowPassword(!showPassword),
                sx: { textTransform: "none", p: 0, minWidth: 0 },
                children: [
                  showPassword ? "Hide" : "Show",
                  " password"
                ]
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: "Confirm Password",
            type: showPassword ? "text" : "password",
            value: confirm2,
            onChange: (e) => setConfirm(e.target.value),
            fullWidth: true,
            autoComplete: "new-password"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "contained", onClick: updatePassword, disabled: loading, fullWidth: true, children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 20 }) : "Update Password & Sign In" })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: !error2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: "Verifying recovery link" }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Alert, { severity: "warning", sx: { mt: 1 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { mb: 1 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Link Expired" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { mb: 2 }, children: 'Password reset links expire after 1 hour. Please request a new one from the Sign In page using the "Forgot Password?" button.' }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 1, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "contained", onClick: goToLogin, fullWidth: true, children: "Go to Sign In & Request New Link" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outlined", onClick: goHome, fullWidth: true, children: "Back to Home" })
        ] })
      ] }) })
    ] }) }) })
  ] });
}
const STARTER_FREE_SCANS = 20;
const MEMBER_SCAN_CAP = 150;
const MEMBER_KEY = "strainspotter_is_member";
const STARTER_USED_KEY = "strainspotter_starter_scans_used";
const EXTRA_CREDITS_KEY = "strainspotter_extra_scan_credits";
const MEMBER_USED_KEY = "strainspotter_member_scans_used";
const TOPUP_PACKS = [
  { id: "pack_20", label: "20 scans", credits: 20 },
  { id: "pack_50", label: "50 scans", credits: 50 },
  { id: "pack_100", label: "100 scans", credits: 100 }
];
const MembershipContext = reactExports.createContext(null);
function MembershipProvider({ children }) {
  const [initialized, setInitialized] = reactExports.useState(false);
  const [isMember, setIsMember] = reactExports.useState(false);
  const [starterUsed, setStarterUsed] = reactExports.useState(0);
  const [extraCredits, setExtraCredits] = reactExports.useState(0);
  const [memberUsed, setMemberUsed] = reactExports.useState(0);
  reactExports.useEffect(() => {
    try {
      const storedMember = localStorage.getItem(MEMBER_KEY);
      const storedStarter = localStorage.getItem(STARTER_USED_KEY);
      const storedExtra = localStorage.getItem(EXTRA_CREDITS_KEY);
      const storedMemberUsed = localStorage.getItem(MEMBER_USED_KEY);
      if (storedMember === "true") {
        setIsMember(true);
      }
      if (storedStarter != null) {
        const n = parseInt(storedStarter, 10);
        if (!Number.isNaN(n) && n >= 0) setStarterUsed(n);
      }
      if (storedExtra != null) {
        const n = parseInt(storedExtra, 10);
        if (!Number.isNaN(n) && n >= 0) setExtraCredits(n);
      }
      if (storedMemberUsed != null) {
        const n = parseInt(storedMemberUsed, 10);
        if (!Number.isNaN(n) && n >= 0) setMemberUsed(n);
      }
    } catch (e) {
    } finally {
      setInitialized(true);
    }
  }, []);
  const persistMember = reactExports.useCallback((next2) => {
    setIsMember(next2);
    try {
      localStorage.setItem(MEMBER_KEY, next2 ? "true" : "false");
    } catch (e) {
    }
  }, []);
  const persistStarterUsed = reactExports.useCallback((next2) => {
    setStarterUsed(next2);
    try {
      localStorage.setItem(STARTER_USED_KEY, String(next2));
    } catch (e) {
    }
  }, []);
  const persistExtraCredits = reactExports.useCallback((next2) => {
    setExtraCredits(next2);
    try {
      localStorage.setItem(EXTRA_CREDITS_KEY, String(next2));
    } catch (e) {
    }
  }, []);
  const persistMemberUsed = reactExports.useCallback((next2) => {
    setMemberUsed(next2);
    try {
      localStorage.setItem(MEMBER_USED_KEY, String(next2));
    } catch (e) {
    }
  }, []);
  const starterRemaining = Math.max(0, STARTER_FREE_SCANS - starterUsed);
  const memberRemaining = Math.max(0, MEMBER_SCAN_CAP - memberUsed);
  const totalAvailableScans = isMember ? memberRemaining + extraCredits : starterRemaining + extraCredits;
  const registerScanConsumed = reactExports.useCallback(() => {
    if (isMember) {
      if (extraCredits > 0) {
        const nextExtra = Math.max(0, extraCredits - 1);
        persistExtraCredits(nextExtra);
      } else if (memberRemaining > 0) {
        const used = memberUsed + 1;
        persistMemberUsed(used);
      }
    } else {
      if (extraCredits > 0) {
        const nextExtra = Math.max(0, extraCredits - 1);
        persistExtraCredits(nextExtra);
      } else if (starterRemaining > 0) {
        const used = starterUsed + 1;
        persistStarterUsed(used);
      }
    }
  }, [
    isMember,
    extraCredits,
    starterRemaining,
    memberRemaining,
    starterUsed,
    memberUsed,
    persistExtraCredits,
    persistStarterUsed,
    persistMemberUsed
  ]);
  const markMember = reactExports.useCallback(() => {
    persistMember(true);
  }, [persistMember]);
  const resetMembership = reactExports.useCallback(() => {
    persistMember(false);
    persistStarterUsed(0);
    persistExtraCredits(0);
    persistMemberUsed(0);
  }, [persistMember, persistStarterUsed, persistExtraCredits, persistMemberUsed]);
  const applyTopupCredits = reactExports.useCallback(
    (credits) => {
      if (!credits || credits <= 0) return;
      const next2 = extraCredits + credits;
      persistExtraCredits(next2);
    },
    [extraCredits, persistExtraCredits]
  );
  const requestMembershipPurchase = reactExports.useCallback(() => {
    console.log("[Membership] requestMembershipPurchase()  hook for native IAP");
    markMember();
  }, [markMember]);
  const requestTopupPurchase = reactExports.useCallback(
    (packId) => {
      console.log(
        "[Membership] requestTopupPurchase()  hook for native IAP, packId=",
        packId
      );
      const pack = TOPUP_PACKS.find((p) => p.id === packId);
      if (!pack) return;
      applyTopupCredits(pack.credits);
    },
    [applyTopupCredits]
  );
  const value = {
    initialized,
    isMember,
    starterUsed,
    starterRemaining,
    memberUsed,
    memberRemaining,
    memberCap: MEMBER_SCAN_CAP,
    extraCredits,
    totalAvailableScans,
    starterCap: STARTER_FREE_SCANS,
    markMember,
    resetMembership,
    registerScanConsumed,
    applyTopupCredits,
    requestMembershipPurchase,
    requestTopupPurchase,
    topupPacks: TOPUP_PACKS
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MembershipContext.Provider, { value, children });
}
function useMembership() {
  const ctx = reactExports.useContext(MembershipContext);
  if (!ctx) {
    throw new Error("useMembership must be used within MembershipProvider");
  }
  return ctx;
}
function featureLabel(featureKey) {
  switch (featureKey) {
    case "garden":
      return "Garden";
    case "reviews":
      return "Reviews";
    case "logbook":
      return "Logbook";
    default:
      return "This feature";
  }
}
function FeatureGate({ featureKey, children }) {
  const {
    isMember,
    totalAvailableScans,
    requestMembershipPurchase,
    requestTopupPurchase
  } = useMembership();
  const label = featureLabel(featureKey);
  if (isMember) {
    return children;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        maxWidth: 520,
        mx: "auto",
        mt: 5,
        p: 3,
        borderRadius: 3,
        border: "1px solid rgba(134, 239, 172, 0.5)",
        background: "radial-gradient(circle at top, rgba(16, 185, 129, 0.16), rgba(10, 15, 10, 0.96))",
        boxShadow: "0 0 24px rgba(16, 185, 129, 0.35)",
        textAlign: "center"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", justifyContent: "center", mb: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CannabisLeafIcon, { sx: { fontSize: 40, color: "#4caf50" } }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h5", sx: { mb: 1, fontWeight: 700 }, children: "Members Only" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Typography,
          {
            variant: "body1",
            sx: { mb: 1.5, color: "rgba(255,255,255,0.9)" },
            children: [
              label,
              " unlocks when you join StrainSpotter as a member."
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Typography,
          {
            variant: "body2",
            sx: { mb: 2.5, color: "rgba(255,255,255,0.7)" },
            children: "Members get unlimited scans plus full access to Garden, Reviews, and Logbook tools to track grows, stash, and sessions."
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Stack,
          {
            direction: "row",
            spacing: 1.5,
            sx: { justifyContent: "center", flexWrap: "wrap" },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "contained",
                  size: "large",
                  onClick: requestMembershipPurchase,
                  sx: {
                    borderRadius: 999,
                    px: 4,
                    py: 1.1,
                    textTransform: "none",
                    fontWeight: 700,
                    background: "linear-gradient(135deg, #4caf50, #8bc34a)",
                    boxShadow: "0 0 18px rgba(76, 175, 80, 0.6)"
                  },
                  children: "Unlock membership"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outlined",
                  size: "large",
                  onClick: () => requestTopupPurchase("pack_20"),
                  sx: {
                    borderRadius: 999,
                    px: 3,
                    py: 1.1,
                    textTransform: "none",
                    fontWeight: 600,
                    borderColor: "rgba(148, 163, 184, 0.8)",
                    color: "rgba(226, 232, 240, 0.95)"
                  },
                  children: "Just buy scans"
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Typography,
          {
            variant: "caption",
            sx: { display: "block", mt: 2, color: "rgba(148,163,184,0.8)" },
            children: "You can keep scanning with top-ups even without membership, but members always get the best experience."
          }
        ),
        totalAvailableScans > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Typography,
          {
            variant: "caption",
            sx: {
              display: "block",
              mt: 0.75,
              color: "rgba(190, 242, 100, 0.9)"
            },
            children: "You still have some scan credits left for the scanner."
          }
        )
      ]
    }
  );
}
const Home$2 = React.lazy(() => __vitePreload(() => Promise.resolve().then(() => Home$1), true ? void 0 : void 0, import.meta.url));
const ScanPage$2 = React.lazy(() => __vitePreload(() => Promise.resolve().then(() => ScanPage$1), true ? void 0 : void 0, import.meta.url));
const HistoryPage$2 = React.lazy(() => __vitePreload(() => Promise.resolve().then(() => HistoryPage$1), true ? void 0 : void 0, import.meta.url));
const AnalyticsDashboard$2 = React.lazy(() => __vitePreload(() => Promise.resolve().then(() => AnalyticsDashboard$1), true ? void 0 : void 0, import.meta.url));
const theme = createTheme(muiThemeOverrides);
function App() {
  const [ageVerified, setAgeVerified] = reactExports.useState(false);
  const [currentView, setCurrentView] = reactExports.useState("home");
  const [activeScan, setActiveScan] = reactExports.useState(null);
  const [showIntro, setShowIntro] = reactExports.useState(() => {
    if (typeof window === "undefined") {
      return false;
    }
    try {
      return localStorage.getItem("ss_intro_complete") !== "true";
    } catch (e) {
      return false;
    }
  });
  const [showGlobalBuyScans, setShowGlobalBuyScans] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const verified = localStorage.getItem("strainspotter_age_verified");
    if (verified === "true") {
      setAgeVerified(true);
    }
    if (typeof window !== "undefined" && window.location.hash) {
      const hash2 = window.location.hash;
      if (hash2 === "#/emergency-logout") {
        setCurrentView("emergency-logout");
      } else if (/type=recovery/.test(hash2)) {
        setCurrentView("reset");
      } else if (/access_token=/.test(hash2)) {
        setCurrentView("home");
        (() => __async(null, null, function* () {
          var _a2;
          try {
            const { data } = yield supabase.auth.getSession();
            const user = (_a2 = data == null ? void 0 : data.session) == null ? void 0 : _a2.user;
            if (user == null ? void 0 : user.id) {
              const email = user.email || void 0;
              const username = email ? email.split("@")[0] : void 0;
              yield fetch(`${API_BASE}/api/users/ensure`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ user_id: user.id, email, username })
              });
            }
          } catch (e) {
            console.warn("[onboard] ensure user after magic link failed:", e);
          }
        }))();
        setTimeout(() => {
          history.replaceState(null, "", window.location.pathname + window.location.search);
        }, 1e3);
      }
    }
  }, []);
  reactExports.useEffect(() => {
    const handler = (event) => {
      if (event == null ? void 0 : event.detail) {
        setCurrentView(event.detail);
      }
    };
    window.addEventListener("nav:set-view", handler);
    return () => window.removeEventListener("nav:set-view", handler);
  }, []);
  reactExports.useEffect(() => {
    logEvent("app_start", { mode: "production", apiBase: API_BASE });
  }, []);
  const handleAgeVerify = () => {
    localStorage.setItem("strainspotter_age_verified", "true");
    setAgeVerified(true);
  };
  if (!ageVerified) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(ThemeProvider, { theme, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(CssBaseline, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AgeGate, { onVerify: handleAgeVerify })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ThemeProvider, { theme, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(CssBaseline, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AuthProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ProModeProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(MembershipProvider, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(MobileOnlyGuard, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
          position: "fixed",
          inset: 0,
          zIndex: 0,
          backgroundImage: "url(/strainspotter-bg.jpg)",
          backgroundSize: "cover",
          backgroundPosition: "center"
        } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary2, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(GuidelinesGate, { children: [
          typeof window !== "undefined" && !/localhost|127\.0\.0\.1/.test(window.location.host) && /localhost:5181/.test("https://strainspotter.onrender.com") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { background: "#ff5555", color: "#fff", padding: "6px 12px", textAlign: "center", fontWeight: 700 }, children: "Warning: Frontend is calling localhost API_BASE. Update VITE_API_BASE or config.js." }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative", zIndex: 10 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(OnboardingFlow, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              FirstRunIntro,
              {
                open: showIntro,
                onFinish: () => {
                  try {
                    localStorage.setItem("ss_intro_complete", "true");
                  } catch (e) {
                  }
                  setShowIntro(false);
                  setCurrentView("home");
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ScanBalanceIndicator, { onBuyCredits: () => setShowGlobalBuyScans(true) }),
            currentView === "home" && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: null, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Home$2, { onNavigate: setCurrentView }) }),
            ["scanner", "guest-scan", "scan"].includes(currentView) && /* @__PURE__ */ jsxRuntimeExports.jsx(
              reactExports.Suspense,
              {
                fallback: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { padding: 16, color: "#C5E1A5" }, children: "Opening scanner" }),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ScanPage$2,
                  {
                    onBack: () => setCurrentView("home"),
                    onNavigate: (view) => setCurrentView(view),
                    onScanComplete: (scan) => {
                      setActiveScan(scan);
                      setCurrentView("result");
                    }
                  }
                )
              }
            ),
            currentView === "wizard" && /* @__PURE__ */ jsxRuntimeExports.jsx(
              ScanWizard,
              {
                onBack: () => setCurrentView("home"),
                onScanComplete: (scan) => {
                  setActiveScan(scan);
                  setCurrentView("result");
                }
              }
            ),
            currentView === "result" && activeScan && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Box,
              {
                sx: {
                  display: "flex",
                  flexDirection: "column",
                  height: "100vh",
                  overflow: "hidden",
                  bgcolor: "#000"
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Box,
                    {
                      sx: {
                        flexShrink: 0,
                        display: "flex",
                        alignItems: "center",
                        gap: 1.5,
                        p: 2,
                        borderBottom: "1px solid rgba(255,255,255,0.08)",
                        bgcolor: "rgba(0,0,0,0.3)",
                        backdropFilter: "blur(8px)",
                        zIndex: 1
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          Button,
                          {
                            variant: "text",
                            onClick: () => setCurrentView("home"),
                            sx: { color: "#fff", minWidth: "auto", px: 1 },
                            children: " Back"
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { fontWeight: 600, color: "#fff", flex: 1 }, children: "Scan Result" })
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Box,
                    {
                      sx: {
                        flex: 1,
                        minHeight: 0,
                        overflowY: "auto",
                        WebkitOverflowScrolling: "touch",
                        paddingBottom: "calc(env(safe-area-inset-bottom) + 80px)",
                        px: 2,
                        py: 2
                      },
                      children: !activeScan ? /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { flex: 1, display: "flex", alignItems: "center", justifyContent: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "Preparing your result" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                        ScanResultCard,
                        {
                          scan: activeScan,
                          result: activeScan,
                          isGuest: false,
                          onViewSeeds: ({ strainName, strainSlug }) => {
                            if (strainName || strainSlug) {
                              const searchTerm = encodeURIComponent(strainName || strainSlug);
                              window.open(`https://www.seedsman.com/en/search?q=${searchTerm}`, "_blank");
                            } else {
                              window.open("https://www.seedsman.com", "_blank");
                            }
                          }
                        }
                      )
                    }
                  )
                ]
              }
            ),
            currentView === "history" && /* @__PURE__ */ jsxRuntimeExports.jsx(FeatureGate, { featureKey: "logbook", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              ScanHistory,
              {
                onBack: () => setCurrentView("home"),
                onSelectScan: (scan) => {
                  setActiveScan(scan);
                  setCurrentView("result");
                }
              }
            ) }),
            currentView === "feedback" && /* @__PURE__ */ jsxRuntimeExports.jsx(FeedbackChat, { onBack: () => setCurrentView("home") }),
            currentView === "growers" && /* @__PURE__ */ jsxRuntimeExports.jsx(FeatureGate, { featureKey: "garden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(GrowerDirectory, { onNavigate: setCurrentView, onBack: () => setCurrentView("home") }) }),
            currentView === "register" && /* @__PURE__ */ jsxRuntimeExports.jsx(FeatureGate, { featureKey: "garden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(GrowerRegistration, { onBack: () => setCurrentView("home") }) }),
            currentView === "groups" && /* @__PURE__ */ jsxRuntimeExports.jsx(FeatureGate, { featureKey: "garden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Groups, { onNavigate: setCurrentView, onBack: () => setCurrentView("home") }) }),
            currentView === "friends" && /* @__PURE__ */ jsxRuntimeExports.jsx(FeatureGate, { featureKey: "garden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Friends, { onBack: () => setCurrentView("home") }) }),
            currentView === "seeds" && /* @__PURE__ */ jsxRuntimeExports.jsx(FeatureGate, { featureKey: "reviews", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Seeds, { onBack: () => setCurrentView("home") }) }),
            currentView === "dispensaries" && /* @__PURE__ */ jsxRuntimeExports.jsx(FeatureGate, { featureKey: "reviews", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Dispensaries, { onBack: () => setCurrentView("home") }) }),
            currentView === "grow-coach" && /* @__PURE__ */ jsxRuntimeExports.jsx(GrowCoach, { onBack: () => setCurrentView("home") }),
            currentView === "membership-join" && /* @__PURE__ */ jsxRuntimeExports.jsx(MembershipJoin, { onBack: () => setCurrentView("home") }),
            currentView === "help" && /* @__PURE__ */ jsxRuntimeExports.jsx(Help, { onNavigate: setCurrentView, onBack: () => setCurrentView("home") }),
            currentView === "login" && /* @__PURE__ */ jsxRuntimeExports.jsx(Auth, { onBack: () => setCurrentView("home") }),
            currentView === "admin-status" && /* @__PURE__ */ jsxRuntimeExports.jsx(AdminStatus, { onBack: () => setCurrentView("home"), onNavigate: setCurrentView }),
            currentView === "journal" && /* @__PURE__ */ jsxRuntimeExports.jsx(JournalPage, { onBack: () => setCurrentView("home") }),
            currentView === "strains" && /* @__PURE__ */ jsxRuntimeExports.jsx(FeatureGate, { featureKey: "reviews", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StrainBrowser, { onNavigate: setCurrentView }) }),
            currentView === "membership-admin" && /* @__PURE__ */ jsxRuntimeExports.jsx(MembershipAdmin, { onBack: () => setCurrentView("home") }),
            currentView === "pipeline" && /* @__PURE__ */ jsxRuntimeExports.jsx(PipelineStatus, { onBack: () => setCurrentView("home") }),
            currentView === "moderation" && /* @__PURE__ */ jsxRuntimeExports.jsx(ModerationDashboard, { onBack: () => setCurrentView("home") }),
            currentView === "guidelines" && /* @__PURE__ */ jsxRuntimeExports.jsx(Guidelines, { onBack: () => setCurrentView("home") }),
            currentView === "reset" && /* @__PURE__ */ jsxRuntimeExports.jsx(PasswordReset, { onBack: () => setCurrentView("home") }),
            currentView === "errors" && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorViewer, { onBack: () => setCurrentView("home") }),
            currentView === "emergency-logout" && /* @__PURE__ */ jsxRuntimeExports.jsx(EmergencyLogout, {}),
            currentView === "analytics" && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: null, children: /* @__PURE__ */ jsxRuntimeExports.jsx(AnalyticsDashboard$2, { onBack: () => setCurrentView("home") }) }),
            currentView === "history" && /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: null, children: /* @__PURE__ */ jsxRuntimeExports.jsx(HistoryPage$2, { onBack: () => setCurrentView("home") }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FloatingScanButton, { onClick: () => setCurrentView("scanner") })
          ] })
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(BuyScansModal, { open: showGlobalBuyScans, onClose: () => setShowGlobalBuyScans(false) })
    ] }) }) })
  ] });
}
const App$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: App
}, Symbol.toStringTag, { value: "Module" }));
function WebLanding() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        minHeight: "100vh",
        background: "linear-gradient(to bottom, rgba(5,7,5,0.95), rgba(10,20,10,0.98))",
        color: "#f5fff5",
        fontFamily: "system-ui, -apple-system, BlinkMacSystemFont, sans-serif"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              maxWidth: "960px",
              margin: "0 auto",
              padding: "80px 20px 60px",
              textAlign: "center"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    fontSize: "64px",
                    marginBottom: "16px"
                  },
                  children: ""
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "h1",
                {
                  style: {
                    fontSize: "clamp(2.5rem, 5vw, 4rem)",
                    fontWeight: 700,
                    margin: "0 0 24px",
                    background: "linear-gradient(135deg, #7CB342, #CDDC39)",
                    WebkitBackgroundClip: "text",
                    WebkitTextFillColor: "transparent",
                    backgroundClip: "text"
                  },
                  children: "StrainSpotter"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "p",
                {
                  style: {
                    fontSize: "clamp(1.125rem, 2vw, 1.5rem)",
                    margin: "0 0 40px",
                    opacity: 0.9,
                    lineHeight: 1.6,
                    maxWidth: "700px",
                    marginLeft: "auto",
                    marginRight: "auto"
                  },
                  children: "AI-powered cannabis scanner & community. Scan packages, decode labels, connect with growers and dispensaries."
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  style: {
                    display: "flex",
                    gap: "16px",
                    justifyContent: "center",
                    flexWrap: "wrap"
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Link$1,
                      {
                        to: "/app",
                        style: {
                          padding: "14px 28px",
                          borderRadius: "999px",
                          border: "none",
                          background: "linear-gradient(135deg, #7CB342, #9CCC65)",
                          color: "#04140a",
                          fontSize: "16px",
                          fontWeight: 600,
                          textDecoration: "none",
                          display: "inline-block",
                          boxShadow: "0 4px 12px rgba(124,179,66,0.4)"
                        },
                        children: "Launch App"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Link$1,
                      {
                        to: "/app",
                        style: {
                          padding: "14px 28px",
                          borderRadius: "999px",
                          border: "2px solid rgba(124,179,66,0.6)",
                          background: "transparent",
                          color: "#7CB342",
                          fontSize: "16px",
                          fontWeight: 600,
                          textDecoration: "none",
                          display: "inline-block"
                        },
                        children: "Sign In"
                      }
                    )
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              maxWidth: "960px",
              margin: "0 auto",
              padding: "60px 20px"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "section",
                {
                  style: {
                    marginBottom: "60px",
                    padding: "40px",
                    borderRadius: "16px",
                    background: "rgba(124,179,66,0.08)",
                    border: "1px solid rgba(124,179,66,0.2)"
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "h2",
                      {
                        style: {
                          fontSize: "2rem",
                          fontWeight: 700,
                          margin: "0 0 16px",
                          color: "#CDDC39"
                        },
                        children: "For Consumers"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "p",
                      {
                        style: {
                          fontSize: "1.125rem",
                          lineHeight: 1.7,
                          opacity: 0.9,
                          marginBottom: "24px"
                        },
                        children: "Point your camera at any cannabis package or bud. StrainSpotter instantly:"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "ul",
                      {
                        style: {
                          listStyle: "none",
                          padding: 0,
                          margin: 0
                        },
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { style: { marginBottom: "12px", paddingLeft: "24px", position: "relative" }, children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { position: "absolute", left: 0 }, children: "" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Scans labels & packages" }),
                            "  Reads THC/CBD, batch info, lab results"
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { style: { marginBottom: "12px", paddingLeft: "24px", position: "relative" }, children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { position: "absolute", left: 0 }, children: "" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Matches strains visually" }),
                            "  AI identifies closest strain matches"
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { style: { marginBottom: "12px", paddingLeft: "24px", position: "relative" }, children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { position: "absolute", left: 0 }, children: "" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Connects you to community" }),
                            "  Join groups, chat with growers & dispensaries"
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { style: { marginBottom: "12px", paddingLeft: "24px", position: "relative" }, children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { position: "absolute", left: 0 }, children: "" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "AI summaries" }),
                            "  Effects, use cases, and grower notes"
                          ] })
                        ]
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "section",
                {
                  style: {
                    marginBottom: "60px",
                    padding: "40px",
                    borderRadius: "16px",
                    background: "rgba(205,220,57,0.08)",
                    border: "1px solid rgba(205,220,57,0.2)"
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "h2",
                      {
                        style: {
                          fontSize: "2rem",
                          fontWeight: 700,
                          margin: "0 0 16px",
                          color: "#CDDC39"
                        },
                        children: "For Growers"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "p",
                      {
                        style: {
                          fontSize: "1.125rem",
                          lineHeight: 1.7,
                          opacity: 0.9,
                          marginBottom: "24px"
                        },
                        children: "Share your expertise and connect with the community:"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "ul",
                      {
                        style: {
                          listStyle: "none",
                          padding: 0,
                          margin: 0
                        },
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { style: { marginBottom: "12px", paddingLeft: "24px", position: "relative" }, children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { position: "absolute", left: 0 }, children: "" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Pin announcements" }),
                            "  Highlight important updates in group chats"
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { style: { marginBottom: "12px", paddingLeft: "24px", position: "relative" }, children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { position: "absolute", left: 0 }, children: "" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Grow logs & journals" }),
                            "  Document your cultivation journey"
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { style: { marginBottom: "12px", paddingLeft: "24px", position: "relative" }, children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { position: "absolute", left: 0 }, children: "" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Connect with dispensaries" }),
                            "  Build relationships and share knowledge"
                          ] })
                        ]
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "section",
                {
                  style: {
                    marginBottom: "60px",
                    padding: "40px",
                    borderRadius: "16px",
                    background: "rgba(124,179,66,0.08)",
                    border: "1px solid rgba(124,179,66,0.2)"
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "h2",
                      {
                        style: {
                          fontSize: "2rem",
                          fontWeight: 700,
                          margin: "0 0 16px",
                          color: "#CDDC39"
                        },
                        children: "For Dispensaries"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "p",
                      {
                        style: {
                          fontSize: "1.125rem",
                          lineHeight: 1.7,
                          opacity: 0.9,
                          marginBottom: "24px"
                        },
                        children: "Engage customers and showcase your products:"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "ul",
                      {
                        style: {
                          listStyle: "none",
                          padding: 0,
                          margin: 0
                        },
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { style: { marginBottom: "12px", paddingLeft: "24px", position: "relative" }, children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { position: "absolute", left: 0 }, children: "" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Pin menus & batch info" }),
                            "  Highlight new arrivals and lab results"
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { style: { marginBottom: "12px", paddingLeft: "24px", position: "relative" }, children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { position: "absolute", left: 0 }, children: "" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Customer support" }),
                            "  Answer questions in group chats"
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { style: { marginBottom: "12px", paddingLeft: "24px", position: "relative" }, children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { position: "absolute", left: 0 }, children: "" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Product discovery" }),
                            "  Help customers find the right strains"
                          ] })
                        ]
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "section",
                {
                  style: {
                    marginBottom: "60px",
                    padding: "40px",
                    borderRadius: "16px",
                    background: "rgba(124,179,66,0.08)",
                    border: "1px solid rgba(124,179,66,0.2)"
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "h2",
                      {
                        style: {
                          fontSize: "2rem",
                          fontWeight: 700,
                          margin: "0 0 16px",
                          color: "#CDDC39"
                        },
                        children: "How the Scanner Works"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "p",
                      {
                        style: {
                          fontSize: "1.125rem",
                          lineHeight: 1.7,
                          opacity: 0.9,
                          marginBottom: "24px"
                        },
                        children: "Our AI-powered scanner uses multiple steps to give you accurate results:"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "ol",
                      {
                        style: {
                          listStyle: "none",
                          padding: 0,
                          margin: 0,
                          counterReset: "step-counter"
                        },
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsxs(
                            "li",
                            {
                              style: {
                                marginBottom: "20px",
                                paddingLeft: "40px",
                                position: "relative",
                                counterIncrement: "step-counter"
                              },
                              children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsx(
                                  "span",
                                  {
                                    style: {
                                      position: "absolute",
                                      left: 0,
                                      width: "28px",
                                      height: "28px",
                                      borderRadius: "50%",
                                      background: "linear-gradient(135deg, #7CB342, #9CCC65)",
                                      display: "flex",
                                      alignItems: "center",
                                      justifyContent: "center",
                                      fontWeight: 700,
                                      fontSize: "0.875rem",
                                      color: "#04140a"
                                    },
                                    children: "1"
                                  }
                                ),
                                /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Vision & OCR" }),
                                "  Google Vision API extracts text and labels from your photo"
                              ]
                            }
                          ),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs(
                            "li",
                            {
                              style: {
                                marginBottom: "20px",
                                paddingLeft: "40px",
                                position: "relative",
                                counterIncrement: "step-counter"
                              },
                              children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsx(
                                  "span",
                                  {
                                    style: {
                                      position: "absolute",
                                      left: 0,
                                      width: "28px",
                                      height: "28px",
                                      borderRadius: "50%",
                                      background: "linear-gradient(135deg, #7CB342, #9CCC65)",
                                      display: "flex",
                                      alignItems: "center",
                                      justifyContent: "center",
                                      fontWeight: 700,
                                      fontSize: "0.875rem",
                                      color: "#04140a"
                                    },
                                    children: "2"
                                  }
                                ),
                                /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Visual Matching" }),
                                "  AI compares your image against 35,000+ strains in our database"
                              ]
                            }
                          ),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs(
                            "li",
                            {
                              style: {
                                marginBottom: "20px",
                                paddingLeft: "40px",
                                position: "relative",
                                counterIncrement: "step-counter"
                              },
                              children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsx(
                                  "span",
                                  {
                                    style: {
                                      position: "absolute",
                                      left: 0,
                                      width: "28px",
                                      height: "28px",
                                      borderRadius: "50%",
                                      background: "linear-gradient(135deg, #7CB342, #9CCC65)",
                                      display: "flex",
                                      alignItems: "center",
                                      justifyContent: "center",
                                      fontWeight: 700,
                                      fontSize: "0.875rem",
                                      color: "#04140a"
                                    },
                                    children: "3"
                                  }
                                ),
                                /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Label Analysis" }),
                                "  Extracts product info, batch numbers, and lab results"
                              ]
                            }
                          ),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs(
                            "li",
                            {
                              style: {
                                marginBottom: "20px",
                                paddingLeft: "40px",
                                position: "relative",
                                counterIncrement: "step-counter"
                              },
                              children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsx(
                                  "span",
                                  {
                                    style: {
                                      position: "absolute",
                                      left: 0,
                                      width: "28px",
                                      height: "28px",
                                      borderRadius: "50%",
                                      background: "linear-gradient(135deg, #7CB342, #9CCC65)",
                                      display: "flex",
                                      alignItems: "center",
                                      justifyContent: "center",
                                      fontWeight: 700,
                                      fontSize: "0.875rem",
                                      color: "#04140a"
                                    },
                                    children: "4"
                                  }
                                ),
                                /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "AI Summary" }),
                                "  Generates effects, use cases, warnings, and grower insights"
                              ]
                            }
                          )
                        ]
                      }
                    )
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "footer",
          {
            style: {
              maxWidth: "960px",
              margin: "0 auto",
              padding: "40px 20px",
              borderTop: "1px solid rgba(124,179,66,0.2)",
              textAlign: "center",
              opacity: 0.7
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  style: {
                    display: "flex",
                    justifyContent: "center",
                    gap: "24px",
                    flexWrap: "wrap",
                    marginBottom: "16px"
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "#", style: { color: "#9CCC65", textDecoration: "none" }, children: "Privacy" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "#", style: { color: "#9CCC65", textDecoration: "none" }, children: "Terms" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "#", style: { color: "#9CCC65", textDecoration: "none" }, children: "Contact" })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { margin: 0, fontSize: "0.875rem" }, children: [
                " ",
                (/* @__PURE__ */ new Date()).getFullYear(),
                " StrainSpotter. All rights reserved."
              ] })
            ]
          }
        )
      ]
    }
  );
}
const WebLanding$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: WebLanding
}, Symbol.toStringTag, { value: "Module" }));
function WebAppShell() {
  const location = useLocation();
  const isAppRoute = location.pathname.startsWith("/app");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "web-app-shell",
      style: {
        minHeight: "100vh",
        display: "flex",
        flexDirection: "column",
        background: "#050705"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "nav",
          {
            className: "web-nav",
            style: {
              padding: "12px 20px",
              borderBottom: "1px solid rgba(124,179,66,0.2)",
              background: "rgba(5,7,5,0.95)",
              backdropFilter: "blur(10px)",
              display: "flex",
              alignItems: "center",
              justifyContent: "space-between",
              flexWrap: "wrap",
              gap: "16px",
              position: "sticky",
              top: 0,
              zIndex: 1e3
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Link$1,
                {
                  to: "/",
                  className: "web-nav-logo",
                  style: {
                    fontSize: "1.25rem",
                    fontWeight: 700,
                    color: "#7CB342",
                    textDecoration: "none",
                    display: "flex",
                    alignItems: "center",
                    gap: "8px"
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "StrainSpotter" })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: "web-nav-links",
                  style: {
                    display: "flex",
                    alignItems: "center",
                    gap: "20px"
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Link$1,
                      {
                        to: "/",
                        style: {
                          color: "#9CCC65",
                          textDecoration: "none",
                          fontSize: "0.9375rem",
                          transition: "color 0.2s"
                        },
                        onMouseEnter: (e) => e.target.style.color = "#CDDC39",
                        onMouseLeave: (e) => e.target.style.color = "#9CCC65",
                        children: "Home"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Link$1,
                      {
                        to: "/app",
                        style: {
                          color: isAppRoute ? "#CDDC39" : "#9CCC65",
                          textDecoration: "none",
                          fontSize: "0.9375rem",
                          fontWeight: isAppRoute ? 600 : 400,
                          transition: "color 0.2s"
                        },
                        onMouseEnter: (e) => !isAppRoute && (e.target.style.color = "#CDDC39"),
                        onMouseLeave: (e) => !isAppRoute && (e.target.style.color = "#9CCC65"),
                        children: "App"
                      }
                    )
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "main",
          {
            className: "web-app-main",
            style: {
              flex: 1,
              minHeight: 0,
              overflow: "auto"
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {})
          }
        )
      ]
    }
  );
}
const WebAppShell$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: WebAppShell
}, Symbol.toStringTag, { value: "Module" }));
function GardenGate({ onSuccess, onBack }) {
  const [mode, setMode] = reactExports.useState("welcome");
  const [loading, setLoading] = reactExports.useState(false);
  const [error2, setError] = reactExports.useState("");
  const [info, setInfo] = reactExports.useState("");
  const [checkingAuth, setCheckingAuth] = reactExports.useState(true);
  const [signupEmail, setSignupEmail] = reactExports.useState("");
  const [signupPassword, setSignupPassword] = reactExports.useState("");
  const [signupName, setSignupName] = reactExports.useState("");
  const [loginEmail, setLoginEmail] = reactExports.useState("");
  const [loginPassword, setLoginPassword] = reactExports.useState("");
  const [paymentComplete, setPaymentComplete] = reactExports.useState(false);
  const [pendingEmail, setPendingEmail] = reactExports.useState("");
  const authConfigured = isAuthConfigured();
  reactExports.useEffect(() => {
    if (!supabase) {
      setCheckingAuth(false);
      return;
    }
    let isMounted = true;
    const checkAuthStatus = () => __async(null, null, function* () {
      var _a2;
      if (!supabase) return;
      try {
        const { data: { session } } = yield supabase.auth.getSession();
        if (!isMounted) return;
        if (session == null ? void 0 : session.user) {
          const membership = (_a2 = session.user.user_metadata) == null ? void 0 : _a2.membership;
          if (membership === "club") {
            onSuccess == null ? void 0 : onSuccess();
          } else {
            setMode("payment");
          }
        }
      } catch (e) {
        console.error("Auth check failed:", e);
      } finally {
        if (isMounted) {
          setCheckingAuth(false);
        }
      }
    });
    checkAuthStatus();
    return () => {
      isMounted = false;
    };
  }, [onSuccess, supabase]);
  const handleSignup = () => __async(null, null, function* () {
    if (!supabase) {
      setError("Supabase authentication is not configured for this deployment. Please contact support.");
      return;
    }
    setError("");
    if (!signupEmail || !signupPassword || !signupName) {
      setError("Please fill in all fields");
      return;
    }
    setLoading(true);
    setInfo("");
    try {
      const { data, error: signupError } = yield supabase.auth.signUp({
        email: signupEmail,
        password: signupPassword,
        options: {
          data: {
            username: signupName,
            membership: "none"
            // Will be upgraded after payment
          },
          emailRedirectTo: typeof window !== "undefined" ? `${window.location.origin}/#/` : void 0
        }
      });
      if (signupError) throw signupError;
      if (data.user) {
        setPendingEmail(signupEmail);
        setMode("verify");
        setInfo("Check your inbox to confirm your email, then sign in.");
      }
    } catch (e) {
      setError(e.message || "Signup failed");
    } finally {
      setLoading(false);
    }
  });
  const handleLogin = () => __async(null, null, function* () {
    var _a2, _b;
    if (!supabase) {
      setError("Supabase authentication is not configured for this deployment. Please contact support.");
      return;
    }
    setError("");
    setInfo("");
    if (!loginEmail || !loginPassword) {
      setError("Please enter email and password");
      return;
    }
    setLoading(true);
    try {
      console.log(" Attempting login for:", loginEmail);
      const { data, error: loginError } = yield supabase.auth.signInWithPassword({
        email: loginEmail,
        password: loginPassword
      });
      console.log("Login response:", { data, error: loginError });
      if (loginError) {
        console.error("Login error:", loginError);
        throw loginError;
      }
      if ((_a2 = data.session) == null ? void 0 : _a2.user) {
        if (!data.session.user.email_confirmed_at) {
          yield supabase.auth.signOut();
          setMode("verify");
          setPendingEmail(loginEmail);
          setError("Please verify your email before entering the garden.");
          return;
        }
        console.log(" Login successful!", data.session.user);
        const membership = (_b = data.session.user.user_metadata) == null ? void 0 : _b.membership;
        console.log("Membership status:", membership);
        if (membership === "club") {
          console.log(" User is a club member, granting access");
          onSuccess == null ? void 0 : onSuccess();
        } else {
          console.log(" User needs to pay for membership");
          setMode("payment");
        }
      }
    } catch (e) {
      console.error(" Login failed:", e);
      setError(e.message || "Login failed");
    } finally {
      setLoading(false);
    }
  });
  const handleForgotPassword = () => __async(null, null, function* () {
    if (!supabase) return;
    if (!loginEmail) {
      setError('Enter your email first, then tap "Forgot password".');
      return;
    }
    setLoading(true);
    setError("");
    setInfo("");
    try {
      const redirectTo = typeof window !== "undefined" ? `${window.location.origin}/#/` : void 0;
      const { error: error22 } = yield supabase.auth.resetPasswordForEmail(loginEmail, { redirectTo });
      if (error22) throw error22;
      setInfo("Password reset email sent. Check your inbox.");
    } catch (err) {
      setError(err.message || "Failed to send reset email.");
    } finally {
      setLoading(false);
    }
  });
  const handleResendVerification = () => __async(null, null, function* () {
    if (!supabase || !pendingEmail) return;
    setLoading(true);
    setError("");
    setInfo("");
    try {
      const { error: error22 } = yield supabase.auth.resend({
        type: "signup",
        email: pendingEmail
      });
      if (error22) throw error22;
      setInfo("Verification email resent. Check your inbox.");
    } catch (err) {
      setError(err.message || "Failed to resend verification email.");
    } finally {
      setLoading(false);
    }
  });
  const handlePayment = () => __async(null, null, function* () {
    var _a2;
    if (!supabase) {
      setError("Supabase authentication is not configured for this deployment. Please contact support.");
      return;
    }
    setLoading(true);
    setError("");
    try {
      const { data: { user } } = yield supabase.auth.getUser();
      if (!user) throw new Error("Not logged in");
      const { error: updateError } = yield supabase.auth.updateUser({
        data: {
          membership: "club",
          membership_started: (/* @__PURE__ */ new Date()).toISOString(),
          payment_status: "active",
          subscription_tier: "premium"
        }
      });
      if (updateError) throw updateError;
      if (signupName && !((_a2 = user.user_metadata) == null ? void 0 : _a2.username)) {
        yield supabase.auth.updateUser({
          data: {
            username: signupName
          }
        });
      }
      setPaymentComplete(true);
      setTimeout(() => {
        onSuccess == null ? void 0 : onSuccess();
      }, 2e3);
    } catch (e) {
      setError(e.message || "Payment failed");
    } finally {
      setLoading(false);
    }
  });
  if (checkingAuth) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { minHeight: "100vh", display: "flex", alignItems: "center", justifyContent: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { sx: { color: "#7cb342" } }) });
  }
  if (!authConfigured) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { minHeight: "100vh", display: "flex", alignItems: "center", justifyContent: "center", p: 3 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper, { sx: { p: 4, borderRadius: 6, maxWidth: 420, textAlign: "center", bgcolor: "rgba(0,0,0,0.6)", color: "#fff" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h5", sx: { mb: 2, fontWeight: 700 }, children: "Authentication Offline" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: "The StrainSpotter authentication service is not configured for this deployment. Please reach out to the site administrator or try again later." }),
      onBack && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outlined", sx: { mt: 3, color: "#fff", borderColor: "rgba(255,255,255,0.4)" }, onClick: onBack, children: " Back" })
    ] }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
    minHeight: "100vh",
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "center",
    p: { xs: 2, sm: 3 }
  }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper, { sx: {
    p: { xs: 3, sm: 4 },
    borderRadius: 6,
    width: "100%",
    maxWidth: 480,
    textAlign: "center",
    background: "rgba(255,255,255,0.15)",
    backdropFilter: "blur(20px)",
    border: "2px solid rgba(124, 179, 66, 0.3)"
  }, children: [
    mode === "welcome" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h3", sx: { mb: 2, color: "#fff", fontWeight: 900 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 1, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { component: "img", src: "/hero.png?v=13", alt: "", sx: { width: 20, height: 20, filter: "drop-shadow(0 0 4px rgba(124, 179, 66, 0.6))" } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Enter the Garden" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { component: "img", src: "/hero.png?v=13", alt: "", sx: { width: 20, height: 20, filter: "drop-shadow(0 0 4px rgba(124, 179, 66, 0.6))" } })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", sx: { mb: 4, color: "#e0e0e0" }, children: "Join the StrainSpotter community to access exclusive features, unlimited scans, and connect with growers worldwide." }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "contained",
            size: "large",
            onClick: () => setMode("signup"),
            sx: {
              width: "100%",
              py: 2,
              fontSize: "1.1rem",
              fontWeight: 700,
              bgcolor: "rgba(124, 179, 66, 0.8)",
              "&:hover": { bgcolor: "rgba(124, 179, 66, 1)" }
            },
            children: "Sign Up & Join"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "outlined",
            size: "large",
            onClick: () => setMode("login"),
            sx: {
              width: "100%",
              py: 2,
              fontSize: "1.1rem",
              fontWeight: 700,
              color: "#fff",
              borderColor: "rgba(124, 179, 66, 0.6)",
              "&:hover": { borderColor: "rgba(124, 179, 66, 1)", bgcolor: "rgba(124, 179, 66, 0.1)" }
            },
            children: "I'm Already a Member"
          }
        ),
        onBack && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "text",
            onClick: onBack,
            sx: { color: "#ccc", mt: 2 },
            children: " Back to Home"
          }
        )
      ] })
    ] }),
    mode === "signup" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", sx: { mb: 3, color: "#fff", fontWeight: 900 }, children: "Create Account" }),
      error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mb: 2 }, children: error2 }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: "Full Name",
            value: signupName,
            onChange: (e) => setSignupName(e.target.value),
            fullWidth: true,
            sx: {
              "& .MuiOutlinedInput-root": { color: "#fff" },
              "& .MuiInputLabel-root": { color: "#ccc" },
              "& .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.5)" }
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: "Email",
            type: "email",
            value: signupEmail,
            onChange: (e) => setSignupEmail(e.target.value),
            fullWidth: true,
            sx: {
              "& .MuiOutlinedInput-root": { color: "#fff" },
              "& .MuiInputLabel-root": { color: "#ccc" },
              "& .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.5)" }
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: "Password",
            type: "password",
            value: signupPassword,
            onChange: (e) => setSignupPassword(e.target.value),
            fullWidth: true,
            sx: {
              "& .MuiOutlinedInput-root": { color: "#fff" },
              "& .MuiInputLabel-root": { color: "#ccc" },
              "& .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.5)" }
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "contained",
            onClick: handleSignup,
            disabled: loading,
            sx: {
              width: "100%",
              py: 2,
              fontSize: "1.1rem",
              fontWeight: 700,
              bgcolor: "rgba(124, 179, 66, 0.8)",
              "&:hover": { bgcolor: "rgba(124, 179, 66, 1)" }
            },
            children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 24, sx: { color: "#fff" } }) : "Continue to Payment"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "text",
            onClick: () => setMode("welcome"),
            sx: { color: "#ccc" },
            children: " Back"
          }
        )
      ] })
    ] }),
    mode === "login" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", sx: { mb: 3, color: "#fff", fontWeight: 900 }, children: "Welcome Back" }),
      error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mb: 2 }, children: error2 }),
      info && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "info", sx: { mb: 2 }, children: info }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: "Email",
            type: "email",
            value: loginEmail,
            onChange: (e) => setLoginEmail(e.target.value),
            fullWidth: true,
            sx: {
              "& .MuiOutlinedInput-root": { color: "#fff" },
              "& .MuiInputLabel-root": { color: "#ccc" },
              "& .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.5)" }
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: "Password",
            type: "password",
            value: loginPassword,
            onChange: (e) => setLoginPassword(e.target.value),
            fullWidth: true,
            sx: {
              "& .MuiOutlinedInput-root": { color: "#fff" },
              "& .MuiInputLabel-root": { color: "#ccc" },
              "& .MuiOutlinedInput-notchedOutline": { borderColor: "rgba(124, 179, 66, 0.5)" }
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "contained",
            onClick: handleLogin,
            disabled: loading,
            sx: {
              width: "100%",
              py: 2,
              fontSize: "1.1rem",
              fontWeight: 700,
              bgcolor: "rgba(124, 179, 66, 0.8)",
              "&:hover": { bgcolor: "rgba(124, 179, 66, 1)" }
            },
            children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 24, sx: { color: "#fff" } }) : "Login"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "text",
            onClick: handleForgotPassword,
            disabled: loading || !loginEmail,
            sx: { color: "#ccc" },
            children: "Forgot password?"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "text",
            onClick: () => setMode("welcome"),
            sx: { color: "#ccc" },
            children: " Back"
          }
        )
      ] })
    ] }),
    mode === "verify" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", sx: { mb: 2, color: "#fff", fontWeight: 900 }, children: "Confirm Your Email" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body1", sx: { mb: 3, color: "#e0e0e0" }, children: [
        "We sent a confirmation link to ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: pendingEmail || signupEmail || loginEmail || "your email" }),
        ". Tap the link, then return here to finish setting up your account."
      ] }),
      error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mb: 2 }, children: error2 }),
      info && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "info", sx: { mb: 2 }, children: info }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "contained",
            onClick: handleResendVerification,
            disabled: loading || !pendingEmail,
            sx: {
              width: "100%",
              py: 2,
              fontSize: "1.1rem",
              fontWeight: 700,
              bgcolor: "rgba(124, 179, 66, 0.8)",
              "&:hover": { bgcolor: "rgba(124, 179, 66, 1)" }
            },
            children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 24, sx: { color: "#fff" } }) : "Resend Verification Email"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "outlined",
            onClick: () => {
              setMode("login");
              setError("");
              setInfo("");
            },
            sx: { color: "#fff", borderColor: "rgba(124, 179, 66, 0.6)" },
            children: "Return to Sign In"
          }
        )
      ] })
    ] }),
    mode === "payment" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", sx: { mb: 2, color: "#fff", fontWeight: 900 }, children: "Join the Club" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", sx: { mb: 3, color: "#e0e0e0" }, children: "Unlock StrainSpotter (20 scans) and add Monthly Member for $4.99/month (200 scans/month + perks)" }),
      error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mb: 2 }, children: error2 }),
      paymentComplete ? /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "success", sx: { mb: 2 }, children: " Payment successful! Welcome to the Garden!" }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { p: 3, bgcolor: "rgba(0,0,0,0.3)", borderRadius: 2, mb: 2 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#fff", mb: 1 }, children: "Membership Benefits:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#e0e0e0", textAlign: "left" }, children: [
            " 200 AI scans per month + extra top-ups (50/200/500)",
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            " Leave reviews & ratings",
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            " Access to community groups",
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            " Grow coach & expert tips",
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            " Strain browser & database",
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            " Priority support"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "contained",
            onClick: handlePayment,
            disabled: loading,
            sx: {
              width: "100%",
              py: 2,
              fontSize: "1.1rem",
              fontWeight: 700,
              bgcolor: "rgba(124, 179, 66, 0.8)",
              "&:hover": { bgcolor: "rgba(124, 179, 66, 1)" }
            },
            children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 24, sx: { color: "#fff" } }) : "Pay $4.99/month"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { color: "#ccc", mt: 2 }, children: "Cancel anytime. No commitments." })
      ] })
    ] })
  ] }) });
}
function useMembershipGuard() {
  const [user, setUser] = reactExports.useState(null);
  const [isMember, setIsMember] = reactExports.useState(false);
  const [isExpired, setIsExpired] = reactExports.useState(false);
  const [loading, setLoading] = reactExports.useState(true);
  const checkMembership = reactExports.useCallback(() => __async(null, null, function* () {
    var _a2;
    try {
      const { data: { session } } = yield supabase.auth.getSession();
      const currentUser = (session == null ? void 0 : session.user) || null;
      setUser(currentUser);
      let inferredTier = null;
      if ((currentUser == null ? void 0 : currentUser.id) && (session == null ? void 0 : session.access_token)) {
        try {
          const resp = yield fetch(`${API_BASE}/api/credits/balance`, {
            headers: { Authorization: `Bearer ${session.access_token}` }
          });
          if (resp.ok) {
            const payload = yield resp.json();
            inferredTier = (payload == null ? void 0 : payload.tier) || null;
          }
        } catch (err) {
          console.warn("useMembershipGuard: failed to fetch credit balance", err);
        }
      }
      if (!inferredTier && currentUser) {
        const metadataTier = (((_a2 = currentUser.user_metadata) == null ? void 0 : _a2.membership) || "").toLowerCase();
        if (metadataTier.includes("club")) {
          inferredTier = "monthly_member";
        }
      }
      const normalizedTier = (inferredTier || "").toLowerCase();
      const memberTiers = /* @__PURE__ */ new Set(["monthly_member", "admin"]);
      setIsMember(memberTiers.has(normalizedTier));
      setIsExpired(false);
    } catch (e) {
      console.error("Membership check failed:", e);
    } finally {
      setLoading(false);
    }
  }), []);
  reactExports.useEffect(() => {
    checkMembership();
    const { data: { subscription } } = supabase.auth.onAuthStateChange(() => {
      checkMembership();
    });
    return () => subscription.unsubscribe();
  }, [checkMembership]);
  const adminEmails = /* @__PURE__ */ new Set([
    "topher.cook7@gmail.com",
    "andrewbeck209@gmail.com",
    "strainspotter25feedback@gmail.com",
    "strainspotter25@gmail.com",
    "admin@strainspotter.com"
  ]);
  const isAdmin = adminEmails.has(((user == null ? void 0 : user.email) || "").toLowerCase());
  const canLogout = isAdmin || !isMember || !isExpired;
  return {
    user,
    isMember,
    isExpired,
    canLogout,
    loading,
    refreshMembership: checkMembership
  };
}
function ReviewsHub({ onBack, currentUser }) {
  const [tab, setTab] = reactExports.useState(0);
  const [myReviews, setMyReviews] = reactExports.useState([]);
  const [allReviews, setAllReviews] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [editDialog, setEditDialog] = reactExports.useState(false);
  const [editingReview, setEditingReview] = reactExports.useState(null);
  const [editRating, setEditRating] = reactExports.useState(5);
  const [editComment, setEditComment] = reactExports.useState("");
  const fetchMyReviews = reactExports.useCallback(() => __async(null, null, function* () {
    if (!(currentUser == null ? void 0 : currentUser.id)) return;
    try {
      setLoading(true);
      const { data, error: error2 } = yield supabase.from("reviews").select("*, strains(name, slug, type)").eq("user_id", currentUser.id).order("created_at", { ascending: false });
      if (error2) throw error2;
      setMyReviews(data || []);
    } catch (error2) {
      console.error("Error fetching my reviews:", error2);
    } finally {
      setLoading(false);
    }
  }), [currentUser == null ? void 0 : currentUser.id]);
  const fetchAllReviews = reactExports.useCallback(() => __async(null, null, function* () {
    try {
      const { data, error: error2 } = yield supabase.from("reviews").select("*, strains(name, slug, type)").order("created_at", { ascending: false }).limit(50);
      if (error2) throw error2;
      setAllReviews(data || []);
    } catch (error2) {
      console.error("Error fetching all reviews:", error2);
    }
  }), []);
  reactExports.useEffect(() => {
    if (currentUser) {
      fetchMyReviews();
    }
    fetchAllReviews();
  }, [currentUser, fetchMyReviews, fetchAllReviews]);
  const handleEditClick = (review) => {
    setEditingReview(review);
    setEditRating(review.rating);
    setEditComment(review.comment || "");
    setEditDialog(true);
  };
  const handleUpdateReview = () => __async(null, null, function* () {
    try {
      const { error: error2 } = yield supabase.from("reviews").update({
        rating: editRating,
        comment: editComment,
        updated_at: (/* @__PURE__ */ new Date()).toISOString()
      }).eq("id", editingReview.id);
      if (error2) throw error2;
      setEditDialog(false);
      fetchMyReviews();
      fetchAllReviews();
    } catch (error2) {
      console.error("Error updating review:", error2);
      alert("Failed to update review");
    }
  });
  const handleDeleteReview = (reviewId) => __async(null, null, function* () {
    if (!confirm("Are you sure you want to delete this review?")) return;
    try {
      const { error: error2 } = yield supabase.from("reviews").delete().eq("id", reviewId);
      if (error2) throw error2;
      fetchMyReviews();
      fetchAllReviews();
    } catch (error2) {
      console.error("Error deleting review:", error2);
      alert("Failed to delete review");
    }
  });
  const getTypeColor = (type) => {
    switch (type == null ? void 0 : type.toLowerCase()) {
      case "indica":
        return "#9c27b0";
      case "sativa":
        return "#ff9800";
      case "hybrid":
        return "#4caf50";
      default:
        return "#757575";
    }
  };
  const ReviewCard = ({ review, showActions = false }) => {
    var _a2, _b;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: {
      background: "rgba(255,255,255,0.1)",
      backdropFilter: "blur(20px)",
      border: "1px solid rgba(124, 179, 66, 0.3)",
      borderRadius: 2,
      mb: 2
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", justifyContent: "space-between", alignItems: "flex-start", mb: 2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 1, flex: 1, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 1, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#fff", fontWeight: 600 }, children: ((_a2 = review.strains) == null ? void 0 : _a2.name) || "Unknown Strain" }),
            ((_b = review.strains) == null ? void 0 : _b.type) && /* @__PURE__ */ jsxRuntimeExports.jsx(
              Chip,
              {
                label: review.strains.type,
                size: "small",
                sx: {
                  bgcolor: getTypeColor(review.strains.type),
                  color: "#fff",
                  fontSize: "0.7rem",
                  height: 20
                }
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 2, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Rating, { value: review.rating, readOnly: true, size: "small" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { color: "#aaa" }, children: new Date(review.created_at).toLocaleDateString() })
          ] })
        ] }),
        showActions && /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton$1,
            {
              size: "small",
              onClick: () => handleEditClick(review),
              sx: { color: "#7cb342" },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(EditIcon, { fontSize: "small" })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton$1,
            {
              size: "small",
              onClick: () => handleDeleteReview(review.id),
              sx: { color: "#f44336" },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteIcon, { fontSize: "small" })
            }
          )
        ] })
      ] }),
      review.comment && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#e0e0e0", whiteSpace: "pre-line" }, children: review.comment })
    ] }) });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
    minHeight: "100vh",
    pt: "calc(env(safe-area-inset-top) + 32px)",
    px: 2,
    pb: 2,
    background: "none"
  }, children: [
    onBack && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        size: "small",
        variant: "outlined",
        onClick: onBack,
        startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowBackIcon, {}),
        sx: {
          color: "#fff",
          borderColor: "rgba(124, 179, 66, 0.6)",
          fontSize: "0.875rem",
          mb: 2,
          "&:hover": {
            borderColor: "rgba(124, 179, 66, 1)",
            bgcolor: "rgba(124, 179, 66, 0.1)"
          }
        },
        children: "Back"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 2, mb: 2, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(RateReviewIcon, { sx: { fontSize: 32, color: "#7cb342" } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h5", sx: { color: "#fff", fontWeight: 700 }, children: "Reviews Hub" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Paper, { sx: {
      mb: 2,
      background: "rgba(255,255,255,0.1)",
      backdropFilter: "blur(20px)",
      border: "1px solid rgba(124, 179, 66, 0.3)",
      borderRadius: 2
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Tabs,
      {
        value: tab,
        onChange: (e, v) => setTab(v),
        sx: {
          borderBottom: "1px solid rgba(124, 179, 66, 0.3)",
          "& .MuiTab-root": { color: "#fff" },
          "& .Mui-selected": { color: "#7cb342" }
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { label: `My Reviews (${myReviews.length})` }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { label: "Community Reviews" })
        ]
      }
    ) }),
    loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", justifyContent: "center", py: 8 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { sx: { color: "#7cb342" } }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: tab === 0 ? (
      // My Reviews
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: !currentUser ? /* @__PURE__ */ jsxRuntimeExports.jsx(Paper, { sx: {
        p: 4,
        textAlign: "center",
        background: "rgba(255,255,255,0.1)",
        backdropFilter: "blur(20px)",
        border: "1px solid rgba(124, 179, 66, 0.3)",
        borderRadius: 2
      }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#fff", mb: 2 }, children: "Please log in to view your reviews" }) }) : myReviews.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper, { sx: {
        p: 4,
        textAlign: "center",
        background: "rgba(255,255,255,0.1)",
        backdropFilter: "blur(20px)",
        border: "1px solid rgba(124, 179, 66, 0.3)",
        borderRadius: 2
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#fff", mb: 2 }, children: "You haven't written any reviews yet" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#e0e0e0" }, children: "Try strains and share your experience with the community!" })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: myReviews.map((review) => /* @__PURE__ */ jsxRuntimeExports.jsx(ReviewCard, { review, showActions: true }, review.id)) }) })
    ) : (
      // All Reviews
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: allReviews.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Paper, { sx: {
        p: 4,
        textAlign: "center",
        background: "rgba(255,255,255,0.1)",
        backdropFilter: "blur(20px)",
        border: "1px solid rgba(124, 179, 66, 0.3)",
        borderRadius: 2
      }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#fff" }, children: "No reviews yet" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: allReviews.map((review) => /* @__PURE__ */ jsxRuntimeExports.jsx(ReviewCard, { review, showActions: false }, review.id)) }) })
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Dialog,
      {
        open: editDialog,
        onClose: () => setEditDialog(false),
        maxWidth: "sm",
        fullWidth: true,
        fullScreen: true,
        PaperProps: {
          sx: {
            background: "rgba(30, 30, 30, 0.95)",
            backdropFilter: "blur(20px)",
            border: "2px solid rgba(124, 179, 66, 0.5)",
            borderRadius: { xs: 0, sm: 3 },
            m: 0,
            maxHeight: "100vh"
          }
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogTitle, { sx: { color: "#fff", borderBottom: "1px solid rgba(124, 179, 66, 0.3)", display: "flex", justifyContent: "space-between", alignItems: "center" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", children: "Edit Review" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: () => setEditDialog(false), sx: { color: "#fff" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowBackIcon, {}) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent, { sx: { pt: 3 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 3, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#e0e0e0", mb: 1 }, children: "Rating" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Rating,
                {
                  value: editRating,
                  onChange: (e, v) => setEditRating(v || 1),
                  size: "large"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                label: "Your Review",
                multiline: true,
                rows: 4,
                value: editComment,
                onChange: (e) => setEditComment(e.target.value),
                fullWidth: true,
                sx: {
                  "& .MuiOutlinedInput-root": {
                    color: "#fff",
                    "& fieldset": { borderColor: "rgba(124, 179, 66, 0.5)" },
                    "&:hover fieldset": { borderColor: "rgba(124, 179, 66, 0.7)" },
                    "&.Mui-focused fieldset": { borderColor: "#7cb342" }
                  },
                  "& .MuiInputLabel-root": { color: "#fff" }
                }
              }
            )
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions, { sx: { p: 2, borderTop: "1px solid rgba(124, 179, 66, 0.3)" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => setEditDialog(false), sx: { color: "#fff" }, children: "Cancel" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                onClick: handleUpdateReview,
                variant: "contained",
                sx: {
                  bgcolor: "#7cb342",
                  "&:hover": { bgcolor: "#689f38" }
                },
                children: "Update"
              }
            )
          ] })
        ]
      }
    )
  ] });
}
function FeedbackReader({ user, onBack }) {
  const [feedback, setFeedback] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [error2, setError] = reactExports.useState(null);
  const [refreshing, setRefreshing] = reactExports.useState(false);
  const [deleting, setDeleting] = reactExports.useState(null);
  const loadFeedback = () => __async(null, null, function* () {
    try {
      setRefreshing(true);
      const res = yield fetch(`${API_BASE}/api/feedback/messages`);
      if (!res.ok) {
        throw new Error("Failed to load feedback");
      }
      const data = yield res.json();
      setFeedback(data || []);
      setError(null);
    } catch (err) {
      console.error("Error loading feedback:", err);
      setError(err.message);
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  });
  const handleDelete = (messageId) => __async(null, null, function* () {
    if (!confirm("Are you sure you want to delete this feedback?")) {
      return;
    }
    try {
      setDeleting(messageId);
      const res = yield fetch(`${API_BASE}/api/feedback/messages/${messageId}`, {
        method: "DELETE",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ admin_user_id: user == null ? void 0 : user.id })
      });
      if (!res.ok) {
        const data = yield res.json();
        throw new Error(data.error || "Failed to delete feedback");
      }
      setFeedback((prev2) => prev2.filter((f) => f.id !== messageId));
    } catch (err) {
      console.error("Error deleting feedback:", err);
      alert("Failed to delete: " + err.message);
    } finally {
      setDeleting(null);
    }
  });
  reactExports.useEffect(() => {
    loadFeedback();
  }, []);
  const formatDate2 = (dateString) => {
    const date = new Date(dateString);
    const now = /* @__PURE__ */ new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 6e4);
    const diffHours = Math.floor(diffMs / 36e5);
    const diffDays = Math.floor(diffMs / 864e5);
    if (diffMins < 1) return "Just now";
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    if (diffDays < 7) return `${diffDays}d ago`;
    return date.toLocaleDateString("en-US", {
      month: "short",
      day: "numeric",
      year: date.getFullYear() !== now.getFullYear() ? "numeric" : void 0
    });
  };
  const formatFullDate = (dateString) => {
    return new Date(dateString).toLocaleString("en-US", {
      month: "long",
      day: "numeric",
      year: "numeric",
      hour: "numeric",
      minute: "2-digit",
      hour12: true
    });
  };
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
      minHeight: "100vh",
      background: "linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { sx: { color: "#7CB342" } }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
    minHeight: "100vh",
    background: "linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%)",
    py: 4,
    px: 2
  }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { maxWidth: 900, mx: "auto" }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Paper, { sx: {
      p: 3,
      mb: 3,
      background: "linear-gradient(135deg, rgba(124, 179, 66, 0.1) 0%, rgba(156, 204, 101, 0.05) 100%)",
      backdropFilter: "blur(10px)",
      border: "1px solid rgba(124, 179, 66, 0.2)",
      borderRadius: 3
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", justifyContent: "space-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { sx: {
          bgcolor: "#7CB342",
          width: 56,
          height: 56
        }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FeedbackIcon, { sx: { fontSize: 32 } }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", sx: {
            fontWeight: 700,
            color: "#fff",
            mb: 0.5
          }, children: "Feedback Reader" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "rgba(255,255,255,0.7)" }, children: [
            feedback.length,
            " ",
            feedback.length === 1 ? "submission" : "submissions"
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Refresh", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton$1,
          {
            onClick: loadFeedback,
            disabled: refreshing,
            sx: {
              color: "#7CB342",
              "&:hover": { bgcolor: "rgba(124, 179, 66, 0.1)" }
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshIcon, { sx: {
              animation: refreshing ? "spin 1s linear infinite" : "none",
              "@keyframes spin": {
                "0%": { transform: "rotate(0deg)" },
                "100%": { transform: "rotate(360deg)" }
              }
            } })
          }
        ) }),
        onBack && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Chip,
          {
            label: "Back",
            onClick: onBack,
            sx: {
              bgcolor: "rgba(124, 179, 66, 0.2)",
              color: "#7CB342",
              fontWeight: 600,
              "&:hover": { bgcolor: "rgba(124, 179, 66, 0.3)" }
            }
          }
        )
      ] })
    ] }) }),
    error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mb: 3 }, children: error2 }),
    !loading && feedback.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper, { sx: {
      p: 6,
      textAlign: "center",
      background: "rgba(255,255,255,0.05)",
      backdropFilter: "blur(10px)",
      border: "1px solid rgba(255,255,255,0.1)",
      borderRadius: 3
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(FeedbackIcon, { sx: { fontSize: 64, color: "rgba(255,255,255,0.3)", mb: 2 } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#fff", mb: 1 }, children: "No Feedback Yet" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "rgba(255,255,255,0.6)" }, children: "Feedback submissions will appear here" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 2, children: feedback.map((item, index2) => {
      var _a2, _b, _c, _d, _e, _f;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: {
        background: "rgba(255,255,255,0.05)",
        backdropFilter: "blur(10px)",
        border: "1px solid rgba(124, 179, 66, 0.2)",
        borderRadius: 2,
        transition: "all 0.3s ease",
        "&:hover": {
          transform: "translateY(-2px)",
          boxShadow: "0 8px 24px rgba(124, 179, 66, 0.2)",
          border: "1px solid rgba(124, 179, 66, 0.4)"
        }
      }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { sx: { p: 3 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", justifyContent: "space-between", mb: 2, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 1.5, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Avatar,
              {
                src: (_a2 = item.sender) == null ? void 0 : _a2.avatar_url,
                sx: {
                  bgcolor: "rgba(124, 179, 66, 0.2)",
                  width: 32,
                  height: 32
                },
                children: !((_b = item.sender) == null ? void 0 : _b.avatar_url) && /* @__PURE__ */ jsxRuntimeExports.jsx(PersonIcon, { sx: { fontSize: 18, color: "#7CB342" } })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: {
                color: "#7CB342",
                fontWeight: 600
              }, children: ((_c = item.sender) == null ? void 0 : _c.display_name) || ((_d = item.sender) == null ? void 0 : _d.username) || `User ${(_e = item.sender_id) == null ? void 0 : _e.substring(0, 8)}` }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 1, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 0.5, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(AccessTimeIcon, { sx: { fontSize: 14, color: "rgba(255,255,255,0.5)" } }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { color: "rgba(255,255,255,0.5)" }, children: formatDate2(item.created_at) })
                ] }),
                ((_f = item.sender) == null ? void 0 : _f.username) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", sx: { color: "rgba(255,255,255,0.4)" }, children: [
                  " @",
                  item.sender.username
                ] })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, alignItems: "center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: formatFullDate(item.created_at), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Chip,
              {
                label: item.message_type || "text",
                size: "small",
                sx: {
                  bgcolor: "rgba(124, 179, 66, 0.2)",
                  color: "#7CB342",
                  fontSize: "0.75rem",
                  fontWeight: 600
                }
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Delete feedback", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton$1,
              {
                size: "small",
                onClick: () => handleDelete(item.id),
                disabled: deleting === item.id,
                sx: {
                  color: "#ff5252",
                  "&:hover": {
                    bgcolor: "rgba(255, 82, 82, 0.1)"
                  }
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteIcon, { sx: { fontSize: 18 } })
              }
            ) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, { sx: { mb: 2, borderColor: "rgba(255,255,255,0.1)" } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: {
          color: "#fff",
          fontSize: "1rem",
          lineHeight: 1.6,
          whiteSpace: "pre-wrap",
          wordBreak: "break-word"
        }, children: item.content }),
        (item.is_flagged || item.is_moderated) && /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, mt: 2, children: [
          item.is_flagged && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Chip,
            {
              label: "Flagged",
              size: "small",
              color: "warning",
              sx: { fontSize: "0.7rem" }
            }
          ),
          item.is_moderated && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Chip,
            {
              label: `Moderated: ${item.moderation_action || "reviewed"}`,
              size: "small",
              color: "info",
              sx: { fontSize: "0.7rem" }
            }
          )
        ] })
      ] }) }, item.id || index2);
    }) })
  ] }) });
}
function CreditBalance({ summary: externalSummary, loading: externalLoading }) {
  var _a2, _b, _c;
  const { user } = useAuth();
  const shouldUseExternal = typeof externalSummary !== "undefined" || typeof externalLoading !== "undefined";
  const { remainingScans, isUnlimited, loading: internalLoading } = (_a2 = useCreditBalance == null ? void 0 : useCreditBalance()) != null ? _a2 : {};
  const isFounderSafe = Boolean(isUnlimited);
  const hasUnlimited = isUnlimited;
  const summary = shouldUseExternal ? externalSummary : {
    creditsRemaining: remainingScans
  };
  const loading = shouldUseExternal ? !!externalLoading : internalLoading;
  const credits = (_c = (_b = summary == null ? void 0 : summary.creditsRemaining) != null ? _b : remainingScans) != null ? _c : null;
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", alignItems: "center", gap: 1 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 20, sx: { color: "rgba(124, 179, 66, 0.8)" } }) });
  }
  if (credits === null && !hasUnlimited) {
    return null;
  }
  const getColor = () => {
    if (hasUnlimited) return "primary";
    if (credits === 0) return "error";
    if (credits <= 10) return "warning";
    return "success";
  };
  const getLabel = () => {
    if (hasUnlimited) return " Scans";
    const displayCredits = credits === Infinity || credits === Number.POSITIVE_INFINITY ? "" : credits != null ? credits : 0;
    return `${displayCredits} Scans`;
  };
  const getTooltip = () => {
    if (hasUnlimited) {
      if (isFounderSafe || (summary == null ? void 0 : summary.membershipTier) === "founder_unlimited") {
        return "Unlimited scans (Founder)";
      }
      return "Unlimited scans (Admin)";
    }
    if (tier === "free") return `${credits} free scans remaining`;
    if (tier === "app_purchase") return `${credits} scans from your app unlock`;
    if (tier === "monthly_member") {
      return `${credits} scans remaining (monthly allotment + top-ups)`;
    }
    return `${credits} scans remaining`;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: getTooltip(), arrow: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Chip,
    {
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(BoltIcon, {}),
      label: getLabel(),
      color: getColor(),
      size: "small",
      sx: {
        fontWeight: 600,
        background: hasUnlimited ? "linear-gradient(135deg, rgba(255, 215, 0, 0.2) 0%, rgba(255, 165, 0, 0.2) 100%)" : void 0,
        backdropFilter: "blur(10px)",
        border: hasUnlimited ? "1px solid rgba(255, 215, 0, 0.5)" : void 0,
        boxShadow: !hasUnlimited && credits <= 10 ? "0 0 10px rgba(255, 152, 0, 0.4)" : void 0,
        animation: !hasUnlimited && credits === 0 ? "pulse 2s ease-in-out infinite" : void 0,
        "@keyframes pulse": {
          "0%, 100%": { opacity: 1 },
          "50%": { opacity: 0.7 }
        }
      }
    }
  ) });
}
function GardenNavBar({ value, onChange, items = [] }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Paper,
    {
      elevation: 10,
      sx: {
        position: "fixed",
        bottom: 0,
        left: 0,
        right: 0,
        zIndex: 1200,
        borderRadius: 0,
        background: "rgba(5, 10, 5, 0.4)",
        backdropFilter: "blur(8px)",
        borderTop: "1px solid rgba(124, 179, 66, 0.2)",
        pb: "env(safe-area-inset-bottom)"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        BottomNavigation,
        {
          value,
          onChange: (_event, next2) => {
            if (next2 && typeof onChange === "function") {
              onChange(next2);
            }
          },
          showLabels: true,
          sx: {
            background: "transparent",
            "& .Mui-selected": {
              color: "#CDDC39 !important"
            }
          },
          children: items.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            BottomNavigationAction,
            {
              label: item.label,
              value: item.value,
              icon: item.icon,
              sx: {
                color: "#9CCC65",
                minWidth: 0,
                maxWidth: "120px"
              }
            },
            item.value
          ))
        }
      )
    }
  );
}
function Garden({ onBack, onNavigate }) {
  const { user, isExpired, canLogout, loading } = useMembershipGuard();
  const [showLogoutWarning, setShowLogoutWarning] = reactExports.useState(false);
  const [showComingSoon, setShowComingSoon] = reactExports.useState(false);
  const [selectedFeature, setSelectedFeature] = reactExports.useState("");
  const [showScan, setShowScan] = reactExports.useState(false);
  const [showStrainBrowser, setShowStrainBrowser] = reactExports.useState(false);
  const [showReviews, setShowReviews] = reactExports.useState(false);
  const [showDispensaryFinder, setShowDispensaryFinder] = reactExports.useState(false);
  const [showSeedFinder, setShowSeedFinder] = reactExports.useState(false);
  const [showGroups, setShowGroups] = reactExports.useState(false);
  const [showGrowCoach, setShowGrowCoach] = reactExports.useState(false);
  const [growCoachInitialTab, setGrowCoachInitialTab] = reactExports.useState(0);
  const [showGrowerDirectory, setShowGrowerDirectory] = reactExports.useState(false);
  const [showFeedback, setShowFeedback] = reactExports.useState(false);
  const [showFeedbackReader, setShowFeedbackReader] = reactExports.useState(false);
  const [showBuyScans, setShowBuyScans] = reactExports.useState(false);
  const [navValue, setNavValue] = reactExports.useState("home");
  const [activeScan, setActiveScan] = reactExports.useState(null);
  const [activeView, setActiveView] = reactExports.useState("scanner");
  reactExports.useEffect(() => {
    console.log("[Garden] mounted  bundle v2 (seedFinderStrain removed)");
  }, []);
  const handleLogout = () => __async(null, null, function* () {
    const isAdminUser = (user == null ? void 0 : user.email) === "topher.cook7@gmail.com" || (user == null ? void 0 : user.email) === "strainspotter25@gmail.com" || (user == null ? void 0 : user.email) === "admin@strainspotter.com" || (user == null ? void 0 : user.email) === "andrewbeck209@gmail.com";
    if (!canLogout && !isAdminUser) {
      setShowLogoutWarning(true);
      return;
    }
    try {
      yield supabase.auth.signOut();
      localStorage.clear();
      sessionStorage.clear();
      onBack == null ? void 0 : onBack();
    } catch (e) {
      console.error("Logout failed:", e);
    }
  });
  const handleFeatureClick = (featureName, nav) => {
    switch (nav) {
      case "scan":
        openScreen("scan", () => setShowScan(true));
        return;
      case "strains":
        openScreen("home", () => setShowStrainBrowser(true));
        return;
      case "reviews":
        openScreen("home", () => setShowReviews(true));
        return;
      case "dispensaries":
        openScreen("dispensaries", () => setShowDispensaryFinder(true));
        return;
      case "seeds":
        openScreen("home", () => setShowSeedFinder(true));
        return;
      case "groups":
        openScreen("groups", () => setShowGroups(true));
        return;
      case "grow-coach":
        setGrowCoachInitialTab(0);
        openScreen("home", () => setShowGrowCoach(true));
        return;
      case "grow-logbook":
        setGrowCoachInitialTab(LOGBOOK_TAB_INDEX);
        openScreen("home", () => setShowGrowCoach(true));
        return;
      case "growers":
        openScreen("growers", () => setShowGrowerDirectory(true));
        return;
      case "feedback-reader":
        openScreen("home", () => setShowFeedbackReader(true));
        return;
      default:
        setSelectedFeature(featureName);
        setShowComingSoon(true);
    }
  };
  const isAdmin = (user == null ? void 0 : user.email) === "topher.cook7@gmail.com" || (user == null ? void 0 : user.email) === "strainspotter25@gmail.com" || (user == null ? void 0 : user.email) === "admin@strainspotter.com" || (user == null ? void 0 : user.email) === "andrewbeck209@gmail.com";
  const tiles = [
    { title: "AI Strain Scan", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CameraAltIcon, {}), nav: "scan", color: "#00e676", description: "Identify any strain instantly", image: "", useEmoji: true },
    { title: "Strain Browser", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(SpaIcon, {}), nav: "strains", color: "#7cb342", description: "Explore 1000+ strains", image: "/hero.png?v=13", useEmoji: false, isHero: true },
    { title: "Reviews Hub", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(RateReviewIcon, {}), nav: "reviews", color: "#ffd600", description: "Read & share experiences", image: "", useEmoji: true },
    { title: "Community Groups", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(GroupsIcon, {}), nav: "groups", color: "#66bb6a", description: "Connect with growers", image: "", useEmoji: true },
    { title: "Grow Coach", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(LocalFloristIcon, {}), nav: "grow-coach", color: "#9ccc65", description: "Expert growing tips", image: "", useEmoji: true },
    { title: "Grow Logbook", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(NoteAltIcon, {}), nav: "grow-logbook", color: "#81c784", description: "Track every stage", image: "", useEmoji: true },
    { title: "Grower Directory", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(PeopleIcon, {}), nav: "growers", color: "#8bc34a", description: "Find local cultivators", image: "", useEmoji: true },
    { title: "Seed Vendors", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuBookIcon, {}), nav: "seeds", color: "#aed581", description: "Trusted seed sources", image: "", useEmoji: true },
    { title: "Dispensaries", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(StoreIcon, {}), nav: "dispensaries", color: "#c5e1a5", description: "Find nearby shops", image: "", useEmoji: true }
  ];
  if (isAdmin) {
    tiles.push({
      title: "Feedback Reader",
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FeedbackIcon, {}),
      nav: "feedback-reader",
      color: "#ff6b6b",
      description: "Admin feedback tool",
      adminOnly: true,
      image: "",
      useEmoji: true
    });
  }
  const resetScreens = (nextNav = "home") => {
    setShowScan(false);
    setShowStrainBrowser(false);
    setShowReviews(false);
    setShowDispensaryFinder(false);
    setShowSeedFinder(false);
    setShowGroups(false);
    setShowGrowCoach(false);
    setShowGrowerDirectory(false);
    setShowFeedbackReader(false);
    setNavValue(nextNav);
  };
  const openScreen = (navId, openCallback) => {
    resetScreens(navId);
    openCallback == null ? void 0 : openCallback();
  };
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { minHeight: "100vh", display: "flex", alignItems: "center", justifyContent: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: { color: "#fff" }, children: "Loading..." }) });
  }
  if (activeView === "result" && activeScan) {
    return renderWithNav(
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box,
        {
          sx: {
            display: "flex",
            flexDirection: "column",
            height: "100%",
            overflow: "hidden",
            bgcolor: "#000"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Box,
              {
                sx: {
                  flexShrink: 0,
                  display: "flex",
                  alignItems: "center",
                  gap: 1.5,
                  p: 2,
                  pt: "calc(env(safe-area-inset-top) + 8px)",
                  borderBottom: "1px solid rgba(255,255,255,0.08)",
                  bgcolor: "rgba(0,0,0,0.3)",
                  backdropFilter: "blur(8px)",
                  zIndex: 1
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      variant: "text",
                      onClick: () => {
                        setActiveView("scanner");
                        setActiveScan(null);
                      },
                      sx: {
                        color: "#fff",
                        minWidth: "auto",
                        px: 1,
                        fontSize: "1rem",
                        fontWeight: 600
                      },
                      children: " Back"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { fontWeight: 600, color: "#fff", flex: 1 }, children: "Scan Result" })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Box,
              {
                sx: {
                  flex: 1,
                  minHeight: 0,
                  overflowY: "auto",
                  WebkitOverflowScrolling: "touch",
                  paddingBottom: "calc(env(safe-area-inset-bottom) + 80px)",
                  px: 2,
                  py: 2
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ScanResultCard,
                  {
                    scan: activeScan,
                    result: activeScan,
                    isGuest: !user,
                    onViewSeeds: (options) => {
                      var _a2;
                      const scanData = (options == null ? void 0 : options.scan) || activeScan;
                      const resultData = (options == null ? void 0 : options.result) || (activeScan == null ? void 0 : activeScan.result) || activeScan;
                      const seedBank = (resultData == null ? void 0 : resultData.seedBank) || ((_a2 = scanData == null ? void 0 : scanData.result) == null ? void 0 : _a2.seedBank) || {};
                      const seedBankUrl = seedBank.seedBankUrl || seedBank.url || null;
                      if (seedBankUrl && typeof seedBankUrl === "string") {
                        try {
                          window.open(seedBankUrl, "_blank", "noopener,noreferrer");
                          return;
                        } catch (e) {
                          console.error("[Garden] Failed to open seedBankUrl", e);
                        }
                      }
                      setShowSeedFinder(true);
                    }
                  }
                )
              }
            )
          ]
        }
      ),
      "scan"
    );
  }
  if (showScan) {
    const handleScanComplete = reactExports.useCallback((scan) => {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _i;
      console.log("[GardenScanner] scan complete:", scan);
      if (!scan || !scan.id && !scan.scanId) {
        console.warn("[GardenScanner] Missing scan object, routing to result with fallback.");
        const fallbackScan = __spreadValues({
          id: (scan == null ? void 0 : scan.scanId) || "unknown",
          status: "completed",
          result: (scan == null ? void 0 : scan.result) || {}
        }, scan);
        setActiveScan(fallbackScan);
        setActiveView("result");
        setShowScan(false);
        return;
      }
      const normalizedScan = __spreadValues({
        id: scan.id || scan.scanId,
        status: scan.status || "completed",
        created_at: (_b = (_a2 = scan.created_at) != null ? _a2 : scan.createdAt) != null ? _b : null,
        processed_at: (_d = (_c = scan.processed_at) != null ? _c : scan.processedAt) != null ? _d : null,
        image_url: (_h = (_g = (_e = scan.image_url) != null ? _e : scan.imageUrl) != null ? _g : (_f = scan.result) == null ? void 0 : _f.image_url) != null ? _h : null,
        result: (_i = scan.result) != null ? _i : {}
      }, scan);
      setActiveScan(normalizedScan);
      setActiveView("result");
      setShowScan(false);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ScanWizard,
      {
        onBack: () => {
          setShowScan(false);
          setActiveView("scanner");
        },
        onScanComplete: handleScanComplete
      }
    );
  }
  if (showStrainBrowser) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(StrainBrowser, { onBack: () => setShowStrainBrowser(false) });
  }
  if (showReviews) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ReviewsHub, { onBack: () => setShowReviews(false), currentUser: user });
  }
  if (showDispensaryFinder) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DispensaryFinder, { onBack: () => setShowDispensaryFinder(false) });
  }
  if (showGroups) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Groups, { onBack: () => setShowGroups(false) });
  }
  if (showGrowCoach) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GrowCoach, { onBack: () => setShowGrowCoach(false), initialTab: growCoachInitialTab });
  }
  if (showGrowerDirectory) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GrowerDirectory, { onBack: () => setShowGrowerDirectory(false) });
  }
  if (showFeedbackReader) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(FeedbackReader, { user, onBack: () => setShowFeedbackReader(false) });
  }
  const handleNavChange = (next2) => {
    if (next2 === navValue) return;
    switch (next2) {
      case "home":
        resetScreens("home");
        return;
      case "scan":
        openScreen("scan", () => setShowScan(true));
        return;
      case "groups":
        openScreen("groups", () => setShowGroups(true));
        return;
      case "dispensaries":
        openScreen("dispensaries", () => setShowDispensaryFinder(true));
        return;
      case "growers":
        openScreen("growers", () => setShowGrowerDirectory(true));
        return;
    }
  };
  const renderWithNav = (content, navActive = navValue) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
    display: "flex",
    flexDirection: "column",
    height: "100vh",
    overflow: "hidden",
    backgroundColor: "background.default"
  }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { flex: 1, minHeight: 0, overflow: "hidden" }, children: content }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { flexShrink: 0 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      GardenNavBar,
      {
        value: navActive,
        onChange: handleNavChange,
        items: [
          { value: "home", label: "Garden", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(SpaIcon, {}) },
          { value: "scan", label: "Scan", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CameraAltIcon, {}) },
          { value: "groups", label: "Groups", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(GroupsIcon, {}) },
          { value: "dispensaries", label: "Shops", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(StoreIcon, {}) },
          { value: "growers", label: "Growers", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(PeopleIcon, {}) }
        ]
      }
    ) })
  ] });
  if (loading) {
    return renderWithNav(
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { minHeight: "70vh", display: "flex", alignItems: "center", justifyContent: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: { color: "#fff" }, children: "Loading..." }) })
    );
  }
  if (showScan) {
    if (activeView === "result" && activeScan) {
      return renderWithNav(
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            sx: {
              display: "flex",
              flexDirection: "column",
              height: "100%",
              overflow: "hidden",
              bgcolor: "#000"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Box,
                {
                  sx: {
                    flexShrink: 0,
                    display: "flex",
                    alignItems: "center",
                    gap: 1.5,
                    p: 2,
                    borderBottom: "1px solid rgba(255,255,255,0.08)",
                    bgcolor: "rgba(0,0,0,0.3)",
                    backdropFilter: "blur(8px)",
                    zIndex: 1
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Button,
                      {
                        variant: "text",
                        onClick: () => {
                          setActiveView("scanner");
                          setActiveScan(null);
                        },
                        sx: { color: "#fff", minWidth: "auto", px: 1 },
                        children: " Back"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { fontWeight: 600, color: "#fff", flex: 1 }, children: "Scan Result" })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Box,
                {
                  sx: {
                    flex: 1,
                    minHeight: 0,
                    overflowY: "auto",
                    WebkitOverflowScrolling: "touch",
                    paddingBottom: "calc(env(safe-area-inset-bottom) + 80px)",
                    px: 2,
                    py: 2
                  },
                  children: !activeScan ? /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { flex: 1, display: "flex", alignItems: "center", justifyContent: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "Preparing your result" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                    ScanResultCard,
                    {
                      scan: activeScan,
                      result: activeScan,
                      isGuest: !user,
                      onViewSeeds: (options) => {
                        var _a2;
                        const scanData = (options == null ? void 0 : options.scan) || activeScan;
                        const resultData = (options == null ? void 0 : options.result) || (activeScan == null ? void 0 : activeScan.result) || activeScan;
                        const seedBank = (resultData == null ? void 0 : resultData.seedBank) || ((_a2 = scanData == null ? void 0 : scanData.result) == null ? void 0 : _a2.seedBank) || {};
                        const seedBankUrl = seedBank.seedBankUrl || seedBank.url || null;
                        if (seedBankUrl && typeof seedBankUrl === "string") {
                          try {
                            window.open(seedBankUrl, "_blank", "noopener,noreferrer");
                            return;
                          } catch (e) {
                            console.error("[Garden] Failed to open seedBankUrl", e);
                          }
                        }
                        setShowSeedFinder(true);
                      }
                    }
                  )
                }
              )
            ]
          }
        ),
        "scan"
      );
    }
    return renderWithNav(
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ScanWizard,
        {
          onBack: () => resetScreens("home"),
          onScanComplete: (scan) => {
            setActiveScan(scan);
            setActiveView("result");
          }
        }
      ),
      "scan"
    );
  }
  if (showStrainBrowser) {
    return renderWithNav(/* @__PURE__ */ jsxRuntimeExports.jsx(StrainBrowser, { onBack: () => resetScreens("home") }));
  }
  if (showReviews) {
    return renderWithNav(/* @__PURE__ */ jsxRuntimeExports.jsx(ReviewsHub, { onBack: () => resetScreens("home"), currentUser: user }));
  }
  if (showDispensaryFinder) {
    return renderWithNav(/* @__PURE__ */ jsxRuntimeExports.jsx(DispensaryFinder, { onBack: () => resetScreens("home") }), "dispensaries");
  }
  if (showSeedFinder) {
    return renderWithNav(
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SeedVendorFinder,
        {
          onBack: () => {
            setShowSeedFinder(false);
            resetScreens("home");
          }
        }
      )
    );
  }
  if (showGroups) {
    return renderWithNav(/* @__PURE__ */ jsxRuntimeExports.jsx(Groups, { onBack: () => resetScreens("home") }), "groups");
  }
  if (showGrowCoach) {
    return renderWithNav(/* @__PURE__ */ jsxRuntimeExports.jsx(GrowCoach, { onBack: () => resetScreens("home"), initialTab: growCoachInitialTab }));
  }
  if (showGrowerDirectory) {
    return renderWithNav(/* @__PURE__ */ jsxRuntimeExports.jsx(GrowerDirectory, { onBack: () => resetScreens("home") }), "growers");
  }
  if (showFeedbackReader) {
    return renderWithNav(/* @__PURE__ */ jsxRuntimeExports.jsx(FeedbackReader, { user, onBack: () => resetScreens("home") }));
  }
  return renderWithNav(
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
      display: "flex",
      flexDirection: "column",
      height: "100%",
      overflow: "hidden",
      backgroundColor: "background.default"
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
        position: "sticky",
        top: 0,
        zIndex: 10,
        paddingTop: "calc(env(safe-area-inset-top) + 8px)",
        paddingBottom: 8,
        px: 2,
        background: "linear-gradient(to bottom, rgba(0,0,0,0.15), rgba(0,0,0,0.02))",
        backdropFilter: "blur(4px)",
        flexShrink: 0
      }, children: [
        isExpired && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Alert,
          {
            severity: "error",
            icon: /* @__PURE__ */ jsxRuntimeExports.jsx(WarningIcon, {}),
            sx: { mb: 1.5, py: 0.5, fontSize: "0.75rem", width: "100%", maxWidth: "600px" },
            children: "Payment overdue. Update payment to continue."
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Paper, { sx: {
          p: 1.5,
          mb: 1.5,
          background: "linear-gradient(135deg, rgba(124, 179, 66, 0.15) 0%, rgba(156, 204, 101, 0.1) 100%)",
          backdropFilter: "blur(20px)",
          border: "1.5px solid rgba(124, 179, 66, 0.4)",
          borderRadius: 3,
          boxShadow: "0 4px 20px rgba(124, 179, 66, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1)",
          transition: "all 0.15s ease",
          width: "100%",
          maxWidth: "600px"
        }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, alignItems: "center", justifyContent: "space-between", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1.5, alignItems: "center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Avatar,
              {
                src: "/hero.png?v=13",
                alt: "StrainSpotter",
                sx: {
                  width: 40,
                  height: 40,
                  borderRadius: "50%",
                  overflow: "hidden",
                  border: "2px solid rgba(124, 179, 66, 0.6)",
                  boxShadow: "0 0 12px rgba(124, 179, 66, 0.4)"
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#fff", fontWeight: 700, fontSize: "1.4rem", lineHeight: 1.2, mb: 0.25 }, children: "The Garden (v2)" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: { color: "#7cb342", fontWeight: 600, fontSize: "0.75rem" }, children: isAdmin ? " Member  Admin & Moderator" : " Member" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 0.5, alignItems: "center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { onClick: () => setShowBuyScans(true), sx: { cursor: "pointer" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CreditBalance, {}) }),
            onBack && /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "outlined",
                size: "small",
                onClick: onBack,
                sx: {
                  color: "#CDDC39",
                  borderColor: "rgba(124, 179, 66, 0.5)",
                  fontSize: "0.7rem",
                  py: 0.5,
                  px: 1,
                  minWidth: "auto",
                  background: "rgba(124, 179, 66, 0.1)",
                  backdropFilter: "blur(5px)",
                  transition: "all 0.15s cubic-bezier(0.4, 0, 0.2, 1)",
                  "&:hover": {
                    borderColor: "rgba(124, 179, 66, 1)",
                    background: "rgba(124, 179, 66, 0.2)",
                    transform: "scale(1.05)",
                    color: "#fff"
                  },
                  "&:active": {
                    transform: "scale(0.95)",
                    transition: "all 0.05s ease"
                  }
                },
                children: "Home"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "outlined",
                size: "small",
                onClick: handleLogout,
                sx: {
                  color: "#CDDC39",
                  borderColor: "rgba(124, 179, 66, 0.5)",
                  fontSize: "0.7rem",
                  py: 0.5,
                  px: 1,
                  minWidth: "auto",
                  background: "rgba(124, 179, 66, 0.1)",
                  backdropFilter: "blur(5px)",
                  transition: "all 0.15s cubic-bezier(0.4, 0, 0.2, 1)",
                  "&:hover": {
                    borderColor: "rgba(124, 179, 66, 1)",
                    background: "rgba(124, 179, 66, 0.2)",
                    transform: "scale(1.05)",
                    color: "#fff"
                  },
                  "&:active": {
                    transform: "scale(0.95)",
                    transition: "all 0.05s ease"
                  }
                },
                children: "Logout"
              }
            )
          ] })
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box,
        {
          sx: {
            flex: 1,
            minHeight: 0,
            overflowY: "auto",
            WebkitOverflowScrolling: "touch",
            px: 2,
            pb: 3
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper, { sx: {
              p: 2,
              mb: 2,
              background: "linear-gradient(135deg, rgba(124, 179, 66, 0.08) 0%, rgba(156, 204, 101, 0.05) 100%)",
              backdropFilter: "blur(15px)",
              border: "1.5px solid rgba(124, 179, 66, 0.25)",
              borderRadius: 3,
              boxShadow: "0 2px 12px rgba(0, 0, 0, 0.2)",
              width: "100%",
              maxWidth: "600px"
            }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: {
                color: "#CDDC39",
                fontWeight: 700,
                fontSize: "1.1rem",
                mb: 1,
                textShadow: "0 1px 3px rgba(0, 0, 0, 0.5)"
              }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", alignItems: "center", spacing: 1, justifyContent: "center", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Welcome to The Garden" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { component: "img", src: "/hero.png?v=13", alt: "", sx: { width: 20, height: 20, borderRadius: "50%", filter: "drop-shadow(0 0 4px rgba(124, 179, 66, 0.6))" } })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: {
                color: "#e8e8e8",
                fontSize: "0.85rem",
                lineHeight: 1.6,
                textShadow: "0 1px 2px rgba(0, 0, 0, 0.3)"
              }, children: "Your premium cannabis companion. Identify strains instantly, track your favorites, find nearby dispensaries, and connect with the community. Every feature is designed to enhance your cannabis experience." })
            ] }),
            tiles.find((t) => t.isHero) && (() => {
              const heroTile = tiles.find((t) => t.isHero);
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Paper,
                {
                  onClick: () => handleFeatureClick(heroTile.title, heroTile.nav),
                  sx: {
                    p: 0,
                    mb: 2,
                    textAlign: "center",
                    cursor: "pointer",
                    background: "rgba(0,0,0,0.25)",
                    backdropFilter: "blur(8px)",
                    border: "1px solid rgba(255,255,255,0.08)",
                    borderRadius: 24,
                    overflow: "hidden",
                    width: "100%",
                    maxWidth: "600px",
                    mx: "auto",
                    transition: "all 0.15s cubic-bezier(0.4, 0, 0.2, 1)",
                    "&:hover": {
                      transform: "translateY(-2px)",
                      boxShadow: "0 8px 24px rgba(124, 179, 66, 0.3)"
                    }
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Box,
                      {
                        component: "img",
                        src: heroTile.image,
                        alt: heroTile.title,
                        sx: {
                          width: "100%",
                          display: "block",
                          objectFit: "cover",
                          maxHeight: 220
                        }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { p: 2 }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#CDDC39", fontWeight: 700, mb: 0.5 }, children: heroTile.title }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#9CCC65", fontSize: "0.85rem" }, children: heroTile.description })
                    ] })
                  ]
                }
              );
            })(),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { container: true, spacing: 1.5, sx: { width: "100%", maxWidth: "600px", justifyContent: "center", mx: "auto" }, children: tiles.filter((t) => !t.isHero).map((tile) => /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 6, sx: { display: "flex", justifyContent: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Paper,
              {
                onClick: () => handleFeatureClick(tile.title, tile.nav),
                sx: {
                  p: 1.5,
                  textAlign: "center",
                  cursor: "pointer",
                  background: "rgba(255,255,255,0.05)",
                  backdropFilter: "blur(20px)",
                  WebkitBackdropFilter: "blur(20px)",
                  border: "1.5px solid rgba(124, 179, 66, 0.3)",
                  borderRadius: 2.5,
                  transition: "all 0.15s cubic-bezier(0.4, 0, 0.2, 1)",
                  boxShadow: "0 2px 8px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.05)",
                  position: "relative",
                  overflow: "hidden",
                  width: "100%",
                  height: "100px",
                  display: "flex",
                  flexDirection: "column",
                  justifyContent: "center",
                  alignItems: "center",
                  "&::before": {
                    content: '""',
                    position: "absolute",
                    top: "-50%",
                    left: "-50%",
                    width: "200%",
                    height: "200%",
                    background: "radial-gradient(circle, rgba(124, 179, 66, 0.1) 0%, transparent 70%)",
                    opacity: 0,
                    transition: "opacity 0.15s ease"
                  },
                  "&:hover": {
                    background: "rgba(124, 179, 66, 0.15)",
                    border: "1.5px solid rgba(124, 179, 66, 0.6)",
                    transform: "translateY(-2px) scale(1.03)",
                    boxShadow: "0 8px 24px rgba(124, 179, 66, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1)",
                    "&::before": {
                      opacity: 1
                    }
                  },
                  "&:active": {
                    transform: "translateY(-1px) scale(1.01)",
                    transition: "all 0.05s ease"
                  }
                },
                children: [
                  tile.useEmoji ? /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
                    fontSize: "2.5rem",
                    lineHeight: 1,
                    mb: 0.5,
                    filter: "drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3))",
                    transition: "all 0.15s ease",
                    textAlign: "center",
                    width: "100%"
                  }, children: tile.image }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
                    width: 40,
                    height: 40,
                    mb: 0.5,
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    borderRadius: "50%",
                    border: "2px solid rgba(124, 179, 66, 0.5)",
                    boxShadow: "0 0 20px rgba(124, 179, 66, 0.4)",
                    overflow: "hidden",
                    background: "transparent",
                    transition: "all 0.15s ease",
                    mx: "auto"
                  }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "img",
                    {
                      src: tile.image,
                      alt: tile.title,
                      style: { width: "100%", height: "100%", objectFit: "cover" }
                    }
                  ) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: {
                    color: "#CDDC39",
                    fontWeight: 700,
                    fontSize: "0.8rem",
                    lineHeight: 1.1,
                    mb: 0.25,
                    display: "block",
                    textShadow: "0 1px 3px rgba(0, 0, 0, 0.5)",
                    transition: "all 0.15s ease",
                    textAlign: "center",
                    width: "100%"
                  }, children: tile.title }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", sx: {
                    color: "#9CCC65",
                    fontSize: "0.65rem",
                    lineHeight: 1.2,
                    display: "block",
                    textShadow: "0 1px 2px rgba(0, 0, 0, 0.5)",
                    textAlign: "center",
                    width: "100%"
                  }, children: tile.description })
                ]
              }
            ) }, tile.nav)) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Paper,
              {
                sx: {
                  p: 1.5,
                  mt: 1.5,
                  background: "linear-gradient(135deg, rgba(124, 179, 66, 0.12) 0%, rgba(156, 204, 101, 0.08) 100%)",
                  backdropFilter: "blur(15px)",
                  border: "1.5px solid rgba(124, 179, 66, 0.3)",
                  borderRadius: 3,
                  boxShadow: "0 2px 12px rgba(124, 179, 66, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.1)",
                  width: "100%",
                  maxWidth: "600px",
                  mx: "auto"
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 1, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, alignItems: "center", justifyContent: "space-between", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Typography,
                      {
                        variant: "caption",
                        sx: { color: "#e8e8e8", fontSize: "0.75rem", textShadow: "0 1px 2px rgba(0, 0, 0, 0.3)" },
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { style: { color: "#CDDC39" }, children: "Plan:" }),
                          " ",
                          isAdmin ? "Creator Access" : "Member  $4.99/mo  200 scans"
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Button,
                      {
                        variant: "text",
                        size: "small",
                        sx: {
                          color: "#ffeb3b",
                          fontSize: "0.7rem",
                          py: 0.25,
                          px: 1.2,
                          minWidth: "auto",
                          border: "1px solid rgba(255, 235, 59, 0.4)",
                          borderRadius: 999,
                          "&:hover": {
                            bgcolor: "rgba(255, 235, 59, 0.15)",
                            transform: "scale(1.05)"
                          }
                        },
                        onClick: () => setShowBuyScans(true),
                        children: "Manage plan"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: { xs: "column", sm: "row" }, spacing: 1, justifyContent: "space-between", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#f5f5f5b5" }, children: [
                      "Initial unlock: ",
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "$5.99  20 scans" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#f5f5f5b5" }, children: [
                      "Membership: ",
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "$4.99/mo  200 scans" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Button,
                      {
                        variant: "outlined",
                        size: "small",
                        sx: { color: "#CDDC39", borderColor: "rgba(124, 179, 66, 0.5)", borderRadius: 2, px: 2 },
                        onClick: () => setShowBuyScans(true),
                        children: "Buy top-ups"
                      }
                    )
                  ] })
                ] })
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Dialog,
        {
          open: showLogoutWarning,
          onClose: () => setShowLogoutWarning(false),
          fullScreen: true,
          PaperProps: {
            sx: {
              bgcolor: "#1a1a1a",
              m: 0,
              maxHeight: "100vh"
            }
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { sx: { bgcolor: "#ff5252", color: "#fff", borderBottom: "1px solid rgba(255,255,255,0.2)" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, alignItems: "center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(WarningIcon, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Cannot Logout" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { sx: { mt: 2, bgcolor: "#1a1a1a", color: "#fff" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", sx: { mb: 2 }, children: "Your membership payment is overdue. You must resolve your payment before you can logout." }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "Please update your payment method or contact support for assistance." }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "contained",
                  fullWidth: true,
                  sx: { mt: 3, bgcolor: "#7cb342", "&:hover": { bgcolor: "#689f38" } },
                  onClick: () => setShowLogoutWarning(false),
                  children: "Update Payment Method"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outlined",
                  fullWidth: true,
                  color: "error",
                  sx: { mt: 1 },
                  onClick: () => __async(null, null, function* () {
                    try {
                      yield supabase.auth.signOut();
                      localStorage.clear();
                      sessionStorage.clear();
                      setShowLogoutWarning(false);
                      onBack == null ? void 0 : onBack();
                    } catch (e) {
                      console.error("Force logout failed:", e);
                    }
                  }),
                  children: "Force Logout Anyway"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "text",
                  fullWidth: true,
                  sx: { mt: 1 },
                  onClick: () => setShowLogoutWarning(false),
                  children: "Close"
                }
              )
            ] })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Dialog,
        {
          open: showComingSoon,
          onClose: () => setShowComingSoon(false),
          fullScreen: true,
          PaperProps: {
            sx: {
              background: "linear-gradient(135deg, rgba(124, 179, 66, 0.95) 0%, rgba(104, 159, 56, 0.95) 100%)",
              backdropFilter: "blur(20px)",
              borderRadius: { xs: 0, sm: 4 },
              border: "2px solid rgba(255, 255, 255, 0.2)",
              m: 0,
              maxHeight: "100vh"
            }
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { sx: { color: "#fff", fontWeight: 700, borderBottom: "1px solid rgba(255,255,255,0.2)" }, children: " Coming Soon!" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { sx: { display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", textAlign: "center", p: 4 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { sx: { color: "#fff", mb: 2 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: selectedFeature }),
                " is currently under development."
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: { color: "#e0e0e0", mb: 2 }, children: "We're working hard to bring you this feature soon! In the meantime, enjoy scanning strains and exploring the community." }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "contained",
                  fullWidth: true,
                  sx: {
                    mt: 2,
                    bgcolor: "#fff",
                    color: "#7cb342",
                    "&:hover": { bgcolor: "#f0f0f0" }
                  },
                  onClick: () => setShowComingSoon(false),
                  children: "Got it!"
                }
              )
            ] })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Send Feedback", placement: "left", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Fab,
        {
          color: "primary",
          onClick: () => setShowFeedback(true),
          sx: {
            position: "fixed",
            bottom: 24,
            right: 24,
            zIndex: 1e3,
            background: "linear-gradient(135deg, #7CB342 0%, #9CCC65 100%)",
            boxShadow: "0 8px 30px rgba(124, 179, 66, 0.4)",
            "&:hover": {
              background: "linear-gradient(135deg, #9CCC65 0%, #7CB342 100%)",
              boxShadow: "0 12px 40px rgba(124, 179, 66, 0.6)",
              transform: "scale(1.05)"
            }
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(FeedbackIcon, {})
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FeedbackModal,
        {
          open: showFeedback,
          onClose: () => setShowFeedback(false),
          user
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        BuyScansModal,
        {
          open: showBuyScans,
          onClose: () => setShowBuyScans(false),
          currentTier: "free",
          creditsRemaining: 0
        }
      )
    ] })
  );
}
function Home({ onNavigate }) {
  const [scanButtonBusy, setScanButtonBusy] = reactExports.useState(false);
  const [showGarden, setShowGarden] = reactExports.useState(false);
  const [inGarden, setInGarden] = reactExports.useState(false);
  const [showFeedback, setShowFeedback] = reactExports.useState(false);
  const { user } = useAuth();
  const isAdmin = isAdminEmail(user == null ? void 0 : user.email);
  const handleScanClick = () => {
    if (scanButtonBusy) return;
    setScanButtonBusy(true);
    if (typeof onNavigate === "function") {
      onNavigate("scanner");
    }
    setTimeout(() => {
      setScanButtonBusy(false);
    }, 2500);
  };
  if (showGarden && !inGarden) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      GardenGate,
      {
        onSuccess: () => {
          setInGarden(true);
        },
        onBack: () => setShowGarden(false)
      }
    );
  }
  if (inGarden) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Garden,
      {
        onNavigate,
        onBack: () => {
          setInGarden(false);
          setShowGarden(false);
        }
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        minHeight: "100vh",
        width: "100%",
        backgroundColor: "#0a0a0a",
        backgroundImage: "url(/strainspotter-bg.jpg)",
        backgroundSize: "cover",
        backgroundPosition: "center",
        backgroundAttachment: "fixed",
        backgroundRepeat: "no-repeat",
        position: "relative",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        "&::before": {
          content: '""',
          position: "absolute",
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          background: "rgba(0, 0, 0, 0.6)",
          pointerEvents: "none",
          zIndex: 0
        }
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { maxWidth: "xs", sx: { position: "relative", zIndex: 1, px: 3 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 3, alignItems: "center", textAlign: "center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Box,
            {
              sx: {
                width: 100,
                height: 100,
                borderRadius: "50%",
                background: "linear-gradient(135deg, rgba(124, 179, 66, 0.2) 0%, rgba(156, 204, 101, 0.2) 100%)",
                border: "3px solid rgba(124, 179, 66, 0.6)",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                boxShadow: "0 0 40px rgba(124, 179, 66, 0.6), 0 0 80px rgba(124, 179, 66, 0.3), inset 0 0 20px rgba(124, 179, 66, 0.1)",
                animation: "pulse 3s ease-in-out infinite",
                "@keyframes pulse": {
                  "0%, 100%": {
                    boxShadow: "0 0 40px rgba(124, 179, 66, 0.6), 0 0 80px rgba(124, 179, 66, 0.3)"
                  },
                  "50%": {
                    boxShadow: "0 0 60px rgba(124, 179, 66, 0.8), 0 0 120px rgba(124, 179, 66, 0.4)"
                  }
                }
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "img",
                {
                  src: "/hero.png?v=13",
                  alt: "StrainSpotter",
                  style: {
                    width: "100%",
                    height: "100%",
                    objectFit: "cover",
                    borderRadius: "50%"
                  }
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "h4",
              sx: {
                fontFamily: "Poppins, sans-serif",
                fontWeight: 900,
                background: "linear-gradient(135deg, #CDDC39 0%, #9CCC65 50%, #7CB342 100%)",
                WebkitBackgroundClip: "text",
                WebkitTextFillColor: "transparent",
                backgroundClip: "text",
                fontSize: "2.5rem",
                lineHeight: 1.1,
                textShadow: "0 0 30px rgba(124, 179, 66, 0.5)",
                filter: "drop-shadow(0 0 20px rgba(124, 179, 66, 0.4))"
              },
              children: "StrainSpotter"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "body1",
              sx: {
                color: "#d0d0d0",
                fontSize: "1rem",
                maxWidth: 320,
                lineHeight: 1.5,
                textShadow: "0 2px 8px rgba(0, 0, 0, 0.5)"
              },
              children: "AI-powered cannabis strain identification and grow journaling."
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, sx: { width: "100%", maxWidth: 300, mt: 2 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Button,
              {
                variant: "contained",
                size: "large",
                fullWidth: true,
                onClick: handleScanClick,
                disabled: scanButtonBusy,
                sx: {
                  mt: 2,
                  py: 1.5,
                  textTransform: "none",
                  fontSize: "1.05rem",
                  fontWeight: 600,
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  gap: 1,
                  opacity: scanButtonBusy ? 0.8 : 1,
                  borderRadius: "16px",
                  background: "linear-gradient(135deg, #7CB342 0%, #9CCC65 50%, #CDDC39 100%)",
                  boxShadow: "0 8px 32px rgba(124, 179, 66, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.2)",
                  transition: "all 0.15s cubic-bezier(0.4, 0, 0.2, 1)",
                  "&:hover": {
                    transform: scanButtonBusy ? "none" : "translateY(-3px) scale(1.02)",
                    boxShadow: "0 12px 40px rgba(124, 179, 66, 0.7), 0 0 60px rgba(124, 179, 66, 0.3)",
                    background: "linear-gradient(135deg, #8BC34A 0%, #AED581 50%, #CDDC39 100%)"
                  },
                  "&:active": {
                    transform: "translateY(-1px) scale(0.98)",
                    transition: "all 0.05s ease"
                  }
                },
                children: [
                  scanButtonBusy && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Box,
                    {
                      component: "span",
                      className: "scan-button-spinner"
                    }
                  ),
                  scanButtonBusy ? "Opening scanner" : "Scan"
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "outlined",
                size: "large",
                fullWidth: true,
                onClick: () => setShowGarden(true),
                startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(SpaIcon, {}),
                sx: {
                  py: 2,
                  fontSize: "1.1rem",
                  fontWeight: 700,
                  borderRadius: "16px",
                  border: "2px solid rgba(124, 179, 66, 0.7)",
                  color: "#CDDC39",
                  background: "rgba(124, 179, 66, 0.1)",
                  backdropFilter: "blur(10px)",
                  textTransform: "none",
                  transition: "all 0.15s cubic-bezier(0.4, 0, 0.2, 1)",
                  boxShadow: "0 4px 16px rgba(124, 179, 66, 0.2), inset 0 1px 0 rgba(124, 179, 66, 0.2)",
                  "&:hover": {
                    border: "2px solid rgba(124, 179, 66, 1)",
                    background: "rgba(124, 179, 66, 0.2)",
                    transform: "translateY(-3px) scale(1.02)",
                    boxShadow: "0 8px 32px rgba(124, 179, 66, 0.4), inset 0 1px 0 rgba(124, 179, 66, 0.3)",
                    color: "#fff"
                  },
                  "&:active": {
                    transform: "translateY(-1px) scale(0.98)",
                    transition: "all 0.05s ease"
                  }
                },
                children: "Enter the Garden"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "caption",
              sx: {
                color: "#7CB342",
                fontSize: "0.875rem",
                fontWeight: 600,
                mt: 2
              },
              children: "35,000+ strains  Instant scan results  AI-powered matching"
            }
          ),
          isAdmin && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "text",
              size: "small",
              startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(TroubleshootIcon, { fontSize: "small" }),
              onClick: () => onNavigate("admin-status"),
              sx: { color: "#A5D6A7", textTransform: "none" },
              children: "Status & debug tools"
            }
          )
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Fab,
          {
            color: "primary",
            size: "small",
            onClick: () => setShowFeedback(true),
            sx: {
              position: "fixed",
              bottom: 16,
              right: 16,
              zIndex: 1e3,
              background: "linear-gradient(135deg, #7CB342 0%, #9CCC65 100%)",
              boxShadow: "0 4px 12px rgba(124, 179, 66, 0.3)",
              width: 48,
              height: 48
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(FeedbackIcon, { fontSize: "small" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          FeedbackModal,
          {
            open: showFeedback,
            onClose: () => setShowFeedback(false),
            user: null
          }
        )
      ]
    }
  );
}
const Home$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Home
}, Symbol.toStringTag, { value: "Module" }));
function formatPercent$1(value) {
  if (value == null || Number.isNaN(Number(value))) return "";
  const num = typeof value === "string" ? parseFloat(value) : value;
  return `${num.toFixed(2)}%`;
}
function formatDate$1(value) {
  if (!value) return "";
  const d = new Date(value);
  if (Number.isNaN(d.getTime())) return value;
  return d.toLocaleDateString();
}
function InfoRow({ label, value }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: 1 }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 11, opacity: 0.7 }, children: label }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 13 }, children: value != null && value !== "" ? value : "" })
  ] });
}
function ScanAISummaryPanel({ summary }) {
  if (!summary) return null;
  const {
    isPackagedProduct,
    matchConfidence,
    matchedStrainName,
    estimateConfidenceLabel,
    estimateType,
    notes,
    scanType = "bud",
    stabilityScore = 1,
    stabilityLabel = "single-frame",
    numberOfFrames = 1,
    label = {}
  } = summary;
  const {
    productName,
    brandName,
    packageType,
    packageSize,
    thcPercent,
    cbdPercent,
    thcaPercent,
    batchId,
    lotNumber,
    harvestDate,
    testDate,
    labName,
    licenseNumber,
    originType
  } = label;
  const confidenceText = estimateConfidenceLabel || (matchConfidence != null ? `${Math.round(
    matchConfidence <= 1 ? matchConfidence * 100 : matchConfidence
  )}% match` : "Unknown");
  const effectiveEstimateType = estimateType || (isPackagedProduct ? "visual+label" : "visual-only");
  const showLabelBlock = isPackagedProduct || Boolean(
    productName || brandName || thcPercent != null || cbdPercent != null || thcaPercent != null
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        marginTop: 16,
        marginBottom: 16,
        padding: 16,
        borderRadius: 24,
        background: "linear-gradient(145deg, rgba(5,20,10,0.96), rgba(5,35,15,0.96))",
        color: "#f5fff5",
        backdropFilter: "blur(12px)"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              marginBottom: 12,
              display: "flex",
              justifyContent: "space-between",
              alignItems: "baseline",
              flexWrap: "wrap",
              gap: 8
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      textTransform: "uppercase",
                      fontSize: 11,
                      letterSpacing: 1.2,
                      opacity: 0.7
                    },
                    children: "AI scan summary"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 14, opacity: 0.8 }, children: [
                  confidenceText,
                  matchConfidence != null && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                    " ",
                    "",
                    " ",
                    Math.round(
                      matchConfidence <= 1 ? matchConfidence * 100 : matchConfidence
                    ),
                    "%"
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    style: {
                      fontSize: 11,
                      opacity: 0.7,
                      marginTop: 4,
                      display: "flex",
                      gap: 8,
                      flexWrap: "wrap"
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                        "Scan type: ",
                        scanType === "package" ? "Packaged product" : scanType === "bud" ? "Loose flower" : "Live plant"
                      ] }),
                      numberOfFrames > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                          numberOfFrames,
                          "-angle scan"
                        ] }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                          "Stability: ",
                          stabilityLabel === "high" ? "High" : stabilityLabel === "medium" ? "Medium" : "Low",
                          stabilityLabel === "low" && " (angles disagree, consider rescanning)",
                          stabilityLabel === "medium" && " (angles partly agree)"
                        ] })
                      ] }),
                      numberOfFrames === 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Single-frame scan. Add more angles in future updates for higher stability." })
                      ] })
                    ]
                  }
                )
              ] }),
              matchedStrainName && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  style: {
                    fontSize: 13,
                    padding: "4px 10px",
                    borderRadius: 999,
                    border: "1px solid rgba(180,255,190,0.3)",
                    textAlign: "right"
                  },
                  children: [
                    "Closest match: ",
                    /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: matchedStrainName })
                  ]
                }
              )
            ]
          }
        ),
        scanType === "package" && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              marginBottom: 16,
              padding: 12,
              borderRadius: 16,
              background: "linear-gradient(135deg, rgba(40,80,30,0.9), rgba(15,40,20,0.95))",
              border: "1px solid rgba(200,255,200,0.18)",
              fontSize: 13,
              lineHeight: 1.4
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    fontSize: 11,
                    textTransform: "uppercase",
                    letterSpacing: 1,
                    opacity: 0.7,
                    marginBottom: 4
                  },
                  children: "Packaged product detected"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "This scan looks like a packaged retail product. THC/CBD and label details were read and combined with visual features." })
            ]
          }
        ),
        scanType === "bud" && !isPackagedProduct && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              marginBottom: 16,
              padding: 12,
              borderRadius: 16,
              background: "linear-gradient(135deg, rgba(30,60,25,0.9), rgba(10,30,15,0.95))",
              border: "1px solid rgba(180,240,180,0.18)",
              fontSize: 13,
              lineHeight: 1.4
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    fontSize: 11,
                    textTransform: "uppercase",
                    letterSpacing: 1,
                    opacity: 0.7,
                    marginBottom: 4
                  },
                  children: "Loose flower detected"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "This looks like loose flower. The estimate is based mostly on visual structure (buds, trichomes, coloration)." })
            ]
          }
        ),
        scanType === "plant" && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              marginBottom: 16,
              padding: 12,
              borderRadius: 16,
              background: "linear-gradient(135deg, rgba(25,50,20,0.9), rgba(8,25,12,0.95))",
              border: "1px solid rgba(160,220,160,0.18)",
              fontSize: 13,
              lineHeight: 1.4
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    fontSize: 11,
                    textTransform: "uppercase",
                    letterSpacing: 1,
                    opacity: 0.7,
                    marginBottom: 4
                  },
                  children: "Live plant detected"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "This appears to be a live plant shot. Estimates for live plants are usually less precise than packaged/bud scans." })
            ]
          }
        ),
        showLabelBlock && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: 18 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                fontSize: 11,
                textTransform: "uppercase",
                letterSpacing: 1,
                opacity: 0.7,
                marginBottom: 6
              },
              children: "Label decode"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                display: "grid",
                gridTemplateColumns: "minmax(0, 1fr) minmax(0, 1fr)",
                gap: 8,
                fontSize: 13
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRow, { label: "Product name", value: productName }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRow, { label: "Brand", value: brandName }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  InfoRow,
                  {
                    label: "Package type",
                    value: packageType || (isPackagedProduct ? "Packaged product" : "")
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRow, { label: "Package size", value: packageSize }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRow, { label: "THC on label", value: formatPercent$1(thcPercent) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRow, { label: "CBD on label", value: formatPercent$1(cbdPercent) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRow, { label: "THCA on label", value: formatPercent$1(thcaPercent) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRow, { label: "Batch / Lot", value: batchId || lotNumber }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRow, { label: "Harvest date", value: formatDate$1(harvestDate) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRow, { label: "Test date", value: formatDate$1(testDate) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRow, { label: "Lab", value: labName }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRow, { label: "License #", value: licenseNumber })
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: 18 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                fontSize: 11,
                textTransform: "uppercase",
                letterSpacing: 1,
                opacity: 0.7,
                marginBottom: 6
              },
              children: "How this estimate was made"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "p",
            {
              style: {
                fontSize: 13,
                lineHeight: 1.5,
                margin: 0,
                opacity: 0.9
              },
              children: [
                effectiveEstimateType === "visual+label" && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "This estimate combines what the AI sees in the plant/packaging (color, structure, visual features) with text decoded from the label (THC/CBD numbers, brand, product name)." }),
                effectiveEstimateType === "label-only" && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "This estimate relies mainly on the label text (THC/CBD numbers, product name, brand). Visual features had little or no impact." }),
                effectiveEstimateType === "visual-only" && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "No reliable label text was found. This estimate is based mainly on visual features and should be treated as an educated guess." })
              ]
            }
          ),
          numberOfFrames > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "p",
            {
              style: {
                fontSize: 13,
                lineHeight: 1.5,
                marginTop: 8,
                opacity: 0.85
              },
              children: [
                stabilityLabel === "high" && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "Results were consistent across multiple angles of the same product." }),
                stabilityLabel === "medium" && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "Results were mostly consistent across angles, with some variation." }),
                stabilityLabel === "low" && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "Different angles gave conflicting signals. Consider rescanning with clearer shots of the bud/label." })
              ]
            }
          ),
          notes && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "p",
            {
              style: {
                fontSize: 13,
                lineHeight: 1.5,
                marginTop: 8,
                opacity: 0.85
              },
              children: notes
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              marginBottom: 14,
              padding: 12,
              borderRadius: 16,
              background: "rgba(10, 40, 15, 0.9)",
              border: "1px solid rgba(130, 220, 150, 0.35)"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    fontSize: 11,
                    textTransform: "uppercase",
                    letterSpacing: 1,
                    opacity: 0.8,
                    marginBottom: 4
                  },
                  children: "For dispensaries"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "ul",
                {
                  style: {
                    paddingLeft: 16,
                    margin: 0,
                    fontSize: 13,
                    lineHeight: 1.45
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                      "Use the ",
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "THC/CBD on label" }),
                      " values above to verify they match your menu and label requirements."
                    ] }),
                    brandName && /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                      "Confirm this product is listed under",
                      " ",
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: brandName }),
                      " in your POS / menu system."
                    ] }),
                    licenseNumber && /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                      "Check that license ",
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: licenseNumber }),
                      " is valid for the product's origin."
                    ] }),
                    batchId || lotNumber ? /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                      "Record batch/lot ID ",
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: batchId || lotNumber }),
                      " for traceability and recall audits."
                    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                      "Consider recording ",
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "batch / lot ID" }),
                      " for traceability, if present on the physical label."
                    ] }),
                    isPackagedProduct ? /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                      "This scan looks like a ",
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "ready-for-sale package" }),
                      ". Use it to support intake checks and compliance reviews."
                    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                      "This scan does ",
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "not" }),
                      " look like a full retail package. Treat this as a visual estimate only, not a compliance check."
                    ] })
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              padding: 12,
              borderRadius: 16,
              background: "rgba(5, 35, 15, 0.9)",
              border: "1px solid rgba(110, 200, 140, 0.3)"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    fontSize: 11,
                    textTransform: "uppercase",
                    letterSpacing: 1,
                    opacity: 0.8,
                    marginBottom: 4
                  },
                  children: "For growers"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "ul",
                {
                  style: {
                    paddingLeft: 16,
                    margin: 0,
                    fontSize: 13,
                    lineHeight: 1.45
                  },
                  children: [
                    matchedStrainName ? /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                      "Visual / label features are closest to",
                      " ",
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: matchedStrainName }),
                      ". Use this as a reference when tracking phenotype consistency across batches."
                    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: "Use this estimate as a starting point when comparing phenotypes or dialing in new genetics." }),
                    thcPercent != null && /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                      "Label THC: ",
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: formatPercent$1(thcPercent) }),
                      ". Compare this to your historical averages for this strain or batch."
                    ] }),
                    thcaPercent != null && /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                      "Label THCA: ",
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: formatPercent$1(thcaPercent) }),
                      ". Use this alongside THC and CBD to track decarb and curing results."
                    ] }),
                    originType && /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                      "Origin detected as: ",
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: originType }),
                      ". Keep this consistent between your internal records and packaging."
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                      "Future versions of StrainSpotter can add",
                      " ",
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "terpene profiles" }),
                      " and grow notes once lab data is linked to this product."
                    ] })
                  ]
                }
              )
            ]
          }
        )
      ]
    }
  );
}
function normalizeTags(raw) {
  if (!raw) return [];
  if (!Array.isArray(raw)) return [];
  return raw.map((item) => {
    if (typeof item === "string") return item.trim();
    if (item && typeof item === "object") {
      if ("name" in item && "percent" in item) {
        const pct = typeof item.percent === "number" ? Math.round(item.percent) : item.percent;
        if (item.name && pct != null && pct !== "") {
          return `${item.name} (${pct}%)`;
        }
        if (item.name) return String(item.name);
      }
      if ("name" in item && item.name) return String(item.name);
      if ("label" in item && item.label) return String(item.label);
      if ("value" in item && item.value) return String(item.value);
    }
    return null;
  }).filter(Boolean);
}
function StrainResultCard({ matchedStrain, scan }) {
  if (!matchedStrain) return null;
  const name2 = matchedStrain.name || "Unknown strain";
  const type = normalizeType(matchedStrain.type);
  const thc = formatPercent(matchedStrain.thc);
  const cbd = formatPercent(matchedStrain.cbd);
  const rawEffects = matchedStrain.effects || null;
  const rawFlavors = matchedStrain.flavors || null;
  const effectsArray = toArray(rawEffects);
  const flavorsArray = toArray(rawFlavors);
  const effects = normalizeTags(effectsArray);
  const flavors = normalizeTags(flavorsArray);
  const lineage = matchedStrain.lineage || "";
  const createdAt = (scan == null ? void 0 : scan.created_at) || (scan == null ? void 0 : scan.createdAt) || null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        marginTop: "1.25rem",
        marginBottom: "0.5rem",
        padding: "1.1rem 1.0rem",
        borderRadius: "1rem",
        border: "1px solid rgba(76, 175, 80, 0.55)",
        background: "radial-gradient(circle at 0% 0%, rgba(178,255,89,0.18), transparent 60%), linear-gradient(145deg, rgba(5,10,5,0.98), rgba(16,30,16,0.98))",
        color: "#e8ffe1",
        boxShadow: "0 16px 40px rgba(0,0,0,0.55)",
        fontFamily: 'system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif'
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              display: "flex",
              gap: "0.75rem",
              alignItems: "flex-start",
              justifyContent: "space-between",
              marginBottom: "0.75rem"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { minWidth: 0, flex: 1 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      fontSize: "0.78rem",
                      textTransform: "uppercase",
                      letterSpacing: "0.12em",
                      opacity: 0.75,
                      marginBottom: "0.15rem"
                    },
                    children: "Scan result"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      fontSize: "1.25rem",
                      fontWeight: 650,
                      lineHeight: 1.2,
                      whiteSpace: "nowrap",
                      overflow: "hidden",
                      textOverflow: "ellipsis"
                    },
                    children: name2
                  }
                ),
                lineage && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    style: {
                      fontSize: "0.8rem",
                      opacity: 0.75,
                      marginTop: "0.2rem"
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { opacity: 0.65 }, children: "Lineage:" }),
                      lineage
                    ]
                  }
                ),
                createdAt && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    style: {
                      fontSize: "0.72rem",
                      opacity: 0.65,
                      marginTop: "0.2rem"
                    },
                    children: [
                      "Scanned on ",
                      formatDate(createdAt)
                    ]
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  style: {
                    display: "flex",
                    flexDirection: "column",
                    gap: "0.35rem",
                    alignItems: "flex-end"
                  },
                  children: [
                    type && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "span",
                      {
                        style: {
                          fontSize: "0.7rem",
                          padding: "0.24rem 0.6rem",
                          borderRadius: 999,
                          border: "1px solid rgba(178,255,89,0.8)",
                          backgroundColor: "rgba(12,25,12,0.95)",
                          textTransform: "uppercase",
                          letterSpacing: "0.11em"
                        },
                        children: type
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "div",
                      {
                        style: {
                          display: "flex",
                          gap: "0.25rem",
                          fontSize: "0.78rem",
                          opacity: 0.88
                        },
                        children: [
                          thc && /* @__PURE__ */ jsxRuntimeExports.jsx(MiniStat, { label: "THC", value: thc, highlight: "rgba(255,255,255,0.08)" }),
                          cbd && /* @__PURE__ */ jsxRuntimeExports.jsx(MiniStat, { label: "CBD", value: cbd, highlight: "rgba(255,255,255,0.04)" })
                        ]
                      }
                    )
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              display: "flex",
              flexWrap: "wrap",
              gap: "0.75rem"
            },
            children: [
              effects.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(TagSection, { title: "Typical effects", items: effects, tone: "effects" }),
              flavors.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(TagSection, { title: "Common flavors", items: flavors, tone: "flavors" })
            ]
          }
        )
      ]
    }
  );
}
function MiniStat({ label, value, highlight }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        padding: "0.22rem 0.45rem",
        borderRadius: "0.55rem",
        backgroundColor: highlight,
        border: "1px solid rgba(190, 220, 190, 0.5)",
        minWidth: 44,
        textAlign: "center"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: {
              fontSize: "0.62rem",
              textTransform: "uppercase",
              opacity: 0.7,
              letterSpacing: "0.09em"
            },
            children: label
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: {
              fontSize: "0.8rem",
              fontWeight: 600
            },
            children: value
          }
        )
      ]
    }
  );
}
function TagSection({ title, items, tone }) {
  const safeItems = Array.isArray(items) ? items : [];
  const cleaned = safeItems.map((item) => {
    if (typeof item === "string") return item;
    if (item && typeof item === "object") {
      if ("name" in item) return String(item.name);
      if ("label" in item) return String(item.label);
      if ("value" in item) return String(item.value);
    }
    return null;
  }).filter(Boolean);
  if (cleaned.length === 0) return null;
  const palette = tone === "flavors" ? {
    chipBg: "rgba(255, 248, 225, 0.06)",
    chipBorder: "1px solid rgba(255, 236, 179, 0.7)",
    chipText: "#fff8e1",
    titleColor: "#fff9c4"
  } : {
    chipBg: "rgba(178, 255, 89, 0.08)",
    chipBorder: "1px solid rgba(200, 255, 140, 0.85)",
    chipText: "#e8ffca",
    titleColor: "#e8f5e9"
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { minWidth: 0 }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          fontSize: "0.78rem",
          textTransform: "uppercase",
          letterSpacing: "0.08em",
          opacity: 0.8,
          marginBottom: "0.25rem",
          color: palette.titleColor
        },
        children: title
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          display: "flex",
          flexWrap: "wrap",
          gap: "0.3rem"
        },
        children: cleaned.map((item, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: {
              fontSize: "0.76rem",
              padding: "0.2rem 0.55rem",
              borderRadius: 999,
              backgroundColor: palette.chipBg,
              border: palette.chipBorder,
              color: palette.chipText,
              maxWidth: "100%"
            },
            children: item
          },
          `${title}-${idx}`
        ))
      }
    )
  ] });
}
function toArray(value) {
  if (!value) return [];
  if (Array.isArray(value)) return value.filter(Boolean);
  if (typeof value === "string") {
    return value.split(",").map((s) => s.trim()).filter(Boolean);
  }
  return [];
}
function formatPercent(raw) {
  if (raw === null || raw === void 0) return null;
  const num = Number(raw);
  if (!Number.isFinite(num)) return null;
  if (num === 0) return "0%";
  if (num > 0 && num <= 1) return `${(num * 100).toFixed(1)}%`;
  if (num > 1 && num < 100) return `${num.toFixed(1)}%`;
  return `${num}%`;
}
function normalizeType(type) {
  if (!type || typeof type !== "string") return null;
  const lower = type.toLowerCase();
  if (lower.includes("indica") && lower.includes("sativa")) return "Hybrid";
  if (lower.includes("indica")) return "Indica";
  if (lower.includes("sativa")) return "Sativa";
  if (lower.includes("hybrid")) return "Hybrid";
  return type.charAt(0).toUpperCase() + type.slice(1);
}
function formatDate(value) {
  try {
    const d = new Date(value);
    if (Number.isNaN(d.getTime())) return "";
    return d.toLocaleDateString(void 0, {
      year: "numeric",
      month: "short",
      day: "numeric"
    });
  } catch (e) {
    return "";
  }
}
function resizeImageToBase64(file, maxWidth2 = 1280, quality = 0.7) {
  return __async(this, null, function* () {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        const scale = Math.min(1, maxWidth2 / img.width);
        const canvas = document.createElement("canvas");
        canvas.width = img.width * scale;
        canvas.height = img.height * scale;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        canvas.toBlob(
          (blob) => {
            if (!blob) return reject(new Error("Failed to create blob"));
            const reader = new FileReader();
            reader.onloadend = () => {
              const dataUrl = reader.result || "";
              const base64 = dataUrl.includes(",") ? dataUrl.split(",")[1] : dataUrl;
              URL.revokeObjectURL(img.src);
              resolve({ base64, contentType: "image/jpeg" });
            };
            reader.onerror = () => {
              URL.revokeObjectURL(img.src);
              reject(new Error("Failed to read blob"));
            };
            reader.readAsDataURL(blob);
          },
          "image/jpeg",
          quality
        );
      };
      img.onerror = () => {
        URL.revokeObjectURL(img.src);
        reject(new Error("Failed to load image"));
      };
      img.src = URL.createObjectURL(file);
    });
  });
}
const GUEST_LIMIT = 20;
function getGuestScansUsed() {
  if (typeof window === "undefined") return 0;
  const raw = window.localStorage.getItem("ss_guest_scans_used");
  const n = raw ? parseInt(raw, 10) : 0;
  return Number.isFinite(n) && n > 0 ? n : 0;
}
function setGuestScansUsed(n) {
  if (typeof window === "undefined") return;
  window.localStorage.setItem("ss_guest_scans_used", String(n));
}
function apiUrl$1(path) {
  if (!path.startsWith("/")) path = `/${path}`;
  return `${API_BASE}${path}`;
}
function ScanPage({ onBack, onNavigate, onScanComplete }) {
  var _a2, _b;
  const { user } = useAuth();
  const {
    isMember,
    starterRemaining,
    memberRemaining,
    memberCap,
    extraCredits,
    totalAvailableScans,
    starterCap,
    registerScanConsumed
  } = useMembership();
  const { proRole, proEnabled } = useProMode();
  const { canScan: canScanFromHook, isFounder, remainingScans: remainingScansFromHook } = useCanScan();
  const { summary: creditSummary } = (_a2 = useCreditBalance == null ? void 0 : useCreditBalance()) != null ? _a2 : {};
  const hasUnlimited = isFounder || Boolean((creditSummary == null ? void 0 : creditSummary.unlimited) || (creditSummary == null ? void 0 : creditSummary.isUnlimited) || (creditSummary == null ? void 0 : creditSummary.membershipTier) === "founder_unlimited" || (creditSummary == null ? void 0 : creditSummary.tier) === "admin");
  const email = (_b = user == null ? void 0 : user.email) != null ? _b : null;
  const isGuest = !user;
  reactExports.useEffect(() => {
    console.log("[FounderDebug]", {
      email,
      isFounder,
      canScan: canScanFromHook,
      remainingScans: remainingScansFromHook
    });
  }, [email, isFounder, canScanFromHook, remainingScansFromHook]);
  const [selectedFile, setSelectedFile] = reactExports.useState(null);
  const [previewUrl, setPreviewUrl] = reactExports.useState(null);
  const [isUploading, setIsUploading] = reactExports.useState(false);
  const [isPolling, setIsPolling] = reactExports.useState(false);
  const [isOpeningPicker, setIsOpeningPicker] = reactExports.useState(false);
  const [isChoosingFile, setIsChoosingFile] = reactExports.useState(false);
  const [scanResult, setScanResult] = reactExports.useState(null);
  const [error2, setError] = reactExports.useState(null);
  const [hasCompletedScan, setHasCompletedScan] = reactExports.useState(false);
  const [guestScansUsed, setGuestScansUsedState] = reactExports.useState(() => getGuestScansUsed());
  const [showPlans, setShowPlans] = reactExports.useState(false);
  const [capturedFrames, setCapturedFrames] = reactExports.useState([]);
  const [multiAngleMode, setMultiAngleMode] = reactExports.useState(false);
  const MAX_FRAMES = 3;
  const canScan = canScanFromHook != null ? canScanFromHook : isFounder || hasUnlimited || totalAvailableScans > 0;
  const [scanPhase, setScanPhase] = reactExports.useState("camera-loading");
  const [statusMessage, setStatusMessage] = reactExports.useState("Opening scanner");
  const [scanStatus, setScanStatus] = reactExports.useState({
    phase: "idle",
    message: "",
    details: ""
  });
  const [scanError, setScanError] = reactExports.useState(null);
  const [currentScanId, setCurrentScanId] = reactExports.useState(null);
  const scanIdRef = reactExports.useRef(null);
  const [cameraReady, setCameraReady] = reactExports.useState(false);
  const [lastPhotoUrl, setLastPhotoUrl] = reactExports.useState(null);
  const [framePulsing, setFramePulsing] = reactExports.useState(false);
  const [activeScanView, setActiveScanView] = reactExports.useState("scanner");
  const [completedScan, setCompletedScan] = reactExports.useState(null);
  const [selectedScanId, setSelectedScanId] = reactExports.useState(null);
  const processedScanIdsRef = reactExports.useRef(/* @__PURE__ */ new Set());
  const hasCompletedScanRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    setScanPhase("camera-loading");
    setStatusMessage("Opening scanner");
    const t = setTimeout(() => {
      setCameraReady(true);
      setScanPhase("ready");
      setStatusMessage("Take or choose a photo of any weed product or packaging.");
    }, 200);
    return () => clearTimeout(t);
  }, []);
  reactExports.useEffect(() => {
    return () => {
      if (previewUrl) {
        URL.revokeObjectURL(previewUrl);
      }
      if (lastPhotoUrl) {
        URL.revokeObjectURL(lastPhotoUrl);
      }
      capturedFrames.forEach((frame) => {
        if (frame.previewUrl) {
          URL.revokeObjectURL(frame.previewUrl);
        }
      });
    };
  }, []);
  reactExports.useEffect(() => {
    if (scanPhase === "done" && completedScan) {
      const cleanupTimer = setTimeout(() => {
        if (previewUrl) {
          URL.revokeObjectURL(previewUrl);
          setPreviewUrl(null);
        }
        if (lastPhotoUrl) {
          URL.revokeObjectURL(lastPhotoUrl);
          setLastPhotoUrl(null);
        }
      }, 2e3);
      return () => clearTimeout(cleanupTimer);
    }
  }, [scanPhase, completedScan]);
  const handleBack = () => {
    if (onBack) onBack();
  };
  const resetScan = () => {
    setError(null);
    setScanError(null);
    setScanPhase("ready");
    setStatusMessage("Take or choose a photo of the product or packaging.");
    setScanStatus({
      phase: "idle",
      message: "Ready to scan.",
      details: ""
    });
    setSelectedFile(null);
    setPreviewUrl(null);
    setLastPhotoUrl(null);
    setScanResult(null);
    setIsUploading(false);
    setIsPolling(false);
    setActiveScanView("scanner");
    setCompletedScan(null);
    setSelectedScanId(null);
    setHasCompletedScan(false);
    setCurrentScanId(null);
    hasCompletedScanRef.current = false;
    processedScanIdsRef.current.clear();
    setCapturedFrames([]);
    setMultiAngleMode(false);
  };
  const handleStartMultiAngleScan = () => __async(null, null, function* () {
    if (capturedFrames.length === 0) {
      setError("Please capture at least one photo");
      return;
    }
    yield startScan(capturedFrames[0].file);
  });
  const toggleMultiAngleMode = () => {
    setMultiAngleMode(!multiAngleMode);
    setCapturedFrames([]);
    setSelectedFile(null);
    setPreviewUrl(null);
    if (!multiAngleMode) {
      setStatusMessage("Step 1/3: Capture the product from the front / top");
    } else {
      setStatusMessage("Take or choose a photo of the product or packaging.");
    }
  };
  const handleScanAgain = () => {
    resetScan();
  };
  const handleBackToHome = () => {
    setActiveScanView("scanner");
  };
  const handleScanCompleted = React.useCallback(
    (scan) => {
      if (!scan || !scan.id) {
        console.warn("[SCAN] handleScanCompleted called with invalid scan", scan);
        return;
      }
      if (onScanComplete && typeof onScanComplete === "function") {
        onScanComplete(scan);
        return;
      }
      console.log("[SCAN] Completed, going to result page", scan.id);
      setSelectedScanId(scan.id);
      setActiveScanView("result");
    },
    []
    // No dependencies needed
  );
  const startScanForFile = (file) => __async(null, null, function* () {
    if (!file) {
      setError("Choose a photo first.");
      return;
    }
    if (isGuest && guestScansUsed >= GUEST_LIMIT) {
      setShowPlans(true);
      return;
    }
    setError(null);
    setScanResult(null);
    yield startScan(file);
  });
  const handleFileChange = (event) => {
    var _a3;
    setIsOpeningPicker(false);
    setIsChoosingFile(false);
    const file = (_a3 = event.target.files) == null ? void 0 : _a3[0];
    if (!file) return;
    setError(null);
    setScanResult(null);
    const previewUrl2 = URL.createObjectURL(file);
    setPreviewUrl(previewUrl2);
    setLastPhotoUrl((oldUrl) => {
      if (oldUrl) URL.revokeObjectURL(oldUrl);
      return previewUrl2;
    });
    setFramePulsing(true);
    if (multiAngleMode && capturedFrames.length < MAX_FRAMES) {
      const newFrame = { file, previewUrl: previewUrl2 };
      const updatedFrames = [...capturedFrames, newFrame];
      setCapturedFrames(updatedFrames);
      if (updatedFrames.length >= MAX_FRAMES) {
        setStatusMessage(`All ${MAX_FRAMES} photos captured. Ready to scan.`);
        setScanPhase("ready");
      } else {
        const step = updatedFrames.length + 1;
        const instructions = [
          "Capture the product from the front / top",
          "Capture from a side angle",
          "Capture a close-up of the bud/label"
        ];
        setStatusMessage(`Step ${step}/${MAX_FRAMES}: ${instructions[step - 1]}`);
        setScanPhase("ready");
      }
    } else {
      setSelectedFile(file);
      setIsUploading(false);
      setIsPolling(false);
      setScanPhase("capturing");
      setStatusMessage("Preparing image");
      startScanForFile(file);
    }
    event.target.value = "";
  };
  const handlePickImageClick = () => {
    const input = document.getElementById("scan-file-input");
    if (!input) return;
    setIsOpeningPicker(true);
    input.click();
  };
  const handleChoosePhotoClick = () => {
    const input = document.getElementById("scan-file-input");
    if (!input) return;
    setIsChoosingFile(true);
    input.click();
    setTimeout(() => {
      setIsChoosingFile(false);
    }, 800);
  };
  const handleStartScan = () => __async(null, null, function* () {
    yield startScanForFile(selectedFile);
  });
  function startScan(file) {
    return __async(this, null, function* () {
      var _a3, _b2, _c;
      if (!isFounder && !canScan) {
        setError(
          `You're out of scans. Members get ${memberCap} scans included; you can also top up scan packs any time.`
        );
        return;
      }
      try {
        setError(null);
        setScanError(null);
        setCurrentScanId(null);
        setScanPhase("capturing");
        setStatusMessage("Preparing image");
        setScanStatus({
          phase: "preparing",
          message: "Preparing your scan...",
          details: ""
        });
        setScanPhase("uploading");
        setStatusMessage("Resizing image for faster upload");
        setScanStatus({
          phase: "compressing",
          message: "Compressing photo for upload...",
          details: "Keeping image sharp while shrinking file size."
        });
        console.time("[Scanner] image-compression");
        const { base64, contentType } = yield resizeImageToBase64(file, 1280, 0.7);
        console.timeEnd("[Scanner] image-compression");
        setStatusMessage("Uploading image");
        setScanStatus({
          phase: "uploading",
          message: "Uploading image securely...",
          details: "Sending your scan to StrainSpotter servers."
        });
        const payload = {
          filename: file.name || "scan.jpg",
          contentType: contentType || "image/jpeg",
          base64
        };
        console.time("[Scanner] upload");
        const res = yield fetch(apiUrl$1("/api/uploads"), {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(payload)
        });
        console.timeEnd("[Scanner] upload");
        const data = yield safeJson(res);
        if (!res.ok) {
          if (res.status === 403 && (data == null ? void 0 : data.error) === "Guest scan limit reached") {
            setShowPlans(true);
            setIsUploading(false);
            setIsPolling(false);
            setScanPhase("error");
            setStatusMessage("Guest scan limit reached.");
            return;
          }
          let errorMessage = (data == null ? void 0 : data.error) || (data == null ? void 0 : data.hint) || `Upload failed (${res.status})`;
          if (res.status === 413 || errorMessage.includes("too large")) {
            errorMessage = "Image is too large. Try taking the photo a bit farther away or with lower resolution.";
          } else if (res.status === 400) {
            errorMessage = "Image problem (too large or wrong type). Try another photo.";
          } else if (res.status >= 500) {
            errorMessage = "Scan failed on the server. Try again in a moment.";
          }
          setScanPhase("error");
          throw new Error(errorMessage);
        }
        const scanId = data.id;
        console.log("[SCAN-ID] Received from backend", {
          scanId,
          responseData: data,
          hasId: !!data.id,
          hasScanId: !!data.scanId,
          hasScan_id: !!data.scan_id
        });
        if (!scanId) {
          console.error("[SCAN-ID] ERROR: No scan ID in backend response", {
            responseData: data,
            responseKeys: Object.keys(data || {})
          });
          setScanPhase("idle");
          setScanStatus({
            phase: "error",
            message: "Server did not return scan ID.",
            details: "Please try again."
          });
          throw new Error("Did not receive a scan id from the server.");
        }
        scanIdRef.current = scanId;
        setCurrentScanId(scanId);
        console.log("[SCAN-ID] Stored scan ID", { scanId, storedInRef: scanIdRef.current });
        setScanStatus({
          phase: "queued",
          message: "Scan received. Getting in line...",
          details: "Our AI is about to process your image."
        });
        if (!processedScanIdsRef.current.has(scanId)) {
          processedScanIdsRef.current.add(scanId);
          try {
            let frameImageUrls = [];
            if (multiAngleMode && capturedFrames.length > 1) {
              for (let i = 1; i < capturedFrames.length; i++) {
                const frame = capturedFrames[i];
                const { base64: frameBase64, contentType: frameContentType } = yield resizeImageToBase64(frame.file, 1280, 0.7);
                const framePayload = {
                  filename: frame.file.name || `frame-${i}.jpg`,
                  contentType: frameContentType || "image/jpeg",
                  base64: frameBase64
                };
                const frameRes = yield fetch(apiUrl$1("/api/uploads"), {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify(framePayload)
                });
                const frameData = yield safeJson(frameRes);
                if (frameRes.ok && frameData.image_url) {
                  frameImageUrls.push(frameData.image_url);
                }
              }
            }
            console.time("[Scanner] process-trigger");
            const processRes = yield fetch(apiUrl$1(`/api/scans/${scanId}/process`), {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ frameImageUrls })
            });
            console.timeEnd("[Scanner] process-trigger");
            if (!processRes.ok) {
              let errorData = {};
              try {
                errorData = yield processRes.json();
              } catch (e) {
                console.warn("[startScan] Failed to parse error response", e);
              }
              console.error("[startScan] Process endpoint returned non-OK", {
                status: processRes.status,
                scanId,
                error: (errorData == null ? void 0 : errorData.error) || ((_a3 = errorData == null ? void 0 : errorData.error) == null ? void 0 : _a3.message) || "Unknown error",
                errorCode: ((_b2 = errorData == null ? void 0 : errorData.error) == null ? void 0 : _b2.code) || null
              });
              setIsUploading(false);
              setIsPolling(false);
              setScanPhase("error");
              const errorMessage = ((_c = errorData == null ? void 0 : errorData.error) == null ? void 0 : _c.message) || (errorData == null ? void 0 : errorData.error) || (errorData == null ? void 0 : errorData.message) || `Server returned ${processRes.status}`;
              setScanError({
                type: "server",
                message: "We couldn't start this scan.",
                details: errorMessage + ". Please try again in a moment.",
                scanId: scanId || void 0
              });
              setScanStatus({
                phase: "error",
                message: "Scan start failed.",
                details: "Our AI couldn't begin processing your image."
              });
              setError("We couldn't start this scan. Please try again in a moment.");
              setStatusMessage("Scan start failed. Please try again.");
              return;
            }
          } catch (e) {
            console.error("[startScan] Error triggering scan processing", {
              error: e,
              scanId,
              message: (e == null ? void 0 : e.message) || String(e)
            });
            setIsUploading(false);
            setIsPolling(false);
            setScanPhase("error");
            setScanError({
              type: "server",
              message: "We couldn't start this scan.",
              details: (e == null ? void 0 : e.message) || "Failed to start scan processing. Please try again.",
              scanId: scanId || void 0
            });
            setScanStatus({
              phase: "error",
              message: "Scan start failed.",
              details: "Our AI couldn't begin processing your image."
            });
            setError("We couldn't start this scan. Please try again in a moment.");
            setStatusMessage("Scan start failed. Please try again.");
            return;
          }
        }
        setIsUploading(false);
        setIsPolling(true);
        setScanPhase("processing");
        setStatusMessage("Processing image with Vision API");
        setScanStatus({
          phase: "processing",
          message: "Analyzing label & bud details...",
          details: "Running vision, OCR, and strain matching."
        });
        setHasCompletedScan(false);
        hasCompletedScanRef.current = false;
        const timeoutId = setTimeout(() => {
          if (!hasCompletedScanRef.current) {
            console.warn("[Scanner] Scan timed out", { scanId: currentScanId });
            setIsPolling(false);
            setScanPhase("error");
            setScanError({
              type: "timeout",
              message: "Our AI took longer than expected.",
              details: "This scan may still finish in the background. It's usually a temporary slowdown on the server or network.",
              scanId: currentScanId || void 0
            });
            setScanStatus({
              phase: "error",
              message: "Scan is taking longer than normal.",
              details: "You can try again now, or wait a bit and retry on a stronger connection."
            });
            setError("Our AI took longer than expected to finish this scan. Please try again in a moment.");
            setStatusMessage("Scan timed out. Please try again.");
          }
        }, 12e4);
        try {
          console.time("[Scanner] total-scan-time");
          yield pollScan(scanId, 0, timeoutId);
          console.timeEnd("[Scanner] total-scan-time");
        } finally {
          clearTimeout(timeoutId);
        }
      } catch (e) {
        console.error("[Scanner] startScan error", e);
        setIsUploading(false);
        setIsPolling(false);
        setHasCompletedScan(true);
        hasCompletedScanRef.current = true;
        setScanPhase("error");
        const errorMsg = String((e == null ? void 0 : e.message) || e || "");
        let userMessage = "We couldn't finish this scan. Please try again.";
        let errorType = "unknown";
        const isInternalError = /ReferenceError|TypeError|SyntaxError|hasCompletedScanRef|Can't find variable|is not defined/i.test(errorMsg);
        if (isInternalError) {
          console.error("[Scanner] Internal error detected, showing generic message:", errorMsg);
          userMessage = "We couldn't finish this scan. Please try again.";
          errorType = "client";
        } else {
          if (errorMsg.includes("413") || errorMsg.includes("too large") || errorMsg.includes("PayloadTooLargeError")) {
            userMessage = "Image is too large. Try taking the photo a bit farther away or with lower resolution.";
            errorType = "client";
          } else if (errorMsg.includes("400") || errorMsg.includes("Bad Request")) {
            userMessage = "Image problem (too large or wrong type). Try another photo.";
            errorType = "client";
          } else if (errorMsg.includes("Network") || errorMsg.includes("fetch") || errorMsg.includes("Failed to fetch") || /NetworkError|network/i.test(errorMsg)) {
            userMessage = "Network issue while scanning. Please check your connection and try again.";
            errorType = "network";
          } else if (errorMsg.includes("500") || errorMsg.includes("Internal Server Error")) {
            userMessage = "Scan failed on the server. Try again in a moment.";
            errorType = "server";
          } else if (errorMsg.includes("403") || errorMsg.includes("Guest scan limit")) {
            userMessage = "You've reached the guest scan limit. Sign up or upgrade to continue scanning.";
            errorType = "server";
          } else if (!errorMsg || errorMsg === "undefined" || errorMsg === "null") {
            userMessage = "Something went wrong. Please try again.";
            errorType = "unknown";
          }
        }
        setScanError({
          type: errorType,
          message: errorType === "network" ? "Network issue during scan." : errorType === "server" ? "Server couldn't finish your scan." : errorType === "client" ? "App had trouble reading the scan result." : "We couldn't finish this scan.",
          details: isInternalError ? "Internal error (see console)" : errorMsg,
          scanId: currentScanId || void 0
        });
        setScanStatus({
          phase: "error",
          message: errorType === "network" ? "Network issue." : errorType === "server" ? "Server error." : "Display error.",
          details: errorType === "network" ? "Check your connection and try again." : errorType === "server" ? "Our AI had trouble finishing this scan." : "We'll fix this in an update."
        });
        setError(userMessage);
        setStatusMessage(userMessage);
      }
    });
  }
  function pollScan(scanId, attempt = 0, timeoutRef = null) {
    return __async(this, null, function* () {
      var _a3, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
      const maxAttempts = 120;
      const delayMs = 1e3;
      const currentScanId2 = scanIdRef.current || scanId;
      if (!currentScanId2 || typeof currentScanId2 !== "string") {
        console.error("[POLL] ERROR: Invalid scanId", {
          scanId: currentScanId2,
          type: typeof currentScanId2,
          refScanId: scanIdRef.current,
          passedScanId: scanId
        });
        throw new Error(`Invalid scan ID: ${currentScanId2}`);
      }
      try {
        if (attempt === 0) {
          setStatusMessage("Processing image with Vision API");
          setScanStatus({
            phase: "processing",
            message: "Analyzing label & bud details...",
            details: "Running vision, OCR, and strain matching."
          });
        } else if (attempt < 5) {
          setStatusMessage("Extracting text from label");
          setScanStatus({
            phase: "processing",
            message: "Extracting text from label...",
            details: "Reading product information and batch numbers."
          });
        } else if (attempt < 10) {
          setStatusMessage("Matching against strain database");
          setScanStatus({
            phase: "processing",
            message: "Matching against strain database...",
            details: "Comparing your image against 35,000+ strains."
          });
        } else if (attempt < 20) {
          setStatusMessage("Analyzing product details");
          setScanStatus({
            phase: "finalizing",
            message: "Building summary & insights...",
            details: "Summarizing effects, warnings, and packaging info."
          });
        } else {
          setStatusMessage("Finalizing results");
          setScanStatus({
            phase: "finalizing",
            message: "Finalizing results...",
            details: "Almost done!"
          });
        }
        if (attempt === 0) {
          console.time("[Scanner] polling");
          console.log("[POLL] Starting poll", {
            scanId: currentScanId2,
            passedScanId: scanId,
            refScanId: scanIdRef.current,
            maxAttempts,
            timeoutMs: maxAttempts * delayMs
          });
        }
        console.log("[POLL] Polling scanId", {
          attempt,
          scanId: currentScanId2,
          passedScanId: scanId,
          refScanId: scanIdRef.current
        });
        const url = `${API_BASE}/api/scans/${currentScanId2}`;
        console.log("[POLL] Fetching scan", { scanId: currentScanId2, url });
        const res = yield fetch(url, {
          credentials: "include"
        });
        if (!res.ok) {
          const body2 = yield res.text().catch(() => "(no body)");
          console.error("[POLL] non-OK response", {
            scanId: currentScanId2,
            status: res.status,
            statusText: res.statusText,
            url,
            body: body2
          });
          throw new Error(`pollScan non-OK: ${res.status}`);
        }
        const scan = yield res.json();
        console.log("[POLL] raw scan data", { scanId: currentScanId2, scan });
        const isDone = scan.status === "completed" || scan.status === "failed" || !!scan.result || !!scan.ai_summary || !!scan.packaging_insights || !!scan.label_insights;
        if (isDone) {
          console.log("[POLL] Scan complete", {
            scanId: currentScanId2,
            status: scan.status,
            hasResult: !!scan.result,
            hasAISummary: !!scan.ai_summary,
            hasPackagingInsights: !!scan.packaging_insights,
            hasLabelInsights: !!scan.label_insights
          });
          if (timeoutRef) clearTimeout(timeoutRef);
          setIsPolling(false);
          setHasCompletedScan(true);
          hasCompletedScanRef.current = true;
          setScanPhase("done");
          setStatusMessage("Scan complete!");
          setError(null);
          setScanError(null);
          setScanStatus({
            phase: "completed",
            message: "Scan complete.",
            details: ""
          });
          const normalized = normalizeScanResult(scan);
          const result = scan.result;
          if (normalized) {
            setScanResult(normalized);
          } else {
            setScanResult({
              topMatch: null,
              otherMatches: [],
              matches: [],
              matched_strain_slug: null,
              labelInsights: (result == null ? void 0 : result.labelInsights) || null,
              aiSummary: ((_a3 = result == null ? void 0 : result.labelInsights) == null ? void 0 : _a3.aiSummary) || null,
              isPackagedProduct: ((_b2 = result == null ? void 0 : result.labelInsights) == null ? void 0 : _b2.isPackagedProduct) || false,
              packagingInsights: (result == null ? void 0 : result.packagingInsights) || null,
              visionRaw: (result == null ? void 0 : result.vision_raw) || null
            });
          }
          const processedResult = scan.result || normalized;
          const transformed = transformScanResult(scan);
          let matchedStrain = null;
          if (transformed && transformed.strainName && transformed.strainName !== "Cannabis (strain unknown)") {
            const packagingInsights = scan.packaging_insights || ((_c = scan.result) == null ? void 0 : _c.packagingInsights) || null;
            const labelInsights = scan.label_insights || ((_d = scan.result) == null ? void 0 : _d.labelInsights) || null;
            const lineage = (packagingInsights == null ? void 0 : packagingInsights.lineage) || (labelInsights == null ? void 0 : labelInsights.lineage) || null;
            const type = ((_e = packagingInsights == null ? void 0 : packagingInsights.basic) == null ? void 0 : _e.type) || (labelInsights == null ? void 0 : labelInsights.type) || null;
            matchedStrain = {
              name: transformed.strainName,
              // CRITICAL: Use strainName from transformScanResult
              lineage: lineage || null,
              type: type || null,
              thc: transformed.thc || null,
              // Use thc from transformScanResult
              cbd: transformed.cbd || null,
              // Use cbd from transformScanResult
              // CRITICAL: Use effects/flavors from transformScanResult (single source of truth)
              effects: transformed.effectsTags || null,
              flavors: transformed.flavorTags || null
            };
          }
          const extractedVisionText = scan.visionText || ((_h = (_g = (_f = result == null ? void 0 : result.vision_raw) == null ? void 0 : _f.textAnnotations) == null ? void 0 : _g[0]) == null ? void 0 : _h.description) || ((_j = (_i = result == null ? void 0 : result.vision_raw) == null ? void 0 : _i.fullTextAnnotation) == null ? void 0 : _j.text) || ((_m = (_l = (_k = result == null ? void 0 : result.visionRaw) == null ? void 0 : _k.textAnnotations) == null ? void 0 : _l[0]) == null ? void 0 : _m.description) || ((_o = (_n = result == null ? void 0 : result.visionRaw) == null ? void 0 : _n.fullTextAnnotation) == null ? void 0 : _o.text) || null;
          setCompletedScan({
            id: scan.id,
            result: processedResult,
            created_at: scan.created_at || (/* @__PURE__ */ new Date()).toISOString(),
            ai_summary: scan.ai_summary || null,
            summary: scan.summary || null,
            matchedStrain: matchedStrain || null,
            visionText: extractedVisionText || null,
            matched_strain_slug: scan.matched_strain_slug || null,
            // Store transformed result for ScanResultCard (single source of truth)
            transformed: transformed || null
          });
          if (scan.status === "completed" && scan.id) {
            handleScanCompleted(scan);
          }
          if (!isMember) {
            registerScanConsumed();
            if (isGuest) {
              const used = guestScansUsed + 1;
              setGuestScansUsedState(used);
              setGuestScansUsed(used);
            }
          }
          return;
        }
        if (scan.status === "failed" || (scan == null ? void 0 : scan.error)) {
          console.error("[POLL] scan failed", {
            scanId: currentScanId2,
            attempt,
            status: scan.status,
            error: scan == null ? void 0 : scan.error
          });
          if (timeoutRef) clearTimeout(timeoutRef);
          setIsPolling(false);
          setHasCompletedScan(true);
          hasCompletedScanRef.current = true;
          setScanPhase("error");
          setFramePulsing(false);
          const errorMessage = (scan == null ? void 0 : scan.error) || (scan == null ? void 0 : scan.errorMessage) || "Scan failed on the server.";
          let userMessage = errorMessage;
          if (errorMessage.includes("Vision") || errorMessage.includes("OCR")) {
            userMessage = "Could not read text from the image. Try a clearer photo with better lighting.";
          } else if (errorMessage.includes("match") || errorMessage.includes("strain")) {
            userMessage = "Could not find a matching strain. Try a photo that shows the product label clearly.";
          } else if (errorMessage.includes("storage") || errorMessage.includes("bucket")) {
            userMessage = "Storage error. Please try again in a moment.";
          }
          setScanError({
            type: "server",
            message: "Server couldn't finish your scan.",
            details: errorMessage,
            scanId: scanId || currentScanId2 || void 0
          });
          setScanStatus({
            phase: "error",
            message: "Server error.",
            details: "Our AI had trouble finishing this scan."
          });
          setError(userMessage);
          setStatusMessage(userMessage);
          return;
        }
        if (attempt >= 120) {
          if (timeoutRef) clearTimeout(timeoutRef);
          setIsPolling(false);
          setHasCompletedScan(true);
          hasCompletedScanRef.current = true;
          setScanPhase("error");
          setFramePulsing(false);
          setScanError({
            type: "timeout",
            message: "Our AI took longer than expected.",
            details: "This scan may still finish in the background. It's usually a temporary slowdown on the server or network.",
            scanId: scanId || currentScanId2 || void 0
          });
          setScanStatus({
            phase: "error",
            message: "Scan is taking longer than normal.",
            details: "You can try again now, or wait a bit and retry on a stronger connection."
          });
          const timeoutError = "Our AI took longer than expected to finish this scan. Please try again in a moment.";
          setError(timeoutError);
          setStatusMessage(timeoutError);
          return;
        }
        setTimeout(() => {
          const nextScanId = scanIdRef.current || currentScanId2 || scanId;
          if (!nextScanId) {
            console.error("[POLL] ERROR: No scan ID available for next poll attempt", {
              attempt,
              scanId,
              currentScanId: currentScanId2,
              refScanId: scanIdRef.current
            });
            throw new Error("Scan ID lost during polling");
          }
          pollScan(nextScanId, attempt + 1, timeoutRef);
        }, delayMs);
      } catch (e) {
        if (timeoutRef) clearTimeout(timeoutRef);
        console.error("[Scanner] pollScan error", {
          scanId: currentScanId2,
          attempt,
          message: (e == null ? void 0 : e.message) || String(e),
          name: (e == null ? void 0 : e.name) || "Error",
          stack: (e == null ? void 0 : e.stack) || null,
          error: e
        });
        setIsPolling(false);
        setHasCompletedScan(true);
        hasCompletedScanRef.current = true;
        setScanPhase("error");
        const errorMsg = String((e == null ? void 0 : e.message) || e || "");
        let userMessage = "We couldn't finish this scan. Please try again.";
        let errorType = "unknown";
        const isInternalError = /ReferenceError|TypeError|SyntaxError|hasCompletedScanRef|Can't find variable|is not defined/i.test(errorMsg);
        if (isInternalError) {
          console.error("[Scanner] Internal error detected, showing generic message:", errorMsg);
          userMessage = "We couldn't finish this scan. Please try again.";
          errorType = "client";
        } else {
          if (errorMsg.includes("404") || errorMsg.includes("not found")) {
            userMessage = "Scan not found. Please try scanning again.";
            errorType = "server";
          } else if (errorMsg.includes("500") || errorMsg.includes("Server error")) {
            userMessage = "Server error while processing scan. Please try again in a moment.";
            errorType = "server";
          } else if (errorMsg.includes("Network") || errorMsg.includes("fetch") || /NetworkError|network/i.test(errorMsg)) {
            userMessage = "Network issue while scanning. Please check your connection and try again.";
            errorType = "network";
          }
        }
        setScanError({
          type: errorType,
          message: errorType === "network" ? "Network issue during scan." : errorType === "server" ? "Server couldn't finish your scan." : "App had trouble reading the scan result.",
          details: isInternalError ? "Internal error (see console)" : errorMsg,
          scanId: scanId || currentScanId2 || void 0
        });
        setScanStatus({
          phase: "error",
          message: errorType === "network" ? "Network issue." : errorType === "server" ? "Server error." : "Display error.",
          details: errorType === "network" ? "Check your connection and try again." : errorType === "server" ? "Our AI had trouble finishing this scan." : "We'll fix this in an update."
        });
        setError(userMessage);
        setStatusMessage(userMessage);
        throw e;
      }
    });
  }
  function safeJson(res) {
    return __async(this, null, function* () {
      try {
        return yield res.json();
      } catch (e) {
        return null;
      }
    });
  }
  if (activeScanView === "result" && completedScan) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Stack,
      {
        direction: "column",
        sx: {
          height: "100vh",
          overflow: "hidden",
          backgroundColor: "#050705",
          paddingTop: "calc(env(safe-area-inset-top) + 20px)",
          paddingBottom: "env(safe-area-inset-bottom)"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Box,
            {
              sx: {
                flexShrink: 0,
                px: 2,
                pb: 1,
                maxWidth: "md",
                mx: "auto",
                width: "100%"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 2, mt: 0, pt: 0, display: "flex", alignItems: "center" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    IconButton$1,
                    {
                      onClick: handleBackToHome,
                      sx: {
                        mr: 1,
                        color: "#C5E1A5"
                      },
                      "aria-label": "Back to home",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowBackIcon, {})
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Typography,
                    {
                      variant: "subtitle2",
                      sx: { color: "#A5D6A7", fontWeight: 500 },
                      children: "Back to scanner"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mb: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Typography,
                  {
                    variant: "h5",
                    sx: {
                      color: "#F1F8E9",
                      fontWeight: 700,
                      mb: 0.5
                    },
                    children: "Scan result"
                  }
                ) })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Box,
            {
              sx: {
                flex: 1,
                minHeight: 0,
                overflowY: "auto",
                overflowX: "hidden",
                WebkitOverflowScrolling: "touch",
                position: "relative"
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Box,
                {
                  sx: {
                    px: 2,
                    pb: 2,
                    maxWidth: "md",
                    mx: "auto",
                    width: "100%"
                  },
                  children: [
                    (completedScan == null ? void 0 : completedScan.matchedStrain) && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mb: 1 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      StrainResultCard,
                      {
                        matchedStrain: completedScan.matchedStrain,
                        scan: completedScan
                      }
                    ) }),
                    !(completedScan == null ? void 0 : completedScan.matchedStrain) && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Box,
                      {
                        sx: {
                          mb: 1.5,
                          p: 1,
                          borderRadius: 1.5,
                          border: "1px solid rgba(90, 130, 90, 0.7)",
                          background: "rgba(5, 10, 5, 0.96)",
                          color: "#d6f5d6",
                          fontSize: "0.84rem"
                        },
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            Typography,
                            {
                              variant: "overline",
                              sx: {
                                fontSize: "0.78rem",
                                letterSpacing: "0.08em",
                                opacity: 0.75,
                                mb: 0.5,
                                display: "block"
                              },
                              children: "Scan details"
                            }
                          ),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            Box,
                            {
                              component: "pre",
                              sx: {
                                margin: 0,
                                whiteSpace: "pre-wrap",
                                wordBreak: "break-word",
                                fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace',
                                fontSize: "0.76rem",
                                opacity: 0.88
                              },
                              children: JSON.stringify(
                                {
                                  id: completedScan.id,
                                  matched_strain_slug: completedScan.matched_strain_slug,
                                  created_at: completedScan.created_at
                                },
                                null,
                                2
                              )
                            }
                          )
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      ScanResultCard,
                      {
                        scan: completedScan,
                        result: normalizeScanResult(completedScan),
                        onCorrectionSaved: () => {
                          console.log("[ScanResultCard] correction saved");
                        }
                      }
                    ),
                    (completedScan == null ? void 0 : completedScan.summary) && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mt: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScanAISummaryPanel, { summary: completedScan.summary }) }),
                    (completedScan == null ? void 0 : completedScan.ai_summary) && !(completedScan == null ? void 0 : completedScan.summary) && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mt: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      ScanAISummaryPanel,
                      {
                        aiSummary: completedScan.ai_summary,
                        visionText: completedScan.visionText || null
                      }
                    ) }),
                    (completedScan == null ? void 0 : completedScan.aiSummary) && !(completedScan == null ? void 0 : completedScan.summary) && !(completedScan == null ? void 0 : completedScan.ai_summary) && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mt: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScanAISummaryPanel, { summary: completedScan.aiSummary }) })
                  ]
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Box,
            {
              sx: {
                flexShrink: 0,
                p: 2,
                borderTop: "1px solid rgba(255, 255, 255, 0.1)",
                background: "rgba(0, 0, 0, 0.3)",
                backdropFilter: "blur(12px)",
                maxWidth: "md",
                mx: "auto",
                width: "100%"
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1.5, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: "outlined",
                    fullWidth: true,
                    onClick: handleBackToHome,
                    sx: {
                      textTransform: "none",
                      borderColor: "rgba(197, 225, 165, 0.8)",
                      color: "#C5E1A5",
                      fontWeight: 500,
                      "&:hover": {
                        borderColor: "#CDDC39",
                        backgroundColor: "rgba(156, 204, 101, 0.08)"
                      }
                    },
                    children: "Back to scanner"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: "contained",
                    fullWidth: true,
                    onClick: handleScanAgain,
                    sx: {
                      textTransform: "none",
                      backgroundColor: "#9CCC65",
                      color: "#050705",
                      fontWeight: 600,
                      "&:hover": {
                        backgroundColor: "#CDDC39"
                      }
                    },
                    children: "Scan again"
                  }
                )
              ] })
            }
          )
        ]
      }
    );
  }
  if (!cameraReady) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        sx: {
          minHeight: "100vh",
          width: "100%",
          backgroundColor: "#050705",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          position: "relative",
          zIndex: 1,
          paddingTop: "env(safe-area-inset-top)",
          paddingBottom: "env(safe-area-inset-bottom)"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Paper,
          {
            elevation: 6,
            sx: {
              p: 4,
              borderRadius: 3,
              background: "rgba(12, 20, 12, 0.95)",
              border: "1px solid rgba(124, 179, 66, 0.6)",
              textAlign: "center",
              maxWidth: 320,
              pointerEvents: "auto"
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, alignItems: "center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 48, sx: { color: "#CDDC39" } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#F1F8E9", fontWeight: 600 }, children: statusMessage || "Opening camera" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "rgba(224, 242, 241, 0.8)" }, children: "Preparing scanner for you." })
            ] })
          }
        )
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box,
    {
      sx: {
        height: "100dvh",
        display: "flex",
        flexDirection: "column",
        overflow: "hidden",
        bgcolor: "background.default",
        backgroundColor: "#050705",
        backgroundImage: "url(/strainspotter-bg.jpg)",
        backgroundSize: "cover",
        backgroundPosition: "center",
        backgroundRepeat: "no-repeat",
        position: "relative"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            sx: {
              position: "absolute",
              inset: 0,
              background: "radial-gradient(circle at top, rgba(124,179,66,0.25), transparent 55%)",
              pointerEvents: "none",
              zIndex: 0
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            sx: {
              flexShrink: 0,
              display: "flex",
              alignItems: "center",
              paddingX: 2,
              paddingTop: 1.5,
              paddingBottom: 1.5,
              gap: 1.5,
              position: "relative",
              zIndex: 1
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton$1,
                {
                  edge: "start",
                  onClick: handleBack,
                  sx: { mr: 1, color: "#C5E1A5" },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowBackIcon, {})
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { flex: 1 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle2", sx: { color: "rgba(255,255,255,0.7)" }, children: "StrainSpotter" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", fontWeight: "600", sx: { color: "#fff" }, children: "Scan a package or bud" })
              ] })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            sx: {
              flex: 1,
              minHeight: 0,
              overflowY: "auto",
              WebkitOverflowScrolling: "touch",
              px: 2,
              pb: 2,
              position: "relative",
              zIndex: 1
            },
            children: [
              scanStatus.phase !== "idle" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                Box,
                {
                  sx: {
                    pt: 1,
                    pb: 1
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Box,
                    {
                      sx: {
                        padding: "8px 12px",
                        borderRadius: "999px",
                        fontSize: 12,
                        display: "flex",
                        alignItems: "center",
                        gap: 1,
                        backgroundColor: scanStatus.phase === "error" ? "rgba(220, 53, 69, 0.12)" : scanStatus.phase === "completed" ? "rgba(25, 135, 84, 0.14)" : "rgba(15, 118, 110, 0.16)",
                        color: "#e5fbea",
                        border: scanStatus.phase === "error" ? "1px solid rgba(220, 53, 69, 0.3)" : "none"
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 14 }, children: scanStatus.phase === "error" ? "" : scanStatus.phase === "completed" ? "" : "" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { flex: 1 }, children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { fontWeight: 500, fontSize: 13 }, children: scanStatus.message || "Ready to scan." }),
                          scanStatus.details && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { fontSize: 11, opacity: 0.8, mt: 0.25 }, children: scanStatus.details })
                        ] })
                      ]
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Container,
                {
                  maxWidth: "sm",
                  sx: {
                    px: 0,
                    display: "flex",
                    flexDirection: "column",
                    gap: 2
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mb: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", justifyContent: "space-between", alignItems: "flex-start", mb: 1 }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { flex: 1 }, children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          Typography,
                          {
                            variant: "h5",
                            sx: {
                              color: "#F1F8E9",
                              fontWeight: 700,
                              mb: 0.5
                            },
                            children: "Scan weed products"
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          Typography,
                          {
                            variant: "body2",
                            sx: { color: "rgba(224, 242, 241, 0.9)" },
                            children: "Choose or take a photo of a cannabis product or bud. We'll analyze it and show you the closest strain matches."
                          }
                        )
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { textAlign: "right", ml: 2, minWidth: 160 }, children: isMember ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          Typography,
                          {
                            variant: "caption",
                            sx: {
                              color: "rgba(163, 230, 186, 0.9)",
                              fontWeight: 700,
                              textTransform: "uppercase",
                              letterSpacing: "0.08em"
                            },
                            children: "Member"
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          Typography,
                          {
                            variant: "body2",
                            sx: {
                              color: "rgba(255,255,255,0.9)",
                              fontWeight: 500
                            },
                            children: [
                              "Included scans: ",
                              memberCap - memberRemaining,
                              "/",
                              memberCap
                            ]
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          Typography,
                          {
                            variant: "caption",
                            sx: { color: "rgba(190, 242, 100, 0.9)" },
                            children: [
                              "Scans left: ",
                              totalAvailableScans,
                              extraCredits > 0 ? " (with top-ups)" : ""
                            ]
                          }
                        )
                      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          Typography,
                          {
                            variant: "caption",
                            sx: { color: "rgba(248, 250, 252, 0.7)" },
                            children: [
                              "Free starter scans used:",
                              " ",
                              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: starterCap - starterRemaining }),
                              " / ",
                              starterCap
                            ]
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          Typography,
                          {
                            variant: "body2",
                            sx: {
                              mt: 0.25,
                              color: totalAvailableScans === 0 ? "#fecaca" : totalAvailableScans <= 5 ? "#fde68a" : "#bbf7d0",
                              fontWeight: 600
                            },
                            children: [
                              "Scans available: ",
                              totalAvailableScans
                            ]
                          }
                        ),
                        extraCredits > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          Typography,
                          {
                            variant: "caption",
                            sx: { color: "rgba(190, 242, 100, 0.9)" },
                            children: [
                              "Includes ",
                              extraCredits,
                              " top-up scans"
                            ]
                          }
                        )
                      ] }) })
                    ] }) }),
                    user && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Typography,
                      {
                        variant: "caption",
                        sx: { color: "#9CCC65", mb: 1.5 },
                        children: [
                          "Signed in as ",
                          user.email,
                          ". Your scans will be saved to your account."
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Paper,
                      {
                        elevation: 6,
                        sx: {
                          p: 2.5,
                          borderRadius: 3,
                          background: "rgba(12, 20, 12, 0.95)",
                          border: "1px solid rgba(124, 179, 66, 0.6)",
                          boxShadow: "0 18px 40px rgba(0, 0, 0, 0.7)",
                          mb: 3
                        },
                        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsxs(
                            Box,
                            {
                              sx: {
                                borderRadius: 2,
                                border: "2px dashed rgba(200, 230, 201, 0.5)",
                                minHeight: 200,
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center",
                                overflow: "hidden",
                                background: "radial-gradient(circle at top, rgba(76, 175, 80, 0.15), rgba(0, 0, 0, 0.95))",
                                position: "relative",
                                animation: framePulsing ? "scan-pulse 1.4s infinite" : "none",
                                "@keyframes scan-pulse": {
                                  "0%": { boxShadow: "0 0 0 0 rgba(0, 255, 120, 0.5)" },
                                  "70%": { boxShadow: "0 0 0 12px rgba(0, 255, 120, 0)" },
                                  "100%": { boxShadow: "0 0 0 0 rgba(0, 255, 120, 0)" }
                                }
                              },
                              children: [
                                previewUrl ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                                  Box,
                                  {
                                    component: "img",
                                    src: previewUrl,
                                    alt: "Selected to scan",
                                    sx: { width: "100%", maxHeight: 280, objectFit: "cover" }
                                  }
                                ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 1, alignItems: "center", children: [
                                  /* @__PURE__ */ jsxRuntimeExports.jsx(CameraAltIcon, { sx: { fontSize: 40, color: "#A5D6A7" } }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                    Typography,
                                    {
                                      variant: "body2",
                                      sx: { color: "rgba(224, 242, 241, 0.9)" },
                                      children: [
                                        scanPhase === "ready" && "Align the label in this area when you take the photo.",
                                        scanPhase === "capturing" && "Preparing image",
                                        scanPhase === "uploading" && (statusMessage || "Uploading image"),
                                        scanPhase === "processing" && (statusMessage || "Processing image with Vision API"),
                                        scanPhase === "done" && "Scan complete! You can review the details below.",
                                        scanPhase !== "ready" && scanPhase !== "capturing" && scanPhase !== "uploading" && scanPhase !== "processing" && scanPhase !== "done" && "Tap below to take a new photo or choose one from your library."
                                      ]
                                    }
                                  )
                                ] }),
                                lastPhotoUrl && /* @__PURE__ */ jsxRuntimeExports.jsx(
                                  Box,
                                  {
                                    sx: {
                                      position: "absolute",
                                      bottom: 8,
                                      right: 8,
                                      width: 64,
                                      height: 64,
                                      borderRadius: 1,
                                      overflow: "hidden",
                                      border: "1px solid rgba(255, 255, 255, 0.4)"
                                    },
                                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                                      Box,
                                      {
                                        component: "img",
                                        src: lastPhotoUrl,
                                        alt: "Last captured",
                                        sx: { width: "100%", height: "100%", objectFit: "cover" }
                                      }
                                    )
                                  }
                                )
                              ]
                            }
                          ),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            "input",
                            {
                              id: "scan-file-input",
                              type: "file",
                              accept: "image/*",
                              style: { display: "none" },
                              onChange: handleFileChange
                            }
                          ),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 1.5, children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              Button,
                              {
                                variant: "contained",
                                fullWidth: true,
                                size: "large",
                                startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(CloudUploadIcon, {}),
                                onClick: handlePickImageClick,
                                disabled: !isFounder && !canScanFromHook && (isOpeningPicker || scanPhase === "uploading" || scanPhase === "processing" || scanPhase === "capturing"),
                                sx: {
                                  textTransform: "none",
                                  fontWeight: 700,
                                  py: 1.3,
                                  borderRadius: 2,
                                  background: "linear-gradient(135deg, #7CB342 0%, #9CCC65 50%, #CDDC39 100%)",
                                  boxShadow: "0 8px 32px rgba(124, 179, 66, 0.5), 0 0 40px rgba(124, 179, 66, 0.3)",
                                  "&:hover": {
                                    background: "linear-gradient(135deg, #8BC34A 0%, #AED581 50%, #CDDC39 100%)",
                                    boxShadow: "0 12px 40px rgba(124, 179, 66, 0.7), 0 0 60px rgba(124, 179, 66, 0.4)"
                                  }
                                },
                                children: scanPhase === "uploading" ? "Uploading" : scanPhase === "processing" ? "Processing" : isOpeningPicker ? "Opening camera" : isFounder || canScanFromHook ? "Scan a package or bud" : "Upgrade to keep scanning"
                              }
                            ),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              Button,
                              {
                                variant: "outlined",
                                fullWidth: true,
                                size: "large",
                                onClick: selectedFile ? handleStartScan : handleChoosePhotoClick,
                                disabled: !selectedFile && isChoosingFile || isUploading || isPolling || previewUrl && (isUploading || isPolling),
                                sx: {
                                  textTransform: "none",
                                  fontWeight: 700,
                                  py: 1.1,
                                  borderRadius: 2,
                                  borderColor: selectedFile ? "#9CCC65" : "rgba(200, 230, 201, 0.4)",
                                  color: selectedFile ? "#C5E1A5" : "rgba(224, 242, 241, 0.6)",
                                  "&:hover": {
                                    borderColor: selectedFile ? "#CDDC39" : "rgba(200, 230, 201, 0.4)",
                                    backgroundColor: selectedFile ? "rgba(156, 204, 101, 0.12)" : "transparent"
                                  }
                                },
                                children: isUploading ? "Uploading photo" : isPolling ? "Analyzing" : selectedFile ? "Start scan" : isChoosingFile ? "Opening photos" : "Choose photo"
                              }
                            ),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              Button,
                              {
                                variant: "text",
                                size: "small",
                                onClick: toggleMultiAngleMode,
                                sx: {
                                  textTransform: "none",
                                  color: multiAngleMode ? "#CDDC39" : "rgba(224, 242, 241, 0.7)",
                                  fontSize: "0.75rem",
                                  py: 0.5
                                },
                                children: multiAngleMode ? " Multi-angle mode" : "Multi-angle mode (3 photos)"
                              }
                            ),
                            multiAngleMode && capturedFrames.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                              Box,
                              {
                                sx: {
                                  mt: 1,
                                  p: 1.5,
                                  borderRadius: 1,
                                  backgroundColor: "rgba(124, 179, 66, 0.15)",
                                  border: "1px solid rgba(124, 179, 66, 0.3)"
                                },
                                children: [
                                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                    Typography,
                                    {
                                      variant: "body2",
                                      sx: { color: "rgba(224, 242, 241, 0.9)", mb: 0.5 },
                                      children: [
                                        capturedFrames.length,
                                        "/",
                                        MAX_FRAMES,
                                        " photos captured"
                                      ]
                                    }
                                  ),
                                  capturedFrames.length >= MAX_FRAMES ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                                    Button,
                                    {
                                      variant: "contained",
                                      fullWidth: true,
                                      size: "medium",
                                      onClick: handleStartMultiAngleScan,
                                      disabled: !isFounder && (isUploading || isPolling || !canScan),
                                      sx: {
                                        textTransform: "none",
                                        background: "linear-gradient(135deg, #7CB342, #9CCC65)",
                                        mt: 0.5
                                      },
                                      children: "Start multi-angle scan"
                                    }
                                  ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                    Typography,
                                    {
                                      variant: "caption",
                                      sx: { color: "rgba(224, 242, 241, 0.7)" },
                                      children: [
                                        "Capture ",
                                        MAX_FRAMES - capturedFrames.length,
                                        " more photo",
                                        MAX_FRAMES - capturedFrames.length > 1 ? "s" : ""
                                      ]
                                    }
                                  )
                                ]
                              }
                            ),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              Typography,
                              {
                                variant: "caption",
                                sx: { color: "rgba(224, 242, 241, 0.8)" },
                                children: multiAngleMode ? "Capture the same product from different angles for better accuracy." : "Clear, close-up photos of labels or flowers give the best results."
                              }
                            )
                          ] }),
                          (previewUrl || selectedFile) && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                            Box,
                            {
                              sx: {
                                mt: 2,
                                mb: 1,
                                borderRadius: 2,
                                overflow: "hidden",
                                border: "1px solid",
                                borderColor: "rgba(124, 179, 66, 0.3)",
                                bgcolor: "rgba(0, 0, 0, 0.3)"
                              },
                              children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsx(
                                  Box,
                                  {
                                    component: "img",
                                    src: previewUrl || (selectedFile ? URL.createObjectURL(selectedFile) : null),
                                    alt: "Selected photo",
                                    sx: {
                                      width: "100%",
                                      height: 220,
                                      objectFit: "cover",
                                      display: "block"
                                    }
                                  }
                                ),
                                /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { p: 1.5, borderTop: "1px solid rgba(124, 179, 66, 0.2)" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, alignItems: "center", children: [
                                  (isUploading || isPolling) && /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 16, sx: { color: "#9CCC65" } }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                                    Typography,
                                    {
                                      variant: "caption",
                                      sx: {
                                        color: isUploading || isPolling ? "rgba(156, 204, 101, 0.9)" : "rgba(224, 242, 241, 0.7)",
                                        fontSize: 12,
                                        fontWeight: isUploading || isPolling ? 600 : 400
                                      },
                                      children: isUploading ? "Uploading photo" : isPolling ? "Processing scan this may take a few seconds." : "Photo selected. Ready to scan."
                                    }
                                  )
                                ] }) })
                              ]
                            }
                          ),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs(
                            Box,
                            {
                              sx: {
                                mt: 2,
                                p: 1.5,
                                borderRadius: 1,
                                backgroundColor: scanPhase === "error" ? "rgba(239, 68, 68, 0.15)" : "rgba(124, 179, 66, 0.1)",
                                border: `1px solid ${scanPhase === "error" ? "rgba(239, 68, 68, 0.4)" : "rgba(124, 179, 66, 0.3)"}`
                              },
                              children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1.5, alignItems: "center", children: [
                                  scanPhase !== "ready" && scanPhase !== "done" && scanPhase !== "error" && /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 18, sx: { color: "#CDDC39" } }),
                                  scanPhase === "error" && /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: { color: "#fecaca", fontSize: 18 }, children: "" }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                    Typography,
                                    {
                                      variant: "body2",
                                      sx: {
                                        color: scanPhase === "error" ? "#fecaca" : "rgba(224, 242, 241, 0.9)",
                                        flex: 1
                                      },
                                      children: [
                                        scanPhase === "ready" && (statusMessage || "Ready to scan."),
                                        scanPhase === "capturing" && "Preparing image",
                                        scanPhase === "uploading" && (statusMessage || "Uploading image"),
                                        scanPhase === "processing" && (statusMessage || "Processing image with Vision API"),
                                        scanPhase === "done" && "Scan complete!",
                                        scanPhase === "error" && (error2 || "Scan failed. Please try again.")
                                      ]
                                    }
                                  )
                                ] }),
                                scanPhase === "error" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                                  Button,
                                  {
                                    variant: "contained",
                                    fullWidth: true,
                                    size: "medium",
                                    onClick: () => {
                                      setError(null);
                                      setScanPhase("ready");
                                      setStatusMessage("Ready to scan.");
                                      setSelectedFile(null);
                                      setPreviewUrl(null);
                                      if (previewUrl) {
                                        URL.revokeObjectURL(previewUrl);
                                      }
                                      if (lastPhotoUrl) {
                                        URL.revokeObjectURL(lastPhotoUrl);
                                      }
                                      setCapturedFrames([]);
                                    },
                                    sx: {
                                      mt: 1.5,
                                      textTransform: "none",
                                      background: "linear-gradient(135deg, #7CB342, #9CCC65)",
                                      "&:hover": {
                                        background: "linear-gradient(135deg, #8BC34A, #AED581)"
                                      }
                                    },
                                    children: "Try again"
                                  }
                                )
                              ]
                            }
                          ),
                          error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                            Alert,
                            {
                              severity: "warning",
                              sx: {
                                mt: 1.5,
                                backgroundColor: "rgba(255, 244, 179, 0.08)",
                                color: "#FFF59D",
                                "& .MuiAlert-icon": { color: "#FFEE58" }
                              },
                              children: error2
                            }
                          )
                        ] })
                      }
                    ),
                    scanPhase !== "ready" && scanPhase !== "done" && scanPhase !== "error" && !scanResult && !error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Paper,
                      {
                        elevation: 6,
                        sx: {
                          p: 2.5,
                          borderRadius: 3,
                          background: "rgba(12, 20, 12, 0.95)",
                          border: "1px solid rgba(124, 179, 66, 0.6)",
                          boxShadow: "0 18px 40px rgba(0, 0, 0, 0.7)",
                          mb: 3
                        },
                        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            Skeleton,
                            {
                              variant: "text",
                              width: "60%",
                              height: 40,
                              sx: { bgcolor: "rgba(255, 255, 255, 0.1)" }
                            }
                          ),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            Skeleton,
                            {
                              variant: "text",
                              width: "100%",
                              height: 24,
                              sx: { bgcolor: "rgba(255, 255, 255, 0.08)" }
                            }
                          ),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            Skeleton,
                            {
                              variant: "text",
                              width: "80%",
                              height: 24,
                              sx: { bgcolor: "rgba(255, 255, 255, 0.08)" }
                            }
                          )
                        ] })
                      }
                    ),
                    scanPhase === "error" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Button,
                      {
                        variant: "outlined",
                        fullWidth: true,
                        onClick: handleScanAgain,
                        sx: {
                          mt: 2,
                          textTransform: "none",
                          borderColor: "#9CCC65",
                          color: "#C5E1A5",
                          "&:hover": {
                            borderColor: "#CDDC39",
                            backgroundColor: "rgba(156, 204, 101, 0.1)"
                          }
                        },
                        children: "Scan again"
                      }
                    ),
                    !scanResult && scanPhase === "ready" && !error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Typography,
                      {
                        variant: "body2",
                        sx: {
                          color: "rgba(224, 242, 241, 0.8)",
                          textAlign: "center"
                        },
                        children: "After you scan, we'll show you the best match and similar strains here."
                      }
                    )
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { height: 8, flexShrink: 0 } }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Dialog,
          {
            open: showPlans,
            onClose: () => setShowPlans(false),
            fullWidth: true,
            maxWidth: "xs",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: "Get more scans" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { dividers: true, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { mb: 2 }, children: "You've used your 20 free guest scans. Join the garden to unlock full access and auto-refreshing monthly scan bundles." }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      variant: "contained",
                      fullWidth: true,
                      onClick: () => {
                        setShowPlans(false);
                        onNavigate == null ? void 0 : onNavigate("membership");
                      },
                      children: "View membership plans"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      variant: "outlined",
                      fullWidth: true,
                      onClick: () => {
                        setShowPlans(false);
                        onNavigate == null ? void 0 : onNavigate("buy-scans");
                      },
                      children: "Buy additional scan packs"
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActions, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => setShowPlans(false), children: "Close" }) })
            ]
          }
        )
      ]
    }
  );
}
const ScanPage$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ScanPage
}, Symbol.toStringTag, { value: "Module" }));
function HistoryListItem({ scan, onClick }) {
  var _a2, _b;
  if (!scan) return null;
  const transformed = transformScanResult(scan);
  const strainName = (transformed == null ? void 0 : transformed.strainName) || scan.canonical_strain_name || scan.matched_strain_name || "Unknown";
  const isPackaged = (transformed == null ? void 0 : transformed.isPackagedProduct) || false;
  const matchConfidence = (transformed == null ? void 0 : transformed.matchConfidence) || scan.canonical_match_confidence || scan.match_confidence || null;
  const intensity = (transformed == null ? void 0 : transformed.intensity) || ((_a2 = scan.ai_summary) == null ? void 0 : _a2.intensity) || ((_b = scan.ai_summary) == null ? void 0 : _b.potency_score) || null;
  const proRole = scan.pro_role;
  const date = new Date(scan.created_at);
  const dateStr = date.toLocaleDateString("en-US", {
    month: "short",
    day: "numeric",
    year: date.getFullYear() !== (/* @__PURE__ */ new Date()).getFullYear() ? "numeric" : void 0
  });
  const timeStr = date.toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    hour12: true
  });
  const thumbnailUrl = scan.image_url || null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Card,
    {
      onClick,
      sx: {
        mb: 2,
        cursor: "pointer",
        background: "rgba(255, 255, 255, 0.05)",
        border: "1px solid rgba(124, 179, 66, 0.2)",
        backdropFilter: "blur(6px)",
        transition: "all 0.2s",
        "&:hover": {
          borderColor: "rgba(124, 179, 66, 0.4)",
          background: "rgba(255, 255, 255, 0.08)",
          transform: "translateY(-2px)"
        }
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { sx: { p: 2, "&:last-child": { pb: 2 } }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", gap: 2 }, children: [
        thumbnailUrl && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            sx: {
              width: 80,
              height: 80,
              borderRadius: 2,
              overflow: "hidden",
              flexShrink: 0,
              background: "rgba(0, 0, 0, 0.3)",
              display: "flex",
              alignItems: "center",
              justifyContent: "center"
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: thumbnailUrl,
                alt: "Scan",
                style: {
                  width: "100%",
                  height: "100%",
                  objectFit: "cover"
                },
                onError: (e) => {
                  e.target.style.display = "none";
                }
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { flex: 1, minWidth: 0 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 1, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", gap: 1, flexWrap: "wrap" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Typography,
              {
                variant: "h6",
                sx: {
                  color: "#E8F5E9",
                  fontWeight: 700,
                  fontSize: "1rem",
                  flex: 1,
                  minWidth: 0,
                  overflow: "hidden",
                  textOverflow: "ellipsis",
                  whiteSpace: "nowrap"
                },
                children: strainName
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Chip,
              {
                icon: isPackaged ? /* @__PURE__ */ jsxRuntimeExports.jsx(LocalShippingIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(SpaIcon, {}),
                label: isPackaged ? "Packaged" : "Bud",
                size: "small",
                sx: {
                  height: "24px",
                  fontSize: "0.7rem",
                  bgcolor: isPackaged ? "rgba(124, 179, 66, 0.15)" : "rgba(179, 229, 252, 0.15)",
                  color: isPackaged ? "#9AE66E" : "#B3E5FC",
                  border: `1px solid ${isPackaged ? "rgba(124, 179, 66, 0.3)" : "rgba(179, 229, 252, 0.3)"}`
                }
              }
            ),
            proRole && /* @__PURE__ */ jsxRuntimeExports.jsx(
              Chip,
              {
                label: proRole === "dispensary" ? "Dispensary" : "Grower",
                size: "small",
                sx: {
                  height: "20px",
                  fontSize: "0.65rem",
                  bgcolor: "rgba(124, 179, 66, 0.2)",
                  color: "#9AE66E",
                  border: "1px solid rgba(124, 179, 66, 0.4)"
                }
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Typography,
            {
              variant: "caption",
              sx: { color: "rgba(200, 230, 201, 0.7)" },
              children: [
                dateStr,
                "  ",
                timeStr
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, flexWrap: "wrap", gap: 0.5, children: [
            !isPackaged && matchConfidence !== null && /* @__PURE__ */ jsxRuntimeExports.jsx(
              Chip,
              {
                label: `${Math.round(matchConfidence * 100)}% match`,
                size: "small",
                sx: {
                  height: "20px",
                  fontSize: "0.65rem",
                  bgcolor: matchConfidence >= 0.8 ? "rgba(76, 175, 80, 0.2)" : "rgba(255, 152, 0, 0.2)",
                  color: matchConfidence >= 0.8 ? "#81C784" : "#FFB74D",
                  border: `1px solid ${matchConfidence >= 0.8 ? "rgba(76, 175, 80, 0.3)" : "rgba(255, 152, 0, 0.3)"}`
                }
              }
            ),
            intensity !== null && /* @__PURE__ */ jsxRuntimeExports.jsx(
              Chip,
              {
                label: `Intensity: ${intensity.toFixed(1)}/5`,
                size: "small",
                sx: {
                  height: "20px",
                  fontSize: "0.65rem",
                  bgcolor: "rgba(255, 204, 128, 0.15)",
                  color: "#FFCC80",
                  border: "1px solid rgba(255, 204, 128, 0.3)"
                }
              }
            )
          ] })
        ] }) })
      ] }) })
    }
  );
}
function AnalyticsSummary({ scans, proRole }) {
  if (!scans || scans.length === 0) {
    return null;
  }
  const now = /* @__PURE__ */ new Date();
  const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
  const thisMonthScans = scans.filter((s) => new Date(s.created_at) >= startOfMonth);
  const packagedScans = scans.filter((s) => {
    var _a2;
    const pkg = s.packaging_insights || s.label_insights || {};
    return !!(pkg.strainName || ((_a2 = pkg.basic) == null ? void 0 : _a2.strain_name));
  });
  const budScans = scans.filter((s) => {
    var _a2;
    const pkg = s.packaging_insights || s.label_insights || {};
    return !(pkg.strainName || ((_a2 = pkg.basic) == null ? void 0 : _a2.strain_name));
  });
  const strainCounts = {};
  scans.forEach((scan) => {
    const strainName = scan.canonical_strain_name || scan.matched_strain_name || "Unknown";
    strainCounts[strainName] = (strainCounts[strainName] || 0) + 1;
  });
  const topStrains = Object.entries(strainCounts).sort((a, b) => b[1] - a[1]).slice(0, 3).map(([name2, count]) => ({ name: name2, count }));
  const intensities = scans.map((s) => {
    var _a2, _b;
    return ((_a2 = s.ai_summary) == null ? void 0 : _a2.intensity) || ((_b = s.ai_summary) == null ? void 0 : _b.potency_score);
  }).filter((i) => typeof i === "number");
  const avgIntensity = intensities.length > 0 ? intensities.reduce((a, b) => a + b, 0) / intensities.length : null;
  const warningsCount = scans.filter((s) => {
    var _a2, _b;
    const warnings = ((_a2 = s.ai_summary) == null ? void 0 : _a2.risksAndWarnings) || ((_b = s.ai_summary) == null ? void 0 : _b.warnings) || [];
    return Array.isArray(warnings) && warnings.length > 0;
  }).length;
  const dispensaryScans = scans.filter((s) => s.pro_role === "dispensary").length;
  const growerScans = scans.filter((s) => s.pro_role === "grower").length;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Card,
    {
      sx: {
        mb: 3,
        background: "rgba(255, 255, 255, 0.05)",
        border: "1px solid rgba(124, 179, 66, 0.3)",
        backdropFilter: "blur(6px)"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { mb: 2, color: "#E8F5E9", fontWeight: 700 }, children: "Analytics Summary" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 2, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "rgba(200, 230, 201, 0.7)", mb: 0.5 }, children: "This Month" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h5", sx: { color: "#E8F5E9", fontWeight: 700 }, children: [
              thisMonthScans.length,
              " scans"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, { sx: { borderColor: "rgba(124, 179, 66, 0.2)" } }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "rgba(200, 230, 201, 0.7)", mb: 1 }, children: "Product Type" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, flexWrap: "wrap", gap: 1, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Chip,
                {
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(LocalShippingIcon, {}),
                  label: `${packagedScans.length} Packaged`,
                  size: "small",
                  sx: {
                    bgcolor: "rgba(124, 179, 66, 0.15)",
                    color: "#9AE66E",
                    border: "1px solid rgba(124, 179, 66, 0.3)"
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Chip,
                {
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(SpaIcon, {}),
                  label: `${budScans.length} Bud`,
                  size: "small",
                  sx: {
                    bgcolor: "rgba(124, 179, 66, 0.15)",
                    color: "#9AE66E",
                    border: "1px solid rgba(124, 179, 66, 0.3)"
                  }
                }
              )
            ] }),
            scans.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", sx: { color: "rgba(200, 230, 201, 0.6)", mt: 0.5, display: "block" }, children: [
              Math.round(packagedScans.length / scans.length * 100),
              "% packaged"
            ] })
          ] }),
          topStrains.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, { sx: { borderColor: "rgba(124, 179, 66, 0.2)" } }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "rgba(200, 230, 201, 0.7)", mb: 1 }, children: "Top Strains" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 0.5, children: topStrains.map(({ name: name2, count }, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", justifyContent: "space-between", alignItems: "center" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { color: "#E8F5E9" }, children: [
                  idx + 1,
                  ". ",
                  name2
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Chip,
                  {
                    label: count,
                    size: "small",
                    sx: {
                      bgcolor: "rgba(124, 179, 66, 0.15)",
                      color: "#9AE66E",
                      height: "20px",
                      fontSize: "0.7rem"
                    }
                  }
                )
              ] }, idx)) })
            ] })
          ] }),
          avgIntensity !== null && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, { sx: { borderColor: "rgba(124, 179, 66, 0.2)" } }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "rgba(200, 230, 201, 0.7)", mb: 0.5 }, children: "Avg AI Intensity" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", gap: 1 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingUpIcon, { sx: { color: "#9AE66E", fontSize: "1.2rem" } }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h6", sx: { color: "#E8F5E9", fontWeight: 700 }, children: [
                  avgIntensity.toFixed(1),
                  "/5"
                ] })
              ] })
            ] })
          ] }),
          warningsCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, { sx: { borderColor: "rgba(124, 179, 66, 0.2)" } }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "rgba(200, 230, 201, 0.7)", mb: 0.5 }, children: "Warnings Encountered" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", gap: 1 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(WarningIcon, { sx: { color: "#FFCC80", fontSize: "1.2rem" } }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h6", sx: { color: "#FFCC80", fontWeight: 700 }, children: [
                  warningsCount,
                  " scans"
                ] })
              ] })
            ] })
          ] }),
          (proRole || dispensaryScans > 0 || growerScans > 0) && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, { sx: { borderColor: "rgba(124, 179, 66, 0.2)" } }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "rgba(200, 230, 201, 0.7)", mb: 1 }, children: "Pro Mode Breakdown" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, flexWrap: "wrap", gap: 1, children: [
                dispensaryScans > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Chip,
                  {
                    label: `${dispensaryScans} Dispensary`,
                    size: "small",
                    sx: {
                      bgcolor: "rgba(124, 179, 66, 0.15)",
                      color: "#9AE66E",
                      border: "1px solid rgba(124, 179, 66, 0.3)"
                    }
                  }
                ),
                growerScans > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Chip,
                  {
                    label: `${growerScans} Grower`,
                    size: "small",
                    sx: {
                      bgcolor: "rgba(124, 179, 66, 0.15)",
                      color: "#9AE66E",
                      border: "1px solid rgba(124, 179, 66, 0.3)"
                    }
                  }
                )
              ] })
            ] })
          ] })
        ] })
      ] })
    }
  );
}
function HistoryPage({ onBack, onNavigate }) {
  const { user } = useAuth();
  const { proRole, proEnabled } = useProMode();
  const [scans, setScans] = reactExports.useState([]);
  const [filteredScans, setFilteredScans] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [error2, setError] = reactExports.useState("");
  const [selectedScan, setSelectedScan] = reactExports.useState(null);
  const [filterRole, setFilterRole] = reactExports.useState("");
  const [filterType, setFilterType] = reactExports.useState("");
  const [filterStrain, setFilterStrain] = reactExports.useState("");
  reactExports.useEffect(() => {
    let cancelled = false;
    function loadScans() {
      return __async(this, null, function* () {
        try {
          setLoading(true);
          setError("");
          const userId = (user == null ? void 0 : user.id) || null;
          const headers = {};
          if (proEnabled && (proRole === "dispensary" || proRole === "grower")) {
            headers["X-Pro-Role"] = proRole;
          }
          const params = new URLSearchParams();
          if (userId) params.append("user_id", userId);
          if (filterRole) params.append("role", filterRole);
          if (filterType) params.append("type", filterType);
          if (filterStrain) params.append("strain", filterStrain);
          params.append("limit", "200");
          const url = `${API_BASE}/api/scans?${params.toString()}`;
          const res = yield fetch(url, { headers });
          if (!res.ok) {
            throw new Error(`HTTP ${res.status}`);
          }
          const data = yield res.json();
          if (!cancelled) {
            setScans(data.scans || []);
            setFilteredScans(data.scans || []);
          }
        } catch (e) {
          if (!cancelled) {
            setError(String(e));
            console.error("[HistoryPage] Load error", e);
          }
        } finally {
          if (!cancelled) setLoading(false);
        }
      });
    }
    loadScans();
    return () => {
      cancelled = true;
    };
  }, [user == null ? void 0 : user.id, filterRole, filterType, filterStrain, proRole, proEnabled]);
  const handleScanSelect = (scan) => {
    setSelectedScan(scan);
  };
  const handleBackFromDetail = () => {
    setSelectedScan(null);
  };
  if (selectedScan) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        sx: {
          minHeight: "100vh",
          width: "100%",
          backgroundColor: "#050705",
          backgroundImage: "url(/strainspotter-bg.jpg)",
          backgroundSize: "cover",
          backgroundPosition: "center",
          position: "relative"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Container,
          {
            maxWidth: "md",
            sx: {
              pt: "calc(env(safe-area-inset-top) + 20px)",
              pb: 4
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 3, display: "flex", alignItems: "center", gap: 1 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: handleBackFromDetail, sx: { color: "#C5E1A5" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowBackIcon, {}) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#F1F8E9", fontWeight: 700 }, children: "Scan Details" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ScanResultCard, { scan: selectedScan, result: selectedScan })
            ]
          }
        )
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      sx: {
        minHeight: "100vh",
        width: "100%",
        backgroundColor: "#050705",
        backgroundImage: "url(/strainspotter-bg.jpg)",
        backgroundSize: "cover",
        backgroundPosition: "center",
        position: "relative"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Container,
        {
          maxWidth: "md",
          sx: {
            pt: "calc(env(safe-area-inset-top) + 20px)",
            pb: 4
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 3, display: "flex", alignItems: "center", gap: 1 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: onBack, sx: { color: "#C5E1A5" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowBackIcon, {}) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", sx: { color: "#F1F8E9", fontWeight: 700 }, children: "Scan History" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { direction: "row", spacing: 1, sx: { mb: 3 }, flexWrap: "wrap", gap: 1, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl, { size: "small", sx: { minWidth: 120 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, { sx: { color: "rgba(200, 230, 201, 0.7)" }, children: "Role" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Select,
                  {
                    value: filterRole,
                    onChange: (e) => setFilterRole(e.target.value),
                    label: "Role",
                    sx: {
                      color: "#E8F5E9",
                      "& .MuiOutlinedInput-notchedOutline": {
                        borderColor: "rgba(124, 179, 66, 0.3)"
                      },
                      "&:hover .MuiOutlinedInput-notchedOutline": {
                        borderColor: "rgba(124, 179, 66, 0.5)"
                      },
                      "& .MuiSvgIcon-root": {
                        color: "rgba(200, 230, 201, 0.7)"
                      }
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "", children: "All" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "dispensary", children: "Dispensary" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "grower", children: "Grower" })
                    ]
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl, { size: "small", sx: { minWidth: 120 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, { sx: { color: "rgba(200, 230, 201, 0.7)" }, children: "Type" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Select,
                  {
                    value: filterType,
                    onChange: (e) => setFilterType(e.target.value),
                    label: "Type",
                    sx: {
                      color: "#E8F5E9",
                      "& .MuiOutlinedInput-notchedOutline": {
                        borderColor: "rgba(124, 179, 66, 0.3)"
                      },
                      "&:hover .MuiOutlinedInput-notchedOutline": {
                        borderColor: "rgba(124, 179, 66, 0.5)"
                      },
                      "& .MuiSvgIcon-root": {
                        color: "rgba(200, 230, 201, 0.7)"
                      }
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "", children: "All" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "packaged", children: "Packaged" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { value: "bud", children: "Bud" })
                    ]
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                TextField,
                {
                  size: "small",
                  placeholder: "Filter by strain...",
                  value: filterStrain,
                  onChange: (e) => setFilterStrain(e.target.value),
                  sx: {
                    flex: 1,
                    minWidth: 150,
                    "& .MuiOutlinedInput-root": {
                      color: "#E8F5E9",
                      "& fieldset": {
                        borderColor: "rgba(124, 179, 66, 0.3)"
                      },
                      "&:hover fieldset": {
                        borderColor: "rgba(124, 179, 66, 0.5)"
                      },
                      "&.Mui-focused fieldset": {
                        borderColor: "#7CB342"
                      }
                    }
                  }
                }
              )
            ] }),
            loading && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", justifyContent: "center", py: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { sx: { color: "#CDDC39" } }) }),
            error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mb: 3 }, children: error2 }),
            !loading && !error2 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              filteredScans.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(AnalyticsSummary, { scans: filteredScans, proRole }),
              filteredScans.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { textAlign: "center", py: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body1", sx: { color: "rgba(200, 230, 201, 0.7)" }, children: [
                "No scans found",
                filterRole || filterType || filterStrain ? " matching filters" : "",
                "."
              ] }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { children: filteredScans.map((scan) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                HistoryListItem,
                {
                  scan,
                  onClick: () => handleScanSelect(scan)
                },
                scan.id
              )) })
            ] })
          ]
        }
      )
    }
  );
}
const HistoryPage$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: HistoryPage
}, Symbol.toStringTag, { value: "Module" }));
function AnalyticsDashboard({ onBack }) {
  var _a2, _b;
  const [loading, setLoading] = reactExports.useState(true);
  const [error2, setError] = reactExports.useState("");
  const [summary, setSummary] = reactExports.useState(null);
  reactExports.useEffect(() => {
    let cancelled = false;
    function fetchSummary() {
      return __async(this, null, function* () {
        try {
          setLoading(true);
          setError("");
          const res = yield fetch(`${API_BASE}/api/analytics/summary`);
          if (!res.ok) {
            throw new Error(`HTTP ${res.status}`);
          }
          const data = yield res.json();
          if (!cancelled) setSummary(data);
        } catch (e) {
          if (!cancelled) setError(String(e));
        } finally {
          if (!cancelled) setLoading(false);
        }
      });
    }
    fetchSummary();
    return () => {
      cancelled = true;
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      sx: {
        minHeight: "100vh",
        width: "100%",
        backgroundColor: "#050705",
        backgroundImage: "url(/strainspotter-bg.jpg)",
        backgroundSize: "cover",
        backgroundPosition: "center",
        position: "relative"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Container,
        {
          maxWidth: "md",
          sx: {
            pt: "calc(env(safe-area-inset-top) + 20px)",
            pb: 4
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 3, display: "flex", alignItems: "center", gap: 1 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: onBack, sx: { color: "#C5E1A5" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowBackIcon, {}) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", sx: { color: "#F1F8E9", fontWeight: 700 }, children: "Analytics" })
            ] }),
            loading && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", justifyContent: "center", py: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { sx: { color: "#CDDC39" } }) }),
            error2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mb: 3 }, children: error2 }),
            !loading && !error2 && summary && /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { spacing: 3, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Paper,
                {
                  elevation: 6,
                  sx: {
                    p: 3,
                    background: "rgba(12, 20, 12, 0.95)",
                    border: "1px solid rgba(124, 179, 66, 0.6)",
                    borderRadius: 3
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h6", sx: { color: "#F1F8E9", mb: 2, fontWeight: 600 }, children: [
                    "Total Scans: ",
                    summary.totalScans || 0
                  ] })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Paper,
                {
                  elevation: 6,
                  sx: {
                    p: 3,
                    background: "rgba(12, 20, 12, 0.95)",
                    border: "1px solid rgba(124, 179, 66, 0.6)",
                    borderRadius: 3
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#F1F8E9", mb: 2, fontWeight: 600 }, children: "Top Strains" }),
                    ((_a2 = summary.topStrains) == null ? void 0 : _a2.length) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 1, children: summary.topStrains.map((s) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", justifyContent: "space-between", alignItems: "center" }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", sx: { color: "#F1F8E9" }, children: s.name }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: s.count, size: "small", color: "success" })
                    ] }, s.name)) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "rgba(224, 242, 241, 0.8)" }, children: "No strain data yet." })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Paper,
                {
                  elevation: 6,
                  sx: {
                    p: 3,
                    background: "rgba(12, 20, 12, 0.95)",
                    border: "1px solid rgba(124, 179, 66, 0.6)",
                    borderRadius: 3
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#F1F8E9", mb: 2, fontWeight: 600 }, children: "Top Brands" }),
                    ((_b = summary.topBrands) == null ? void 0 : _b.length) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 1, children: summary.topBrands.map((b) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", justifyContent: "space-between", alignItems: "center" }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", sx: { color: "#F1F8E9" }, children: b.name }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: b.count, size: "small", color: "success" })
                    ] }, b.name)) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "rgba(224, 242, 241, 0.8)" }, children: "No brand data yet." })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Paper,
                {
                  elevation: 6,
                  sx: {
                    p: 3,
                    background: "rgba(12, 20, 12, 0.95)",
                    border: "1px solid rgba(124, 179, 66, 0.6)",
                    borderRadius: 3
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "#F1F8E9", mb: 2, fontWeight: 600 }, children: "THC Potency Distribution" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { spacing: 1, children: summary.potencyBuckets && Object.entries(summary.potencyBuckets).map(([bucket, count]) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", justifyContent: "space-between", alignItems: "center" }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", sx: { color: "#F1F8E9" }, children: bucket === "unknown" ? "Unknown" : `${bucket}%` }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: count, size: "small", color: "success" })
                    ] }, bucket)) })
                  ]
                }
              )
            ] })
          ]
        }
      )
    }
  );
}
const AnalyticsDashboard$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: AnalyticsDashboard
}, Symbol.toStringTag, { value: "Module" }));
//# sourceMappingURL=index-EBjh04nQ.js.map
